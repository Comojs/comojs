"\"this.global = this;\\n\\nglobal.COUNTER_HTTP_CLIENT_REQUEST = function(){};\\nglobal.DTRACE_HTTP_CLIENT_RESPONSE = function(){};\\nglobal.LTTNG_HTTP_CLIENT_RESPONSE = function(){};\\nglobal.COUNTER_HTTP_CLIENT_RESPONSE = function(){};\\n\\nglobal.LTTNG_HTTP_CLIENT_REQUEST = function(){};\\nglobal.DTRACE_HTTP_CLIENT_REQUEST = function(){};\\nglobal.COUNTER_HTTP_SERVER_RESPONSE = function(){};\\nglobal.LTTNG_HTTP_SERVER_RESPONSE = function(){};\\nglobal.DTRACE_HTTP_SERVER_RESPONSE = function(){};\\nglobal.COUNTER_HTTP_SERVER_REQUEST = function(){};\\nglobal.LTTNG_HTTP_SERVER_REQUEST = function(){};\\nglobal.DTRACE_HTTP_SERVER_REQUEST = function(){};\\nglobal.DTRACE_NET_SERVER_CONNECTION = function(){};\\nglobal.LTTNG_NET_SERVER_CONNECTION  = function(){};\\nglobal.COUNTER_NET_SERVER_CONNECTION = function(){};\\nglobal.COUNTER_NET_SERVER_CONNECTION_CLOSE = function(){};\\nglobal.DTRACE_NET_STREAM_END = function(){};\\nglobal.LTTNG_NET_STREAM_END = function(){};\\nglobal.NODE_BUFFER = Buffer;\\n\\nglobal.gc = Duktape.gc;\\n\\n// FIXME: use Objectsetporperity instead?!\\n// definegetter polyfill\\nif (typeof Object.prototype.__defineGetter__ === 'undefined') {\\n\\tObject.defineProperty(Object.prototype, '__defineGetter__', {\\n\\t\\tvalue: function (n, f) {\\n\\t\\t\\tObject.defineProperty(this, n, { enumerable: true, configurable: true, get: f });\\n\\t\\t}, writable: true, enumerable: false, configurable: true\\n\\t});\\n}\\n\\nif (!String.prototype.startsWith) {\\n    String.prototype.startsWith = function(searchString, position){\\n\\t\\tposition = position || 0;\\n\\t\\treturn this.substr(position, searchString.length) === searchString;\\n\\t};\\n}\\n\\n// Number.isFinite polyfill\\n// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite\\nif (typeof Number.isFinite !== 'function') {\\n\\tNumber.isFinite = function isFinite(value) {\\n\\t\\t// 1. If Type(number) is not Number, return false.\\n\\t\\tif (typeof value !== 'number') {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t// 2. If number is NaN, +∞, or −∞, return false.\\n\\t\\tif (value !== value || value === Infinity || value === -Infinity) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t// 3. Otherwise, return true.\\n\\t\\treturn true;\\n\\t};\\n}\\n\\n(function(process){\\n\\t'use strict';\\n\\n\\tif (process.platform === 'windows'){\\n\\t\\tprocess.platform = 'win32';\\n\\t}\\n\\n\\tprocess.execArgv = [];\\n\\n\\tprocess.throwErrno = function(errno){\\n\\t\\terrno = errno || process.errno;\\n\\t\\tthrow new Error(\\\"Errno Error \\\" + errno + \\\"\\\\n\\\" + \\\"Errno: \\\" + process.errno);\\n\\t};\\n\\n\\tprocess.reportError = function (e){\\n\\t\\tvar caught;\\n\\t\\tif (!caught) caught = process.emit('uncaughtException', e);\\n\\t\\tif (caught) return;\\n\\t\\tprint(e && e.stack ? e.stack : e);\\n\\t\\tprocess.reallyExit(1);\\n\\t};\\n\\n\\tprocess.moduleLoadList = [];\\n\\tvar binding_modules = process.bindings;\\n\\tdelete process.bindings; //clean up\\n\\n\\tvar cached_bindings = {};\\n\\tvar wrap_test       = /_wrap/i;\\n\\tprocess.binding = function (name){\\n\\t\\tif (name === 'uv') name = 'uv_wrap';\\n\\t\\tif ( wrap_test.test(name) ){\\n\\t\\t\\treturn NativeModule.require(name);\\n\\t\\t} else if (name === 'http_parser'){\\n\\t\\t\\treturn NativeModule.require('http_parser');\\n\\t\\t}\\n\\n\\t\\tvar binding_func = binding_modules[name];\\n\\t\\tif (!binding_func) {\\n\\t\\t\\tthrow new Error('unknown binding name ' + name);\\n\\t\\t}\\n\\n\\t\\tif (!cached_bindings[name]) {\\n\\t\\t\\tcached_bindings[name] = binding_func();\\n\\t\\t}\\n\\t\\treturn cached_bindings[name];\\n\\t};\\n\\n\\tprocess.MakeCallback = function (handle, string, a, b, c, d, e) {\\n\\t\\tif (!handle[string]) return;\\n\\t\\tprocess.nextTick(function(){\\n\\t\\t\\thandle[string](a, b, c, d, e);\\n\\t\\t});\\n\\t};\\n\\n\\tfunction startup () {\\n\\t\\t//in case of using tcc by running como.bat the first argument will\\n\\t\\t//be main.c so we need to replace this\\n\\t\\tif (process.argv[0] == 'src/main.c') {\\n\\t\\t\\tprocess.argv[0] = process.platform === 'win32' ? 'como.bat' : './como.sh';\\n\\t\\t} else {\\n\\t\\t\\tprocess.argv[0] = process.platform === 'win32' ? './como.exe' : './como';\\n\\t\\t}\\n\\n\\t\\tvar EventEmitter = NativeModule.require('events').EventEmitter;\\n\\t\\tprocess.__proto__ = Object.create(EventEmitter.prototype, {\\n\\t\\t\\tconstructor: {\\n\\t\\t\\t\\tvalue: process.constructor\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tEventEmitter.call(process);\\n\\n\\t\\tvar path = NativeModule.require('path');\\n\\t\\tprocess.execPath = path.resolve(process.cwd() + '/' + process.argv[0]);\\n\\t\\t// process.argv[0] = process.execPath;\\n\\n\\t\\tglobal.Buffer = NativeModule.require('buffer').Buffer;\\n\\t\\tstartup.processAssert();\\n\\t\\tstartup.globalTimeouts();\\n\\t\\tstartup.syscallAndUV();\\n\\t\\tstartup.processKillAndExit();\\n\\t\\tstartup.nextTick();\\n\\t\\tstartup.processStdio();\\n\\t\\tstartup.globalConsole();\\n\\t\\tstartup.processChannel();\\n\\n\\t\\tif (process.argv[1] == 'debug') {\\n\\t\\t\\t// Start the debugger agent\\n\\t\\t\\t// var d = NativeModule.require('_debugger');\\n\\t\\t\\t// d.start();\\n\\t\\t} else if (process.argv[1] == '--debug-agent') {\\n\\t\\t\\t// Start the debugger agent\\n\\t\\t\\t// var d = NativeModule.require('_debug_agent');\\n\\t\\t\\t// d.start();\\n\\t\\t} else {\\n\\t\\t\\t// There is user code to be run\\n\\t\\t\\t// If this is a worker in cluster mode, start up the communication\\n\\t\\t\\t// channel. This needs to be done before any user code gets executed\\n\\t\\t\\t// (including preload modules).\\n\\t\\t\\tif (process.argv[1] && process.env.NODE_UNIQUE_ID) {\\n\\t\\t\\t\\tvar cluster = NativeModule.require('cluster');\\n\\t\\t\\t\\tcluster._setupWorker();\\n\\t\\t\\t\\t// Make sure it's not accidentally inherited by child processes.\\n\\t\\t\\t\\tdelete process.env.NODE_UNIQUE_ID;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (process._eval != null) {\\n\\t\\t\\t\\t// TODO eval\\n\\t\\t\\t\\t// User passed '-e' or '--eval' arguments to Node.\\n\\t\\t\\t\\t// startup.preloadModules();\\n\\t\\t\\t\\t// evalScript('[eval]');\\n\\t\\t\\t} else if (process.argv[1]) {\\n\\t\\t\\t\\t// make process.argv[1] into a full path\\n\\t\\t\\t\\tprocess.argv[1] = path.resolve(process.argv[1]);\\n\\t\\t\\t\\tvar Module = NativeModule.require('module');\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tModule.runMain();\\n\\t\\t\\t\\t} catch(e){ process.reportError(e) }\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t//TODO repl\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tstartup.loop();\\n\\t}\\n\\n\\t// initiate uv and syscall with some related functions\\n\\t// associated by default with process object\\n\\t//===========================================================\\n\\t  var syscall, UV;\\n\\t  startup.syscallAndUV = function() {\\n\\t//===========================================================\\n\\t\\tsyscall = NativeModule.require('syscall');\\n\\t\\tUV      = NativeModule.require('uv');\\n\\t\\tprocess._kill = UV.kill;\\n\\n\\t\\tprocess.setuid = syscall.setuid;\\n\\t\\tprocess.getuid = syscall.getuid;\\n\\t};\\n\\n\\tvar assert;\\n\\tstartup.processAssert = function() {\\n\\t\\tassert = process.assert = function(x, msg) {\\n\\t\\t\\tif (!x) throw new Error(msg || 'assertion error');\\n\\t\\t};\\n\\t};\\n\\n\\tstartup._lazyConstants = null;\\n\\n\\tstartup.lazyConstants = function() {\\n\\t\\tif (!startup._lazyConstants) {\\n\\t\\t\\tstartup._lazyConstants = process.binding('constants');\\n\\t\\t}\\n\\t\\treturn startup._lazyConstants;\\n\\t};\\n\\n\\tstartup.processKillAndExit = function() {\\n\\n\\t\\tprocess.exit = function(code) {\\n\\t\\t\\tcode = Number(code) || 0;\\n\\t\\t\\tprocess.exitCode = code;\\n\\t\\t\\tif (!process._exiting) {\\n\\t\\t\\t\\tprocess._exiting = true;\\n\\t\\t\\t\\tprocess.emit('exit', process.exitCode);\\n\\t\\t\\t}\\n\\n\\t\\t\\tprocess.reallyExit(process.exitCode);\\n\\t\\t};\\n\\n\\t\\tprocess.kill = function(pid, sig) {\\n\\t\\t\\tvar err;\\n\\t\\t\\tif (pid != (pid | 0)) {\\n\\t\\t\\t\\tthrow new TypeError('invalid pid');\\n\\t\\t\\t}\\n\\n\\t\\t\\t// preserve null signal\\n\\t\\t\\tif (0 === sig) {\\n\\t\\t\\t\\terr = process._kill(pid, 0);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsig = sig || 'SIGTERM';\\n\\t\\t\\t\\tif (startup.lazyConstants()[sig] &&\\n\\t\\t\\t\\t\\t\\tsig.slice(0, 3) === 'SIG') {\\n\\t\\t\\t\\t\\terr = process._kill(pid, startup.lazyConstants()[sig]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tthrow new Error('Unknown signal: ' + sig);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (err) {\\n\\t\\t\\t\\tvar errnoException = NativeModule.require('util')._errnoException;\\n\\t\\t\\t\\tthrow errnoException(err, 'kill');\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\t\\t};\\n\\t};\\n\\n\\tstartup.processChannel = function() {\\n\\t\\t// If we were spawned with env NODE_CHANNEL_FD then load that up and\\n\\t\\t// start parsing data from that stream.\\n\\t\\tif (process.env.NODE_CHANNEL_FD) {\\n\\t\\t\\tvar fd = parseInt(process.env.NODE_CHANNEL_FD, 10);\\n\\t\\t\\tassert(fd >= 0);\\n\\t\\t\\t// Make sure it's not accidentally inherited by child processes.\\n\\t\\t\\tdelete process.env.NODE_CHANNEL_FD;\\n\\n\\t\\t\\tvar cp = NativeModule.require('child_process');\\n\\t\\t\\tvar syscall = NativeModule.require('syscall');\\n\\n\\t\\t\\t// Load tcp_wrap to avoid situation where we might immediately receive\\n\\t\\t\\t// a message.\\n\\t\\t\\t// FIXME is this really necessary?\\n\\t\\t\\tprocess.binding('tcp_wrap');\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tvar como_fd = 'COMO_FD_' + fd;\\n\\t\\t\\t\\tfd = process.env[como_fd] || fd;\\n\\t\\t\\t\\tvar handle = parseInt(fd, 10);\\n\\t\\t\\t\\tcp._forkChild(handle);\\n\\t\\t\\t} catch(e){\\n\\t\\t\\t\\tconsole.log(e.stack);\\n\\t\\t\\t\\tprocess.exit(2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tassert(process.send);\\n\\t\\t}\\n\\t};\\n\\n\\tvar nextTickQueue = [];\\n\\tstartup.nextTick = function(){\\n\\n\\n\\t\\tvar kLength   = 0;\\n\\t\\tvar kIndex    = 0;\\n\\t\\tvar tock, callback, args;\\n\\n\\t\\tvar tickDone = function(){\\n\\t\\t\\tif (kLength !== 0) {\\n\\t\\t\\t\\tif (kLength <= kIndex) {\\n\\t\\t\\t\\t\\tnextTickQueue = [];\\n\\t\\t\\t\\t\\tnextTickQueue.length = 0;\\n\\t\\t\\t\\t\\tkLength = 0;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnextTickQueue.splice(0, kIndex);\\n\\t\\t\\t\\t\\tkLength = nextTickQueue.length;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tkIndex = 0;\\n\\t\\t};\\n\\n\\t\\tvar slice = Array.prototype.slice;\\n\\t\\tprocess.nextTick = function (){\\n\\t\\t\\tvar args = slice.call(arguments);\\n\\t\\t\\tvar callback = args.shift();\\n\\n\\t\\t\\t// on the way out, don't bother. it won't get fired anyway.\\n\\t\\t\\tif (process._exiting) return;\\n\\n\\t\\t\\tkLength++;\\n\\t\\t\\tnextTickQueue.push({\\n\\t\\t\\t\\tcallback : callback,\\n\\t\\t\\t\\targs     : args\\n\\t\\t\\t});\\n\\t\\t};\\n\\n\\t\\tprocess._tickCallback = function(){\\n\\t\\t\\twhile (kIndex < kLength){\\n\\t\\t\\t\\tvar tock = nextTickQueue[kIndex++];\\n\\t\\t\\t\\tvar callback = tock.callback;\\n\\t\\t\\t\\tvar args = tock.args;\\n\\t\\t\\t\\tvar threw = true;\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tswitch(args.length){\\n\\t\\t\\t\\t\\t\\tcase 0  : callback(); break;\\n\\t\\t\\t\\t\\t\\tcase 1  : callback(args[0]); break;\\n\\t\\t\\t\\t\\t\\tcase 2  : callback(args[0], args[1]); break;\\n\\t\\t\\t\\t\\t\\tcase 3  : callback(args[0], args[1], args[2]); break;\\n\\t\\t\\t\\t\\t\\tcase 4  : callback(args[0], args[1], args[2], args[3]); break;\\n\\t\\t\\t\\t\\t\\tdefault : callback.apply(null, args);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthrew = false;\\n\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\tif (threw) tickDone();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttickDone();\\n\\t\\t};\\n\\t};\\n\\n\\tstartup.globalTimeouts = function() {\\n\\n\\n\\t\\tglobal.setTimeout = function(fn, timeout, a, b, c) {\\n\\t\\t\\tvar uv = NativeModule.require('uv');\\n\\t\\t\\tvar h = uv.new_timer();\\n\\t\\t\\tfn.timerHandle = h;\\n\\t\\t\\tfn.unref = function(){ uv.unref(h) };\\n\\t\\t\\tuv.timer_start(h, timeout | 0, 0, fn);\\n\\t\\t\\treturn fn;\\n\\t\\t};\\n\\n\\t\\tglobal.setInterval = function(fn, timeout) {\\n\\t\\t\\tvar uv = NativeModule.require('uv');\\n\\t\\t\\tvar h = uv.new_timer();\\n\\t\\t\\tfn.timerHandle = h;\\n\\t\\t\\tfn.unref = function(){ uv.unref(h) };\\n\\t\\t\\tuv.timer_start(h, timeout | 0, (timeout | 0) || 1, fn);\\n\\t\\t\\treturn fn;\\n\\t\\t};\\n\\n\\t\\tglobal.setImmediate = function(fn, timeout) {\\n\\t\\t\\tvar uv = NativeModule.require('uv');\\n\\t\\t\\tvar h = uv.new_timer();\\n\\t\\t\\tfn.timerHandle = h;\\n\\t\\t\\tfn.unref = function(){ uv.unref(h) };\\n\\t\\t\\tuv.timer_start(h, 1, 0, fn);\\n\\t\\t\\treturn fn;\\n\\t\\t};\\n\\n\\t\\tglobal.clearImmediate = global.clearTimeout = global.clearInterval = function(timer) {\\n\\t\\t\\tvar uv = NativeModule.require('uv');\\n\\t\\t\\tif (!timer.timerHandle){\\n\\t\\t\\t\\tthrow new Error(\\\"clearing Timer Error\\\");\\n\\t\\t\\t}\\n\\t\\t\\tuv.handle_close(timer.timerHandle);\\n\\t\\t\\ttimer.timerHandle = null;\\n\\t\\t};\\n\\t};\\n\\n\\tstartup.globalConsole = function() {\\n\\t\\tglobal.console = NativeModule.require('console');\\n\\t};\\n\\n\\tstartup.processStdio  = function() {\\n\\n\\t\\tvar stdio = NativeModule.require('setup/stdio');\\n\\t\\tvar stdin, stdout, stderr;\\n\\n\\t\\t//stdout\\n\\t\\tprocess.__defineGetter__('stdout', function() {\\n\\t\\t\\tif (stdout) return stdout;\\n\\t\\t\\tstdout = stdio.createWritableStdioStream(1);\\n\\t\\t\\tstdout.destroy = stdout.destroySoon = function(er) {\\n\\t\\t\\t\\ter = er || new Error('process.stdout cannot be closed.');\\n\\t\\t\\t\\tstdout.emit('error', er);\\n\\t\\t\\t};\\n\\n\\t\\t\\tif (stdout.isTTY) {\\n\\t\\t\\t\\tprocess.on('SIGWINCH', function() {\\n\\t\\t\\t\\t\\tstdout._refreshSize();\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\treturn stdout;\\n\\t\\t});\\n\\n\\t\\t//stderr\\n\\t\\tprocess.__defineGetter__('stderr', function() {\\n\\t\\t\\tif (stderr) return stderr;\\n\\t\\t\\tstderr = stdio.createWritableStdioStream(2);\\n\\t\\t\\tstderr.destroy = stderr.destroySoon = function(er) {\\n\\t\\t\\t\\ter = er || new Error('process.stderr cannot be closed.');\\n\\t\\t\\t\\tstderr.emit('error', er);\\n\\t\\t\\t};\\n\\n\\t\\t\\tif (stderr.isTTY) {\\n\\t\\t\\t\\tprocess.on('SIGWINCH', function() {\\n\\t\\t\\t\\t\\tstderr._refreshSize();\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\treturn stderr;\\n\\t\\t});\\n\\n\\t\\t//stdin\\n\\t\\tprocess.__defineGetter__('stdin', function() {\\n\\t\\t\\tif (stdin) return stdin;\\n\\t\\t\\tstdin = stdio.createReadableStdioStream(0);\\n\\t\\t\\treturn stdin;\\n\\t\\t});\\n\\t};\\n\\n\\tstartup.loop = function(){\\n\\t\\tvar uv = NativeModule.require('uv');\\n\\t\\tvar gcHandle = uv.new_timer();\\n\\t\\tuv.unref(gcHandle);\\n\\t\\tuv.timer_start(gcHandle, 5000, 5000, function(){\\n\\t\\t\\tDuktape.gc();\\n\\t\\t});\\n\\n\\t\\t(function _starter(){\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tvar i = 0;\\n\\t\\t\\t\\tvar n = 0;\\n\\t\\t\\t\\twhile(1){\\n\\t\\t\\t\\t\\tprocess._tickCallback();\\n\\t\\t\\t\\t\\tn = uv.run(1);\\n\\t\\t\\t\\t\\tif (nextTickQueue.length) continue;\\n\\t\\t\\t\\t\\tif (n === 0) break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprocess.emit('exit', 0);\\n\\t\\t\\t} catch (e){\\n\\t\\t\\t\\tprocess.reportError(e);\\n\\t\\t\\t\\t// if we reached here then error has been handeled\\n\\t\\t\\t\\t// by uncaughtException, so redo our loop\\n\\t\\t\\t\\t_starter();\\n\\t\\t\\t}\\n\\t\\t})();\\n\\t};\\n\\n\\tvar NativeModule = process.NativeModule = function(id) {\\n\\t\\tthis.filename = NativeModule._source[id];// + '.js';\\n\\t\\tthis.id = id;\\n\\t\\tthis.exports = {};\\n\\t\\tthis.loaded = false;\\n\\t}\\n\\n\\n\\tvar NativeModulesMap;\\n\\ttry {\\n\\t\\tNativeModulesMap = process.readFile('./src/ModulesMap.json');\\n\\t\\tNativeModulesMap = JSON.parse(NativeModulesMap);\\n\\t} catch(e){\\n\\t\\tNativeModulesMap = process.NativeSource.fileMap;\\n\\t}\\n\\n\\tNativeModule._source = NativeModulesMap;\\n\\tNativeModule._cache  = {};\\n\\n\\tNativeModule.require = function(id, p) {\\n\\t\\tif (id == 'native_module') {\\n\\t\\t\\treturn NativeModule;\\n\\t\\t}\\n\\n\\t\\tvar cached = NativeModule.getCached(id);\\n\\t\\tif (cached) {\\n\\t\\t\\treturn cached.exports;\\n\\t\\t}\\n\\n\\t\\tif (!NativeModule.exists(id)) {\\n\\t\\t\\tvar t = NativeModule.require('module');\\n\\t\\t\\tvar path = NativeModule.require('path');\\n\\t\\t\\treturn t.require(path.resolve(process.cwd() + '/js/' + id));\\n\\t\\t\\tthrow new Error('No such native module ' + id);\\n\\t\\t}\\n\\n\\t\\tprocess.moduleLoadList.push('NativeModule ' + id);\\n\\t\\tvar nativeModule = new NativeModule(id);\\n\\t\\tnativeModule.cache();\\n\\t\\tnativeModule.compile();\\n\\t\\treturn nativeModule.exports;\\n\\t};\\n\\n\\tNativeModule.getCached = function(id) {\\n\\t\\treturn NativeModule._cache[id];\\n\\t};\\n\\n\\tNativeModule.exists = function(id) {\\n\\t\\treturn NativeModule._source.hasOwnProperty(id);\\n\\t};\\n\\n\\tNativeModule.getSource = function(id) {\\n\\t\\tvar filename = NativeModule._source[id];\\n\\t\\tif (process.NativeSource){\\n\\t\\t\\tvar source = process.NativeSource[id];\\n\\t\\t\\t//this will be cached so clean up\\n\\t\\t\\tdelete process.NativeSource[id];\\n\\t\\t\\treturn source;\\n\\t\\t}\\n\\t\\treturn process.readFile(filename);\\n\\t};\\n\\n\\tNativeModule.wrap = function(script) {\\n\\t\\treturn NativeModule.wrapper[0] + script + NativeModule.wrapper[1];\\n\\t};\\n\\n\\tNativeModule.wrapper = [\\n\\t\\t'(function (exports, require, module, __filename, __dirname) { ',\\n\\t\\t'\\\\n});'\\n\\t];\\n\\n\\tNativeModule.prototype.compile = function() {\\n\\t\\tvar source = NativeModule.getSource(this.id);\\n\\t\\tsource = NativeModule.wrap(source);\\n\\t\\tvar fn = process.eval(source, NativeModule._source[this.id]);\\n\\t\\ttry {\\n\\t\\t\\tfn(this.exports, NativeModule.require, this, this.filename);\\n\\t\\t} catch(e){\\n\\t\\t\\tprocess.reportError(e);\\n\\t\\t}\\n\\t\\tthis.loaded = true;\\n\\t};\\n\\n\\tNativeModule.prototype.cache = function() {\\n\\t\\tNativeModule._cache[this.id] = this;\\n\\t};\\n\\n\\tNativeModule.nonInternalExists = function(id) {\\n\\t\\treturn NativeModule.exists(id) && !NativeModule.isInternal(id);\\n\\t};\\n\\n\\tNativeModule.isInternal = function(id) {\\n\\t\\treturn id.startsWith('internal/');;\\n\\t};\\n\\n\\tstartup();\\n})(process);\\n\""
