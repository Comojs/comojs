"\"this.global = this;\\r\\n\\r\\nglobal.COUNTER_HTTP_CLIENT_REQUEST = function(){};\\r\\nglobal.DTRACE_HTTP_CLIENT_RESPONSE = function(){};\\r\\nglobal.LTTNG_HTTP_CLIENT_RESPONSE = function(){};\\r\\nglobal.COUNTER_HTTP_CLIENT_RESPONSE = function(){};\\r\\n\\r\\nglobal.LTTNG_HTTP_CLIENT_REQUEST = function(){};\\r\\nglobal.DTRACE_HTTP_CLIENT_REQUEST = function(){};\\r\\nglobal.COUNTER_HTTP_SERVER_RESPONSE = function(){};\\r\\nglobal.LTTNG_HTTP_SERVER_RESPONSE = function(){};\\r\\nglobal.DTRACE_HTTP_SERVER_RESPONSE = function(){};\\r\\nglobal.COUNTER_HTTP_SERVER_REQUEST = function(){};\\r\\nglobal.LTTNG_HTTP_SERVER_REQUEST = function(){};\\r\\nglobal.DTRACE_HTTP_SERVER_REQUEST = function(){};\\r\\nglobal.DTRACE_NET_SERVER_CONNECTION = function(){};\\r\\nglobal.LTTNG_NET_SERVER_CONNECTION  = function(){};\\r\\nglobal.COUNTER_NET_SERVER_CONNECTION = function(){};\\r\\nglobal.COUNTER_NET_SERVER_CONNECTION_CLOSE = function(){};\\r\\nglobal.DTRACE_NET_STREAM_END = function(){};\\r\\nglobal.LTTNG_NET_STREAM_END = function(){};\\r\\nglobal.NODE_BUFFER = Buffer;\\r\\n\\r\\nglobal.gc = Duktape.gc;\\r\\n\\r\\n// FIXME: use Objectsetporperity instead?!\\r\\n// definegetter polyfill\\r\\nif (typeof Object.prototype.__defineGetter__ === 'undefined') {\\r\\n\\tObject.defineProperty(Object.prototype, '__defineGetter__', {\\r\\n\\t\\tvalue: function (n, f) {\\r\\n\\t\\t\\tObject.defineProperty(this, n, { enumerable: true, configurable: true, get: f });\\r\\n\\t\\t}, writable: true, enumerable: false, configurable: true\\r\\n\\t});\\r\\n}\\r\\n\\r\\n// Number.isFinite polyfill\\r\\n// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite\\r\\nif (typeof Number.isFinite !== 'function') {\\r\\n\\tNumber.isFinite = function isFinite(value) {\\r\\n\\t\\t// 1. If Type(number) is not Number, return false.\\r\\n\\t\\tif (typeof value !== 'number') {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t\\t// 2. If number is NaN, +∞, or −∞, return false.\\r\\n\\t\\tif (value !== value || value === Infinity || value === -Infinity) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t\\t// 3. Otherwise, return true.\\r\\n\\t\\treturn true;\\r\\n\\t};\\r\\n}\\r\\n\\r\\n(function(process){\\r\\n\\t'use strict';\\r\\n\\r\\n\\tprocess.execArgv = [];\\r\\n\\r\\n\\tprocess.throwErrno = function(errno){\\r\\n\\t\\terrno = errno || process.errno;\\r\\n\\t\\tthrow new Error(\\\"Errno Error \\\" + errno + \\\"\\\\n\\\" + \\\"Errno: \\\" + process.errno);\\r\\n\\t};\\r\\n\\r\\n\\tprocess.reportError = function (e){\\r\\n\\t\\tvar caught;\\r\\n\\t\\tif (!caught) caught = process.emit('uncaughtException', e);\\r\\n\\t\\tif (caught) return;\\r\\n\\t\\tprint(e.stack || e);\\r\\n\\t\\tprocess.reallyExit(1);\\r\\n\\t};\\r\\n\\r\\n\\tprocess.moduleLoadList = [];\\r\\n\\tvar binding_modules = process.bindings;\\r\\n\\tdelete process.bindings; //clean up\\r\\n\\r\\n\\tvar cached_bindings = {};\\r\\n\\tvar wrap_test       = /_wrap/i;\\r\\n\\tprocess.binding = function (name){\\r\\n\\t\\tif (name === 'uv') name = 'uv_wrap';\\r\\n\\t\\tif ( wrap_test.test(name) ){\\r\\n\\t\\t\\treturn NativeModule.require(name);\\r\\n\\t\\t} else if (name === 'http_parser'){\\r\\n\\t\\t\\treturn NativeModule.require('http_parser');\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar binding_func = binding_modules[name];\\r\\n\\t\\tif (!binding_func) {\\r\\n\\t\\t\\tthrow new Error('unknown binding name ' + name);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!cached_bindings[name]) {\\r\\n\\t\\t\\tcached_bindings[name] = binding_func();\\r\\n\\t\\t}\\r\\n\\t\\treturn cached_bindings[name];\\r\\n\\t};\\r\\n\\r\\n\\tprocess.MakeCallback = function (handle, string, a, b, c, d, e) {\\r\\n\\t\\t// process._tickCallBack();\\r\\n\\t\\tif (!handle[string]) return;\\r\\n\\t\\tprocess.nextTick(function(){\\r\\n\\t\\t\\thandle[string](a, b, c, d, e);\\r\\n\\t\\t});\\r\\n\\t};\\r\\n\\r\\n\\tfunction startup () {\\r\\n\\r\\n\\t\\t//in case of using tcc by running como.bat the first argument will\\r\\n\\t\\t//be main.c so we need to replace this\\r\\n\\t\\tif (process.argv[0] == 'src/main.c') {\\r\\n\\t\\t\\tprocess.argv[0] = process.platform === 'win32' ? 'como.bat' : './como.sh';\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tprocess.argv[0] = process.platform === 'win32' ? './como.exe' : './como';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar EventEmitter = NativeModule.require('events').EventEmitter;\\r\\n\\t\\tprocess.__proto__ = Object.create(EventEmitter.prototype, {\\r\\n\\t\\t\\tconstructor: {\\r\\n\\t\\t\\t\\tvalue: process.constructor\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\tEventEmitter.call(process);\\r\\n\\r\\n\\t\\tvar path = NativeModule.require('path');\\r\\n\\t\\tprocess.execPath = path.resolve(process.cwd() + '/' + process.argv[0]);\\r\\n\\t\\t// process.argv[0] = process.execPath;\\r\\n\\t\\tglobal.Buffer = NativeModule.require('buffer').Buffer;\\r\\n\\r\\n\\t\\tstartup.processAssert();\\r\\n\\t\\tstartup.globalTimeouts();\\r\\n\\t\\tstartup.syscallAndUV();\\r\\n\\r\\n\\t\\tstartup.processKillAndExit();\\r\\n\\r\\n\\t\\tstartup.nextTick();\\r\\n\\r\\n\\t\\t// startup.processStdio();\\r\\n\\t\\tstartup.globalConsole();\\r\\n\\r\\n\\t\\tstartup.processChannel();\\r\\n\\t\\t//initiate go globals\\r\\n\\t\\t//NativeModule.require('go/globals');\\r\\n\\t}\\r\\n\\r\\n\\t// initiate uv and syscall with some related functions\\r\\n\\t// associated by default with process object\\r\\n\\t//===========================================================\\r\\n\\t  var syscall, UV;\\r\\n\\t  startup.syscallAndUV = function() {\\r\\n\\t//===========================================================\\r\\n\\t\\tsyscall = NativeModule.require('syscall');\\r\\n\\t\\tUV      = NativeModule.require('uv');\\r\\n\\t\\tprocess._kill = UV.kill;\\r\\n\\r\\n\\t\\tprocess.setuid = syscall.setuid;\\r\\n\\t\\tprocess.getuid = syscall.getuid;\\r\\n\\t};\\r\\n\\r\\n\\tvar assert;\\r\\n\\tstartup.processAssert = function() {\\r\\n\\t\\tassert = process.assert = function(x, msg) {\\r\\n\\t\\t\\tif (!x) throw new Error(msg || 'assertion error');\\r\\n\\t\\t};\\r\\n\\t};\\r\\n\\r\\n\\tstartup._lazyConstants = null;\\r\\n\\r\\n\\tstartup.lazyConstants = function() {\\r\\n\\t\\tif (!startup._lazyConstants) {\\r\\n\\t\\t\\tstartup._lazyConstants = process.binding('constants');\\r\\n\\t\\t}\\r\\n\\t\\treturn startup._lazyConstants;\\r\\n\\t};\\r\\n\\r\\n\\tstartup.processKillAndExit = function() {\\r\\n\\r\\n\\t\\tprocess.exit = function(code) {\\r\\n\\t\\t\\tcode = Number(code) || 0;\\r\\n\\t\\t\\tprocess.exitCode = code;\\r\\n\\t\\t\\tif (!process._exiting) {\\r\\n\\t\\t\\t\\tprocess._exiting = true;\\r\\n\\t\\t\\t\\tprocess.emit('exit', process.exitCode);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tprocess.reallyExit(process.exitCode);\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tprocess.kill = function(pid, sig) {\\r\\n\\t\\t\\tvar err;\\r\\n\\t\\t\\tif (pid != (pid | 0)) {\\r\\n\\t\\t\\t\\tthrow new TypeError('invalid pid');\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// preserve null signal\\r\\n\\t\\t\\tif (0 === sig) {\\r\\n\\t\\t\\t\\terr = process._kill(pid, 0);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tsig = sig || 'SIGTERM';\\r\\n\\t\\t\\t\\tif (startup.lazyConstants()[sig] &&\\r\\n\\t\\t\\t\\t\\t\\tsig.slice(0, 3) === 'SIG') {\\r\\n\\t\\t\\t\\t\\terr = process._kill(pid, startup.lazyConstants()[sig]);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthrow new Error('Unknown signal: ' + sig);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (err) {\\r\\n\\t\\t\\t\\tvar errnoException = NativeModule.require('util')._errnoException;\\r\\n\\t\\t\\t\\tthrow errnoException(err, 'kill');\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t};\\r\\n\\t};\\r\\n\\r\\n\\tstartup.processChannel = function() {\\r\\n\\t\\t// If we were spawned with env NODE_CHANNEL_FD then load that up and\\r\\n\\t\\t// start parsing data from that stream.\\r\\n\\t\\tif (process.env.NODE_CHANNEL_FD) {\\r\\n\\t\\t\\tvar fd = parseInt(process.env.NODE_CHANNEL_FD, 10);\\r\\n\\t\\t\\tassert(fd >= 0);\\r\\n\\t\\t\\t// Make sure it's not accidentally inherited by child processes.\\r\\n\\t\\t\\tdelete process.env.NODE_CHANNEL_FD;\\r\\n\\r\\n\\t\\t\\tvar cp = NativeModule.require('child_process');\\r\\n\\t\\t\\tvar syscall = NativeModule.require('syscall');\\r\\n\\r\\n\\t\\t\\t// Load tcp_wrap to avoid situation where we might immediately receive\\r\\n\\t\\t\\t// a message.\\r\\n\\t\\t\\t// FIXME is this really necessary?\\r\\n\\t\\t\\tprocess.binding('tcp_wrap');\\r\\n\\t\\t\\ttry {\\r\\n\\t\\t\\t\\tvar como_fd = 'COMO_FD_' + fd;\\r\\n\\t\\t\\t\\tfd = process.env[como_fd] || fd;\\r\\n\\t\\t\\t\\tvar handle = parseInt(fd, 10);\\r\\n\\t\\t\\t\\tcp._forkChild(handle);\\r\\n\\t\\t\\t} catch(e){\\r\\n\\t\\t\\t\\tconsole.log(e.stack);\\r\\n\\t\\t\\t\\tprocess.exit(2);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tassert(process.send);\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\tvar nextTickQueue = [];\\r\\n\\tstartup.nextTick = function(){\\r\\n\\r\\n\\r\\n\\t\\tvar kLength   = 0;\\r\\n\\t\\tvar kIndex    = 0;\\r\\n\\t\\tvar tock, callback, args;\\r\\n\\r\\n\\t\\tvar tickDone = function(){\\r\\n\\t\\t\\tif (kLength !== 0) {\\r\\n\\t\\t\\t\\tif (kLength <= kIndex) {\\r\\n\\t\\t\\t\\t\\tnextTickQueue = [];\\r\\n\\t\\t\\t\\t\\tnextTickQueue.length = 0;\\r\\n\\t\\t\\t\\t\\tkLength = 0;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tnextTickQueue.splice(0, kIndex);\\r\\n\\t\\t\\t\\t\\tkLength = nextTickQueue.length;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tkIndex = 0;\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tvar slice = Array.prototype.slice;\\r\\n\\t\\tprocess.nextTick = function (){\\r\\n\\t\\t\\tvar args = slice.call(arguments);\\r\\n\\t\\t\\tvar callback = args.shift();\\r\\n\\r\\n\\t\\t\\t// on the way out, don't bother. it won't get fired anyway.\\r\\n\\t\\t\\tif (process._exiting) return;\\r\\n\\r\\n\\t\\t\\t// if (kLength > 500){\\r\\n\\t\\t\\t//     process._tickCallBack();\\r\\n\\t\\t\\t// }\\r\\n\\r\\n\\t\\t\\tkLength++;\\r\\n\\t\\t\\tnextTickQueue.push({\\r\\n\\t\\t\\t\\tcallback : callback,\\r\\n\\t\\t\\t\\targs     : args\\r\\n\\t\\t\\t});\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tprocess._tickCallBack = function(){\\r\\n\\t\\t\\twhile (kIndex < kLength){\\r\\n\\t\\t\\t\\tvar tock = nextTickQueue[kIndex++];\\r\\n\\t\\t\\t\\tvar callback = tock.callback;\\r\\n\\t\\t\\t\\tvar args = tock.args;\\r\\n\\t\\t\\t\\tvar threw = true;\\r\\n\\t\\t\\t\\ttry {\\r\\n\\t\\t\\t\\t\\tswitch(args.length){\\r\\n\\t\\t\\t\\t\\t\\tcase 0  : callback(); break;\\r\\n\\t\\t\\t\\t\\t\\tcase 1  : callback(args[0]); break;\\r\\n\\t\\t\\t\\t\\t\\tcase 2  : callback(args[0], args[1]); break;\\r\\n\\t\\t\\t\\t\\t\\tcase 3  : callback(args[0], args[1], args[2]); break;\\r\\n\\t\\t\\t\\t\\t\\tcase 4  : callback(args[0], args[1], args[2], args[3]); break;\\r\\n\\t\\t\\t\\t\\t\\tdefault : callback.apply(null, args);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tthrew = false;\\r\\n\\t\\t\\t\\t} finally {\\r\\n\\t\\t\\t\\t\\tif (threw) tickDone();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\ttickDone();\\r\\n\\t\\t};\\r\\n\\t};\\r\\n\\r\\n\\tstartup.globalTimeouts = function() {\\r\\n\\t\\tvar loop = process.binding('loop');\\r\\n\\t\\tvar _default = loop.init();\\r\\n\\t\\tprocess.main_loop = _default;\\r\\n\\r\\n\\t\\tglobal.setTimeout = function(fn, timeout, a, b, c) {\\r\\n\\t\\t\\tvar h = loop.handle_init(_default, fn);\\r\\n\\r\\n\\t\\t\\tfn.timerHandle = h;\\r\\n\\t\\t\\tloop.timer_start(h, timeout, 0);\\r\\n\\t\\t\\treturn fn;\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tglobal.setInterval = function(fn, timeout) {\\r\\n\\t\\t\\tvar h = loop.handle_init(process.main_loop, fn);\\r\\n\\t\\t\\tfn.timerHandle = h;\\r\\n\\t\\t\\tfn.unref = function(){\\r\\n\\t\\t\\t\\tloop.handle_unref(h);\\r\\n\\t\\t\\t};\\r\\n\\t\\t\\tloop.timer_start(h, timeout, timeout);\\r\\n\\t\\t\\treturn fn;\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tglobal.setImmediate = function(fn, timeout) {\\r\\n\\t\\t\\tvar h = loop.handle_init(process.main_loop, fn);\\r\\n\\t\\t\\tfn.timerHandle = h;\\r\\n\\t\\t\\tfn.unref = function(){\\r\\n\\t\\t\\t\\tloop.handle_unref(h);\\r\\n\\t\\t\\t};\\r\\n\\t\\t\\tloop.timer_start(h, 1, 0);\\r\\n\\t\\t\\treturn fn;\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tglobal.clearImmediate = global.clearTimeout = global.clearInterval = function(timer) {\\r\\n\\t\\t\\tif (!timer.timerHandle){\\r\\n\\t\\t\\t\\tthrow new Error(\\\"clearing Timer Error\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tloop.handle_close(timer.timerHandle);\\r\\n\\t\\t\\ttimer.timerHandle = null;\\r\\n\\t\\t};\\r\\n\\t};\\r\\n\\r\\n\\tstartup.globalConsole = function() {\\r\\n\\t\\tglobal.console = NativeModule.require('console');\\r\\n\\t};\\r\\n\\r\\n\\tstartup.processStdio  = function() {\\r\\n\\r\\n\\t\\tvar stdio = NativeModule.require('./setup/stdio.js');\\r\\n\\t\\tvar stdin, stdout, stderr;\\r\\n\\r\\n\\t\\t//stdout\\r\\n\\t\\tprocess.__defineGetter__('stdout', function() {\\r\\n\\t\\t\\tif (stdout) return stdout;\\r\\n\\t\\t\\tstdout = stdio.createWritableStdioStream(1);\\r\\n\\t\\t\\tstdout.destroy = stdout.destroySoon = function(er) {\\r\\n\\t\\t\\t\\ter = er || new Error('process.stdout cannot be closed.');\\r\\n\\t\\t\\t\\tstdout.emit('error', er);\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tif (stdout.isTTY) {\\r\\n\\t\\t\\t\\tprocess.on('SIGWINCH', function() {\\r\\n\\t\\t\\t\\t\\tstdout._refreshSize();\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn stdout;\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\t//stderr\\r\\n\\t\\tprocess.__defineGetter__('stderr', function() {\\r\\n\\t\\t\\tif (stderr) return stderr;\\r\\n\\t\\t\\tstderr = stdio.createWritableStdioStream(2);\\r\\n\\t\\t\\tstderr.destroy = stderr.destroySoon = function(er) {\\r\\n\\t\\t\\t\\ter = er || new Error('process.stderr cannot be closed.');\\r\\n\\t\\t\\t\\tstderr.emit('error', er);\\r\\n\\t\\t\\t};\\r\\n\\r\\n\\t\\t\\tif (stderr.isTTY) {\\r\\n\\t\\t\\t\\tprocess.on('SIGWINCH', function() {\\r\\n\\t\\t\\t\\t\\tstderr._refreshSize();\\r\\n\\t\\t\\t\\t});\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn stderr;\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\t//stdin\\r\\n\\t\\tprocess.__defineGetter__('stdin', function() {\\r\\n\\t\\t\\tif (stdin) return stdin;\\r\\n\\t\\t\\tstdin = stdio.createReadableStdioStream(0);\\r\\n\\t\\t\\treturn stdin;\\r\\n\\t\\t});\\r\\n\\t};\\r\\n\\r\\n\\tvar NativeModule = process.NativeModule = function(id) {\\r\\n\\t\\tthis.filename = NativeModule._source[id];// + '.js';\\r\\n\\t\\tthis.id = id;\\r\\n\\t\\tthis.exports = {};\\r\\n\\t\\tthis.loaded = false;\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tvar NativeModulesMap;\\r\\n\\ttry {\\r\\n\\t\\tNativeModulesMap = process.readFile('./src/ModulesMap.json');\\r\\n\\t\\tNativeModulesMap = JSON.parse(NativeModulesMap);\\r\\n\\t} catch(e){\\r\\n\\t\\tNativeModulesMap = process.NativeSource.fileMap;\\r\\n\\t}\\r\\n\\r\\n\\tNativeModule._source = NativeModulesMap;\\r\\n\\tNativeModule._cache  = {};\\r\\n\\r\\n\\tNativeModule.require = function(id, p) {\\r\\n\\t\\tif (id == 'native_module') {\\r\\n\\t\\t\\treturn NativeModule;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar cached = NativeModule.getCached(id);\\r\\n\\t\\tif (cached) {\\r\\n\\t\\t\\treturn cached.exports;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!NativeModule.exists(id)) {\\r\\n\\t\\t\\tvar t = NativeModule.require('module');\\r\\n\\t\\t\\tvar path = NativeModule.require('path');\\r\\n\\r\\n\\t\\t\\treturn t.require(path.resolve(process.cwd() + '/js/' + id));\\r\\n\\t\\t\\tthrow new Error('No such native module ' + id);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tprocess.moduleLoadList.push('NativeModule ' + id);\\r\\n\\t\\tvar nativeModule = new NativeModule(id);\\r\\n\\t\\tnativeModule.cache();\\r\\n\\t\\tnativeModule.compile();\\r\\n\\t\\treturn nativeModule.exports;\\r\\n\\t};\\r\\n\\r\\n\\tNativeModule.getCached = function(id) {\\r\\n\\t\\treturn NativeModule._cache[id];\\r\\n\\t};\\r\\n\\r\\n\\tNativeModule.exists = function(id) {\\r\\n\\t\\treturn NativeModule._source.hasOwnProperty(id);\\r\\n\\t};\\r\\n\\r\\n\\tNativeModule.getSource = function(id) {\\r\\n\\t\\tvar filename = NativeModule._source[id];\\r\\n\\t\\tif (process.NativeSource){\\r\\n\\t\\t\\tvar source = process.NativeSource[id];\\r\\n\\t\\t\\t//this will be cached so clean up\\r\\n\\t\\t\\tdelete process.NativeSource[id];\\r\\n\\t\\t\\treturn source;\\r\\n\\t\\t}\\r\\n\\t\\treturn process.readFile(filename);\\r\\n\\t};\\r\\n\\r\\n\\tNativeModule.wrap = function(script) {\\r\\n\\t\\treturn NativeModule.wrapper[0] + script + NativeModule.wrapper[1];\\r\\n\\t};\\r\\n\\r\\n\\tNativeModule.wrapper = [\\r\\n\\t\\t'(function (exports, require, module, __filename, __dirname) {' +\\r\\n\\t\\t\\t'var fn = (function(){',\\r\\n\\t\\t\\t//source here\\r\\n\\t\\t\\t'\\\\n});' +\\r\\n\\t\\t\\t'try {' +\\r\\n\\t\\t\\t\\t'fn();\\\\n' +\\r\\n\\t\\t\\t'} catch (e){\\\\n' +\\r\\n\\t\\t\\t\\t'process.reportError(e);\\\\n' +\\r\\n\\t\\t\\t'};\\\\n'+\\r\\n\\t\\t'});'\\r\\n\\t];\\r\\n\\r\\n\\tNativeModule.prototype.compile = function() {\\r\\n\\t\\tvar source = NativeModule.getSource(this.id);\\r\\n\\t\\tsource = NativeModule.wrap(source);\\r\\n\\t\\tvar fn = process.eval(source, NativeModule._source[this.id]);\\r\\n\\t\\ttry {\\r\\n\\t\\t\\tfn(this.exports, NativeModule.require, this, this.filename);\\r\\n\\t\\t} catch(e){\\r\\n\\t\\t\\tprocess.reallyExit(1);\\r\\n\\t\\t}\\r\\n\\t\\tthis.loaded = true;\\r\\n\\t};\\r\\n\\r\\n\\tNativeModule.prototype.cache = function() {\\r\\n\\t\\tNativeModule._cache[this.id] = this;\\r\\n\\t};\\r\\n\\r\\n\\tstartup();\\r\\n\\r\\n\\tvar _run_looop = function(){\\r\\n\\t\\tvar main_loop = process.main_loop;\\r\\n\\t\\tvar loop = process.binding('loop');\\r\\n\\t\\tvar gcHandle = loop.handle_init(main_loop, function(){\\r\\n\\t\\t\\tDuktape.gc();\\r\\n\\t\\t});\\r\\n\\t\\tloop.handle_unref(gcHandle);\\r\\n\\t\\tloop.timer_start(gcHandle, 5000, 5000);\\r\\n\\r\\n\\t\\t(function _starter(){\\r\\n\\t\\t\\ttry {\\r\\n\\t\\t\\t\\tvar i = 0;\\r\\n\\t\\t\\t\\tvar n = 0;\\r\\n\\t\\t\\t\\twhile(1){\\r\\n\\t\\t\\t\\t\\tprocess._tickCallBack();\\r\\n\\t\\t\\t\\t\\tn = loop.run(main_loop, 1);\\r\\n\\t\\t\\t\\t\\tif (nextTickQueue.length) continue;\\r\\n\\t\\t\\t\\t\\tif (n == 0) break;\\r\\n\\t\\t\\t\\t\\tprocess.sleep(1);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tprocess.emit('exit', 0);\\r\\n\\t\\t\\t} catch (e){\\r\\n\\t\\t\\t\\tprocess.reportError(e);\\r\\n\\t\\t\\t\\t// if we reached here then error has been handeled\\r\\n\\t\\t\\t\\t// by uncaughtException, so redo our loop\\r\\n\\t\\t\\t\\t_starter();\\r\\n\\t\\t\\t}\\r\\n\\t\\t})();\\r\\n\\t};\\r\\n\\r\\n\\tvar r = NativeModule.require('module');\\r\\n\\tvar argv = process.argv;\\r\\n\\tif (argv[1]) {\\r\\n\\t\\tprocess.main = true;\\r\\n\\t\\tr.require(process.argv[1]);\\r\\n\\t}\\r\\n\\r\\n\\t_run_looop();\\r\\n})(process);\\r\\n\""
