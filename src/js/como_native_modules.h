"{\"fileMap\":{\"main\":\"js/main.js\",\"loop\":\"js/loop.js\",\"C\":\"js/C.js\",\"syscall\":\"js/syscall/index.js\",\"syscall/linux\":\"js/syscall/linux.js\",\"syscall/windows\":\"js/syscall/windows.js\",\"module\":\"js/module.js\",\"http_parser\":\"js/http-parser.js\",\"socket\":\"js/socket.js\",\"errno\":\"js/errno.js\",\"os\":\"js/os.js\",\"uv\":\"js/uv/index.js\",\"uv/stream\":\"js/uv/stream.js\",\"uv/tcp\":\"js/uv/tcp.js\",\"uv/pipe\":\"js/uv/pipe.js\",\"uv/process\":\"js/uv/process.js\",\"uv/process/windows\":\"js/uv/process/windows.js\",\"uv/process/unix\":\"js/uv/process/unix.js\",\"uv/tty\":\"js/uv/tty.js\",\"uv/tty/windows\":\"js/uv/tty/windows.js\",\"uv/tty/ansi\":\"js/uv/tty/ansi.js\",\"uv/tty/linux\":\"js/uv/tty/linux.js\",\"internal/util\":\"js/node/internal/util.js\",\"internal/linkedlist\":\"js/node/internal/linkedlist.js\",\"buffer\":\"js/node/buffer.js\",\"util\":\"js/node/util.js\",\"path\":\"js/node/path.js\",\"fs\":\"js/node/fs.js\",\"url\":\"js/node/url.js\",\"readline\":\"js/node/readline.js\",\"querystring\":\"js/node/querystring.js\",\"assert\":\"js/node/assert.js\",\"console\":\"js/node/console.js\",\"constants\":\"js/node/constants.js\",\"events\":\"js/node/events.js\",\"timers\":\"js/node/timers.js\",\"net\":\"js/node/net.js\",\"dns\":\"js/node/dns.js\",\"cluster\":\"js/node/cluster.js\",\"string_decoder\":\"js/node/string_decoder.js\",\"tty\":\"js/node/tty.js\",\"internal/child_process\":\"js/node/internal/child_process.js\",\"internal/socket_list\":\"js/node/internal/socket_list.js\",\"child_process\":\"js/node/child_process.js\",\"stream\":\"js/node/stream.js\",\"_stream_readable\":\"js/node/stream/_stream_readable.js\",\"_stream_writable\":\"js/node/stream/_stream_writable.js\",\"_stream_duplex\":\"js/node/stream/_stream_duplex.js\",\"_stream_transform\":\"js/node/stream/_stream_transform.js\",\"_stream_passthrough\":\"js/node/stream/_stream_passthrough.js\",\"http\":\"js/node/http.js\",\"_http_agent\":\"js/node/http/_http_agent.js\",\"_http_client\":\"js/node/http/_http_client.js\",\"_http_common\":\"js/node/http/_http_common.js\",\"_http_incoming\":\"js/node/http/_http_incoming.js\",\"_http_outgoing\":\"js/node/http/_http_outgoing.js\",\"_http_server\":\"js/node/http/_http_server.js\",\"internal/freelist\":\"js/node/internal/freelist.js\",\"timer_wrap\":\"js/node_wrap/timer_wrap.js\",\"buffer_wrap\":\"js/node_wrap/buffer_wrap.js\",\"tcp_wrap\":\"js/node_wrap/tcp_wrap.js\",\"stream_wrap\":\"js/node_wrap/stream_wrap.js\",\"pipe_wrap\":\"js/node_wrap/pipe_wrap.js\",\"fs_wrap\":\"js/node_wrap/fs_wrap.js\",\"fs_event_wrap\":\"js/node_wrap/fs_event_wrap.js\",\"cares_wrap\":\"js/node_wrap/cares_wrap.js\",\"tty_wrap\":\"js/node_wrap/tty_wrap.js\",\"spawn_sync\":\"js/node_wrap/spawn_sync.js\",\"process_wrap\":\"js/node_wrap/process_wrap.js\",\"uv_wrap\":\"js/node_wrap/uv.js\",\"setup/stdio\":\"js/node/setup/stdio.js\"},\"loop\":\"var loop = process.binding('loop');\\nvar util = require('util');\\nexports.POLLOUT = loop.POLLOUT;\\nexports.POLLIN  = loop.POLLIN;\\nexports.POLLERR = loop.POLLERR;\\nexports.POLLHUP = loop.POLLHUP;\\n\\nconst TIMER = 0;\\nconst IO    = 1;\\n\\nexports.main = new Loop();\\n\\nexports.init = function(){\\n\\treturn new Loop();\\n};\\n\\nfunction Handle (loopHandle, cb){\\n\\tif (cb) this.cb = cb;\\n\\tthis._handle = loop.handle_init(loopHandle, cb);\\n}\\n\\nHandle.prototype.ref = function(){\\n\\tloop.handle_ref(this._handle);\\n};\\n\\nHandle.prototype.unref = function(){\\n\\tloop.handle_unref(this._handle);\\n};\\n\\nHandle.prototype.io_start = function(fd, events, cb){\\n\\tif (cb) this.cb = cb;\\n\\tloop.io_start(this._handle, fd, events, cb);\\n};\\n\\nHandle.prototype.io_stop = function(events){\\n\\tloop.io_stop(this._handle, events);\\n};\\n\\nHandle.prototype.io_active = function(events){\\n\\treturn loop.io_active(this._handle, events);\\n};\\n\\nHandle.prototype.timer_start = function(timeout, repeat, cb){\\n\\tif (cb) this.cb = cb;\\n\\tloop.timer_start(this._handle, timeout, repeat, cb);\\n};\\n\\nHandle.prototype.timer_stop = function(timeout, repeat, cb){\\n\\tloop.timer_stop(this._handle);\\n};\\n\\nHandle.prototype.timer_again = function(timeout, repeat, cb){\\n\\tloop.timer_again(this._handle);\\n};\\n\\n\\nHandle.prototype.close = function(events){\\n\\tloop.handle_close(this._handle, events);\\n};\\n\\nfunction Loop (){\\n\\tthis._handle = loop.init();\\n\\tfor (var key in loop){\\n\\t\\tif (key === 'run' || key === 'update_time') continue;\\n\\t\\tthis[key] = loop[key];\\n\\t}\\n}\\n\\nLoop.prototype.update_time = function(type){\\n\\treturn loop.update_time(this._handle);\\n};\\n\\nLoop.prototype.run = function(type){\\n\\treturn loop.run(this._handle, type);\\n};\\n\\n// inititae new handle\\nLoop.prototype.handle = function(cb){\\n\\treturn new Handle(this._handle, cb);\\n};\\n\\n// initiate io handle\\nLoop.prototype.io = function(cb){\\n\\treturn new IOHandle(this._handle, cb);\\n};\\n\\n/* IO HANDLE */\\nfunction IOHandle (loopHandle, cb){\\n\\tif (cb) this.cb = cb;\\n\\tthis._handle = loop.handle_init(loopHandle, cb);\\n}\\n\\nIOHandle.prototype.close = function(events){\\n\\tloop.handle_close(this._handle, events);\\n};\\n\\nIOHandle.prototype.start = function(fd, events, cb){\\n\\tif (cb) this.cb = cb;\\n\\tloop.io_start(this._handle, fd, events, cb);\\n};\\n\\nIOHandle.prototype.active = function(events){\\n\\treturn loop.io_active(this._handle, events);\\n};\\n\\nIOHandle.prototype.stop = function(events){\\n\\tloop.io_stop(this._handle, events);\\n};\\n\\nIOHandle.prototype.handle_stop = function(){\\n\\tloop.handle_stop(this._handle);\\n};\\n\\nIOHandle.prototype.ref = function(){\\n\\tloop.handle_ref(this._handle);\\n};\\n\\nIOHandle.prototype.unref = function(){\\n\\tloop.handle_unref(this._handle);\\n};\\n\\nexports.setTimeout = setTimeout;\\nexports.setInterval = setInterval;\\nexports.clearInterval = clearInterval;\\nexports.clearTimeout = clearTimeout;\\n\",\"C\":\"'use strict';\\n\\nvar C = process.binding('C');\\n\\nC.LE = (function() {\\n\\tvar buffer = new ArrayBuffer(2);\\n\\tnew DataView(buffer).setInt16(0, 256, true /* littleEndian */);\\n\\t// Int16Array uses the platform's endianness.\\n\\treturn new Int16Array(buffer)[0] === 256;\\n})();\\n\\nvar _typesMap = {\\n\\tuint : {\\n\\t\\tfn   : C.uint,\\n\\t\\tsize : C.sizeOf.int\\n\\t},\\n\\tuint8 : {\\n\\t\\tfn   : C.uint8,\\n\\t\\tsize : C.sizeOf.int8\\n\\t},\\n\\tuint16 : {\\n\\t\\tfn   : C.uint16,\\n\\t\\tsize : C.sizeOf.int16\\n\\t},\\n\\tuint32 : {\\n\\t\\tfn   : C.uint32,\\n\\t\\tsize : C.sizeOf.int32\\n\\t},\\n\\tuint64 : {\\n\\t\\tfn   : C.uint64,\\n\\t\\tsize : C.sizeOf.uint64\\n\\t},\\n\\tint : {\\n\\t\\tfn   : C.int,\\n\\t\\tsize : C.sizeOf.int\\n\\t},\\n\\tint8 : {\\n\\t\\tfn   : C.int8,\\n\\t\\tsize : C.sizeOf.int8\\n\\t},\\n\\tint16 : {\\n\\t\\tfn   : C.int16,\\n\\t\\tsize : C.sizeOf.int16\\n\\t},\\n\\tint32 : {\\n\\t\\tfn   : C.int32,\\n\\t\\tsize : C.sizeOf.int32\\n\\t},\\n\\tint64 : {\\n\\t\\tfn   : C.int64,\\n\\t\\tsize : C.sizeOf.int64\\n\\t},\\n\\tpointer : {\\n\\t\\tfn   : C.pointer,\\n\\t\\tsize : C.sizeOf.uintptr\\n\\t},\\n\\t'*' : {\\n\\t\\tfn   : C.pointer,\\n\\t\\tsize : C.sizeOf.uintptr\\n\\t}\\n};\\n\\nfunction STRUCT (obj, data, off, siz){\\n\\tvar self = this;\\n\\tself.byteLength = 0;\\n\\tself.fields = {};\\n\\n\\tfor (var key in obj){\\n\\t\\tvar val = obj[key];\\n\\t\\tvar field = self.fields[key] = { offset : self.byteLength };\\n\\t\\tvar size = 0;\\n\\n\\t\\tif (typeof val === 'number') {\\n\\t\\t\\tsize = val;\\n\\t\\t\\tfield.fn = function(buff, offset, size, val){\\n\\t\\t\\t\\tvar fix = buff.type !== 'struct' ? buff.off : 0;\\n\\t\\t\\t\\tif (val){\\n\\t\\t\\t\\t\\tC.buffer( buff.buffer, offset + fix, size, val );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn new Uint8Array(buff.buffer, offset + fix, size);\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t} else if (typeof val === 'string') {\\n\\t\\t\\tvar s = _typesMap[val];\\n\\t\\t\\tif (!s) throw new Error('unknow struct type ' + val);\\n\\t\\t\\tsize = s.size;\\n\\t\\t\\tfield.fn = s.fn;\\n\\t\\t} else if (typeof val === 'function' && val.type === 'STRUCT') {\\n\\t\\t\\t(function(val){\\n\\t\\t\\t\\tvar struct = new val();\\n\\t\\t\\t\\tsize = struct.byteLength;\\n\\t\\t\\t\\tfield.fn = function(buff, offset, size){\\n\\t\\t\\t\\t\\treturn new val(buff, offset, size);\\n\\t\\t\\t\\t};\\n\\t\\t\\t})(val);\\n\\t\\t}\\n\\n\\t\\tif (typeof val === 'object'){\\n\\t\\t\\tif (self.fields.length) {\\n\\t\\t\\t\\tself.byteLength = self.fields.length.size;\\n\\t\\t\\t\\tdelete self.fields.length;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfield.offset = val.offset;\\n\\t\\t\\tfield.size   = val.size;\\n\\t\\t\\tfield.fn     = _typesMap[val.type].fn;\\n\\t\\t} else {\\n\\t\\t\\tself.byteLength += size;\\n\\t\\t\\tfield.size = size;\\n\\t\\t}\\n\\n\\t\\t(function(field){\\n\\t\\t\\tObject.defineProperty(self, key, {\\n\\t\\t\\t\\tget : function(){\\n\\t\\t\\t\\t\\treturn field.fn(this, field.offset, field.size);\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tset : function(val){\\n\\t\\t\\t\\t\\tfield.fn(this, field.offset, field.size, val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t})(self.fields[key]);\\n\\t}\\n\\n\\tObject.defineProperty(self, 'pointer', {\\n\\t\\tget : function(){\\n\\t\\t\\treturn C.to_pointer(this);\\n\\t\\t}\\n\\t});\\n\\n\\treturn self;\\n}\\n\\nSTRUCT.prototype.inspect = function() {\\n\\tvar b = new Uint8Array(this);\\n\\tb.Length = this.byteLength;\\n\\tb.fields = this.fields;\\n\\treturn b;\\n}\\n\\nC.struct = function (obj) {\\n\\tvar st = new STRUCT(obj);\\n\\tvar fn = function(data, off, size) {\\n\\t\\tvar buff;\\n\\t\\tst.off = 0 || off;\\n\\t\\tst.type = 'struct';\\n\\n\\t\\tif (data && size){\\n\\t\\t\\tbuff = new Uint8Array( data.buffer, off + (data.off || 0), size );\\n\\t\\t} else {\\n\\t\\t\\tbuff = new Uint8Array( st.byteLength );\\n\\t\\t\\tif (data) C.buffer( buff, data );\\n\\t\\t}\\n\\n\\t\\tst.buffer = buff.buffer;\\n\\n\\t\\tObject.setPrototypeOf(buff, st);\\n\\t\\treturn buff;\\n\\t};\\n\\tfn.type = 'STRUCT';\\n\\treturn fn;\\n};\\n\\nC.union = function(obj) {\\n\\tvar st = new STRUCT(obj);\\n\\tvar fn = function(data, off, size) {\\n\\t\\tst.off = 0 || off;\\n\\t\\tvar maxSize = 0;\\n\\t\\tfor (var key in st.fields){\\n\\t\\t\\tst.fields[key].offset = 0;\\n\\t\\t\\tif (st.fields[key].size > maxSize) {\\n\\t\\t\\t\\tmaxSize = st.fields[key].size;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tst.byteLength = maxSize;\\n\\n\\t\\tvar buff;\\n\\t\\tif (data && size){\\n\\t\\t\\tif (size > maxSize) throw('max size');\\n\\t\\t\\tbuff = new Uint8Array( data.buffer, off + (data.off || 0), size);\\n\\t\\t} else {\\n\\t\\t\\tbuff = new Uint8Array( maxSize );\\n\\t\\t\\tif (data) C.buffer( buff, data );\\n\\t\\t}\\n\\n\\t\\tst.buffer = buff.buffer;\\n\\t\\tObject.setPrototypeOf(buff, st);\\n\\t\\treturn buff;\\n\\t};\\n\\tfn.type = 'STRUCT';\\n\\treturn fn;\\n};\\n\\nvar voidValues = {};\\nObject.defineProperty(voidValues, 'ptr', {\\n\\tget : function(){\\n\\t\\treturn C.pointer(this);\\n\\t}\\n});\\n\\nObject.defineProperty(voidValues, 'int', {\\n\\tget : function(){\\n\\t\\treturn C.int(this, 0);\\n\\t},\\n\\tset : function(v){\\n\\t\\tC.int(this, 0, 0, v);\\n\\t}\\n});\\n\\nObject.defineProperty(voidValues, 'int32', {\\n\\tget : function(){\\n\\t\\treturn C.int32(this, 0);\\n\\t},\\n\\tset : function(v){\\n\\t\\tC.int32(this, 0, 0, v);\\n\\t}\\n});\\n\\nObject.defineProperty(voidValues, 'uint32', {\\n\\tget : function(){\\n\\t\\treturn C.uint32(this, 0);\\n\\t},\\n\\tset : function(v){\\n\\t\\tC.uint32(this, 0, 0, v);\\n\\t}\\n});\\n\\nC.void = function(n){\\n\\tvar buf = new ArrayBuffer(n || C.sizeOf.intptr);\\n\\tObject.setPrototypeOf(buf, voidValues);\\n\\treturn buf;\\n}\\n\\nvar Struct = {};\\nObject.keys(C.Struct).forEach(function(name) {\\n\\tif (name === 'create') return;\\n\\tStruct[name] = C.struct(C.Struct[name]());\\n});\\n\\nC.Struct = Struct;\\n\\nmodule.exports = C;\\n\",\"syscall\":\"var binding = process.binding('syscall');\\nvar errno   = require('errno');\\nvar C       = require('C');\\nvar sock    = require('socket');\\nvar syscall = exports;\\n\\n{\\t// shared constants\\n\\tsyscall.AF_UNSPEC   = sock.AF_UNSPEC;\\n\\tsyscall.SOCK_STREAM = sock.SOCK_STREAM;\\n\\tsyscall.IPPROTO_IP  = sock.IPPROTO_IP;\\n\\tsyscall.AF_INET     = sock.AF_INET;\\n\\tsyscall.AF_INET6    = sock.AF_INET6;\\n}\\n\\nvar _LoadedLib = {};\\nvar littleEndian = (function() {\\n\\tvar buffer = new ArrayBuffer(2);\\n\\tnew DataView(buffer).setInt16(0, 256, true /* littleEndian */);\\n\\treturn new Int16Array(buffer)[0] === 256; // Int16Array uses the platform's endianness.\\n})();\\n\\nvar rr     = new ArrayBuffer(8);\\nvar retVal = new DataView(rr, 0);\\n\\n// syscall.LoadLibrary Constructor\\n// see expoprts.LoadLibrary\\nfunction NewLoadLibrary (h){\\n\\tthis._handle = h;\\n\\tthis.procs = {};\\n\\n\\t// return a function (name) from proc address\\n\\t// if errval passed, the return value will check against\\n\\t// this errval and if matched the function will return null\\n\\t// and set process.errno to the last error\\n\\tthis.GetProcAddress = function(name, errval){\\n\\t\\tvar fn = binding.GetProcAddress(h, name);\\n\\t\\tif (fn === null){\\n\\t\\t\\tthrow new Error(\\\"unknown proc name \\\" + name);\\n\\t\\t}\\n\\n\\t\\t//return cached function\\n\\t\\tvar proc = this.procs[name];\\n\\t\\tif (proc) return proc;\\n\\n\\t\\tthis.procs[name] = function (){\\n\\t\\t\\tvar args = [].slice.call(arguments);\\n\\t\\t\\targs.unshift(retVal);\\n\\t\\t\\targs.unshift(fn);\\n\\t\\t\\tbinding.syscall.apply(null, args);\\n\\t\\t\\tvar r = retVal.getInt32(0, littleEndian);\\n\\t\\t\\tif (typeof errval !== 'undefined'){\\n\\t\\t\\t\\tif (r === errval){\\n\\t\\t\\t\\t\\tprocess.errno = syscall.GetLastError() || errno.EINVAL;\\n\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn r;\\n\\t\\t};\\n\\t\\treturn this.procs[name];\\n\\t};\\n}\\n\\n\\n// load WINAPI Library\\n// var lib = syscall.LoadLibrary('kernel32');\\n// var ReadFile = lib.GetProcAddress('ReadFile');\\n// ReadFile( ..args.. );\\n//===========================================================\\n  syscall.LoadLibrary = function (lib){\\n//===========================================================\\n\\tif (_LoadedLib[lib]) {\\n\\t\\treturn _LoadedLib[lib];\\n\\t}\\n\\n\\tvar handle = binding.LoadLibrary(lib);\\n\\tif (handle === null){\\n\\t\\tthrow new Error(\\\"unknown library name \\\" + lib);\\n\\t}\\n\\n\\t_LoadedLib[lib] = new NewLoadLibrary(handle);\\n\\treturn _LoadedLib[lib];\\n};\\n\\n\\nvar platform = process.platform;\\nif (platform === 'win32'){\\n\\trequire('syscall/windows')(module);\\n} else {\\n\\trequire('syscall/linux')(module);\\n}\\n\\n//===========================================================\\n  syscall.LookupIP = function(name) {\\n//===========================================================\\n\\tvar hints = new C.Struct.addrinfo();\\n\\n\\t//set hints\\n\\thints.ai_family   = syscall.AF_UNSPEC;\\n\\thints.ai_socktype = syscall.SOCK_STREAM;\\n\\thints.ai_protocol = syscall.IPPROTO_IP;\\n\\n\\tvar result = C.void();\\n\\t// name = UTF16PtrFromString(name);\\n\\n\\tvar e = syscall.getaddrinfo(name, null, hints, result);\\n\\tif (e !== 0){\\n\\t\\tthrow new Error(e);\\n\\t}\\n\\n\\t// get pointer address stored in result buffer\\n\\tvar freePTR = result.ptr;\\n\\tresult = freePTR;\\n\\tvar addrs = [];\\n\\n\\tvar info = new C.Struct.addrinfo(result);\\n\\twhile (result !== null){\\n\\t\\tvar info = new C.Struct.addrinfo(result);\\n\\t\\tresult = info.ai_next;\\n\\t\\tswitch (info.ai_family){\\n\\t\\t\\tcase syscall.AF_INET : {\\n\\t\\t\\t\\tvar addr = new C.Struct.sockaddr(info.ai_addr);\\n\\t\\t\\t\\taddrs.push(sock.ntop(addr.pointer));\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcase syscall.AF_INET6 : {\\n\\t\\t\\t\\tvar addr = new C.Struct.sockaddr6(info.ai_addr);\\n\\t\\t\\t\\taddrs.push(sock.ntop(addr.pointer));\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tdefault : throw new Error('unknown family type');\\n\\t\\t}\\n\\t}\\n\\n\\tsyscall.freeaddrinfo(freePTR);\\n\\treturn addrs;\\n};\\n\",\"syscall/linux\":\"module.exports = (function(platform){\\n\\tvar sys     = process.binding('syscall');\\n\\tvar C       = require('C');\\n\\tvar assert  = require('assert');\\n\\tvar errno   = require('errno');\\n\\n\\texports = platform.exports;\\n\\texports.SYS = sys;\\n\\n\\t//===========================================================\\n\\t  var Timespec                                   // STRUCT //\\n\\t//===========================================================\\n\\t= exports.Timespec\\n\\t= C.struct({\\n\\t\\tSec  : 'int32',\\n\\t\\tNsec : 'int32'\\n\\t});\\n\\n\\t//===========================================================\\n\\t  var Stat_t                                     // STRUCT //\\n\\t//===========================================================\\n\\t= exports.Stat_t\\n\\t= C.struct({\\n\\t\\tDev       : 'uint64',\\n\\t\\tX__pad1   : 'uint16',\\n\\t\\tPad_cgo_0 : 2, //2 bytes buffer padding\\n\\t\\tX__st_ino : 'uint32',\\n\\t\\tMode      : 'uint32',\\n\\t\\tNlink     : 'uint32',\\n\\t\\tUid       : 'uint32',\\n\\t\\tGid       : 'uint32',\\n\\t\\tRdev      : 'uint64',\\n\\t\\tX__pad2   : 'uint16',\\n\\t\\tPad_cgo_1 : 2, //2 bytes buffer padding\\n\\t\\tSize      : 'int64',\\n\\t\\tBlksize   : 'int32',\\n\\t\\tBlocks    : 'int64',\\n\\t\\tAtim      : exports.Timespec, //Timespec\\n\\t\\tMtim      : exports.Timespec, //Timespec\\n\\t\\tCtim      : exports.Timespec, //Timespec\\n\\t\\tIno       : 'uint64'\\n\\t});\\n\\n\\t//===========================================================\\n\\t  var WinSize                                    // STRUCT //\\n\\t//===========================================================\\n\\t= exports.WinSize\\n\\t= C.struct({\\n\\t\\tws_row    : 'uint16',\\n\\t\\tws_col    : 'uint16',\\n\\t\\tws_xpixel : 'uint16',\\n\\t\\tws_ypixel : 'uint16'\\n\\t});\\n\\n\\tvar libc = exports.LoadLibrary(null);\\n\\n\\tvar kill  = libc.GetProcAddress('kill', -1, 2);\\n\\tvar fcntl = libc.GetProcAddress('fcntl', -1);\\n\\tvar fork = libc.GetProcAddress('fork', -1, 0);\\n\\tvar dup2 = libc.GetProcAddress('dup2', -1, 2);\\n\\tvar chdir = libc.GetProcAddress('chdir', -1, 1);\\n\\tvar setgroups = libc.GetProcAddress('setgroups', -1, 2);\\n\\tvar execlp = libc.GetProcAddress('execlp', -1, 3);\\n\\tvar wait = libc.GetProcAddress('wait', -1, 1);\\n\\tvar waitpid = libc.GetProcAddress('waitpid', -1, 3);\\n    var setenv  = libc.GetProcAddress('setenv', -1, 3);\\n    var putenv  = libc.GetProcAddress('putenv', -1, 1);\\n    var recvmsg  = libc.GetProcAddress('recvmsg', -1, 3);\\n    var setsid  = libc.GetProcAddress('setsid', -1, 0);\\n    var open  = libc.GetProcAddress('open', -1, 3);\\n    var getuid = libc.GetProcAddress('getuid', -1, 0);\\n    var setuid = libc.GetProcAddress('setuid', -1, 1);\\n    var isatty = libc.GetProcAddress('isatty', -1, 1);\\n    var getaddrinfo   = libc.GetProcAddress('getaddrinfo');\\n    var freeaddrinfo   = libc.GetProcAddress('freeaddrinfo');\\n    var ioctl   = libc.GetProcAddress('ioctl', -1);\\n\\n\\tvar pipe2;\\n\\ttry {\\n\\t\\tpipe2 = libc.GetProcAddress('pipe2', -1, 2);\\n\\t} catch (e){}\\n\\n\\tvar pipe = libc.GetProcAddress('pipe', -1, 1);\\n\\n\\t// direct exported functions\\n\\t//===========================================================\\n\\t  exports.GetLastError = sys.GetLastError;\\n\\t  exports.kill  = sys.kill;\\n\\t  exports.fcntl = fcntl;\\n\\t  exports.fork  = fork;\\n\\t  exports.dup2  = dup2;\\n\\t  exports.chdir  = chdir;\\n\\t  exports.setgroups  = setgroups;\\n\\t  exports.execlp = execlp;\\n\\t  exports.waitpid = waitpid;\\n\\t  exports.putenv = putenv;\\n\\t  exports.recvmsg = recvmsg;\\n\\t  exports.setsid = setsid;\\n\\t  exports.setuid = setuid;\\n\\t  exports.getuid = getuid;\\n\\t  exports.getaddrinfo = getaddrinfo;\\n\\t  exports.freeaddrinfo = freeaddrinfo;\\n\\t  exports.isatty = isatty;\\n\\t  exports.ioctl = ioctl;\\n\\t//===========================================================\\n\\n\\t// cloexec\\n\\t//===========================================================\\n\\t  exports.cloexec = function(fd, set){\\n\\t//===========================================================\\n\\t\\tvar flags = 0;\\n\\t\\tvar ret = fcntl(fd, sys.F_GETFD);\\n\\t\\tif (ret === null) return null;\\n\\n\\t\\t// if cloexec flag already set do nothing\\n\\t\\tif (!!(ret & sys.FD_CLOEXEC) == !!set) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tif (set) {\\n\\t\\t\\tflags = ret | sys.FD_CLOEXEC;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tflags = ret & ~sys.FD_CLOEXEC;\\n\\t\\t}\\n\\n\\t\\tret = fcntl(fd, sys.F_SETFD, flags);\\n\\t\\tif (ret === null) return null;\\n\\t\\treturn 1;\\n\\t};\\n\\n\\t// return a pair of pipes, null on error\\n\\t//===========================================================\\n\\t  var pairs = new C.struct({ f : 'int', s : 'int' })();\\n\\t  exports.pipe = function(){\\n\\t//===========================================================\\n\\t\\tif (pipe(pairs) === null) return null;\\n\\t\\treturn [pairs.f, pairs.s];\\n\\t}\\n\\n\\n\\tif (pipe2){\\n\\t\\t// exports pipe2 function if supported\\n\\t\\t//===========================================================\\n\\t\\t  exports.pipe2 = function(flags){\\n\\t\\t//===========================================================\\n\\t\\t\\tif (pipe2(pairs, flags || 0) === null) return null;\\n\\t\\t\\treturn [pairs.f, pairs.s];\\n\\t\\t}\\n\\t}\\n\\n\\t// process check status\\n\\t//===========================================================\\n\\t  exports.WTERMSIG    = function(s) { return (s & 0x7f) }\\n\\t  exports.WEXITSTATUS = function(s) { return ((s) & 0xff00) >> 8 }\\n\\t  exports.WIFEXITED   = function(s)  { return !exports.WTERMSIG(s) }\\n\\t  exports.WIFSIGNALED = function(s) { return (( s & 0xffff) -1) < 0xff }\\n\\t//===========================================================\\n\\n\\n\\t// set environment variable\\n\\t//===========================================================\\n\\t  exports.Setenv = function(name, val){\\n\\t//===========================================================\\n\\t\\treturn setenv(name, val, 1);\\n\\t};\\n\\n\\n\\texports.Open = function(file, access, perm){\\n\\t\\treturn open(file, access, perm || 0);\\n\\t}\\n});\\n\",\"syscall/windows\":\"module.exports = (function(platform){\\n\\tvar binding = process.binding('syscall');\\n\\tvar assert  = require('assert');\\n\\tvar errno   = require('errno');\\n\\tvar C       = require('C');\\n\\t// var utf16   = require('../go/unicode/utf16');\\n\\n\\tvar syscall = exports = platform.exports;\\n\\n\\t{\\t// Invented values to support what package os expects.\\n\\t\\tvar O_RDONLY   = exports.O_RDONLY   = 0x00000;\\n\\t\\tvar O_WRONLY   = exports.O_WRONLY   = 0x00001;\\n\\t\\tvar O_RDWR     = exports.O_RDWR     = 0x00002;\\n\\t\\tvar O_CREAT    = exports.O_CREAT    = 0x00040;\\n\\t\\tvar O_EXCL     = exports.O_EXCL     = 0x00080;\\n\\t\\tvar O_NOCTTY   = exports.O_NOCTTY   = 0x00100;\\n\\t\\tvar O_TRUNC    = exports.O_TRUNC    = 0x00200;\\n\\t\\tvar O_NONBLOCK = exports.O_NONBLOCK = 0x00800;\\n\\t\\tvar O_APPEND   = exports.O_APPEND   = 0x00400;\\n\\t\\tvar O_SYNC     = exports.O_SYNC     = 0x01000;\\n\\t\\tvar O_ASYNC    = exports.O_ASYNC    = 0x02000;\\n\\t\\tvar O_CLOEXEC  = exports.O_CLOEXEC  = 0x80000;\\n\\t}\\n\\n\\t{\\n\\t\\tGENERIC_READ    = 0x80000000\\n\\t\\tGENERIC_WRITE   = 0x40000000\\n\\t\\tGENERIC_EXECUTE = 0x20000000\\n\\t\\tGENERIC_ALL     = 0x10000000\\n\\n\\t\\tFILE_LIST_DIRECTORY   = 0x00000001\\n\\t\\tFILE_APPEND_DATA      = 0x00000004\\n\\t\\tFILE_WRITE_ATTRIBUTES = 0x00000100\\n\\n\\t\\tFILE_SHARE_READ              = 0x00000001\\n\\t\\tFILE_SHARE_WRITE             = 0x00000002\\n\\t\\tFILE_SHARE_DELETE            = 0x00000004\\n\\t\\tFILE_ATTRIBUTE_READONLY      = 0x00000001\\n\\t\\tFILE_ATTRIBUTE_HIDDEN        = 0x00000002\\n\\t\\tFILE_ATTRIBUTE_SYSTEM        = 0x00000004\\n\\t\\tFILE_ATTRIBUTE_DIRECTORY     = 0x00000010\\n\\t\\tFILE_ATTRIBUTE_ARCHIVE       = 0x00000020\\n\\t\\tFILE_ATTRIBUTE_NORMAL        = 0x00000080\\n\\t\\tFILE_ATTRIBUTE_REPARSE_POINT = 0x00000400\\n\\n\\t\\tINVALID_FILE_ATTRIBUTES = 0xffffffff\\n\\n\\t\\tCREATE_NEW        = 1\\n\\t\\tCREATE_ALWAYS     = 2\\n\\t\\tOPEN_EXISTING     = 3\\n\\t\\tOPEN_ALWAYS       = 4\\n\\t\\tTRUNCATE_EXISTING = 5\\n\\n\\t\\tFILE_FLAG_OPEN_REPARSE_POINT = 0x00200000\\n\\t\\tFILE_FLAG_BACKUP_SEMANTICS   = 0x02000000\\n\\t\\tFILE_FLAG_OVERLAPPED         = 0x40000000\\n\\n\\t\\texports.HANDLE_FLAG_INHERIT    = 0x00000001\\n\\t\\texports.STARTF_USESTDHANDLES   = 0x00000100\\n\\t\\texports.STARTF_USESHOWWINDOW   = 0x00000001\\n\\t\\texports.DUPLICATE_CLOSE_SOURCE = 0x00000001\\n\\t\\texports.DUPLICATE_SAME_ACCESS  = 0x00000002\\n\\n\\t\\tSTD_INPUT_HANDLE  = -10\\n\\t\\tSTD_OUTPUT_HANDLE = -11\\n\\t\\tSTD_ERROR_HANDLE  = -12\\n\\n\\t\\tFILE_BEGIN   = 0\\n\\t\\tFILE_CURRENT = 1\\n\\t\\tFILE_END     = 2\\n\\n\\t\\tLANG_ENGLISH       = 0x09\\n\\t\\tSUBLANG_ENGLISH_US = 0x01\\n\\n\\t\\tFORMAT_MESSAGE_ALLOCATE_BUFFER = 256\\n\\t\\tFORMAT_MESSAGE_IGNORE_INSERTS  = 512\\n\\t\\tFORMAT_MESSAGE_FROM_STRING     = 1024\\n\\t\\tFORMAT_MESSAGE_FROM_HMODULE    = 2048\\n\\t\\tFORMAT_MESSAGE_FROM_SYSTEM     = 4096\\n\\t\\tFORMAT_MESSAGE_ARGUMENT_ARRAY  = 8192\\n\\t\\tFORMAT_MESSAGE_MAX_WIDTH_MASK  = 255\\n\\n\\t\\tMAX_PATH      = 260\\n\\t\\tMAX_LONG_PATH = 32768\\n\\n\\t\\tMAX_COMPUTERNAME_LENGTH = 15\\n\\n\\t\\tTIME_ZONE_ID_UNKNOWN  = 0\\n\\t\\tTIME_ZONE_ID_STANDARD = 1\\n\\n\\t\\tTIME_ZONE_ID_DAYLIGHT = 2\\n\\t\\tIGNORE                = 0\\n\\t\\tINFINITE              = 0xffffffff\\n\\n\\t\\tWAIT_TIMEOUT   = 258\\n\\t\\tWAIT_ABANDONED = 0x00000080\\n\\t\\tWAIT_OBJECT_0  = 0x00000000\\n\\t\\tWAIT_FAILED    = 0xFFFFFFFF\\n\\n\\t\\tCREATE_NEW_PROCESS_GROUP   = 0x00000200\\n\\t\\tCREATE_UNICODE_ENVIRONMENT = 0x00000400\\n\\n\\t\\texports.PROCESS_TERMINATE         = 1\\n\\t\\texports.PROCESS_QUERY_INFORMATION = 0x00000400\\n\\t\\texports.SYNCHRONIZE               = 0x00100000\\n\\n\\t\\tPAGE_READONLY          = 0x02\\n\\t\\tPAGE_READWRITE         = 0x04\\n\\t\\tPAGE_WRITECOPY         = 0x08\\n\\t\\tPAGE_EXECUTE_READ      = 0x20\\n\\t\\tPAGE_EXECUTE_READWRITE = 0x40\\n\\t\\tPAGE_EXECUTE_WRITECOPY = 0x80\\n\\n\\t\\tFILE_MAP_COPY    = 0x01\\n\\t\\tFILE_MAP_WRITE   = 0x02\\n\\t\\tFILE_MAP_READ    = 0x04\\n\\t\\tFILE_MAP_EXECUTE = 0x20\\n\\n\\t\\tCTRL_C_EVENT     = 0\\n\\t\\tCTRL_BREAK_EVENT = 1\\n\\t}\\n\\n\\t{\\t//File types\\n\\t\\texports.FILE_TYPE_CHAR    = 0x0002\\n\\t\\texports.FILE_TYPE_DISK    = 0x0001\\n\\t\\texports.FILE_TYPE_PIPE    = 0x0003\\n\\t\\texports.FILE_TYPE_REMOTE  = 0x8000\\n\\t\\texports.FILE_TYPE_UNKNOWN = 0x0000\\n\\t}\\n\\n\\n\\t{\\t// ShowWindow constants\\n\\t\\t// winuser.h\\n\\t\\texports.SW_HIDE            = 0\\n\\t\\tSW_NORMAL          = 1\\n\\t\\tSW_SHOWNORMAL      = 1\\n\\t\\texports.SW_SHOWMINIMIZED   = 2\\n\\t\\tSW_SHOWMAXIMIZED   = 3\\n\\t\\tSW_MAXIMIZE        = 3\\n\\t\\tSW_SHOWNOACTIVATE  = 4\\n\\t\\tSW_SHOW            = 5\\n\\t\\tSW_MINIMIZE        = 6\\n\\t\\tSW_SHOWMINNOACTIVE = 7\\n\\t\\tSW_SHOWNA          = 8\\n\\t\\tSW_RESTORE         = 9\\n\\t\\texports.SW_SHOWDEFAULT     = 10\\n\\t\\tSW_FORCEMINIMIZE   = 11\\n\\t}\\n\\n\\tvar WORD   = 'uint16';\\n\\tvar DWORD  = 'uint32';\\n\\tvar HANDLE = 'uint32';\\n\\tvar ULONG  = 'uint32';\\n\\n\\t//===========================================================\\n\\t\\tvar Overlapped                               // STRUCT //\\n\\t//===========================================================\\n\\t= exports.Overlapped\\n\\t= C.struct({\\n\\t\\tInternal     : ULONG,\\n\\t\\tInternalHigh : ULONG,\\n\\t\\tOffset       : 'uint32',\\n\\t\\tOffsetHigh   : 'uint32',\\n\\t\\tHEvent       : HANDLE\\n\\t});\\n\\n\\n\\t//===========================================================\\n\\t\\tvar Filetime                                 // STRUCT //\\n\\t//===========================================================\\n\\t= exports.Filetime\\n\\t= C.struct({\\n\\t\\tLowDateTime  : DWORD,\\n\\t\\tHighDateTime : DWORD\\n\\t});\\n\\n\\n\\t//===========================================================\\n\\t\\tvar ByHandleFileInformation                  // STRUCT //\\n\\t//===========================================================\\n\\t= exports.ByHandleFileInformation\\n\\t= C.struct({\\n\\t\\tFileAttributes      : DWORD,\\n\\t\\tCreationTime        : exports.Filetime,\\n\\t\\tLastAccessTime      : exports.Filetime,\\n\\t\\tLastWriteTime       : exports.Filetime,\\n\\t\\tVolumeSerialNumber  : DWORD,\\n\\t\\tFileSizeHigh        : DWORD,\\n\\t\\tFileSizeLow         : DWORD,\\n\\t\\tNumberOfLinks       : DWORD,\\n\\t\\tFileIndexHigh       : DWORD,\\n\\t\\tFileIndexLow        : DWORD\\n\\t});\\n\\n\\n\\t//===========================================================\\n\\t\\tvar Win32FileAttributeData                   // STRUCT //\\n\\t//===========================================================\\n\\t= exports.Win32FileAttributeData\\n\\t= C.struct({\\n\\t\\tFileAttributes : 'uint32',\\n\\t\\tCreationTime   : exports.Filetime,\\n\\t\\tLastAccessTime : exports.Filetime,\\n\\t\\tLastWriteTime  : exports.Filetime,\\n\\t\\tFileSizeHigh   : 'uint32',\\n\\t\\tFileSizeLow    : 'uint32'\\n\\t});\\n\\n\\n\\t//===========================================================\\n\\t\\tvar SystemTime                               // STRUCT //\\n\\t//===========================================================\\n\\t= exports.SystemTime\\n\\t= C.struct({\\n\\t\\tYear         : WORD,\\n\\t\\tMonth        : WORD,\\n\\t\\tDayOfWeek    : WORD,\\n\\t\\tDay          : WORD,\\n\\t\\tHour         : WORD,\\n\\t\\tMinute       : WORD,\\n\\t\\tSecond       : WORD,\\n\\t\\tMilliseconds : WORD\\n\\t});\\n\\n\\t//===========================================================\\n\\t\\tvar SecurityAttributes                       // STRUCT //\\n\\t//===========================================================\\n\\t= exports.SecurityAttributes\\n\\t= C.struct ({\\n\\t\\tLength             : 'uint32',\\n\\t\\tSecurityDescriptor : 'uint32',\\n\\t\\tInheritHandle      : 'uint32'\\n\\t});\\n\\n\\n\\t//===========================================================\\n\\t\\tvar StartupInfo                              // STRUCT //\\n\\t//===========================================================\\n\\t= exports.StartupInfo\\n\\t= C.struct({\\n\\t\\tCb            : 'uint32',\\n\\t\\tReserved1     : '*',\\n\\t\\tDesktop       : '*',\\n\\t\\tTitle         : '*',\\n\\t\\tX             : 'uint32',\\n\\t\\tY             : 'uint32',\\n\\t\\tXSize         : 'uint32',\\n\\t\\tYSize         : 'uint32',\\n\\t\\tXCountChars   : 'uint32',\\n\\t\\tYCountChars   : 'uint32',\\n\\t\\tFillAttribute : 'uint32',\\n\\t\\tFlags         : 'uint32',\\n\\t\\tShowWindow    : 'uint16',\\n\\t\\tReserved2     : 'uint16',\\n\\t\\tReserved3     : '*',\\n\\t\\tStdInput      : HANDLE,\\n\\t\\tStdOutput     : HANDLE,\\n\\t\\tStdError      : HANDLE\\n\\t});\\n\\n\\t//===========================================================\\n\\t\\tvar ProcessInformation                       // STRUCT //\\n\\t//===========================================================\\n\\t= exports.ProcessInformation\\n\\t= C.struct({\\n\\t\\tProcess   : HANDLE,\\n\\t\\tThread    : HANDLE,\\n\\t\\tProcessId : 'uint32',\\n\\t\\tThreadId  : 'uint32'\\n\\t});\\n\\n\\t//kernel32 library\\n\\tvar kernel       = exports.LoadLibrary('kernel32');\\n\\tvar ws2          = exports.LoadLibrary('Ws2_32');\\n\\texports.WSADuplicateSocket = ws2.GetProcAddress('WSADuplicateSocketW', -1, 3);\\n\\texports.WSASocket = ws2.GetProcAddress('WSASocketW');\\n\\texports.WSAGetLastError = ws2.GetProcAddress('WSAGetLastError');\\n\\n\\texports.getaddrinfo   = ws2.GetProcAddress('getaddrinfo', null, 4);\\n\\texports.freeaddrinfo  = ws2.GetProcAddress('freeaddrinfo');\\n\\n\\tGetLastError     = kernel.GetProcAddress('GetLastError');\\n\\n\\t// functions with failure value of -1.\\n\\tvar GetStdHandle = kernel.GetProcAddress('GetStdHandle', -1);\\n\\tvar CreateFile   = kernel.GetProcAddress('CreateFileW', -1);\\n\\n\\tvar ReadFile      = kernel.GetProcAddress('ReadFile', 0);\\n\\tvar WriteFile     = kernel.GetProcAddress('WriteFile', 0);\\n\\tvar GetTempPath   = kernel.GetProcAddress('GetTempPathW');\\n\\tvar WriteConsole  = kernel.GetProcAddress('WriteConsoleW');\\n\\tvar GetFileType   = kernel.GetProcAddress('GetFileType', 0, 1);\\n\\n\\tvar SetHandleInformation = kernel.GetProcAddress('SetHandleInformation', 0);\\n\\tvar GetFileInformationByHandle = kernel.GetProcAddress('GetFileInformationByHandle', 0);\\n\\tvar DuplicateHandle = kernel.GetProcAddress('DuplicateHandle', 0);\\n\\tvar GetCurrentProcess = kernel.GetProcAddress('GetCurrentProcess');\\n\\tvar GetCurrentProcessId = kernel.GetProcAddress('GetCurrentProcessId');\\n\\tvar FileTimeToSystemTime = kernel.GetProcAddress('FileTimeToSystemTime', 0, 2);\\n\\tvar OpenProcess    = kernel.GetProcAddress('OpenProcess', 0);\\n\\tvar TerminateProcess   = kernel.GetProcAddress('TerminateProcess', 0, 2);\\n\\tvar CreateProcess    = kernel.GetProcAddress('CreateProcessW', 0);\\n\\tvar CloseHandle    = kernel.GetProcAddress('CloseHandle', 0);\\n\\tvar GetExitCodeProcess = kernel.GetProcAddress('GetExitCodeProcess', 0);\\n\\tvar GetCurrentDirectory =  kernel.GetProcAddress('GetCurrentDirectoryW', 0);\\n\\tvar GetEnvironmentVariable =  kernel.GetProcAddress('GetEnvironmentVariableW', 0);\\n\\tvar CreatePipe = kernel.GetProcAddress('CreatePipe', 0);\\n\\tvar GetConsoleMode = kernel.GetProcAddress('GetConsoleMode', 0, 2);\\n\\n\\t// exported raw syscall functions\\n\\t//===========================================================\\n\\t  exports.GetLastError = GetLastError;\\n\\t  exports.CloseOnExec = CloseOnExec;\\n\\t  exports.DuplicateHandle = DuplicateHandle;\\n\\t  exports.GetCurrentProcess = GetCurrentProcess;\\n\\t  exports.GetCurrentProcessId = GetCurrentProcessId;\\n\\n\\t  exports.OpenProcess     = OpenProcess;\\n\\t  exports.TerminateProcess  = TerminateProcess;\\n\\t  exports.CreateProcess     = CreateProcess;\\n\\t  exports.CloseHandle = CloseHandle;\\n\\t  exports.GetExitCodeProcess = GetExitCodeProcess;\\n\\n\\t  exports.GetFdHandle = binding.GetFdHandle;\\n\\t  exports.GetHandleFd = binding.GetHandleFd;\\n\\n\\t  exports.UTF16PtrFromString = UTF16PtrFromString;\\n\\n\\t  exports.WriteFile = WriteFile;\\n\\t  exports.GetFileInformationByHandle = GetFileInformationByHandle;\\n\\t  exports.FileTimeToSystemTime  = FileTimeToSystemTime;\\n\\t  exports.GetFileType = GetFileType;\\n\\t//===========================================================\\n\\n\\n\\t// STDIO handles\\n\\t//===========================================================\\n\\t  exports.Stdin  = getStdHandle(STD_INPUT_HANDLE);\\n\\t  exports.Stdout = getStdHandle(STD_OUTPUT_HANDLE);\\n\\t  exports.Stderr = getStdHandle(STD_ERROR_HANDLE);\\n\\t//===========================================================\\n\\n\\n\\tfunction _kill(handle, signum){\\n\\n\\t}\\n\\n\\texports.kill = function(pid, signum) {\\n\\n\\t\\tvar process_handle = OpenProcess(\\n\\t\\t\\tPROCESS_TERMINATE | PROCESS_QUERY_INFORMATION,\\n\\t\\t\\t0, pid\\n\\t\\t);\\n\\n\\t\\tif (process_handle === null) {\\n\\t\\t\\terr = process.errno;\\n\\t\\t\\tif (err == errno.ERROR_INVALID_PARAMETER) {\\n\\t\\t\\t\\treturn errno.ESRCH;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn uv_translate_sys_error(err);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\terr = _kill(process_handle, signum);\\n\\t\\tCloseHandle(process_handle);\\n\\t\\treturn err;  /* err is already translated. */\\n\\t};\\n\\n\\n\\tfunction CloseOnExec(fd) {\\n\\t\\treturn SetHandleInformation(fd, exports.HANDLE_FLAG_INHERIT, 0);\\n\\t}\\n\\n\\n\\tfunction getStdHandle(h){\\n\\t\\tvar r = GetStdHandle(h);\\n\\t\\tif (r === null) return null;\\n\\t\\tCloseOnExec(r);\\n\\t\\treturn r;\\n\\t}\\n\\n\\n\\tfunction UTF16PtrFromString (s){\\n\\t\\ts = s + '\\\\0'; //nul terminated string\\n\\t\\treturn new Buffer(s, 'ucs2');\\n\\t\\t// return utf16.Encode(rune(s + \\\"\\\\x00\\\"));\\n\\t}\\n\\n\\n\\t// SetFilePointer return value is not as other win32 functions\\n\\t// on failure it returns INVALID_SET_FILE_POINTER  0xffffffff\\n\\t// we could define this error as GetProcAddress 2nd argument\\n\\t// but for clarification we created a whole function\\n\\tvar _SetFilePointer  = kernel.GetProcAddress('SetFilePointer');\\n\\tfunction SetFilePointer(handle, lowoffset, highoffsetptr, whence) {\\n\\t\\tvar newlowoffset = _SetFilePointer(handle, lowoffset, highoffsetptr, whence);\\n\\t\\tif (newlowoffset === 0xffffffff) {\\n\\t\\t\\tprocess.errno = GetLastError() || errno.EINVAL;\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\treturn newlowoffset;\\n\\t}\\n\\n\\n\\t// returns a utf16 buffer to the current working directory\\n\\t//===========================================================\\n\\t  exports.GetCurrentDirectory = function() {\\n\\t//===========================================================\\n\\n\\t\\t// first need get the current directory length\\n\\t\\tvar buf_length = GetCurrentDirectory(0, null);\\n\\t\\tif (!buf_length) return null;\\n\\n\\t\\tvar buf = new Buffer(buf_length * 2);\\n\\n\\t\\tvar ret = GetCurrentDirectory(buf.byteLength, buf);\\n\\t\\tif (ret === null){\\n\\t\\t\\tthrow new Error(process.errno);\\n\\t\\t}\\n\\t\\treturn buf;\\n\\t};\\n\\n\\n\\t// returns string value of environment variable (v)\\n\\t//===========================================================\\n\\t  exports.Getenv = function(v) {\\n\\t//===========================================================\\n\\t\\tvar vUTF16 = UTF16PtrFromString(v);\\n\\n\\t\\tvar n = 200;\\n\\n\\t\\t// we first try with small buffer\\n\\t\\t// if the return value exceeds our initial\\n\\t\\t// buffer length we go through the loop\\n\\t\\t// again and allocate a new buffer with the\\n\\t\\t// exact length of charcters returned\\n\\t\\twhile (1){\\n\\t\\t\\tvar buf = new Buffer(n);\\n\\t\\t\\tvar len = buf.byteLength;\\n\\n\\t\\t\\tn = GetEnvironmentVariable(vUTF16, buf, len);\\n\\t\\t\\tif (n === null){\\n\\t\\t\\t\\tif (process.errno === errno.ERROR_ENVVAR_NOT_FOUND){\\n\\t\\t\\t\\t\\treturn \\\"\\\";\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthrow new Error(process.errno);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (n <= len){\\n\\t\\t\\t\\treturn buf.toString('ucs2').slice(0, n);\\n\\t\\t\\t}\\n\\t\\t\\tn *= 2;\\n\\t\\t}\\n\\t};\\n\\n\\n\\t// enable disable file handle inheritance\\n\\t// in new created child processes\\n\\t//===========================================================\\n\\t  exports.cloexec = function(fd, close){\\n\\t//===========================================================\\n\\t\\tvar n = close ? 0 : 1;\\n\\t\\treturn SetHandleInformation(fd, exports.HANDLE_FLAG_INHERIT, n);\\n\\t};\\n\\n\\n\\t// open file with mode and permission\\n\\t// on success returns file handle opened\\n\\t// on error returns null and set process.errno\\n\\t// with the last syscall error\\n\\t//===========================================================\\n\\t  exports.Open = function(path, mode, perm) {\\n\\t//===========================================================\\n\\t\\tassert(typeof path === 'string', \\\"path must be a string\\\");\\n\\n\\t\\tif (path.length === 0) {\\n\\t\\t\\tprocess.errno = ERROR_FILE_NOT_FOUND;\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tvar pathp = UTF16PtrFromString(path);\\n\\t\\tif (pathp == null) { //return null as this already set errno\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tvar access = 0;\\n\\t\\tswitch (mode & (O_RDONLY | O_WRONLY | O_RDWR)) {\\n\\t\\t\\tcase O_RDONLY:\\n\\t\\t\\t\\taccess = GENERIC_READ; break;\\n\\t\\t\\tcase O_WRONLY:\\n\\t\\t\\t\\taccess = GENERIC_WRITE; break;\\n\\t\\t\\tcase O_RDWR:\\n\\t\\t\\t\\taccess = GENERIC_READ | GENERIC_WRITE; break;\\n\\t\\t}\\n\\n\\t\\tif ( (mode & O_CREAT) != 0 ) {\\n\\t\\t\\taccess |= GENERIC_WRITE;\\n\\t\\t}\\n\\n\\t\\tif ( (mode & O_APPEND) != 0 ) {\\n\\t\\t\\taccess &= ~GENERIC_WRITE;\\n\\t\\t\\taccess |= FILE_APPEND_DATA;\\n\\t\\t}\\n\\n\\t\\tvar sharemode = FILE_SHARE_READ | FILE_SHARE_WRITE;\\n\\t\\tvar sa = SecurityAttributes();\\n\\n\\t\\t//if no O_CLOEXEC flag make this handle inheritable\\n\\t\\tif ( (mode & O_CLOEXEC) == 0 ) {\\n\\t\\t\\t// sa = makeInheritSa();\\n\\t\\t}\\n\\n\\t\\tvar createmode = 0;\\n\\n\\t\\t{\\t/*  file creation mode */\\n\\t\\t\\tif ((mode & (O_CREAT | O_EXCL)) === (O_CREAT | O_EXCL)) {\\n\\t\\t\\t\\tcreatemode = CREATE_NEW;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if ((mode & (O_CREAT|O_TRUNC)) == (O_CREAT | O_TRUNC)){\\n\\t\\t\\t\\tcreatemode = CREATE_ALWAYS;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if ( (mode & O_CREAT) == O_CREAT ) {\\n\\t\\t\\t\\tcreatemode = OPEN_ALWAYS;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if ((mode & O_TRUNC) == O_TRUNC){\\n\\t\\t\\t\\tcreatemode = TRUNCATE_EXISTING;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse {\\n\\t\\t\\t\\tcreatemode = OPEN_EXISTING;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar h = CreateFile(pathp, access, sharemode, sa, createmode, FILE_ATTRIBUTE_NORMAL, 0);\\n\\t\\treturn h;\\n\\t};\\n\\n\\n\\t// Read file (fd) into buffer (b)\\n\\t// on success returns number of read bytes\\n\\t// on error returns null and set process.errno\\n\\t// to the last syscall error\\n\\t//===========================================================\\n\\t  var rDone = new C.void( C.sizeOf.uint32 );\\n\\t  exports.Read = function(fd, b) {\\n\\t//===========================================================\\n\\t\\tvar e = ReadFile(fd, b, b.byteLength, rDone, null);\\n\\t\\tif (e === null) return e;\\n\\t\\treturn rDone.uint32;\\n\\t};\\n\\n\\n\\t// Write data from buffer (b) into file fd\\n\\t// return null on failure and number of written data\\n\\t// on success\\n\\t//===========================================================\\n\\t  var wDone = new C.void( C.sizeOf.uint32 );\\n\\t  exports.Write = function(fd, b) {\\n\\t//===========================================================\\n\\t\\tvar e = WriteFile(fd, b, b.byteLength, wDone, null);\\n\\t\\tif (e === null) return null;\\n\\t\\treturn wDone.uint32;\\n\\t};\\n\\n\\n\\t//===========================================================\\n\\t  exports.Seek = function(fd, offset, whence) {\\n\\t//===========================================================\\n\\t\\tvar w = 0;\\n\\t\\tswitch (whence) {\\n\\t\\t\\tcase 0:\\n\\t\\t\\t\\tw = FILE_BEGIN; break;\\n\\t\\t\\tcase 1:\\n\\t\\t\\t\\tw = FILE_CURRENT; break;\\n\\t\\t\\tcase 2:\\n\\t\\t\\t\\tw = FILE_END; break;\\n\\t\\t\\tdeafult: throw new Error('unknown file seek whence');\\n\\t\\t}\\n\\n\\t\\tvar hi = new C.void( C.sizeOf.uint32 );\\n\\t\\thi.uint32 = offset.RShift(32); // offset >> 32\\n\\n\\t\\tvar lo = offset;\\n\\t\\t// use GetFileType to check pipe, pipe can't do seek\\n\\t\\tvar ft = GetFileType(fd);\\n\\t\\tif (ft == FILE_TYPE_PIPE) {\\n\\t\\t\\tprocess.errno = errno.EPIPE;\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tvar rlo = SetFilePointer(fd, lo, hi, w);\\n\\t\\tif (rlo === null) return null;\\n\\n\\t\\t//(hi << 32) + rlo\\n\\t\\treturn ( hi.uint32.LShift(32) ) + rlo;\\n\\t};\\n\\n\\t//===========================================================\\n\\t  var consoleMode = new C.void( C.sizeOf.uint32 );\\n\\t  exports.GetConsoleMode = function(handle){\\n\\t//===========================================================\\n\\t\\tif (GetConsoleMode(handle, consoleMode) === null){\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\treturn consoleMode.uint32;\\n\\t};\\n});\\n\",\"module\":\"'use strict';\\n\\nconst NativeModule = process.NativeModule;\\nconst util = require('util');\\nconst internalModule = {};\\n\\ninternalModule.stripBOM = function(content) {\\n\\tif (content.charCodeAt(0) === 0xFEFF) {\\n\\t\\tcontent = content.slice(1);\\n\\t}\\n\\treturn content;\\n};\\n\\ninternalModule.makeRequireFunction = function() {\\n\\tconst Module = this.constructor;\\n\\tconst self = this;\\n\\n\\tfunction require(path) {\\n\\t\\treturn self.require(path);\\n\\t}\\n\\n\\trequire.resolve = function(request) {\\n\\t\\treturn Module._resolveFilename(request, self);\\n\\t};\\n\\n\\trequire.main = process.mainModule;\\n\\n\\t// Enable support to add extra extension types.\\n\\trequire.extensions = Module._extensions;\\n\\n\\trequire.cache = Module._cache;\\n\\n\\treturn require;\\n};\\n\\nconst runInThisContext = function(script, options){\\n\\treturn process.eval(script, options.filename, options.lineOffset);\\n};\\n\\nconst internalUtil = require('internal/util');\\nconst assert = require('assert').ok;\\nconst fs = require('fs');\\nconst path = require('path');\\npath._makeLong = function(p){ return p };\\n\\nconst internalModuleReadFile = function(file){\\n\\tif (process.isFile(file)){\\n\\t\\tvar content = process.readFile(file);\\n\\t\\treturn internalModule.stripBOM(content);\\n\\t}\\n\\treturn;\\n};\\n\\nconst internalModuleStat = function(file){\\n\\treturn process.stat(file);\\n};\\n\\nconst splitRe = process.platform === 'win32' ? /[\\\\/\\\\\\\\]/ : /\\\\//;\\nconst isIndexRe = /^index\\\\.\\\\w+?$/;\\nconst shebangRe = /^\\\\#\\\\!.*/;\\n\\n// If obj.hasOwnProperty has been overridden, then calling\\n// obj.hasOwnProperty(prop) will break.\\n// See: https://github.com/joyent/node/issues/1707\\nfunction hasOwnProperty(obj, prop) {\\n\\treturn Object.prototype.hasOwnProperty.call(obj, prop);\\n}\\n\\n\\nfunction Module(id, parent) {\\n\\tthis.id = id;\\n\\tthis.exports = {};\\n\\tthis.parent = parent;\\n\\tif (parent && parent.children) {\\n\\t\\tparent.children.push(this);\\n\\t}\\n\\n\\tthis.filename = null;\\n\\tthis.loaded = false;\\n\\tthis.children = [];\\n}\\nmodule.exports = Module;\\n\\nModule._cache = {};\\nModule._pathCache = {};\\nModule._extensions = {};\\nvar modulePaths = [];\\nModule.globalPaths = [];\\n\\nModule.wrapper = NativeModule.wrapper;\\nModule.wrap = NativeModule.wrap;\\nModule._debug = util.debuglog('module');\\n\\n// We use this alias for the preprocessor that filters it out\\nconst debug = Module._debug;\\n\\n\\n// given a module name, and a list of paths to test, returns the first\\n// matching file in the following precedence.\\n//\\n// require(\\\"a.<ext>\\\")\\n//   -> a.<ext>\\n//\\n// require(\\\"a\\\")\\n//   -> a\\n//   -> a.<ext>\\n//   -> a/index.<ext>\\n\\n// check if the directory is a package.json dir\\nconst packageMainCache = {};\\n\\nfunction readPackage(requestPath) {\\n\\tif (hasOwnProperty(packageMainCache, requestPath)) {\\n\\t\\treturn packageMainCache[requestPath];\\n\\t}\\n\\n\\tvar jsonPath = path.resolve(requestPath, 'package.json');\\n\\tvar json = internalModuleReadFile(path._makeLong(jsonPath));\\n\\n\\tif (json === undefined) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttry {\\n\\t\\tvar pkg = packageMainCache[requestPath] = JSON.parse(json).main;\\n\\t} catch (e) {\\n\\t\\te.path = jsonPath;\\n\\t\\te.message = 'Error parsing ' + jsonPath + ': ' + e.message;\\n\\t\\tthrow e;\\n\\t}\\n\\treturn pkg;\\n}\\n\\nfunction tryPackage(requestPath, exts) {\\n\\tvar pkg = readPackage(requestPath);\\n\\n\\tif (!pkg) return false;\\n\\n\\tvar filename = path.resolve(requestPath, pkg);\\n\\treturn tryFile(filename) || tryExtensions(filename, exts) ||\\n\\t\\t\\t\\t tryExtensions(path.resolve(filename, 'index'), exts);\\n}\\n\\n// In order to minimize unnecessary lstat() calls,\\n// this cache is a list of known-real paths.\\n// Set to an empty object to reset.\\nModule._realpathCache = {};\\n\\n// check if the file exists and is not a directory\\nfunction tryFile(requestPath) {\\n\\tconst rc = internalModuleStat(path._makeLong(requestPath));\\n\\treturn rc === 0 && toRealPath(requestPath);\\n}\\n\\nfunction toRealPath(requestPath) {\\n\\treturn fs.realpathSync(requestPath, Module._realpathCache);\\n}\\n\\n// given a path check a the file exists with any of the set extensions\\nfunction tryExtensions(p, exts) {\\n\\tfor (var i = 0, EL = exts.length; i < EL; i++) {\\n\\t\\tvar filename = tryFile(p + exts[i]);\\n\\n\\t\\tif (filename) {\\n\\t\\t\\treturn filename;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n\\nvar warned = false;\\nModule._findPath = function(request, paths) {\\n\\tvar exts = Object.keys(Module._extensions);\\n\\n\\tif (path.isAbsolute(request)) {\\n\\t\\tpaths = [''];\\n\\t}\\n\\n\\tvar trailingSlash = (request.slice(-1) === '/');\\n\\n\\tvar cacheKey = JSON.stringify({request: request, paths: paths});\\n\\tif (Module._pathCache[cacheKey]) {\\n\\t\\treturn Module._pathCache[cacheKey];\\n\\t}\\n\\n\\t// For each path\\n\\tfor (var i = 0, PL = paths.length; i < PL; i++) {\\n\\t\\t// Don't search further if path doesn't exist\\n\\t\\tif (paths[i] && internalModuleStat(path._makeLong(paths[i])) < 1) continue;\\n\\t\\tvar basePath = path.resolve(paths[i], request);\\n\\t\\tvar filename;\\n\\n\\t\\tif (!trailingSlash) {\\n\\t\\t\\tconst rc = internalModuleStat(path._makeLong(basePath));\\n\\t\\t\\tif (rc === 0) {  // File.\\n\\t\\t\\t\\tfilename = toRealPath(basePath);\\n\\t\\t\\t} else if (rc === 1) {  // Directory.\\n\\t\\t\\t\\tfilename = tryPackage(basePath, exts);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!filename) {\\n\\t\\t\\t\\t// try it with each of the extensions\\n\\t\\t\\t\\tfilename = tryExtensions(basePath, exts);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!filename) {\\n\\t\\t\\tfilename = tryPackage(basePath, exts);\\n\\t\\t}\\n\\n\\t\\tif (!filename) {\\n\\t\\t\\t// try it with each of the extensions at \\\"index\\\"\\n\\t\\t\\tfilename = tryExtensions(path.resolve(basePath, 'index'), exts);\\n\\t\\t}\\n\\n\\t\\tif (filename) {\\n\\t\\t\\t// Warn once if '.' resolved outside the module dir\\n\\t\\t\\tif (request === '.' && i > 0) {\\n\\t\\t\\t\\twarned = internalUtil.printDeprecationMessage(\\n\\t\\t\\t\\t\\t'warning: require(\\\\'.\\\\') resolved outside the package ' +\\n\\t\\t\\t\\t\\t'directory. This functionality is deprecated and will be removed ' +\\n\\t\\t\\t\\t\\t'soon.', warned);\\n\\t\\t\\t}\\n\\n\\t\\t\\tModule._pathCache[cacheKey] = filename;\\n\\t\\t\\treturn filename;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n};\\n\\n// 'from' is the __dirname of the module.\\nModule._nodeModulePaths = function(from) {\\n\\t// guarantee that 'from' is absolute.\\n\\tfrom = path.resolve(from);\\n\\n\\t// note: this approach *only* works when the path is guaranteed\\n\\t// to be absolute.  Doing a fully-edge-case-correct path.split\\n\\t// that works on both Windows and Posix is non-trivial.\\n\\tvar paths = [];\\n\\tvar parts = from.split(splitRe);\\n\\n\\tfor (var tip = parts.length - 1; tip >= 0; tip--) {\\n\\t\\t// don't search in .../node_modules/node_modules\\n\\t\\tif (parts[tip] === 'node_modules') continue;\\n\\t\\tvar dir = parts.slice(0, tip + 1).concat('node_modules').join(path.sep);\\n\\t\\tpaths.push(dir);\\n\\t}\\n\\n\\treturn paths;\\n};\\n\\n\\nModule._resolveLookupPaths = function(request, parent) {\\n\\tif (NativeModule.nonInternalExists(request)) {\\n\\t\\treturn [request, []];\\n\\t}\\n\\n\\tvar start = request.substring(0, 2);\\n\\tif (start !== './' && start !== '..') {\\n\\t\\tvar paths = modulePaths;\\n\\t\\tif (parent) {\\n\\t\\t\\tif (!parent.paths) parent.paths = [];\\n\\t\\t\\tpaths = parent.paths.concat(paths);\\n\\t\\t}\\n\\n\\t\\t// Maintain backwards compat with certain broken uses of require('.')\\n\\t\\t// by putting the module's directory in front of the lookup paths.\\n\\t\\tif (request === '.') {\\n\\t\\t\\tif (parent && parent.filename) {\\n\\t\\t\\t\\tpaths.splice(0, 0, path.dirname(parent.filename));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpaths.splice(0, 0, path.resolve(request));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn [request, paths];\\n\\t}\\n\\n\\t// with --eval, parent.id is not set and parent.filename is null\\n\\tif (!parent || !parent.id || !parent.filename) {\\n\\t\\t// make require('./path/to/foo') work - normally the path is taken\\n\\t\\t// from realpath(__filename) but with eval there is no filename\\n\\t\\tvar mainPaths = ['.'].concat(modulePaths);\\n\\t\\tmainPaths = Module._nodeModulePaths('.').concat(mainPaths);\\n\\t\\treturn [request, mainPaths];\\n\\t}\\n\\n\\t// Is the parent an index module?\\n\\t// We can assume the parent has a valid extension,\\n\\t// as it already has been accepted as a module.\\n\\tvar isIndex = isIndexRe.test(path.basename(parent.filename));\\n\\tvar parentIdPath = isIndex ? parent.id : path.dirname(parent.id);\\n\\tvar id = path.resolve(parentIdPath, request);\\n\\n\\t// make sure require('./path') and require('path') get distinct ids, even\\n\\t// when called from the toplevel js file\\n\\tif (parentIdPath === '.' && id.indexOf('/') === -1) {\\n\\t\\tid = './' + id;\\n\\t}\\n\\n\\tdebug('RELATIVE: requested: %s set ID to: %s from %s', request, id,\\n\\t\\t\\t\\tparent.id);\\n\\n\\treturn [id, [path.dirname(parent.filename)]];\\n};\\n\\n\\n// Check the cache for the requested file.\\n// 1. If a module already exists in the cache: return its exports object.\\n// 2. If the module is native: call `NativeModule.require()` with the\\n//    filename and return the result.\\n// 3. Otherwise, create a new module for the file and save it to the cache.\\n//    Then have it load  the file contents before returning its exports\\n//    object.\\nModule._load = function(request, parent, isMain) {\\n\\tif (parent) {\\n\\t\\tdebug('Module._load REQUEST %s parent: %s', request, parent.id);\\n\\t}\\n\\n\\tvar filename = Module._resolveFilename(request, parent);\\n\\n\\tvar cachedModule = Module._cache[filename];\\n\\tif (cachedModule) {\\n\\t\\treturn cachedModule.exports;\\n\\t}\\n\\n\\tif (NativeModule.nonInternalExists(filename)) {\\n\\t\\tdebug('load native module %s', request);\\n\\t\\treturn NativeModule.require(filename);\\n\\t}\\n\\n\\tvar module = new Module(filename, parent);\\n\\n\\tif (isMain) {\\n\\t\\tprocess.mainModule = module;\\n\\t\\tmodule.id = '.';\\n\\t}\\n\\n\\tModule._cache[filename] = module;\\n\\n\\tvar hadException = true;\\n\\n\\ttry {\\n\\t\\tmodule.load(filename);\\n\\t\\thadException = false;\\n\\t} finally {\\n\\t\\tif (hadException) {\\n\\t\\t\\tdelete Module._cache[filename];\\n\\t\\t}\\n\\t}\\n\\n\\treturn module.exports;\\n};\\n\\nModule._resolveFilename = function(request, parent) {\\n\\tif (NativeModule.nonInternalExists(request)) {\\n\\t\\treturn request;\\n\\t}\\n\\n\\tvar resolvedModule = Module._resolveLookupPaths(request, parent);\\n\\tvar id = resolvedModule[0];\\n\\tvar paths = resolvedModule[1];\\n\\n\\t// look up the filename first, since that's the cache key.\\n\\tdebug('looking for %j in %j', id, paths);\\n\\n\\tvar filename = Module._findPath(request, paths);\\n\\tif (!filename) {\\n\\t\\tvar err = new Error(\\\"Cannot find module '\\\" + request + \\\"'\\\");\\n\\t\\terr.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow err;\\n\\t}\\n\\treturn filename;\\n};\\n\\n\\n// Given a file name, pass it to the proper extension handler.\\nModule.prototype.load = function(filename) {\\n\\tdebug('load %j for module %j', filename, this.id);\\n\\n\\tassert(!this.loaded);\\n\\tthis.filename = filename;\\n\\tthis.paths = Module._nodeModulePaths(path.dirname(filename));\\n\\n\\tvar extension = path.extname(filename) || '.js';\\n\\tif (!Module._extensions[extension]) extension = '.js';\\n\\tModule._extensions[extension](this, filename);\\n\\tthis.loaded = true;\\n};\\n\\n\\n// Loads a module at the given file path. Returns that module's\\n// `exports` property.\\nModule.prototype.require = function(path) {\\n\\tassert(path, 'missing path');\\n\\tassert(typeof path === 'string', 'path must be a string');\\n\\treturn Module._load(path, this);\\n};\\n\\n\\n// Resolved path to process.argv[1] will be lazily placed here\\n// (needed for setting breakpoint when called with --debug-brk)\\nvar resolvedArgv;\\n\\n\\n// Run the file contents in the correct scope or sandbox. Expose\\n// the correct helper variables (require, module, exports) to\\n// the file.\\n// Returns exception, if any.\\nModule.prototype._compile = function(content, filename) {\\n\\t// remove shebang\\n\\tcontent = content.replace(shebangRe, '');\\n\\n\\t// create wrapper function\\n\\tvar wrapper = Module.wrap(content);\\n\\n\\tvar compiledWrapper = runInThisContext(wrapper,\\n\\t\\t{ filename: filename, lineOffset: 0 });\\n\\tif (global.v8debug) {\\n\\t\\tif (!resolvedArgv) {\\n\\t\\t\\t// we enter the repl if we're not given a filename argument.\\n\\t\\t\\tif (process.argv[1]) {\\n\\t\\t\\t\\tresolvedArgv = Module._resolveFilename(process.argv[1], null);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresolvedArgv = 'repl';\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Set breakpoint on module start\\n\\t\\tif (filename === resolvedArgv) {\\n\\t\\t\\t// Installing this dummy debug event listener tells V8 to start\\n\\t\\t\\t// the debugger.  Without it, the setBreakPoint() fails with an\\n\\t\\t\\t// 'illegal access' error.\\n\\t\\t\\tglobal.v8debug.Debug.setListener(function() {});\\n\\t\\t\\tglobal.v8debug.Debug.setBreakPoint(compiledWrapper, 0, 0);\\n\\t\\t}\\n\\t}\\n\\tconst dirname = path.dirname(filename);\\n\\tconst require = internalModule.makeRequireFunction.call(this);\\n\\tconst args = [this.exports, require, this, filename, dirname];\\n\\treturn compiledWrapper.apply(this.exports, args);\\n};\\n\\n\\n// Native extension for .js\\nModule._extensions['.js'] = function(module, filename) {\\n\\tvar content = fs.readFileSync(filename, 'utf8');\\n\\tmodule._compile(internalModule.stripBOM(content), filename);\\n};\\n\\n\\n// Native extension for .json\\nModule._extensions['.json'] = function(module, filename) {\\n\\tvar content = fs.readFileSync(filename, 'utf8');\\n\\ttry {\\n\\t\\tmodule.exports = JSON.parse(internalModule.stripBOM(content));\\n\\t} catch (err) {\\n\\t\\terr.message = filename + ': ' + err.message;\\n\\t\\tthrow err;\\n\\t}\\n};\\n\\n\\n//Native extension for .node\\nModule._extensions['.como'] =\\nModule._extensions['.node'] = function(module, filename) {\\n\\treturn process.dlopen(module, path._makeLong(filename));\\n};\\n\\n\\n// bootstrap main module.\\nModule.runMain = function() {\\n\\t// Load the main module--the command line argument.\\n\\tModule._load(process.argv[1], null, true);\\n\\t// Handle any nextTicks added in the first tick of the program\\n\\tprocess._tickCallback();\\n};\\n\\nModule._initPaths = function() {\\n\\tconst isWindows = process.platform === 'win32';\\n\\n\\tif (isWindows) {\\n\\t\\tvar homeDir = process.env.USERPROFILE;\\n\\t} else {\\n\\t\\tvar homeDir = process.env.HOME;\\n\\t}\\n\\n\\tvar paths = [path.resolve(process.execPath, '..', '..', 'lib', 'node')];\\n\\n\\tif (homeDir) {\\n\\t\\tpaths.unshift(path.resolve(homeDir, '.node_libraries'));\\n\\t\\tpaths.unshift(path.resolve(homeDir, '.node_modules'));\\n\\t}\\n\\n\\tvar nodePath = process.env['NODE_PATH'];\\n\\tif (nodePath) {\\n\\t\\tpaths = nodePath.split(path.delimiter).filter(function(path) {\\n\\t\\t\\treturn !!path;\\n\\t\\t}).concat(paths);\\n\\t}\\n\\n\\tmodulePaths = paths;\\n\\n\\t// clone as a read-only copy, for introspection.\\n\\tModule.globalPaths = modulePaths.slice(0);\\n};\\n\\n// TODO(bnoordhuis) Unused, remove in the future.\\nModule.requireRepl = internalUtil.deprecate(function() {\\n\\treturn NativeModule.require('internal/repl');\\n}, 'Module.requireRepl is deprecated.');\\n\\nModule._preloadModules = function(requests) {\\n\\tif (!Array.isArray(requests))\\n\\t\\treturn;\\n\\n\\t// Preloaded modules have a dummy parent module which is deemed to exist\\n\\t// in the current working directory. This seeds the search path for\\n\\t// preloaded modules.\\n\\tvar parent = new Module('internal/preload', null);\\n\\ttry {\\n\\t\\tparent.paths = Module._nodeModulePaths(process.cwd());\\n\\t}\\n\\tcatch (e) {\\n\\t\\tif (e.code !== 'ENOENT') {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t}\\n\\trequests.forEach(function(request) {\\n\\t\\tparent.require(request);\\n\\t});\\n};\\n\\nModule._initPaths();\\n\\n// backwards compatibility\\nModule.Module = Module;\\n\",\"http_parser\":\"/**\\n* @module http-parser\\n* @author Mamod A. Mehyar\\n* @license MIT\\n******************************************************************************/\\n\\\"use strict\\\";\\n\\nvar parser = process.binding('http-parser');\\nvar assert = require('assert');\\n\\n\\nvar headersNum = 0;\\nvar lastHeaderfield = '';\\nvar lastHeaderValue = '';\\n\\n/** @constructor\\n  * @alias module:http-parser\\n  * @param type {Constant} http parsing type [ <b>parser.REQUEST</b> |\\n  * <b>parser.RESPONSE</b> | <b>parser.BOTH</b> ]\\n  *\\n  * @example\\n  * var parser = require('http-parser');\\n  * var p = new parser(parser.RESPONSE);\\n  *\\n  * var HTTPResponse = \\\"POST /example HTTP/1.1\\\\r\\\\n\\\"  +\\n  *                    \\\"Host: example.com\\\\r\\\\n\\\"       +\\n  *                    \\\"Content-Type: text/html\\\\r\\\\n\\\" +\\n  *                    \\\"Content-Length: 2\\\\r\\\\n\\\\r\\\\n\\\"   +\\n  *                    \\\"Hi\\\";\\n  *\\n  * var nread = p.parse(HTTPResponse);\\n  * console.log(p.method);  // log method type\\n  * console.log(p.path);    // log response path\\n  * console.log(p.headers); // log response headers\\n  * p.on_status = function(val){\\n  *     console.log(val);\\n  * };\\n  *\\n  * @returns {Object} an http parser object\\n  *\\n******************************************************************************/\\nfunction HTTPParser (type){\\n\\ttype = type || 0;\\n\\tthis.headers = {};\\n\\tthis._headers = [];\\n\\tthis._headerFields = [];\\n\\tthis._headerValues = [];\\n\\n\\tthis.body = '';\\n\\tthis.url = '';\\n\\tvar pointer = parser.init(type, this);\\n\\tthis.pointer = pointer;\\n\\tthis.type = type;\\n\\tif (pointer === null) {\\n\\t\\tthrow new Error(\\\"out of memory while creating new Http parser\\\");\\n\\t}\\n\\treturn this;\\n}\\n\\nHTTPParser.prototype._reset = function(){\\n\\theadersNum = 0;\\n\\tlastHeaderfield = '';\\n\\tlastHeaderValue = '';\\n\\n\\tthis.status_message = '';\\n\\tthis._headers = [];\\n\\tthis._headerFields = [];\\n\\tthis._headerValues = [];\\n\\n\\tthis._headerFields.length = 0;\\n\\tthis._headerValues.length = 0;\\n\\tthis._headers.length = 0;\\n\\n\\tthis.headers = {};\\n\\tthis.url = '';\\n}\\n\\nHTTPParser.prototype._check_message = function(r){\\n\\tif (!r){\\n\\t\\tthis.got_exception = true;\\n\\t\\treturn -1;\\n\\t}\\n\\treturn 0;\\n};\\n\\n/** parse http strings, on error return an instance of Error object,\\n  * other wise number of bytes parsed so far will be returned\\n  *\\n  * @function\\n  * @param type {String} http string (either a response or request string)\\n  *\\n  * @returns {Number} number of parsed bytes\\n  *\\n******************************************************************************/\\nHTTPParser.prototype.execute = HTTPParser.prototype.parse = function (str, len){\\n\\tstr = String(str); //make sure it's a string\\n\\tlen = len || str.length;\\n\\tvar nparsed = parser.execute(this.pointer, str, len);\\n\\tif (!this.upgrade() && nparsed !== len) {\\n\\t\\tvar cb = this[HTTPParser.kOnExecute];\\n\\t\\tvar err  = Error('Parse Error');\\n\\t\\terr.bytesRead = nparsed;\\n\\t\\tif (!cb) return err;\\n\\t\\tcb.call(this, err);\\n\\t\\treturn err;\\n\\t}\\n\\n\\treturn nparsed;\\n};\\n\\n/** Reinitialize parser type so you can use it on different http headers\\n  * [response / request] without a need to reconstruct a new http-parser\\n  * object\\n  *\\n  * @function\\n  * @param type {Constant} http parsing type [ <b>parser.REQUEST</b> |\\n  * <b>parser.RESPONSE</b> | <b>parser.BOTH</b> ]\\n  *\\n  * @example\\n  * var p = new parser(parser.RESPONSE);\\n  * //do some response header parsing ...\\n  * p.reinitialize(parser.REQUEST);\\n  * //do some request headers parsing ...\\n  *\\n******************************************************************************/\\nHTTPParser.prototype.reinitialize = function (type){\\n\\tassert(type == parser.HTTP_REQUEST ||\\n\\t\\t   type == parser.HTTP_RESPONSE);\\n\\n\\tthis._reset();\\n\\tthis.type = type;\\n\\tparser.reinitialize(this.pointer, type);\\n};\\n\\n\\n/** Will be called every time the parser parses header field name\\n  * and should be followed by on_header_value callback\\n  *\\n  * @ignore\\n  * @function on_header_field\\n  * @param value {String} header field name\\n  *\\n  * @returns {Number} [1|0] return 1 to continue parsing, 0 to stop the parser\\n  *\\n******************************************************************************/\\nHTTPParser.prototype.on_header_field = function (value){\\n\\tlastHeaderfield = lastHeaderfield + value;\\n};\\n\\n/** Will be called every time the parser parses header field name\\n  * and should be followed by on_header_value callback\\n  *\\n  * @ignore\\n  * @function on_header_value\\n  * @param value {String} header field name\\n  *\\n  * @returns {Number} [1|0] return 1 to continue parsing, 0 to stop the parser\\n  *\\n******************************************************************************/\\n\\nHTTPParser.prototype.on_header_value = function (value){\\n\\tif (lastHeaderfield !== ''){\\n\\t\\tthis._headers.push(lastHeaderfield);\\n\\t\\theadersNum = this._headers.length;\\n\\t\\tlastHeaderValue = lastHeaderfield;\\n\\t\\tthis.headers[lastHeaderfield] = '';\\n\\t\\tlastHeaderfield = '';\\n\\t\\tthis._headers[headersNum] = '';\\n\\t}\\n\\tthis.headers[lastHeaderValue] += value;\\n\\tthis._headers[headersNum] += value;\\n};\\n\\n\\nHTTPParser.prototype.on_url = function (value){\\n\\tthis.url = this.url + value;\\n};\\n\\n\\nHTTPParser.prototype.on_status = function (msg){\\n\\tthis.status_message = msg;\\n};\\n\\n\\nHTTPParser.prototype.on_body = function (val){\\n\\tthis.body += val;\\n\\tvar cb = this[HTTPParser.kOnBody];\\n\\tif (!cb) return 0;\\n\\tvar r = cb.call(this, val, 0, val.length);\\n\\treturn this._check_message(r);\\n};\\n\\n\\nHTTPParser.prototype.on_message_begin = function (){\\n\\tthis._reset();\\n};\\n\\n\\nHTTPParser.prototype.on_headers_complete = function (){\\n\\n\\tvar message_info = {};\\n\\tvar headers = this._headers;\\n\\tvar cb = this[HTTPParser.kOnHeadersComplete];\\n\\tif (!cb) return 0;\\n\\n\\tvar statusCode, statusMessage, url, method;\\n\\tif (this.type === parser.HTTP_REQUEST) {\\n\\t\\turl = this.url;\\n\\t\\tmethod = this.method();\\n\\t}\\n\\n\\t// STATUS\\n\\tif (this.type === parser.HTTP_RESPONSE) {\\n\\t\\tstatusCode = this.status_code();\\n\\t\\tstatusMessage = this.status_message;\\n\\t}\\n\\n\\t// VERSION\\n\\tvar versionMajor = this.versionMajor();\\n\\tvar versionMinor = this.versionMinor();\\n\\tvar shouldKeepAlive = this.shouldKeepAlive();\\n\\tvar upgrade = this.upgrade();\\n\\n\\n\\tvar head_response = cb.call(this, versionMajor, versionMinor, headers, method,\\n\\t                               url, statusCode, statusMessage, upgrade,\\n\\t                               shouldKeepAlive);\\n\\n\\t//reset\\n\\tthis._headers.length = 0;\\n\\tthis.headers = [];\\n\\tthis.headers.length = 0;\\n\\tthis.url = '';\\n\\tlastHeaderfield = '';\\n\\theadersNum = 0;\\n\\n\\tif (head_response !== 0 && !head_response){\\n\\t\\tthis.got_exception = true;\\n\\t\\treturn -1;\\n\\t}\\n\\n\\treturn head_response ? 1 : 0;\\n};\\n\\n\\nHTTPParser.prototype.Flush = function (){\\n\\tvar cb = this[HTTPParser.kOnHeaders];\\n\\tif (!cb) return;\\n\\tcb.call(this, this._headers, this.url);\\n\\tthis.flushed = true;\\n\\tthis.url = '';\\n};\\n\\n\\nHTTPParser.prototype.on_message_complete = function (){\\n\\tif (this._headers.length) this.Flush();\\n\\tvar cb = this[HTTPParser.kOnMessageComplete];\\n\\tif (!cb) return 0;\\n\\tvar r = cb.call(this, 0);\\n\\treturn this._check_message(r);\\n};\\n\\n\\nHTTPParser.prototype.shouldKeepAlive = function (){\\n\\treturn parser.http_should_keep_alive(this.pointer);\\n};\\n\\n\\nHTTPParser.prototype.upgrade = function (){\\n\\treturn parser.http_upgrade(this.pointer);\\n};\\n\\n\\nHTTPParser.prototype.versionMinor = function (){\\n\\treturn parser.http_minor(this.pointer);\\n};\\n\\n\\nHTTPParser.prototype.versionMajor = function (){\\n\\treturn parser.http_major(this.pointer);\\n};\\n\\n\\nHTTPParser.prototype.method = function (){\\n\\treturn parser.http_method(this.pointer);\\n};\\n\\n\\nHTTPParser.prototype.status_code = function (){\\n\\treturn parser.status_code(this.pointer);\\n};\\n\\n\\nHTTPParser.prototype.finish = function (){\\n\\tthis._reset();\\n\\treturn 0;\\n};\\n\\n\\nHTTPParser.prototype.close = function (){\\n\\tparser.destroy(this.pointer);\\n};\\n\\n/** @constant REQUEST  */ HTTPParser.REQUEST  = parser.HTTP_REQUEST;\\n/** @constant RESPONSE */ HTTPParser.RESPONSE = parser.HTTP_RESPONSE;\\n/** @constant BOTH     */ HTTPParser.BOTH     = parser.HTTP_BOTH;\\n\\n//compatable with node\\nHTTPParser.methods = parser.methods();\\n\\n\\nHTTPParser.kOnHeaders = 0;\\nHTTPParser.kOnHeadersComplete = 1;\\nHTTPParser.kOnBody = 2;\\nHTTPParser.kOnMessageComplete = 3;\\nHTTPParser.kOnExecute = 4;\\n\\nHTTPParser.HTTPParser = HTTPParser;\\n\\nmodule.exports = HTTPParser;\\n\",\"socket\":\"\\\"use strict\\\";\\n\\nvar socket = process.binding('socket');\\n\\nvar SOCK_STREAM = socket.SOCK_STREAM;\\nvar AF_INET     = socket.AF_INET;\\n\\nsocket.ipAddress = socket.pton;\\n\\nObject.defineProperty(socket, 'hasIPv6', {\\n\\tget : function (){\\n\\t\\tif (typeof this.IPV6 !== 'undefined')\\n\\t\\t\\treturn this.IPV6;\\n\\n\\t\\tvar s = this.socket(this.AF_INET6, this.SOCK_STREAM, 0);\\n\\t\\tif (s === null){\\n\\t\\t\\tthis.IPV6 = false;\\n\\t\\t} else {\\n\\t\\t\\tthis.IPV6 = true;\\n\\t\\t\\tthis.close(s);\\n\\t\\t}\\n\\n\\t\\treturn this.IPV6;\\n\\t}\\n});\\n\\n\\nsocket.winsocketpair = function(n){\\n\\treturn socket.socketpair(n);\\n\\n\\tvar proto = socket.getprotobyname('tcp');\\n\\t// for (1..5) {\\n\\t// \\tcarp \\\"winsocketpair failed: $!, retrying\\\" unless $_ == 1;\\n\\tvar port = 5000;\\n\\twhile (1){\\n\\t\\tvar listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto );\\n\\t\\tvar server = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto );\\n\\t\\tvar client = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto );\\n\\n\\t\\tsocket.nonblock(client, 0);\\n\\n\\t\\tvar addr = socket.pton4(socket.INADDR_LOOPBACK, port++);\\n\\n\\t\\tif (socket.bind( listener, addr ) === null){\\n\\t\\t\\tif (process.errno === 10048 || process.errno === 98){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tthrow new Error(\\\"bind error \\\" + process.errno);\\n\\t\\t}\\n\\n\\t\\tif (socket.listen( listener, 1 ) === null){\\n\\t\\t\\tthrow new Error(\\\"listen error \\\" + process.errno);\\n\\t\\t}\\n\\n\\t\\taddr = socket.getsockname( listener );\\n\\t\\tif (addr === null) throw new Error('get sock name ' + process.errno);\\n\\n\\t\\tvar ret = 0;\\n\\t\\tdo {\\n\\t\\t\\tret = socket.connect(client, addr);\\n\\t\\t} while(ret === null & process.errno === 10035);\\n\\n\\t\\tif (ret === null){\\n\\t\\t\\tthrow new Error(\\\"connect error \\\" + process.errno);\\n\\t\\t}\\n\\n\\t\\tvar peer = socket.accept( listener );\\n\\t\\tif (peer === null){\\n\\t\\t\\tthrow new Error('accept error ' + process.errno);\\n\\t\\t\\t//continue\\n\\t\\t}\\n\\n\\t\\tsocket.nonblock(client, 1);\\n\\t\\treturn [peer, client];\\n\\t}\\n};\\n\\nmodule.exports = socket;\\n\",\"errno\":\"var errno = process.binding('errno');\\nvar _toString = errno.toString;\\n\\nerrno.toString = function(errno){\\n\\tif (errno < 0) errno = -errno;\\n\\treturn _toString(errno);\\n};\\n\\n// windows specific errors\\nerrno.ERROR_ENVVAR_NOT_FOUND        = 203;\\nerrno.ERROR_INVALID_PARAMETER       = 87;\\nerrno.ERROR_ACCESS_DENIED           = 5;\\n\\nvar ERROR_MAP = {};\\nObject.keys(errno).forEach(function(key) {\\n    var val = errno[key];\\n    if (typeof val === 'function') return;\\n    ERROR_MAP[val] = key;\\n    var uv_key = 'UV_' + key;\\n    errno[uv_key] = -val;\\n});\\n\\nerrno.errname = function(err){\\n    if (err < 0) err = -err;\\n    return ERROR_MAP[err];\\n};\\n\\nmodule.exports = errno;\\n\",\"os\":\"var isWindows = process.platform === 'win32';\\n\\nexports.EOL = isWindows ? '\\\\r\\\\n' : '\\\\n';\\n\\nvar trailingSlashRe = isWindows ? /[^:]\\\\\\\\$/ : /.\\\\/$/;\\n\\nexports.tmpdir = function() {\\n\\tvar path;\\n\\tif (isWindows) {\\n\\t\\tpath = process.env.TEMP ||\\n\\t\\t  process.env.TMP ||\\n\\t\\t  (process.env.SystemRoot || process.env.windir) + '\\\\\\\\temp';\\n\\n\\t} else {\\n\\t\\tpath = process.env.TMPDIR ||\\n\\t\\t  process.env.TMP ||\\n\\t\\t  process.env.TEMP ||\\n\\t\\t  '/tmp';\\n\\t}\\n\\n\\tif (trailingSlashRe.test(path)) {\\n\\t\\tpath = path.slice(0, -1);\\n\\t}\\n\\treturn path;\\n};\\n\",\"uv\":\"// delete global uv if available\\n// this required when we are compiling with\\n// dukluv which exports uv as global object\\ndelete global.uv;\\n\\nvar sock     = require('socket');\\nvar posix    = process.binding('posix');\\nvar loop     = require('loop').main;\\nvar errno    = require('errno');\\nvar assert   = require('assert');\\nvar syscall  = require('syscall');\\nvar SYS      = syscall.SYS;\\n\\nvar C        = require('C');\\nvar constant = require('constants');\\n\\nvar isWin   = process.platform === 'win32';\\n\\nexports.CLOSING              = 0x01;    /* uv_close() called but not finished. */\\nexports.CLOSED               = 0x02;    /* close(2) finished. */\\nexports.STREAM_READING       = 0x04;    /* uv_read_start() called. */\\nexports.STREAM_SHUTTING      = 0x08;    /* uv_shutdown() called but not complete. */\\nexports.STREAM_SHUT          = 0x10;    /* Write side closed. */\\nexports.STREAM_READABLE      = 0x20;    /* The stream is readable */\\nexports.STREAM_WRITABLE      = 0x40;    /* The stream is writable */\\nexports.STREAM_BLOCKING      = 0x80;    /* Synchronous writes. */\\nexports.STREAM_READ_PARTIAL  = 0x100;   /* read(2) read less than requested. */\\nexports.STREAM_READ_EOF      = 0x200;   /* read(2) read EOF. */\\nexports.TCP_NODELAY          = 0x400;   /* Disable Nagle. */\\nexports.TCP_KEEPALIVE        = 0x800;   /* Turn on keep-alive. */\\nexports.TCP_SINGLE_ACCEPT    = 0x1000;  /* Only accept() when idle. */\\nexports.HANDLE_IPV6          = 0x10000; /* Handle is bound to a IPv6 socket. */\\n\\nexports.TCP_IPV6ONLY         = 1;\\n\\nexports.IGNORE               = 0x00;\\nexports.CREATE_PIPE          = 0x01;\\nexports.INHERIT_FD           = 0x02;\\nexports.INHERIT_STREAM       = 0x04;\\nexports.PROCESS_SETUID       = (1 << 0);\\nexports.PROCESS_SETGID       = (1 << 1);\\nexports.PROCESS_DETACHED     = (1 << 3);\\nexports.PROCESS_WINDOWS_HIDE = (1 << 4);\\nexports.PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2);\\n\\nexports.EOF = errno.EOF;\\n\\nexports.isWin = isWin;\\n\\nexports.new_timer = function(){\\n\\treturn loop.handle_init(loop._handle);\\n};\\n\\nexports.unref = function(handle){\\n\\tloop.handle_unref(handle);\\n};\\n\\nexports.ref = function(handle){\\n\\tloop.handle_ref(handle);\\n};\\n\\nexports.run = function(type){\\n\\treturn loop.run(type);\\n};\\n\\nexports.timer_start = function(handle, timeout, repeat, cb){\\n\\treturn loop.timer_start(handle, timeout, repeat, cb);\\n};\\n\\nexports.timer_stop = function(handle, timeout, repeat, cb){\\n\\tloop.timer_stop(handle);\\n};\\n\\nexports.handle_close = function(handle){\\n\\treturn loop.handle_close(handle);\\n};\\n\\nexports.update_time = function(handle){\\n\\treturn loop.update_time();\\n};\\n\\n\\n// create a socket with (domain, type, protocol) options\\n// the created socket will be set to nonblocking mode\\n// and mark as un inheritable, cloexec = 1\\n//===========================================================\\n  exports.socket = function(domain, type, protocol) {\\n//===========================================================\\n\\tvar sockfd, err;\\n\\n\\tif (sock.SOCK_NONBLOCK && sock.SOCK_CLOEXEC) {\\n\\t\\tsockfd = sock.socket(domain, type | sock.SOCK_NONBLOCK | sock.SOCK_CLOEXEC, protocol);\\n\\t\\tif (sockfd !== null) return sockfd;\\n\\n\\t\\t// if EINVAL error returned this may indicate\\n\\t\\t// that SOCK_NONBLOCK or SOCK_CLOEXEC are\\n\\t\\t// not supported, we give it another shot\\n\\t\\t// by doing a seperate call by creating a\\n\\t\\t// socket then set it's blocking and cloexec flags\\n\\t\\tif (process.errno !== errno.EINVAL) return;\\n\\t}\\n\\n\\tsockfd = sock.socket(domain, type, protocol);\\n\\tif (sockfd === null) return;\\n\\n\\tif (!sock.nonblock(sockfd, 1)){\\n\\t\\tsock.close(sockfd);\\n\\t\\treturn;\\n\\t}\\n\\n\\tif (!syscall.cloexec(sockfd, 1)){\\n\\t\\tsock.close(sockfd);\\n\\t\\treturn;\\n\\t}\\n\\n\\tif (sock.SO_NOSIGPIPE){\\n\\t\\tsock.setsockopt(sockfd, sock.SOL_SOCKET, sock.SO_NOSIGPIPE, 1);\\n\\t}\\n\\n\\treturn sockfd;\\n};\\n\\n\\n// return an ip4 packed addrerss\\n//===========================================================\\n  exports.ip4_addr = exports.ip4_address = function(ip, port){\\n//===========================================================\\n\\treturn sock.pton4(ip, port);\\n};\\n\\n\\n// return an ip4 packed addrerss\\n//===========================================================\\n  exports.ip6_addr = exports.ip6_address = function(ip, port){\\n//===========================================================\\n\\treturn sock.pton6(ip, port);\\n};\\n\\n\\n// either ip6 or ip4 address\\n//===========================================================\\n  exports.ip_address = exports.ip_addr = function(ip, port){\\n//===========================================================\\n\\treturn sock.pton(ip, port);\\n};\\n\\n\\n//===========================================================\\n  exports.make_socketpair = function(fds, flags) {\\n//===========================================================\\n\\tvar pairs = sock.winsocketpair(1);\\n\\n\\tif (!pairs) return process.errno;\\n\\tfds[0] = pairs[0];\\n\\tfds[1] = pairs[1];\\n\\n\\tsyscall.cloexec(fds[0], 1);\\n\\tsyscall.cloexec(fds[1], 1);\\n\\n\\tif (flags & 1) {\\n\\t\\tsock.nonblock(fds[0], 1);\\n\\t\\tsock.nonblock(fds[1], 1);\\n\\t}\\n\\n\\treturn 0;\\n};\\n\\n//===========================================================\\n  exports.make_pipe = function(fds, flags) {\\n//===========================================================\\n\\tvar pairs;\\n\\tif (syscall.pipe2){\\n\\t\\tpairs = syscall.pipe2(SYS.O_CLOEXEC);\\n\\t\\tif (!pairs) return process.errno;\\n\\t\\tfds[0] = pairs[0];\\n\\t\\tfds[1] = pairs[1];\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tvar pairs = syscall.pipe();\\n\\n\\tif (!pairs) return process.errno;\\n\\tfds[0] = pairs[0];\\n\\tfds[1] = pairs[1];\\n\\n\\tsyscall.cloexec(fds[0], 1);\\n\\tsyscall.cloexec(fds[1], 1);\\n\\n\\tif (flags & 1) {\\n\\t\\tsock.nonblock(fds[0], 1);\\n\\t\\tsock.nonblock(fds[1], 1);\\n\\t}\\n\\n\\treturn 0;\\n};\\n\\n\\n// make fd/file handle (h) inheritable accross new\\n// created child processes\\n//===========================================================\\n  exports.make_inheritable = function(h){\\n//===========================================================\\n\\tif (!syscall.cloexec(h, 0)){\\n\\t\\tthrow new Error(\\\"can't inherit handle\\\");\\n\\t}\\n\\n\\treturn h;\\n};\\n\\n// generates an array container for stdio options\\n//===========================================================\\n  exports.stdio_container = function(count){\\n//===========================================================\\n\\tvar stdio = [];\\n\\tfor (var i = 0; i < count; i++){\\n\\t\\tstdio[i] = {\\n\\t\\t\\tflags  : exports.IGNORE,\\n\\t\\t\\tstream : null,\\n\\t\\t\\tfd     : null\\n\\t\\t}\\n\\t}\\n\\n\\treturn stdio;\\n};\\n\\n// returns win32 os handle for the\\n// passed file descriptor\\n//===========================================================\\n  exports.get_fd_handle = function(fd){\\n//===========================================================\\n\\tvar handle = syscall.GetFdHandle(fd);\\n\\tif (handle === null){\\n\\t\\tthrow new Error(\\\"can't get os handle for fd : \\\" + fd);\\n\\t}\\n\\n\\treturn handle;\\n};\\n\\n\\n// win32 return exit code of the running process (h)\\n// exit code 259 indicates that the process still running\\n//===========================================================\\n  var exitCode = new C.void( C.sizeOf.int32 );\\n  exports.get_exit_code = function(h){\\n//===========================================================\\n\\tif (syscall.GetExitCodeProcess(h, exitCode) === null){\\n\\t\\tthrow new Error(\\\"GetExitCodeProcess error \\\" + process.errno);\\n\\t}\\n\\treturn exitCode.int32;\\n};\\n\\n\\n// close fd/handle\\n//===========================================================\\n  var _close = isWin ? syscall.CloseHandle : posix.close;\\n  exports.close = function(fd) {\\n//===========================================================\\n\\t/* Catch uninitialized io_watcher.fd bugs. */\\n\\tassert(fd > -1, \\\"uv.close fd uninitialized\\\");\\n\\n\\t// FIXME: win test against stdio handles\\n\\t/* Catch stdio close bugs. */\\n\\tassert(fd > 2, \\\"uv.close stdio file\\\");\\n\\n\\tvar saved_errno = process.errno;\\n\\tvar rc = _close(fd);\\n\\n\\tif (rc === null) {\\n\\t\\trc = process.errno;\\n\\t\\tif (rc == errno.EINTR) rc = errno.EINPROGRESS;  /* For platform/libc consistency. */\\n\\t\\tprocess.errno = saved_errno;\\n\\t}\\n\\n\\treturn rc;\\n};\\n\\n\\n//===========================================================\\n  var _write = isWin ? sock.send : sock.write;\\n  exports.write = function(fd, buf, len, flag){\\n//===========================================================\\n\\treturn _write(fd, buf, len);\\n};\\n\\n\\n//===========================================================\\n  var _read  = isWin ? sock.recv : sock.read;\\n  exports.read = function(fd, len){\\n//===========================================================\\n\\treturn _read(fd, len);\\n};\\n\\n\\n// return number of pending handles\\n//===========================================================\\n  exports.pipe_pending_count = function(handle) {\\n//===========================================================\\n\\tif (!handle.ipc) return 0;\\n\\n\\tif (handle.accepted_fd === -1){\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tif ( handle.queued_fds.length === 0 ){\\n\\t\\treturn 1;\\n\\t}\\n\\n\\treturn handle.queued_fds.length;\\n};\\n\\n\\nvar STILL_ACTIVE = 259;\\nvar Win32kill = exports.Win32kill = function(process_handle, signum){\\n\\tvar status = new C.void( C.sizeOf.int32 );\\n\\tswitch (signum) {\\n\\t\\tcase constant.SIGTERM:\\n\\t\\tcase constant.SIGKILL:\\n\\t\\tcase constant.SIGINT: {\\n\\t\\t\\t/* Unconditionally terminate the process. On Windows, killed processes */\\n\\t\\t\\t/* normally return 1. */\\n\\t\\t\\tvar err;\\n\\n\\t\\t\\tif (syscall.TerminateProcess(process_handle, 1)) return 0;\\n\\n\\t\\t\\t/* If the process already exited before TerminateProcess was called, */\\n\\t\\t\\t/* TerminateProcess will fail with ERROR_ACCESS_DENIED. */\\n\\t\\t\\terr = syscall.GetLastError();\\n\\t\\t\\tif (err == errno.ERROR_ACCESS_DENIED &&\\n\\t\\t\\t\\t\\tsyscall.GetExitCodeProcess(process_handle, status) &&\\n\\t\\t\\t\\t\\tstatus.int32 !== STILL_ACTIVE) {\\n\\t\\t\\t\\treturn errno.ESRCH;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn errno.translate(err);\\n\\t\\t}\\n\\n\\t\\tcase 0: {\\n\\t\\t\\t/* Health check: is the process still alive? */\\n\\n\\t\\t\\tif (syscall.GetExitCodeProcess(process_handle, status) === null) {\\n\\t\\t\\t\\treturn errno.translate(process.errno);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (status.int32 !== STILL_ACTIVE) {\\n\\t\\t\\t\\treturn errno.ESRCH;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tdefault: {\\n\\t\\t\\t/* Unsupported signal. */\\n\\t\\t\\treturn errno.ENOSYS;\\n\\t\\t}\\n\\t}\\n}\\n\\nif (isWin){\\n\\t// kill process (pid) with signal (signum)\\n\\t//===========================================================\\n\\t  exports.kill = function(pid, signum) {\\n\\t//===========================================================\\n\\t\\tvar process_handle = syscall.OpenProcess(\\n\\t\\t\\tsyscall.PROCESS_TERMINATE | syscall.PROCESS_QUERY_INFORMATION,\\n\\t\\t\\t0, pid\\n\\t\\t);\\n\\n\\t\\tif (process_handle === null) {\\n\\t\\t\\terr = process.errno;\\n\\t\\t\\tif (err == errno.ERROR_INVALID_PARAMETER) {\\n\\t\\t\\t\\treturn errno.ESRCH;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn errno.translate(err);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\terr = Win32kill(process_handle, signum);\\n\\t\\tsyscall.CloseHandle(process_handle);\\n\\t\\treturn err;  /* err is already translated. */\\n\\t};\\n} else {\\n\\t// kill process (pid) with signal (signum)\\n\\t//===========================================================\\n\\t  exports.kill = function(pid, signum) {\\n\\t//===========================================================\\n\\t\\tif (syscall.kill(pid, signum) === null){\\n\\t\\t\\treturn process.errno;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t};\\n}\\n\\n// returns pipe handle type\\n// TCP, NAMED_PIPE, UNKNOWN\\n//===========================================================\\n  exports.pipe_handle_type = function(handle){\\n//===========================================================\\n\\tif (!handle.ipc) {\\n\\t\\treturn 'UNKNOWN_HANDLE';\\n\\t}\\n\\n\\tif (handle.accepted_fd === -1) {\\n\\t\\treturn 'UNKNOWN_HANDLE';\\n\\t}\\n\\n\\telse {\\n\\t\\tvar fd = handle.accepted_fd;\\n\\t\\tvar sockaddr = sock.getsockname(fd);\\n\\n\\t\\tif (sockaddr === null) {\\n\\t\\t\\treturn 'UNKNOWN_HANDLE';\\n\\t\\t}\\n\\n\\t\\tvar type = sock.getsockopt(fd, sock.SOL_SOCKET, sock.SO_TYPE);\\n\\t\\tif (type === null) {\\n\\t\\t\\treturn 'UNKNOWN_HANDLE';\\n\\t\\t}\\n\\n\\t\\tvar family = sock.family(sockaddr);\\n\\t\\tif (family === null) {\\n\\t\\t\\treturn 'UNKNOWN_HANDLE';\\n\\t\\t}\\n\\n\\t\\tif (type === sock.SOCK_STREAM) {\\n\\t\\t\\tif (family === sock.AF_UNIX) {\\n\\t\\t\\t\\treturn 'NAMED_PIPE';\\n\\t\\t\\t}\\n\\t\\t\\telse if (family === sock.AF_INET || family === sock.AF_INET6 ){\\n\\t\\t\\t\\treturn 'TCP';\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (type === sock.SOCK_DGRAM &&\\n\\t\\t\\t(family === sock.AF_INET || family === sock.AF_INET6)) {\\n\\t\\t\\treturn 'UDP';\\n\\t\\t}\\n\\n\\t\\treturn 'UNKNOWN_HANDLE';\\n\\t}\\n};\\n\\n\\n// windows recvmsg & sendmsg emulation\\n// this should be moved to a seperate platform\\n// file ** TODO\\nvar protobuf = C.struct({\\n\\tstart  : 'uint16',\\n\\ttarget : 'uint32',\\n\\tpid    : 'uint32',\\n\\thandle : 'uint32',\\n\\tpad    :  1024 * 8,\\n\\tend    : 'uint16'\\n});\\n\\n\\nif (isWin){\\n\\t// win32 duplicate handle with same access flags\\n\\t//===========================================================\\n\\t  var pseudo_id = syscall.GetCurrentProcess();\\n\\t  exports.duplicate_handle = function(h){\\n\\t//===========================================================\\n\\t\\tvar dupHandle = new C.void( C.sizeOf.int32 );\\n\\n\\t\\tvar ret = syscall.DuplicateHandle( pseudo_id, h, pseudo_id, dupHandle, 0, 1,\\n\\t\\t\\tsyscall.DUPLICATE_SAME_ACCESS);\\n\\n\\t\\tif (ret === null){\\n\\t\\t\\tthrow new Error(\\\"can't duplicate handle\\\");\\n\\t\\t}\\n\\n\\t\\treturn dupHandle.int32;\\n\\t};\\n\\n\\n\\t// win32 sendmsg\\n\\t//===========================================================\\n\\t  exports.sendmsg = function(fd, buf, len, fd_to_send, pid, flag){\\n\\t//===========================================================\\n\\t\\tvar dupHandle = new C.void( C.sizeOf.int32 );\\n\\t\\tvar protoBuf  = new protobuf();\\n\\t\\tvar ret = syscall.DuplicateHandle(\\n\\t\\t\\t-1,\\n\\t\\t\\tfd_to_send,\\n\\t\\t\\t-1,\\n\\t\\t\\tdupHandle, 0, 0,\\n\\t\\t\\tsyscall.DUPLICATE_SAME_ACCESS);\\n\\n\\t\\tif (ret === null){\\n\\t\\t\\tthrow new Error(\\\"can't duplicate\\\");\\n\\t\\t}\\n\\n\\t\\tprotoBuf.target = pid;\\n\\t\\tprotoBuf.pid = process.pid;\\n\\t\\tprotoBuf.handle = dupHandle.int32;\\n\\n\\t\\t// special message\\n\\t\\tprotoBuf.start = 123;\\n\\t\\tprotoBuf.end   = 456;\\n\\n\\t\\t// first send both processid and duplicated handle\\n\\t\\tif (_write(fd, protoBuf, protoBuf.size, flag) !== protoBuf.size){\\n\\t\\t\\tthrow new Error(\\\"error sending handle\\\");\\n\\t\\t}\\n\\n\\t\\treturn _write(fd, buf, len, flag);\\n\\t};\\n\\n\\n\\t//===========================================================\\n\\t  var PROCESS_DUP_HANDLE = 0x0040;\\n\\t  exports.recvmsg = function(fd, len, fds){\\n\\t//===========================================================\\n\\t\\tvar dupHandle = new C.void( C.sizeOf.int32 );\\n\\t\\tvar protoBuf  = new protobuf();\\n\\t\\tvar n = sock.readIntoBuffer(fd, protoBuf, 0);\\n\\t\\tif (n === null) return null;\\n\\n\\t\\t//this is not protocol buffer\\n\\t\\tif (n !== protoBuf.size){\\n\\t\\t\\treturn Buffer(protoBuf).slice(0, n).toString();\\n\\t\\t}\\n\\n\\t\\t// maybe protocol buffer\\n\\t\\tif (protoBuf.start === 123 && protoBuf.end === 456){\\n\\t\\t\\t// print('gottt protocol buffer');\\n\\t\\t\\t// get source process handle\\n\\t\\t\\tvar source = syscall.OpenProcess(PROCESS_DUP_HANDLE, 0, protoBuf.pid);\\n\\t\\t\\tif (source === null){\\n\\t\\t\\t\\tthrow new Error(\\\"can't open process\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar ret = syscall.DuplicateHandle(\\n\\t\\t\\t\\tsource,\\n\\t\\t\\t\\tprotoBuf.handle,\\n\\t\\t\\t\\t-1,\\n\\t\\t\\t\\tdupHandle, 0, 0,\\n\\t\\t\\t\\tsyscall.DUPLICATE_SAME_ACCESS | syscall.DUPLICATE_CLOSE_SOURCE\\n\\t\\t\\t);\\n\\n\\t\\t\\tif (ret === null){\\n\\t\\t\\t\\tthrow new Error(\\\"can't duplicate\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\tfds.push(dupHandle.int32);\\n\\t\\t}\\n\\t\\telse { // it's just a normal data sent to socket\\n\\t\\t\\treturn Buffer(protoBuf, 0, n).toString();\\n\\t\\t}\\n\\n\\t\\treturn _read(fd, len);\\n\\t};\\n} else {\\n\\t// linux sendmsg\\n\\t//===========================================================\\n\\t  exports.sendmsg = function(fd, buf, len, fd_to_send, pid, flag){\\n\\t//===========================================================\\n\\t\\t//send fd\\n\\t\\tif (sock.sendfd(fd, fd_to_send) === null){\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\treturn _write(fd, buf, len, flag);\\n\\t};\\n\\n\\t// linux recvmsg\\n\\t//===========================================================\\n\\t  exports.recvmsg = function(fd, len, fds){\\n\\t//===========================================================\\n\\t\\t//get fd\\n\\t\\tvar pfd = new C.void( C.sizeOf.int );\\n\\t\\tpfd.int = -1;\\n\\n\\t\\tvar buf = Buffer(len);\\n\\t\\tvar ret = sock.recvfd(fd, buf, pfd);\\n\\t\\tif (ret === null){\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tvar nfd = pfd.int;\\n\\t\\tif (nfd !== -1){\\n\\t\\t\\texports.cloexec(nfd, 1);\\n\\t\\t\\tfds.push(nfd);\\n\\t\\t\\tif (ret === 1 && buf[0] === 0){\\n\\t\\t\\t\\treturn exports.recvmsg(fd, len, fds);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn buf.slice(0, ret).toString();\\n\\t};\\n}\\n\\nexports.cloexec  = syscall.cloexec;\\nexports.nonblock = sock.nonblock;\\n\\nexports.O_RDWR  = posix.O_RDWR;\\nexports.open    = posix.open;\\n\\n\\n//===========================================================\\n  exports.TCP    = require('uv/tcp');\\n  exports.Pipe   = require('uv/pipe');\\n  exports.Stream = require('uv/stream');\\n  exports.TTY    = require('uv/tty');\\n//===========================================================\\n\\n//===========================================================\\n  var uvProcess  = require('uv/process');\\n  exports.spawn  = function(options){\\n//===========================================================\\n\\treturn new uvProcess(options);\\n};\\n\\nif (isWin){\\n\\texports.guess_handle = function(fd){\\n\\t\\tvar handle = syscall.GetFdHandle(fd);\\n\\t\\tvar type = syscall.GetFileType(handle);\\n\\t\\tif (type === null){\\n\\t\\t\\ttype = syscall.GetFileType(fd);\\n\\t\\t\\tif (type === null){\\n\\t\\t\\t\\treturn 'UNKNOWN_HANDLE';\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tswitch (type){\\n\\t\\t\\tcase syscall.FILE_TYPE_CHAR : {\\n\\t\\t\\t\\tif (syscall.GetConsoleMode(handle) !== null){\\n\\t\\t\\t\\t\\treturn 'TTY';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn 'FILE'\\n\\t\\t\\t}\\n\\t\\t\\tcase syscall.FILE_TYPE_DISK : {\\n\\t\\t\\t\\treturn 'FILE'\\n\\t\\t\\t}\\n\\t\\t\\tcase syscall.FILE_TYPE_PIPE : {\\n\\t\\t\\t\\treturn 'TCP';\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn 'UNKNOWN_HANDLE';\\n\\t};\\n} else {\\n\\tvar fs = require('fs');\\n\\texports.guess_handle = function(fd){\\n\\t\\tif (fd < 0) return 'UNKNOWN_HANDLE';\\n\\n\\t\\t// tty\\n\\t\\tif (syscall.isatty(fd)) return 'TTY';\\n\\n\\t\\tvar st = fs.fstatSync(fd);\\n\\t\\tif (st.isFile()) return 'FILE';\\n\\t\\tif (st.isFIFO()) return 'NAMED_PIPE';\\n\\t\\tif (st.isSocket()) return 'TCP';\\n\\n\\t\\treturn 'UNKNOWN_HANDLE';\\n\\t};\\n}\\n\",\"uv/stream\":\"var sock   = require('socket');\\nvar loop   = require('loop').main;\\nvar errno  = require('errno');\\nvar uv     = require('uv');\\nvar assert = require('assert');\\n\\nvar POLLERR   = loop.POLLERR;\\nvar POLLIN    = loop.POLLIN;\\nvar POLLOUT   = loop.POLLOUT;\\n\\nvar POLLREAD  = POLLIN | POLLERR;\\nvar POLLWRITE = POLLOUT | POLLERR;\\n\\nvar _shutting_mask = ( uv.STREAM_SHUT | uv.STREAM_SHUTTING | uv.CLOSED | uv.CLOSING);\\n\\nvar MAXREAD   =  80 * 1024;\\nvar SEND_FLAG = sock.MSG_NOSIGNAL ? sock.MSG_NOSIGNAL : 0;\\n\\nfunction _accept (self){\\n\\tvar sockfd = self.fd;\\n\\twhile (1) {\\n\\t\\tvar peerfd = sock.accept(sockfd);\\n\\t\\tif (peerfd === null){\\n\\t\\t\\tif (process.errno === errno.EINTR){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t//TODO cloexec\\n\\t\\tif (!sock.nonblock(peerfd, 1)){\\n\\t\\t\\tthrow new Error(\\\"can't set nonblocking peerfd \\\" + peerfd);\\n\\t\\t}\\n\\n\\t\\treturn peerfd;\\n\\t}\\n}\\n\\n\\nfunction Stream (type){\\n\\tthis.type = type;\\n\\tthis.accepted_fd = -1;\\n\\tthis.fd  = -1;\\n\\tthis.flags = 0;\\n\\n\\tthis.queued_fds      = [];\\n\\tthis.pending_queue   = [];\\n\\tthis.write_queue     = [];\\n\\tthis.write_completed = [];\\n\\n\\tthis.write_queue_size = 0;\\n\\n\\tvar self = this;\\n\\tthis.io_watcher = loop.io(function(h, events){\\n\\t\\tself.stream_io(events);\\n\\t});\\n}\\n\\n\\nStream.prototype.server_io = function(events){\\n\\n\\tassert(events === POLLIN);\\n\\tassert(!(this.flags & uv.CLOSING));\\n\\n\\tprocess.errno = 0;\\n\\twhile (this.fd !== -1){\\n\\t\\tassert(this.accepted_fd === -1);\\n\\t\\tvar ret = _accept(this);\\n\\t\\tif (!ret){\\n\\t\\t\\tvar err = process.errno;\\n\\t\\t\\tif (err === errno.EAGAIN || err === errno.EWOULDBLOCK) {\\n\\t\\t\\t\\treturn; //not an error\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (err === errno.ECONNABORTED){\\n\\t\\t\\t\\tcontinue; //nothing to do\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (err === errno.EMFILE || err === errno.ENFILE) {\\n\\t\\t\\t\\tthrow new Error(\\\"EMFILE Error\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.connection_cb(err);\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tthis.accepted_fd = ret;\\n\\t\\tthis.connection_cb(0);\\n\\t\\tif (this.accepted_fd != -1) {\\n\\t\\t\\tthis.io_watcher.stop(POLLIN);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t}\\n};\\n\\n\\nfunction __stream_recv_cmsg (stream, fds) {\\n\\n\\tfor (var i = 0; i < fds.length; i++){\\n\\t\\tvar fd = fds[i];\\n\\t\\tif (stream.accepted_fd !== -1){\\n\\t\\t\\tstream.queued_fds.push(fd);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tuv.nonblock(fd, 1);\\n\\t\\t\\tstream.accepted_fd = fd;\\n\\t\\t\\tstream.flags |= uv.STREAM_READABLE | uv.STREAM_WRITABLE;\\n\\t\\t}\\n\\t}\\n    return 1;\\n}\\n\\n\\nfunction _read (stream){\\n\\tvar buf;\\n\\tvar err = 0;\\n\\tvar is_ipc;\\n\\n\\tstream.flags &= ~uv.STREAM_READ_PARTIAL;\\n\\n\\t/* Prevent loop starvation when the data comes in as fast as (or faster than)\\n\\t * we can read it. XXX Need to rearm fd if we switch to edge-triggered I/O.\\n\\t*/\\n\\n\\tvar count = 24;\\n\\n\\tvar is_ipc = stream.type === \\\"NAMED_PIPE\\\" && stream.ipc;\\n\\n\\t/* XXX: Maybe instead of having UV_STREAM_READING we just test if\\n\\t * tcp->read_cb is NULL or not?\\n\\t*/\\n\\n\\tvar fds = [];\\n\\tvar fd = stream.fd;\\n\\twhile (stream.read_cb\\n\\t\\t  && (stream.flags & uv.STREAM_READING)\\n\\t\\t  && (count-- > 0)) {\\n\\n\\t\\tassert(fd >= 0);\\n\\n\\t\\tif (!is_ipc) {\\n\\t\\t\\tbuf = uv.read(fd, MAXREAD);\\n\\t\\t} else {\\n\\t\\t\\tbuf = uv.recvmsg(fd, MAXREAD, fds);\\n\\t\\t}\\n\\n\\t\\tvar error = process.errno;\\n\\t\\tif (buf === null) {\\n\\t\\t\\t// EOF\\n\\t\\t\\tif (error === errno.EOF){\\n\\t\\t\\t\\tstream.stream_eof(\\\"\\\");\\n\\t\\t\\t}\\n\\t\\t\\t/* Error */\\n\\t\\t\\telse if (error === errno.EAGAIN || error === errno.EWOULDBLOCK) {\\n\\t\\t\\t\\t/* Wait for the next one. */\\n\\t\\t\\t\\tif (stream.flags & uv.STREAM_READING) {\\n\\t\\t\\t\\t\\tstream.io_watcher.start(stream.fd, POLLIN);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstream.read_cb(0, \\\"\\\");\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t/* Error. User should call uv_close(). */\\n\\t\\t\\t\\tstream.read_cb(error, \\\"\\\");\\n\\t\\t\\t\\tif (stream.flags & uv.STREAM_READING) {\\n\\t\\t\\t\\t\\tstream.flags &= ~uv.STREAM_READING;\\n\\t\\t\\t\\t\\tstream.io_watcher.stop(POLLIN);\\n\\t\\t\\t\\t\\tif (!stream.io_watcher.active(POLLOUT)){\\n\\t\\t\\t\\t\\t\\tstream.io_watcher.handle_stop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t} else {\\n\\t\\t\\t/* Successful read */\\n\\t\\t\\tif (is_ipc) {\\n\\t\\t\\t\\t__stream_recv_cmsg(stream, fds);\\n\\t\\t\\t}\\n\\n\\t\\t\\tstream.read_cb(0, buf);\\n\\n\\t\\t\\t/* Return if we didn't fill the buffer, there is no more data to read. */\\n\\t\\t\\tif (buf.length < MAXREAD) {\\n\\t\\t\\t\\tstream.flags |= uv.STREAM_READ_PARTIAL;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nfunction _write_req_finish (req) {\\n\\tvar stream = req.handle;\\n\\treq.call(req, req.error);\\n\\t// stream.write_completed.push(req);\\n\\t// stream.io_feed();\\n}\\n\\n\\nfunction _write(stream) {\\n\\tvar req = stream.write_queue[0];\\n\\tif (!req){ return }\\n\\n\\tvar buffer = req.buf;\\n\\tvar length = req.len;\\n\\tvar nbufs = 0;\\n\\tvar n;\\n\\n\\t//TODO check if array\\n\\tif (Array.isArray(buffer)){\\n\\t\\t//this is an array of buffers to write\\n\\t\\tnbufs = buffer.length;\\n\\t}\\n\\n\\t// writev\\n\\tif (nbufs > 0){\\n\\t\\tthrow new Error(\\\"writev\\\");\\n\\t}\\n\\n\\t// sendmsg\\n\\telse if (req.send_handle) {\\n\\t\\tvar fd_to_send = req.send_handle.fd;\\n\\t\\tvar pid        = stream.ipc_pid;\\n\\t\\tn = uv.sendmsg(stream.fd, buffer, length, fd_to_send, pid, SEND_FLAG);\\n\\t}\\n\\n\\telse { // single write\\n\\t\\tn = uv.write(stream.fd, buffer, length, SEND_FLAG);\\n\\t}\\n\\n\\t// null indicates an error\\n\\tif (n === null){\\n\\t\\t// anything other than EWOULDBLOCK & EAGAIN\\n\\t\\t// should be treated as an error\\n\\t\\tvar error = process.errno;\\n\\t\\tif ( error != errno.EAGAIN && error != errno.EWOULDBLOCK) {\\n\\t\\t\\treq.error = -error;\\n\\t\\t\\t_write_req_finish(req);\\n\\t\\t\\tstream.io_watcher.stop(POLLOUT);\\n\\t\\t\\tif (!stream.io_watcher.active(POLLIN)){\\n\\t\\t\\t\\tstream.io_watcher.handle_stop();\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t}\\n\\n\\telse {\\n\\t\\treq.bytes += n;\\n\\t\\tstream.write_queue_size -= n;\\n\\n\\t\\tif (n === length){\\n\\t\\t\\tstream.write_queue.shift();\\n\\t\\t\\t_write_req_finish(req);\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\telse if (n > 0) {\\n\\t\\t\\treq.buf = Buffer(buffer).slice(n, length).toString();\\n\\t\\t\\treq.len = length - n;\\n\\t\\t\\tstream.write_queue[0] = req;\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nStream.prototype.stream_io = function(events){\\n\\n\\tif (events === POLLERR){\\n\\t\\tthis.maybe_error = 1;\\n\\t}\\n\\n\\tassert(!(this.flags & uv.CLOSING));\\n\\n\\tif (this.connect_req) {\\n\\t\\tthis.stream_connect();\\n\\t\\treturn;\\n\\t}\\n\\n\\tvar fd = this.fd;\\n\\tif ( events & (POLLIN | POLLERR) ){\\n\\t\\t_read(this);\\n\\t}\\n\\n\\tif (this.fd === -1) return;  /* read_cb closed stream. */\\n\\n\\tvar flag = this.flags;\\n\\tif ( (events & POLLERR) &&\\n\\t  (flag & uv.STREAM_READING) &&\\n\\t  (flag & uv.STREAM_READ_PARTIAL) &&\\n\\t  !(flag & uv.STREAM_READ_EOF)) {\\n\\n\\t\\tthis.stream_eof(\\\"\\\");\\n\\t}\\n\\n\\tif (this.fd === -1) return;  /* read_cb closed stream. */\\n\\n\\tif (events & (POLLOUT | POLLERR)) {\\n\\t\\t_write(this);\\n\\n\\t\\t//uv_write_callbacks\\n\\t\\twhile (1){\\n\\t\\t\\tvar req = this.write_completed.shift();\\n\\t\\t\\tif (!req) break;\\n\\t\\t\\treq.call(req, req.error);\\n\\t\\t}\\n\\n\\t\\tthis.write_completed = [];\\n\\t\\tthis.write_completed.length = 0;\\n\\n\\t\\t//uv_drain\\n\\t\\tif (!this.write_queue.length){\\n\\t\\t\\tthis.write_queue.length = 0;\\n\\t\\t\\tthis.io_watcher.stop(POLLOUT);\\n\\t\\t\\tvar flag = this.flags;\\n\\t\\t\\tif ((flag & uv.STREAM_SHUTTING) && !(flag & uv.CLOSING) && !(flag & uv.STREAM_SHUT)) {\\n\\t\\t\\t\\tthis.flags &= ~uv.STREAM_SHUTTING;\\n\\n\\t\\t\\t\\tvar error = 0;\\n\\t\\t\\t\\tif (!sock.shutdown(this.fd, sock.SHUT_WR)){\\n\\t\\t\\t\\t\\terror = process.errno;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tthis.flags |= uv.STREAM_SHUT;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (this.shutdown_cb){\\n\\t\\t\\t\\t\\tthis.shutdown_cb(error);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\n\\nStream.prototype.stream_eof = function(buf){\\n\\tthis.flags |= uv.STREAM_READ_EOF;\\n\\tthis.io_watcher.stop(POLLIN);\\n\\tif (!this.io_watcher.active(POLLOUT)){\\n\\t\\tthis.io_watcher.handle_stop();\\n\\t}\\n\\n\\tthis.read_cb(errno.EOF, buf);\\n\\tthis.flags &= ~uv.STREAM_READING;\\n};\\n\\n\\nStream.prototype.shutdown = function(cb){\\n\\n\\tif (this.flags & _shutting_mask){\\n\\t\\treturn errno.ENOTCONN;\\n\\t}\\n\\n\\tthis.shutdown_cb = cb;\\n\\tthis.flags |= uv.STREAM_SHUTTING;\\n\\n\\tif (!this.io_watcher.active(POLLOUT)){\\n\\t\\tthis.io_watcher.start(this.fd, POLLWRITE);\\n\\t}\\n\\n\\treturn 0;\\n};\\n\\n\\nStream.prototype.close = function(cb){\\n\\tthis.flags |= uv.CLOSING;\\n\\tthis.read_stop();\\n\\tthis.io_watcher.close(cb);\\n\\n\\tif (this.fd !== -1){\\n\\t\\tsock.close(this.fd);\\n\\t\\tthis.fd = -1;\\n\\t}\\n\\n\\tif (this.accepted_fd !== -1){\\n\\t\\tsock.close(this.accepted_fd);\\n\\t\\tthis.accepted_fd = -1;\\n\\t}\\n\\n\\treturn 0;\\n};\\n\\n\\nStream.prototype.read_stop = function(cb){\\n\\tif (!(this.flags & uv.STREAM_READING)) return 0;\\n\\n\\tthis.flags &= ~uv.STREAM_READING;\\n\\tthis.io_watcher.stop(POLLIN);\\n\\tif (!this.io_watcher.active(POLLOUT)){\\n\\t\\tthis.io_watcher.handle_stop();\\n\\t}\\n\\n\\tthis.read_cb = null;\\n\\treturn 0;\\n};\\n\\n\\nStream.prototype.stream_open = function(fd, flags){\\n\\tif (!(this.fd === -1 || this.fd === fd)){\\n\\t\\treturn errno.EBUSY;\\n\\t}\\n\\n\\tthis.flags |= flags;\\n\\n\\tif (this.type === \\\"TCP\\\") {\\n\\t\\t// if ((this.flags & uv.TCP_NODELAY) && uv__tcp_nodelay(fd, 1)){\\n\\t\\t//     return process.errno;\\n\\t\\t// }\\n\\n\\t\\t/* TODO Use delay the user passed in. */\\n\\t\\t// if ((this.flags & uv.TCP_KEEPALIVE) && uv__tcp_keepalive(fd, 1, 60)) {\\n\\t\\t//     return process.errno;\\n\\t\\t// }\\n\\t}\\n\\n\\tthis.fd = fd;\\n\\treturn 0;\\n};\\n\\n\\n//override in uv/tcp.js\\nStream.prototype.connect = function(ip, port, cb){\\n\\treturn errno.EINVAL;\\n};\\n\\n\\n//override in tcp.js & uv/ipc.js\\nStream.prototype.listen = function(backlog, cb){\\n\\treturn errno.EINVAL;\\n};\\n\\n\\nStream.prototype.accept = function(client){\\n\\tif (this.accepted_fd === -1) return errno.EINVAL;\\n\\n\\tvar ret = client.stream_open(this.accepted_fd, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\n\\tif (ret){\\n\\t\\tthrow new Error(\\\"stream open error\\\");\\n\\t}\\n\\n\\tthis.accepted_fd = -1;\\n\\treturn 0;\\n};\\n\\n\\nStream.prototype.read_start = function(cb){\\n\\n\\tif (this.flags & uv.CLOSING) return errno.EINVAL;\\n\\n\\tif (cb) this.read_cb = cb.bind(this);\\n\\n\\tthis.flags |= uv.STREAM_READING;\\n\\n\\t//TODO try to read immediately\\n\\tassert(this.fd !== -1);\\n\\tthis.io_watcher.start(this.fd, POLLREAD);\\n\\treturn 0;\\n};\\n\\n\\nStream.prototype.dowrite = function(){\\n\\tvar self = this;\\n\\tvar sockfd = self.fd;\\n\\tassert(sockfd > 0);\\n\\n\\tvar req = this.write_queue[0];\\n\\tif (!req){\\n\\t\\tself.write_queue.length = 0;\\n\\t\\treturn;\\n\\t}\\n\\n\\tvar buf    = req.buf;\\n\\tvar length = req.len;\\n\\n\\n\\tvar n = sock.send(sockfd, buf, length, SEND_FLAG);\\n\\tif (n === null){\\n\\t\\t//do nothing just yet\\n\\t\\t//queue it for the event loop\\n\\t} else {\\n\\t\\tself.write_queue_size -= n;\\n\\t\\tif (n === length){\\n\\t\\t\\tself.write_queue.shift();\\n\\t\\t\\treq.call(self, 0, n);\\n\\t\\t\\treturn 0;\\n\\t\\t} else if (n > 0) {\\n\\t\\t\\treq.buf = Buffer(buf).slice(n, length).toString();\\n\\t\\t\\treq.len = length - n;\\n\\t\\t\\tself.write_queue[0] = req;\\n\\t\\t}\\n\\t}\\n\\n\\tif (!self.io_watcher.active(POLLOUT)){\\n\\t\\tself.io_watcher.start(sockfd, POLLWRITE);\\n\\t}\\n\\treturn n;\\n};\\n\\n\\nStream.prototype.write = function(buf, cb, send_handle){\\n\\tvar self = this;\\n\\tvar sockfd = self.fd;\\n\\tassert(sockfd > 0);\\n\\n\\tif (Array.isArray(buf)){\\n\\t\\tvar last = buf.pop();\\n\\t\\tbuf.forEach(function(b){\\n\\t\\t\\tself.write(b);\\n\\t\\t});\\n\\n\\t\\treturn self.write(last, cb);\\n\\t}\\n\\n\\tvar empty_queue = self.write_queue_size === 0;\\n\\tvar length = Buffer.byteLength(buf);\\n\\tself.write_queue_size += length;\\n\\n\\tvar req    = cb || function (){};\\n\\treq.buf    = buf;\\n\\treq.send_handle = send_handle;\\n\\treq.len    = length;\\n\\treq.handle = self;\\n\\treq.write_index = 0;\\n\\treq.bytes = 0;\\n\\treq.error = 0;\\n\\n\\tself.write_queue.push(req);\\n\\n\\tif (self.connect_req) {\\n\\t\\t//still connecting\\n\\t}\\n\\telse if (empty_queue){\\n\\t\\t_write(self);\\n\\t}\\n\\telse {\\n\\t\\tself.io_watcher.start(sockfd, POLLWRITE);\\n\\t}\\n\\treturn 0;\\n};\\n\\n\\nStream.prototype.stream_connect = function(){\\n\\n\\tassert(this.type == \\\"TCP\\\" || this.type == \\\"NAMED_PIPE\\\");\\n\\n\\tvar error = 0;\\n\\tif (this.delayed_error) {\\n\\t\\t/* To smooth over the differences between unixes errors that\\n\\t\\t * were reported synchronously on the first connect can be delayed\\n\\t\\t * until the next tick--which is now.\\n\\t\\t */\\n\\t\\terror = this.delayed_error;\\n\\t\\tthis.delayed_error = 0;\\n\\t} else {\\n\\t\\t/* Normal situation: we need to get the socket error from the kernel. */\\n\\t\\tassert(this.fd >= 0);\\n\\t\\terror = sock.getsockopt(this.fd, sock.SOL_SOCKET, sock.SO_ERROR);\\n\\t}\\n\\n\\tif (error === errno.EINPROGRESS) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tthis.connect_req = null;\\n\\n\\tif (error || this.write_queue.length === 0) {\\n\\t\\tthis.io_watcher.stop(POLLOUT);\\n\\t}\\n\\n\\tif (this.connect_req_cb) {\\n\\t\\tvar cb = this.connect_req_cb;\\n\\t\\t// this.connect_req_cb = null;\\n\\t\\tcb(error);\\n\\t}\\n\\n\\tif (this.fd === -1){\\n\\t\\treturn;\\n\\t}\\n\\n\\tif (error) {\\n\\t\\t// throw new Error(\\\"flush write & connect error \\\" + error);\\n\\t\\t// uv__stream_flush_write_queue(stream, -ECANCELED);\\n\\t\\t// uv__write_callbacks(stream);\\n\\t}\\n};\\n\\n\\nStream.prototype.io_feed = function(){\\n\\tvar stream = this;\\n\\tvar io = this.io_watcher;\\n\\tsetTimeout(function(){\\n\\t\\tstream.stream_io(POLLOUT);\\n\\t}, 1);\\n};\\n\\n\\nStream.prototype.ref = function(cb){\\n\\tthis.io_watcher.ref();\\n};\\n\\n\\nStream.prototype.unref = function(cb){\\n\\tthis.io_watcher.unref();\\n};\\n\\nmodule.exports = Stream;\\n\",\"uv/tcp\":\"var util   = require(\\\"util\\\");\\nvar stream = require('uv/stream');\\nvar sock   = require('socket');\\nvar errno  = require('errno');\\nvar loop   = require('loop').main;\\nvar uv     = require('uv');\\nvar assert = require('assert');\\n\\nvar isWin  = process.platform === \\\"win32\\\";\\n\\nutil.inherits(TCP, stream);\\nfunction TCP (){\\n\\tstream.call(this, 'TCP');\\n}\\n\\n\\nTCP.prototype.open = function(s){\\n\\tif (!sock.nonblock(s, 1)){\\n\\t\\treturn process.errno;\\n\\t}\\n\\n\\treturn this.stream_open(s, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\n};\\n\\n\\nTCP.prototype.maybe_new_socket = function(domain, flags){\\n\\tif (domain == sock.AF_UNSPEC || this.fd !== -1) {\\n\\t\\tthis.flags |= flags;\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tvar fd = uv.socket(domain, sock.SOCK_STREAM, 0);\\n\\tif (!fd) return process.errno;\\n\\n\\tthis.stream_open(fd, flags);\\n\\treturn 0;\\n};\\n\\n\\nTCP.prototype.simultaneous_accepts = function(enable){\\n\\treturn 0;\\n};\\n\\n\\nTCP.prototype.bind = function(addr, flags) {\\n\\n\\tvar family = sock.family(addr);\\n\\n\\t/* Cannot set IPv6-only mode on non-IPv6 socket. */\\n\\tif ((flags & uv.TCP_IPV6ONLY) && family !== uv.AF_INET6) {\\n\\t\\treturn errno.EINVAL;\\n\\t}\\n\\n\\tvar err = this.maybe_new_socket(family, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\n\\n\\tif (err) return err;\\n\\n\\tvar set = process.platform === 'win32' ? 0 : 1;\\n\\tif (!sock.setsockopt(this.fd, sock.SOL_SOCKET, sock.SO_REUSEADDR, set)) {\\n\\t\\treturn process.errno;\\n\\t}\\n\\n\\tprocess.errno = 0;\\n\\tif (!sock.bind(this.fd, addr) && process.errno !== errno.EADDRINUSE) {\\n\\t\\tif (process.errno === errno.EAFNOSUPPORT) {\\n\\t\\t\\t/* OSX, other BSDs and SunoS fail with EAFNOSUPPORT when binding a\\n\\t\\t\\t* socket created with AF_INET to an AF_INET6 address or vice versa. */\\n\\t\\t\\treturn errno.EINVAL;\\n\\t\\t}\\n\\t\\treturn process.errno;\\n\\t}\\n\\n\\tthis.delayed_error = process.errno;\\n\\n\\tif (family === sock.AF_INET6) {\\n\\t\\tthis.flags |= uv.HANDLE_IPV6;\\n\\t}\\n\\n\\treturn 0;\\n};\\n\\n\\nTCP.prototype.listen = function(backlog, cb){\\n\\tvar self = this;\\n\\n\\tif (this.delayed_error) {\\n\\t\\treturn this.delayed_error;\\n\\t}\\n\\n\\tthis.maybe_new_socket(sock.AF_INET, uv.STREAM_READABLE);\\n\\n\\tif (!sock.listen(this.fd, backlog)){\\n\\t\\treturn process.errno;\\n\\t}\\n\\n\\tthis.connection_cb = cb.bind(this);\\n\\n\\t// close previous loop watcher and\\n\\t// create new one to be handled with\\n\\t// server_io function\\n\\tself.io_watcher.close();\\n\\tthis.io_watcher = loop.io(function(h, events){\\n\\t\\tself.server_io(events);\\n\\t});\\n\\n\\tthis.io_watcher.start(this.fd, loop.POLLIN);\\n\\treturn 0;\\n};\\n\\n\\nTCP.prototype.connect = function(addr, cb){\\n\\tvar self = this;\\n\\n\\tif (this.connect_req){\\n\\t\\treturn errno.EALREADY;\\n\\t}\\n\\n\\tvar family = sock.family(addr);\\n\\n\\tvar err = this.maybe_new_socket(family, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\n\\tif (err) return err;\\n\\n\\tthis.delayed_error = 0;\\n\\tthis.connect_req    = 1;\\n\\tif (cb) this.connect_req_cb = cb.bind(this);\\n\\n\\tself.io_watcher.start(self.fd, loop.POLLIN | loop.POLLOUT | loop.POLLERR);\\n\\tsock.connect(this.fd, addr);\\n\\n\\treturn 0;\\n};\\n\\nTCP.prototype.getpeername = function(){\\n\\tvar addr = sock.getpeername(this.fd);\\n\\tif (addr === null) return process.errno;\\n\\tvar peerinfo = sock.addr_info(addr);\\n\\tif (peerinfo === null) return process.errno;\\n\\treturn {\\n\\t\\tip : peerinfo[0],\\n\\t\\tport : peerinfo[1]\\n\\t};\\n};\\n\\n\\nmodule.exports = TCP;\\n\",\"uv/pipe\":\"var util   = require(\\\"util\\\");\\nvar stream = require('uv/stream');\\nvar sock   = require('socket');\\nvar errno  = require('errno');\\nvar loop   = require('loop');\\nvar uv     = require('uv');\\nvar assert = require('assert');\\n\\nvar isWin  = process.platform === 'win32';\\n\\nvar pipe_map = {};\\n\\nutil.inherits(Pipe, stream);\\nfunction Pipe (ipc){\\n\\tstream.call(this, 'NAMED_PIPE');\\n\\tthis.shutdown_req = null;\\n\\tthis.connect_req = null;\\n\\tthis.pipe_fname = null;\\n\\tthis.ipc = ipc;\\n}\\n\\n\\nPipe.prototype.open = function(fd){\\n\\tif (!sock.nonblock(fd, 1)){\\n\\t\\tthrow new Error(process.errno);\\n\\t\\treturn process.errno;\\n\\t}\\n\\n\\treturn this.stream_open(fd, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\n};\\n\\n\\nPipe.prototype.listen = function(backlog, cb){\\n\\tvar self = this;\\n\\n\\tif (this.fd === -1) return errno.EINVAL;\\n\\n\\tif (!sock.listen(this.fd, backlog)){\\n\\t\\treturn process.errno;\\n\\t}\\n\\n\\t// we already have io_watcher active with\\n\\t// stream_io, clean this up and activate again\\n\\t// on server_io cb\\n\\tthis.io_watcher.close();\\n\\tthis.io_watcher = null;\\n\\n\\tthis.connection_cb = cb;\\n\\tthis.io_watcher = loop.io(function(h, events){\\n\\t\\tself.server_io(events);\\n\\t});\\n\\n\\tthis.io_watcher.start(this.fd, loop.POLLIN);\\n\\treturn 0;\\n};\\n\\n\\nPipe.prototype.bind = function(pipe_fname) {\\n\\n\\tvar sockfd;\\n\\n\\t/* Already bound? */\\n\\tif (this.fd >= 0) {\\n\\t\\treturn errno.EINVAL;\\n\\t}\\n\\n\\t//we are emulatiing AF_UNIX\\n\\tif (isWin){\\n\\t\\tsockfd = uv.socket(sock.AF_INET, sock.SOCK_STREAM, 0);\\n\\t} else {\\n\\t\\tsockfd = uv.socket(sock.AF_UNIX, sock.SOCK_STREAM, 0);\\n\\t}\\n\\n\\tif (!sockfd) return process.errno;\\n\\n\\tvar addr = sock.pton(\\\"127.0.0.1\\\", 8000);\\n\\tif (addr === null){\\n\\t\\tthrow new Error(\\\"addr error \\\" + process.errno);\\n\\t}\\n\\n\\tpipe_map[pipe_fname] = addr;\\n\\n\\t// memset(&saddr, 0, sizeof saddr);\\n\\t// strncpy(saddr.sun_path, pipe_fname, sizeof(saddr.sun_path) - 1);\\n\\t// saddr.sun_path[sizeof(saddr.sun_path) - 1] = '\\\\0';\\n\\t// saddr.sun_family = AF_UNIX;\\n\\n\\tif (!sock.bind(sockfd, addr)) {\\n\\t\\tuv.close(sockfd);\\n\\t\\t/* Convert ENOENT to EACCES for compatibility with Windows. */\\n\\t\\tif (process.errno == errno.ENOENT) return errno.EACCES;\\n\\t\\treturn process.errno;\\n\\t}\\n\\n\\t/* Success. */\\n\\tthis.pipe_fname = pipe_fname; /* Is a strdup'ed copy. */\\n\\tthis.fd = sockfd;\\n\\treturn 0;\\n};\\n\\n\\nPipe.prototype.connect = function(name, cb) {\\n\\n\\tvar new_sock = (this.fd === -1);\\n\\n\\tif (new_sock) {\\n\\t\\tif (isWin){\\n\\t\\t\\tnewSock = uv.socket(sock.AF_INET, sock.SOCK_STREAM, 0);\\n\\t\\t} else {\\n\\t\\t\\tnewSock = uv.socket(sock.AF_UNIX, sock.SOCK_STREAM, 0);\\n\\t\\t}\\n\\n\\t\\tif (!newSock) return this.connect_error();\\n\\t\\tthis.fd = newSock;\\n\\t}\\n\\n\\tvar addr = pipe_map[name];\\n\\tvar err = 0;\\n\\tvar r;\\n\\n\\tvar self = this;\\n\\n\\tthis.connect_req   = 1;\\n\\tif (cb) this.connect_req_cb = cb.bind(this);\\n\\n\\tif (new_sock) {\\n\\t\\terr = this.stream_open(this.fd, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\n\\t}\\n\\n\\tself.io_watcher.start(self.fd, loop.POLLIN | loop.POLLOUT | loop.POLLERR);\\n\\tsock.connect(this.fd, addr);\\n\\n\\tthis.delayed_error = err;\\n\\treturn 0;\\n};\\n\\nmodule.exports = Pipe;\\n\",\"uv/process\":\"var isWin = process.platform === 'win32';\\nmodule.exports = isWin ? require('uv/process/windows') :\\n                         require('uv/process/unix');\\n\",\"uv/process/windows\":\"var assert   = require('assert');\\nvar uv       = require('uv');\\nvar errno    = require('errno');\\nvar syscall  = require('syscall');\\nvar timers   = require('timers');\\n\\nvar DETACHED_PROCESS           = 0x00000008;\\nvar CREATE_NEW_PROCESS_GROUP   = 0x00000200;\\nvar CREATE_UNICODE_ENVIRONMENT = 0x00000400;\\nvar CREATE_NO_WINDOW           = 0x08000000;\\n\\nvar READ_PIPE  = 0;\\nvar WRITE_PIPE = 1;\\n\\n// TODO child_watcher ref\\n\\nfunction Process (options) {\\n\\n\\tthis.exit_signal = 0;\\n\\n\\toptions = options || {};\\n\\tassert(options.file, \\\"options.file required\\\");\\n\\n\\tassert(!(options.flags & ~(\\n\\t\\tuv.PROCESS_DETACHED |\\n\\t\\tuv.PROCESS_SETGID |\\n\\t\\tuv.PROCESS_SETUID |\\n\\t\\tuv.PROCESS_WINDOWS_HIDE |\\n\\t\\tuv.PROCESS_WINDOWS_VERBATIM_ARGUMENTS\\n\\t)));\\n\\n\\tvar stdio_count = options.stdio_count;\\n\\tif (stdio_count < 3) stdio_count = 3;\\n\\n\\tvar err = errno.ENOMEM;\\n\\n\\tvar pipes = [];\\n\\n\\tfor (var i = 0; i < stdio_count; i++) {\\n\\t\\tpipes[i]    = [];\\n\\t\\tpipes[i][0] = -1;\\n\\t\\tpipes[i][1] = -1;\\n\\t}\\n\\n\\tfor (var i = 0; i < options.stdio_count; i++) {\\n\\t\\terr = this.init_stdio(options.stdio[i], pipes[i], i);\\n\\t\\tif (err) throw new Error(\\\"STDIO initiate error \\\" + err);\\n\\t}\\n\\n\\tthis.status = 0;\\n\\tthis.pid = 0;\\n\\tthis.exit_cb = options.exit_cb;\\n\\n\\t// on error returns null and set process.errno\\n\\t// on success returns an object hold process\\n\\t// handle and process id\\n\\tvar ret = this.child_init(options, stdio_count, pipes);\\n\\tthis.pipes = pipes;\\n\\n\\tif (ret === null) {\\n\\t\\terr = process.errno;\\n\\t\\tthis.errno = errno.translate(process.errno);\\n\\t} else {\\n\\t\\tthis.process_handle = ret.process || -1;\\n\\t\\tthis.pid = ret.process_id || 0;\\n\\t}\\n\\n\\tfor (var i = 0; i < options.stdio_count; i++) {\\n\\t\\t// set process id for all stream pipes\\n\\t\\t// we need to use this with msgrecv function\\n\\t\\tvar stream = options.stdio[i].stream;\\n\\t\\tif (stream){\\n\\t\\t\\tif (stream.type === 'NAMED_PIPE' || stream.type){\\n\\t\\t\\t\\toptions.stdio[i].stream.ipc_pid = this.pid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\terr = this.open_stream(options.stdio[i], pipes[i], i === 0);\\n\\t\\tif (err === 0) continue;\\n\\n\\t\\twhile (i--) {\\n\\t\\t\\tthis.close_stream(options.stdio[i]);\\n\\t\\t}\\n\\t}\\n\\n\\t// Only activate this handle if exec() happened\\n\\t// successfully, we are hacky here as we are using\\n\\t// a timer loop to check for process status\\n\\tif ( !err && this.pid ) {\\n\\t\\tvar self = this;\\n\\t\\tvar process_handle = this.process_handle;\\n\\t\\tself.child_watcher = setInterval(function(){\\n\\t\\t\\tvar exitcode = uv.get_exit_code(process_handle);\\n\\n\\t\\t\\t// 259 indicates that the\\n\\t\\t\\t// process still running\\n\\t\\t\\tif (exitcode === 259){\\n\\t\\t\\t\\treturn; /* do nothing we need to check again */\\n\\t\\t\\t}\\n\\n\\t\\t\\t// stop child status watcher\\n\\t\\t\\tclearInterval(this);\\n\\t\\t\\tself.child_watcher = null;\\n\\n\\t\\t\\t// close process handle\\n\\t\\t\\tassert(syscall.CloseHandle(self.process_handle) !== null);\\n\\n\\t\\t\\tif (self.exit_cb) self.exit_cb.call(self, exitcode, self.exit_signal);\\n\\n\\t\\t\\tfor (var fd = 0; fd < pipes.length; fd++) {\\n\\t\\t\\t\\tif (pipes[fd][0] > -1){\\n\\t\\t\\t\\t\\tuv.close(pipes[fd][0]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}, 1);\\n\\t} else {\\n\\t\\tfor (var fd = 0; fd < pipes.length; fd++) {\\n\\t\\t\\tif (pipes[fd][0] > -1){\\n\\t\\t\\t\\tuv.close(pipes[fd][0]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif (err) {\\n\\t\\tthis.errno = errno.translate(err);\\n\\t}\\n\\treturn this;\\n}\\n\\n\\nProcess.prototype.unref = function(){\\n\\tif (this.child_watcher){\\n\\t\\tthis.child_watcher.unref();\\n\\t}\\n\\treturn 0;\\n};\\n\\n\\nProcess.prototype.open_stream = function (container, pipefds, writable) {\\n\\n\\tif (!(container.flags & uv.CREATE_PIPE) || pipefds[0] < 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tvar flags = 0;\\n\\n\\tif (container.stream.type === 'NAMED_PIPE' && container.stream.ipc ) {\\n\\t\\tflags = uv.STREAM_READABLE | uv.STREAM_WRITABLE;\\n\\t}\\n\\n\\telse if (writable) {\\n\\t\\tflags = uv.STREAM_WRITABLE;\\n\\t}\\n\\n\\telse {\\n\\t\\tflags = uv.STREAM_READABLE;\\n\\t}\\n\\n\\treturn container.stream.stream_open(pipefds[1], flags);\\n};\\n\\n\\n// constructs a utf16 buffer of environment\\n// variables block, windows require each env to be\\n// seperated with 1 nul and ends with 2 nul charachters\\nfunction make_env_block(env){\\n\\tif (!env){\\n\\t\\treturn null;\\n\\t}\\n\\n\\tvar envBlock = process.env;\\n\\n\\t//extend\\n\\tfor (var key in envBlock){\\n\\t\\tenv.unshift(key + '=' + envBlock[key]);\\n\\t}\\n\\n\\tvar len = env.length;\\n\\n\\tvar n = \\\"\\\";\\n\\tfor (var i = 0; i < len; i++){\\n\\t\\tn += env[i] + '\\\\0';\\n\\t}\\n\\tn += '\\\\0\\\\0';\\n\\treturn new Buffer(n, 'ucs2');\\n}\\n\\n\\nfunction join_arguments (args, verbatim){\\n\\tif (!verbatim){\\n\\t\\tfor (var i = 0; i < args.length; i++){\\n\\t\\t\\tvar arg = args[i];\\n\\t\\t\\tif (/\\\\s/g.test(arg)){\\n\\t\\t\\t\\targ.replace(/\\\"/g, '\\\\\\\"');\\n\\t\\t\\t\\targ = '\\\"' + arg + '\\\"'\\n\\t\\t\\t\\targs[i] = arg;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\targs = args.join(' ');\\n\\treturn syscall.UTF16PtrFromString(args);\\n}\\n\\n\\nProcess.prototype.child_init = function(options, stdio_count, pipes) {\\n\\n\\tvar process_flags = CREATE_UNICODE_ENVIRONMENT;\\n\\tif (options.flags & uv.PROCESS_DETACHED) {\\n\\t\\tprocess_flags |= DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP;\\n\\t}\\n\\n\\t//initiate stdio handles\\n\\tvar stdioHandles = [-1, -1, -1];\\n\\n\\tfor (var fd = 0; fd < stdio_count; fd++) {\\n\\t\\tvar use_handle   = pipes[fd][2];\\n\\t\\tif (use_handle > -1) {\\n\\t\\t\\tif (fd <= 2) {\\n\\t\\t\\t\\tstdioHandles[fd] = use_handle;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// store shared handles?\\n\\t\\t\\t\\toptions.env = options.env || [];\\n\\t\\t\\t\\toptions.env.push(\\\"COMO_FD_\\\"+fd+'='+use_handle);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// working directory\\n\\tvar cwd = null\\n\\tif (options.cwd) {\\n\\t\\tcwd = syscall.UTF16PtrFromString(options.cwd);\\n\\t} else {\\n\\t\\tcwd = syscall.GetCurrentDirectory();\\n\\t\\tif (!cwd) return null;\\n\\t}\\n\\n\\t// var path = syscall.Getenv('PATH');\\n\\n\\t//custom env block\\n\\tvar env = null;\\n\\tif (options.env) {\\n\\t\\tenv = make_env_block(options.env);\\n\\t}\\n\\n\\t// CreateProcess syscall\\n\\tvar info    = new syscall.ProcessInformation();\\n\\tvar startup = new syscall.StartupInfo();\\n\\n\\tstartup.Cb = startup.size;\\n\\tstartup.Flags = (syscall.STARTF_USESTDHANDLES | syscall.STARTF_USESHOWWINDOW);\\n\\tstartup.StdInput  = stdioHandles[0];\\n\\tstartup.StdOutput = stdioHandles[1];\\n\\tstartup.StdError  = stdioHandles[2];\\n\\n\\tif (options.flags & uv.PROCESS_WINDOWS_HIDE) {\\n\\t\\t/* Use SW_HIDE to avoid any potential process window. */\\n\\t\\tstartup.ShowWindow = syscall.SW_HIDE;\\n\\t} else {\\n\\t\\tstartup.wShowWindow = syscall.SW_SHOWDEFAULT;\\n\\t}\\n\\n\\tvar program = null;\\n\\tvar arguments = join_arguments(options.args,\\n\\t\\toptions.flags & uv.PROCESS_WINDOWS_VERBATIM_ARGUMENTS);\\n\\n\\t// syscall CreateProcess\\n\\t// on failure returns null and set\\n\\t// process.errno to last error\\n\\tvar ret = syscall.CreateProcess(\\n\\t\\tprogram,      // programs path\\n\\t\\targuments,    // utf16 buffer of all args\\n\\t\\tnull,\\n\\t\\tnull,\\n\\t\\t1,\\n\\t\\tprocess_flags,\\n\\t\\tenv,          // utf16 env block\\n\\t\\tcwd,          // child working director\\n\\t\\tstartup,      // startup info\\n\\t\\tinfo          // new created process info\\n\\t);\\n\\n\\t// duplicated handles passed to the child\\n\\t// we can close them now\\n\\tfor (var fd = 0; fd < pipes.length; fd++) {\\n\\t\\tif (pipes[fd][2] !== -1){\\n\\t\\t\\tuv.close(pipes[fd][2]);\\n\\t\\t}\\n\\t}\\n\\n\\tif (ret === null) return null;\\n\\n\\tassert(syscall.CloseHandle(info.Thread) !== null);\\n\\n\\treturn {\\n\\t\\tprocess: info.Process,\\n\\t\\tprocess_id : info.ProcessId\\n\\t};\\n};\\n\\n\\nProcess.prototype.init_stdio = function (container, fds, i) {\\n\\tvar STDIO_MASK = uv.IGNORE | uv.CREATE_PIPE | uv.INHERIT_FD | uv.INHERIT_STREAM;\\n\\n\\t// initiated fd to invalid handle\\n\\t// ignore by default\\n\\tif (i <= 2) fds[2] = -1;\\n\\n\\tif (!container) return 0;\\n\\tswitch (container.flags & STDIO_MASK){\\n\\t\\tcase uv.IGNORE : {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tcase uv.CREATE_PIPE : {\\n\\t\\t\\tassert(container.stream.type === 'NAMED_PIPE');\\n\\n\\t\\t\\tif (uv.make_socketpair(fds, 0)) throw new Error(\\\"Error creating socketpair\\\");\\n\\t\\t\\tvar fh = fds[0];\\n\\t\\t\\tvar inherit_handle = -1;\\n\\t\\t\\tif (i > 2) {\\n\\t\\t\\t\\tinherit_handle = uv.make_inheritable(fh);\\n\\t\\t\\t\\tinherit_handle = uv.duplicate_handle(inherit_handle);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinherit_handle = uv.duplicate_handle(fh);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfds[2] = inherit_handle;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tcase uv.INHERIT_FD :\\n\\t\\tcase uv.INHERIT_STREAM : {\\n\\t\\t\\tif (container.flags & uv.INHERIT_FD) {\\n\\t\\t\\t\\tfd = container.fd;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfd = container.stream.fd;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (typeof fd === 'undefined' || fd == -1){\\n\\t\\t\\t\\treturn errno.EINVAL;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//duplicate fd to handle\\n\\t\\t\\tvar handle = uv.get_fd_handle(fd);\\n\\t\\t\\tif (handle === null) return process.errno;\\n\\t\\t\\tvar dupHandle = uv.duplicate_handle(handle);\\n\\t\\t\\tfds[2] = dupHandle;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tdefault : {\\n\\t\\t\\tthrow new Error(\\\"unknown stdio type\\\");\\n\\t\\t}\\n\\t}\\n};\\n\\n\\nProcess.prototype.kill = function(signum){\\n\\tvar process = this;\\n\\tvar err;\\n\\n\\tif (process.process_handle == -1) {\\n\\t\\treturn errno.EINVAL;\\n\\t}\\n\\n\\terr = uv.Win32kill(process.process_handle, signum);\\n\\tif (err) return err;  /* err is already translated. */\\n\\tprocess.exit_signal = signum;\\n\\treturn 0;\\n};\\n\\n\\nProcess.prototype.close = function(cb){\\n\\tvar self = this;\\n\\n\\t// clean opened pipes\\n\\tvar pipes = this.pipes || [];\\n\\tfor (var fd = 0; fd < pipes.length; fd++) {\\n\\t\\tif (pipes[fd][0] > -1){\\n\\t\\t\\tuv.close(pipes[fd][0]);\\n\\t\\t}\\n\\t}\\n\\n\\t// only close if process handle is there\\n\\tif (this.process_handle){\\n\\t\\tuv.close(this.process_handle);\\n\\t}\\n\\n\\t//clear child watcher interval\\n\\tif (this.child_watcher){\\n\\t\\tclearInterval(this.child_watcher);\\n\\t}\\n};\\n\\nmodule.exports = Process;\\n\",\"uv/process/unix\":\"var assert   = require('assert');\\nvar uv       = require('uv');\\nvar errno    = require('errno');\\nvar syscall  = require('syscall');\\nvar SYS      = syscall.SYS;\\nvar timers   = require('timers');\\nvar C        = require('C');\\n\\nvar DETACHED_PROCESS           = 0x00000008;\\nvar CREATE_NEW_PROCESS_GROUP   = 0x00000200;\\nvar CREATE_UNICODE_ENVIRONMENT = 0x00000400;\\nvar CREATE_NO_WINDOW           = 0x08000000;\\n\\nvar READ_PIPE  = 0;\\nvar WRITE_PIPE = 1;\\n\\nfunction _exit(n){\\n\\tprocess.reallyExit(n);\\n}\\n\\nfunction init_stdio (container, fds) {\\n\\tvar mask = uv.IGNORE | uv.CREATE_PIPE | uv.INHERIT_FD | uv.INHERIT_STREAM;\\n\\tvar fd;\\n\\n\\tswitch( container.flags & mask ){\\n\\t\\tcase uv.IGNORE : {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tcase uv.CREATE_PIPE : {\\n\\t\\t\\tassert(container.stream.type === 'NAMED_PIPE');\\n\\t\\t\\tif (uv.make_socketpair(fds, 0)) throw new Error(\\\"Error creating socketpair\\\");\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tcase uv.INHERIT_FD :\\n\\t\\tcase uv.INHERIT_STREAM : {\\n\\t\\t\\tif (container.flags & uv.INHERIT_FD) {\\n\\t\\t\\t\\tfd = container.fd;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfd = container.stream.fd;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (typeof fd === 'undefined' || fd == -1){\\n\\t\\t\\t\\treturn errno.EINVAL;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfds[1] = fd;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tdefault : {\\n\\t\\t\\tthrow new Error(\\\"unknown stdio type\\\");\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction write_int (fd, val){\\n\\tval = \\\"\\\" + val; //stringify\\n\\tvar n;\\n\\tdo {\\n\\t\\tn = uv.write(fd, val, val.length);\\n\\t} while (n === null && process.errno === errno.EINVAL);\\n\\n\\tif (n === null && process.errno === errno.EPIPE){\\n\\t\\treturn;\\n\\t}\\n}\\n\\n\\nvar jargs;\\nfunction make_args_block (args){\\n\\tfor (var i = 0; i < args.length; i++){\\n\\t\\targs[i] = args[i] + '\\\\0';\\n\\t}\\n\\tjargs = Buffer(args.join(''));\\n\\treturn jargs;\\n}\\n\\nfunction child_init (options, stdio_count, pipes, error_fd){\\n\\n\\tvar fd, use_fd, close_fd;\\n\\n\\tif (options.flags & uv.PROCESS_DETACHED) {\\n\\t\\tsyscall.setsid();\\n\\t}\\n\\n\\t/* First duplicate low numbered fds, since it's not safe to duplicate them,\\n\\t * they could get replaced. Example: swapping stdout and stderr; without\\n\\t * this fd 2 (stderr) would be duplicated into fd 1, thus making both\\n\\t * stdout and stderr go to the same fd, which was not the intention. */\\n\\tfor (fd = 0; fd < stdio_count; fd++) {\\n\\t\\tuse_fd = pipes[fd][1];\\n\\t\\tif (use_fd < 0 || use_fd >= fd) continue;\\n\\n\\t\\tpipes[fd][1] = syscall.fcntl(use_fd, SYS.F_DUPFD, stdio_count);\\n\\t\\tif (pipes[fd][1] === null) {\\n\\t\\t\\twrite_int(error_fd, process.errno);\\n\\t\\t\\t_exit(127);\\n\\t\\t}\\n\\t}\\n\\n\\tfor (fd = 0; fd < stdio_count; fd++) {\\n\\n\\t\\tclose_fd = pipes[fd][0];\\n\\t\\tuse_fd   = pipes[fd][1];\\n\\n\\t\\tif (use_fd < 0) {\\n\\t\\t\\tif (fd >= 3) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// redirect stdin, stdout and stderr to /dev/null even if\\n\\t\\t\\t\\t// uv.IGNORE is set\\n\\t\\t\\t\\tuse_fd = syscall.Open(\\\"/dev/null\\\", fd == 0 ? SYS.O_RDONLY : SYS.O_RDWR);\\n\\t\\t\\t\\tclose_fd = use_fd;\\n\\n\\t\\t\\t\\tif (use_fd === null) {\\n\\t\\t\\t\\t\\twrite_int(error_fd, process.errno);\\n\\t\\t\\t\\t\\t_exit(127);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (fd === use_fd) {\\n\\t\\t\\tuv.cloexec(use_fd, 0);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tfd = syscall.dup2(use_fd, fd);\\n\\t\\t}\\n\\n\\t\\tif (fd === null) {\\n\\t\\t\\twrite_int(error_fd, process.errno);\\n\\t\\t\\t_exit(127);\\n\\t\\t}\\n\\n\\t\\tif (fd <= 2) {\\n\\t\\t\\tuv.nonblock(fd, 0);\\n\\t\\t}\\n\\n\\t\\tif (close_fd >= stdio_count) {\\n\\t\\t\\tuv.close(close_fd);\\n\\t\\t}\\n\\t}\\n\\n\\tfor (fd = 0; fd < stdio_count; fd++) {\\n\\t\\tuse_fd = pipes[fd][1];\\n\\t\\tif (use_fd >= stdio_count) {\\n\\t\\t\\tuv.close(use_fd);\\n\\t\\t}\\n\\t}\\n\\n\\tif (options.cwd) {\\n\\t\\tvar ret = syscall.chdir(options.cwd);\\n\\t\\tif (ret === null){\\n\\t\\t\\twrite_int(error_fd, process.errno);\\n\\t\\t\\t_exit(127);\\n\\t\\t}\\n\\t}\\n\\n\\tif (options.flags & (uv.PROCESS_SETUID | uv.PROCESS_SETGID)) {\\n\\t\\t/* When dropping privileges from root, the `setgroups` call will\\n\\t\\t * remove any extraneous groups. If we don't call this, then\\n\\t\\t * even though our uid has dropped, we may still have groups\\n\\t\\t * that enable us to do super-user things. This will fail if we\\n\\t\\t * aren't root, so don't bother checking the return value, this\\n\\t\\t * is just done as an optimistic privilege dropping function.\\n\\t\\t */\\n\\t\\tvar olderrno = process.errno;\\n\\t\\tsyscall.setgroups(0, null);\\n\\t\\tprocess.errno = olderrno;\\n\\t}\\n\\n\\tif ((options.flags & uv.PROCESS_SETGID) && syscall.setgid(options.gid) === null) {\\n\\t\\twrite_int(error_fd, process.errno);\\n\\t\\t_exit(127);\\n\\t}\\n\\n\\tif ((options.flags & uv.PROCESS_SETUID) && syscall.setuid(options.uid) === null) {\\n\\t\\twrite_int(error_fd, process.errno);\\n\\t\\t_exit(127);\\n\\t}\\n\\n\\tif (options.env) {\\n\\t\\tset_env_block(options.env);\\n\\t}\\n\\n\\tvar args = options.args.slice(0);\\n\\targs.unshift(options.file);\\n\\n\\t// make sure to convert everything to strings\\n\\tfor (var i = 0; i < args.length; i++){\\n\\t\\targs[i] = String(args[i]);\\n\\t}\\n\\targs.push(null);\\n\\n\\tif (syscall.execlp.apply(null, args) === null){\\n\\t\\twrite_int(error_fd, process.errno);\\n\\t}\\n\\n\\t// write_int(error_fd, options.cwd);\\n\\t// var n = write_int(error_fd, \\\"done\\\");\\n\\t// // console.log(n);\\n\\t// console.log(process.errno);\\n\\t// console.log('done');\\n}\\n\\n// TODO child_watcher ref\\n\\nfunction Process (options) {\\n\\tvar self = this;\\n\\tthis.exit_signal = 0;\\n\\n\\toptions = options || {};\\n\\tassert(options.file, \\\"options.file required\\\");\\n\\n\\tassert(!(options.flags & ~(\\n\\t\\tuv.PROCESS_DETACHED |\\n\\t\\tuv.PROCESS_SETGID |\\n\\t\\tuv.PROCESS_SETUID |\\n\\t\\tuv.PROCESS_WINDOWS_HIDE |\\n\\t\\tuv.PROCESS_WINDOWS_VERBATIM_ARGUMENTS\\n\\t)));\\n\\n\\tvar stdio_count = options.stdio_count;\\n\\tif (stdio_count < 3) stdio_count = 3;\\n\\n\\tvar err = errno.ENOMEM;\\n\\n\\tvar pipes = [];\\n\\tvar signal_pipe = [ -1, -1 ];\\n\\n\\tfor (var i = 0; i < stdio_count; i++) {\\n\\t\\tpipes[i]    = [];\\n\\t\\tpipes[i][0] = -1;\\n\\t\\tpipes[i][1] = -1;\\n\\t}\\n\\n\\tfor (var i = 0; i < options.stdio_count; i++) {\\n\\t\\terr = init_stdio(options.stdio[i], pipes[i], i);\\n\\t\\tif (err) throw new Error(\\\"STDIO initiate error \\\" + err);\\n\\t}\\n\\n\\t// initiate child parent signal pipes\\n\\tif (uv.make_pipe(signal_pipe, 0)) throw new Error(\\\"Error creating signal pipe\\\");\\n\\n\\t/* Acquire write lock to prevent opening new fds in worker threads */\\n\\t// uv_rwlock_wrlock(&loop->cloexec_lock);\\n\\n\\tvar pid = syscall.fork();\\n\\tif (pid === null){\\n\\t\\tthrow new Error(\\\"can't fork\\\");\\n\\t}\\n\\n\\t// child process\\n\\tif (pid === 0){\\n\\t\\tchild_init(options, stdio_count, pipes, signal_pipe[1]);\\n\\t\\tprocess.reallyExit(0);\\n\\t}\\n\\n\\t/* Release lock in parent process */\\n\\t// uv_rwlock_wrunlock(&loop->cloexec_lock);\\n\\tuv.close(signal_pipe[1]);\\n\\n\\t// waitpid status\\n\\tvar status = new C.void( C.sizeOf.int );\\n\\tvar r;\\n\\tvar spawn_error = 0;\\n\\n\\tdo {\\n\\t\\tr = uv.read(signal_pipe[0], 1024);\\n\\t} while (r === null && process.errno === errno.EINTR);\\n\\n\\tif (r === null && process.errno === errno.EOF){\\n\\t\\t/* okay, EOF - do nothing */\\n\\t}\\n\\telse if (r) {\\n\\t\\tdo {\\n\\t\\t\\terr = syscall.waitpid(pid, status, 0);  //okay, read errorno\\n\\t\\t} while (err === null && process.errno == errno.EINTR);\\n\\t\\tassert(err == pid);\\n\\t\\tspawn_error = Number(r);\\n\\t}\\n\\telse if (r === null && process.errno === errno.EPIPE) {\\n\\t\\t// do\\n\\t\\t// \\terr = waitpid(pid, &status, 0); /* okay, got EPIPE */\\n\\t\\t// while (err == -1 && errno == EINTR);\\n\\t\\t// assert(err == pid);\\n\\t}\\n\\telse {\\n\\t\\tthrow new Error('spawn error ' + process.errno);\\n\\t}\\n\\n\\tuv.close(signal_pipe[0]);\\n\\n\\tthis.pipes = pipes;\\n\\tfor (var i = 0; i < options.stdio_count; i++) {\\n\\t\\terr = this.open_stream(options.stdio[i], pipes[i], i === 0);\\n\\t\\tif (err === 0) continue;\\n\\n\\t\\twhile (i--) {\\n\\t\\t\\tthis.close_stream(options.stdio[i]);\\n\\t\\t}\\n\\t}\\n\\n\\tthis.pid = pid;\\n\\tthis.exit_cb = options.exit_cb;\\n\\n\\tif (!spawn_error){\\n\\t\\tthis.child_watcher = setInterval(function(){\\n\\t\\t\\tvar t = syscall.waitpid(pid, status, SYS.WNOHANG);\\n\\t\\t\\tif (t === pid){\\n\\t\\t\\t\\tvar s = status.int;\\n\\t\\t\\t\\tvar exitcode = 0;\\n\\t\\t\\t\\tvar termsignal = 0;\\n\\n\\t\\t\\t\\tif (syscall.WIFEXITED(s)){\\n\\t\\t\\t\\t\\texitcode = syscall.WEXITSTATUS(s);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttermsignal = syscall.WTERMSIG(s);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (self.exit_signal){\\n\\t\\t\\t\\t\\ttermsignal = self.exit_signal;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tclearInterval(this);\\n\\t\\t\\t\\tself.child_watcher = null;\\n\\n\\t\\t\\t\\tif (self.exit_cb) self.exit_cb.call(self, exitcode, termsignal);\\n\\t\\t\\t}\\n\\t\\t}, 1);\\n\\t}\\n\\n\\tif (spawn_error) {\\n\\t\\tthis.errno = errno.translate(spawn_error);\\n\\t}\\n\\treturn this;\\n}\\n\\n\\nProcess.prototype.unref = function(){\\n\\tif (this.child_watcher){\\n\\t\\tthis.child_watcher.unref();\\n\\t}\\n\\treturn 0;\\n};\\n\\n\\nProcess.prototype.open_stream = function (container, pipefds, writable) {\\n\\tvar flags = 0;\\n\\n\\tif (!(container.flags & uv.CREATE_PIPE) || pipefds[0] < 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tif (uv.close(pipefds[1]) === null){\\n\\t\\tthrow new Error('closing pipe fd ' + pipefds[1]);\\n\\t}\\n\\n\\tpipefds[1] = -1;\\n\\tuv.nonblock(pipefds[0], 1);\\n\\n\\tif (container.stream.type === 'NAMED_PIPE' && container.stream.ipc ) {\\n\\t\\tflags = uv.STREAM_READABLE | uv.STREAM_WRITABLE;\\n\\t}\\n\\n\\telse if (writable) {\\n\\t\\tflags = uv.STREAM_WRITABLE;\\n\\t}\\n\\n\\telse {\\n\\t\\tflags = uv.STREAM_READABLE;\\n\\t}\\n\\n\\treturn container.stream.stream_open(pipefds[0], flags);\\n};\\n\\n\\n// constructs a utf16 buffer of environment\\n// variables block, windows require each env to be\\n// seperated with 1 nul and ends with 2 nul charachters\\nfunction set_env_block(env){\\n\\tif (!env){\\n\\t\\treturn;\\n\\t}\\n\\n\\tvar envBlock = process.env;\\n\\n\\t//extend\\n\\tfor (var key in envBlock){\\n\\t\\tenv.unshift(key + '=' + envBlock[key]);\\n\\t}\\n\\n\\tvar len = env.length;\\n\\n\\tvar n = \\\"\\\";\\n\\tfor (var i = 0; i < len; i++){\\n\\t\\tassert(syscall.putenv(env[i]) !== null);\\n\\t}\\n\\treturn;\\n}\\n\\n\\nProcess.prototype.kill = function(signum){\\n\\tvar process = this;\\n\\tvar err;\\n\\n\\tif (process.process_handle == -1) {\\n\\t\\treturn errno.EINVAL;\\n\\t}\\n\\n\\terr = uv.kill(process.pid, signum);\\n\\tif (err) return err;  /* err is already translated. */\\n\\tprocess.exit_signal = signum;\\n\\treturn 0;\\n};\\n\\n\\nProcess.prototype.close = function(cb){\\n\\tvar self = this;\\n\\t//clear child watcher interval\\n\\tif (this.child_watcher){\\n\\t\\tclearInterval(this.child_watcher);\\n\\t}\\n};\\n\\nmodule.exports = Process;\\n\",\"uv/tty\":\"var util     = require(\\\"util\\\");\\nvar stream   = require('uv/stream');\\nvar uv       = require('uv');\\n\\nutil.inherits(TTY, stream);\\nfunction TTY (){\\n\\tif (uv.isWin) require('uv/tty/windows').apply(this, arguments);\\n\\telse require('uv/tty/linux').apply(this, arguments);\\n}\\n\\nmodule.exports = TTY;\\n\",\"uv/tty/windows\":\"var uv      = require('uv');\\nvar syscall = require('syscall');\\nvar C       = require('C');\\nvar ansi    = require('uv/tty/ansi');\\n\\nvar kernel  = syscall.LoadLibrary('kernel32');\\nvar CreateEvent = kernel.GetProcAddress('CreateEventW', null, 4);\\nvar WaitForSingleObject = kernel.GetProcAddress('WaitForSingleObject', undefined, 2);\\nvar SetConsoleMode    = kernel.GetProcAddress('SetConsoleMode', 0, 2);\\nvar ReadConsoleInput  = kernel.GetProcAddress('ReadConsoleInputW', 0, 4);\\nvar WriteConsole      = kernel.GetProcAddress('WriteConsoleW', 0, 5);\\nvar ReadConsole       = kernel.GetProcAddress('ReadConsoleW', 0, 5);\\n\\nvar WORD   = 'uint16';\\nvar DWORD  = 'uint32';\\nvar WCHAR  = 2;\\nvar CHAR   = 1;\\nvar UINT   = 'uint32';\\nvar BOOL   = 'int';\\n\\n\\nvar COORD = C.struct({\\n\\tX : 'int16',\\n\\tY : 'int16'\\n});\\n\\n\\nvar FOCUS_EVENT_RECORD = C.struct({\\n\\tbSetFocus : BOOL\\n});\\n\\n\\nvar MOUSE_EVENT_RECORD =  C.struct({\\n\\tdwMousePosition   : COORD,\\n\\tdwButtonState     : DWORD,\\n\\tdwControlKeyState : DWORD,\\n\\tdwEventFlags      : DWORD\\n});\\n\\n\\nvar WINDOW_BUFFER_SIZE_RECORD =  C.struct({\\n\\tdwSize : COORD\\n});\\n\\n\\nvar MENU_EVENT_RECORD = C.struct({\\n\\tdwCommandId : UINT\\n});\\n\\n\\nvar KEY_EVENT_RECORD = C.struct({\\n\\tbKeyDown : BOOL,\\n\\twRepeatCount : WORD,\\n\\twVirtualKeyCode : WORD,\\n\\twVirtualScanCode : WORD,\\n\\tuChar : C.union ({\\n\\t\\tUnicodeChar : WCHAR,\\n\\t\\tAsciiChar : CHAR\\n\\t}),\\n\\tdwControlKeyState : DWORD\\n});\\n\\n\\nvar INPUT_RECORD = C.struct({\\n\\tEventType : WORD,\\n\\t__pad : 2, // FIXME : padding on x64!!\\n\\tEvent : C.union ({\\n\\t\\tKeyEvent : KEY_EVENT_RECORD,\\n\\t\\tMouseEvent : MOUSE_EVENT_RECORD,\\n\\t\\tWindowBufferSizeEvent : WINDOW_BUFFER_SIZE_RECORD,\\n\\t\\tMenuEvent  : MENU_EVENT_RECORD,\\n\\t\\tFocusEvent : FOCUS_EVENT_RECORD\\n\\t})\\n});\\n\\n\\nvar rDone = new C.void( C.sizeOf.uint32 );\\nvar irec  = new INPUT_RECORD();\\n\\nvar ENHANCED_KEY  = 256;\\nvar KEY_LEFT      = 37;\\nvar KEY_UP        = 38;\\nvar KEY_DOWN      = 40;\\nvar KEY_RIGHT     = 39;\\nvar KEY_HOME      = 36;\\nvar KEY_END       = 35;\\nvar KEY_DEL       = 46;\\n\\nmodule.exports = function (fd, readable){\\n\\tvar self = this;\\n\\tthis.fd = fd;\\n\\tthis.fdHandle = syscall.GetFdHandle(fd);\\n\\n\\tif (readable){\\n\\t\\tthis.readable = true;\\n\\t}\\n};\\n\\n\\nuv.TTY.prototype.read_start = function(cb){\\n\\tvar self = this;\\n\\tthis._doread = true;\\n\\tthis.read_cb = cb;\\n\\tif (!this.readable) return;\\n\\tif (this.timer) clearInterval(this.timer);\\n\\tself.timer = setInterval(function(){\\n\\t\\twhile (self._doread){\\n\\t\\t\\tvar t = WaitForSingleObject(self.fdHandle, 0);\\n\\t\\t\\tif (t === 0){\\n\\t\\t\\t\\tif (self.mode !== 1){\\n\\t\\t\\t\\t\\tvar b = new Buffer(16 * 1024);\\n\\t\\t\\t\\t\\tvar n = ReadConsole(self.fdHandle, b, 8 * 1024, rDone, null);\\n\\t\\t\\t\\t\\tself.read_cb(0, b.toString('ucs2').slice(0, rDone.uint32));\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (ReadConsoleInput (self.fdHandle, irec, 1, rDone) === null) {\\n\\t\\t\\t\\t\\tself.read_cb(process.errno);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar ev = irec.Event.KeyEvent;\\n\\t\\t\\t\\tvar b = '';\\n\\t\\t\\t\\tif (irec.EventType === 1 && ev.bKeyDown){\\n\\t\\t\\t\\t\\tif (ev.dwControlKeyState & ENHANCED_KEY) {\\n\\t\\t\\t\\t\\t\\tb = '\\\\u001b';\\n\\t\\t\\t\\t\\t\\tswitch(ev.wVirtualKeyCode) {\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_DOWN  : b += '[B';  break;\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_UP    : b += '[A';  break;\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_RIGHT : b += '[C';  break;\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_LEFT  : b += '[D';  break;\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_HOME  : b += '[H';  break;\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_END   : b += '[F';  break;\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_DEL   : b += '[3~'; break;\\n\\t\\t\\t\\t\\t\\t\\t// default : throw new Error(\\\"unknown key type \\\" + ev.wVirtualKeyCode);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tself.read_cb(0, Buffer(b));\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif(\\tev.uChar.UnicodeChar[0] === 0) {\\n\\t\\t\\t\\t\\t\\t\\t// console.log(ev.wVirtualKeyCode);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tb = ev.uChar.UnicodeChar;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tself.read_cb(0, Buffer(b).toString('ucs2'));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}, 10);\\n};\\n\\n\\nuv.TTY.prototype.read_stop = function(cb){\\n\\tthis._doread = false;\\n\\tif (this.timer) clearInterval(this.timer);\\n\\tthis.timer = false;\\n};\\n\\n\\nuv.TTY.prototype.write = function(data){\\n\\tansi.write(this.fdHandle, data);\\n};\\n\\n\\nuv.TTY.prototype.close = function(cb){\\n\\tthis._doread = false;\\n\\tif (this.timer) clearInterval(this.timer);\\n\\tthis.timer = false;\\n};\\n\\n\\nuv.TTY.prototype.get_winsize = function(){\\n\\tvar info = new ansi.CONSOLE_SCREEN_BUFFER_INFO();\\n\\tif (ansi.GetConsoleScreenBufferInfo(this.fdHandle, info) === null){\\n\\t\\tthrow new Error(\\\"GetConsoleScreenBufferInfo \\\" + process.errno);\\n\\t}\\n\\tvar cols = info.srWindow.Right - info.srWindow.Left + 1;\\n\\tvar rows = info.srWindow.Bottom - info.srWindow.Top + 1;\\n\\treturn {\\n\\t\\twidth  : cols,\\n\\t\\theight : rows\\n\\t};\\n};\\n\\n\\nuv.TTY.prototype.set_mode = function(mode){\\n\\tif (this.mode === mode) return;\\n\\tthis.mode = mode;\\n\\tvar flags = 0;\\n\\tif (mode){\\n\\t\\tflags = 0x0008;\\n\\t} else {\\n\\t\\tflags = 0x0004 | 0x0002 | 0x0001;\\n\\t}\\n\\tSetConsoleMode(this.fdHandle, flags);\\n};\\n\",\"uv/tty/ansi\":\"var C       = require('C');\\nvar syscall = require('syscall');\\nvar kernel  = syscall.LoadLibrary('kernel32');\\n\\n\\n{\\t// color codes\\n\\tconst FOREGROUND_BLUE       = 0x0001; // text color contains blue.\\n\\tconst FOREGROUND_GREEN      = 0x0002; // text color contains green.\\n\\tconst FOREGROUND_RED        = 0x0004; // text color contains red.\\n\\tconst FOREGROUND_INTENSITY  = 0x0008; // text color is intensified.\\n\\tconst BACKGROUND_BLUE       = 0x0010; // background color contains blue.\\n\\tconst BACKGROUND_GREEN      = 0x0020; // background color contains green.\\n\\tconst BACKGROUND_RED        = 0x0040; // background color contains red.\\n\\tconst BACKGROUND_INTENSITY  = 0x0080; // background color is intensified.\\n\\n\\t// masks\\n\\tconst FOREGROUND_MASK       = (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);\\n\\tconst BACKGROUND_MASK       = (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY);\\n\\n\\t// extended colors\\n\\tconst FOREGROUND_WHITE\\t    = (FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN);\\n\\tconst FOREGROUND_YELLOW     = (FOREGROUND_RED | FOREGROUND_GREEN);\\n\\n\\tconst FOREGROUND_CYAN\\t\\t= (FOREGROUND_BLUE | FOREGROUND_GREEN);\\n\\tconst FOREGROUND_MAGENTA\\t= (FOREGROUND_RED | FOREGROUND_BLUE);\\n\\n\\tconst BACKGROUND_WHITE     = (BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_GREEN);\\n\\tconst BACKGROUND_YELLOW\\t   = (BACKGROUND_RED | BACKGROUND_GREEN);\\n\\tconst BACKGROUND_CYAN      = (BACKGROUND_BLUE | BACKGROUND_GREEN);\\n\\tconst BACKGROUND_MAGENTA   = (BACKGROUND_RED | BACKGROUND_BLUE);\\n\\n\\tconst FOREGROUND_BLACK     = 0;\\n\\tconst BACKGROUND_BLACK     = 0;\\n}\\n\\n\\nvar WORD = 'uint16';\\n\\nvar COORD = C.struct({\\n\\tX : 'int16',\\n\\tY : 'int16'\\n});\\n\\nvar SMALL_RECT = C.struct({\\n\\tLeft   : 'int16',\\n\\tTop    : 'int16',\\n\\tRight  : 'int16',\\n\\tBottom : 'int16'\\n});\\n\\nvar CONSOLE_SCREEN_BUFFER_INFO = C.struct({\\n\\tdwSize              : COORD,\\n\\tdwCursorPosition    : COORD,\\n\\twAttributes         : WORD,\\n\\tsrWindow            : SMALL_RECT,\\n\\tdwMaximumWindowSize : COORD\\n});\\n\\n\\nvar CHAR_INFO = C.struct({\\n\\tUnicodeChar : 2, //size of WCHAR!!\\n\\tAttributes  : WORD\\n});\\n\\n\\nvar info = new CONSOLE_SCREEN_BUFFER_INFO();\\n\\nvar FillConsoleOutputAttribute = kernel.GetProcAddress('FillConsoleOutputAttribute', 0, 5);\\nvar GetConsoleScreenBufferInfo = kernel.GetProcAddress('GetConsoleScreenBufferInfo', 0, 2);\\nvar FillConsoleOutputCharacter = kernel.GetProcAddress('FillConsoleOutputCharacterW', 0, 5);\\nvar ScrollConsoleScreenBuffer  = kernel.GetProcAddress('ScrollConsoleScreenBufferW', 0, 5);\\nvar SetConsoleTextAttribute    = kernel.GetProcAddress('SetConsoleTextAttribute', 0, 2);\\nvar SetConsoleCursorPosition   = kernel.GetProcAddress('SetConsoleCursorPosition', 0, 2);\\nvar GetConsoleCursorInfo       = kernel.GetProcAddress('GetConsoleCursorInfo', 0, 2);\\nvar SetConsoleCursorInfo       = kernel.GetProcAddress('SetConsoleCursorInfo', 0, 2);\\n\\nvar WriteConsole               = kernel.GetProcAddress('WriteConsoleW', 0, 5);\\n\\n\\nGetConsoleScreenBufferInfo(syscall.Stdout, info);\\nvar oldattr = info.wAttributes;\\n\\nfunction _splitArgs (str){\\n\\treturn str.split(';');\\n}\\n\\nvar numberOfWritten = new C.void( C.sizeOf.uint32 );\\nvar translateAnsiActions = {};\\nvar empty     = new Buffer(\\\" \\\\0\\\", 'ucs2');\\nvar CHAR_BUFF = new Buffer(' ', 'ucs2');\\n\\n// ESC[#J\\ntranslateAnsiActions.J   = function(args, cHandle, info, pos){\\n\\tvar len = 0;\\n\\t// ESC[0J Erase from the cursor to the end of the screen.\\n\\tif (args[0] == 0){\\n\\t\\tpos.X = info.dwCursorPosition.X;\\n\\t\\tpos.Y = info.dwCursorPosition.Y;\\n\\n\\t\\tlen = (info.dwSize.Y - info.dwCursorPosition.Y - 1) * info.dwSize.X\\n\\t\\t\\t+ info.dwSize.X - info.dwCursorPosition.X - 1;\\n\\n\\t\\tFillConsoleOutputCharacter( cHandle, C.address(empty), len, C.address(pos), numberOfWritten );\\n\\t\\tFillConsoleOutputAttribute( cHandle, info.wAttributes, len, C.address(pos), numberOfWritten );\\n\\t}\\n\\t// ESC[1J erase from start to cursor.\\n\\telse if (args[0] == 1){\\n\\t\\tpos.X = 0;\\n\\t\\tpos.Y = 0;\\n\\t\\tlen   = info.dwCursorPosition.Y * info.dwSize.X\\n\\t\\t\\t+ info.dwCursorPosition.X + 1;\\n\\n\\t\\tFillConsoleOutputCharacter( cHandle, C.address(empty), len, C.address(pos), numberOfWritten );\\n\\t\\tFillConsoleOutputAttribute( cHandle, info.wAttributes, len, C.address(pos), numberOfWritten );\\n\\t}\\n\\t// ESC[2J \\tclear screen and home cursor\\n\\telse if (args[0] == 2){\\n\\t\\tpos.X = 0;\\n\\t\\tpos.Y = 0;\\n\\t\\tlen   = info.dwSize.X * info.dwSize.Y;\\n\\n\\t\\tFillConsoleOutputCharacter( cHandle, C.address(empty), len, C.address(pos), numberOfWritten );\\n\\t\\tFillConsoleOutputAttribute( cHandle, info.wAttributes, len, C.address(pos), numberOfWritten );\\n\\t\\tSetConsoleCursorPosition( cHandle,  C.address(pos));\\n\\t}\\n};\\n\\n\\n// ESC[#X Erase # characters.\\ntranslateAnsiActions.X = function(args, cHandle, info, pos){\\n\\tvar val = (args[0] | 0) || 1;\\n\\tFillConsoleOutputCharacter( cHandle, C.address(empty), val,\\n\\t\\tC.address(info.dwCursorPosition),\\n\\t\\tnumberOfWritten );\\n\\n\\tFillConsoleOutputAttribute( cHandle, info.wAttributes, val,\\n\\t\\tC.address(info.dwCursorPosition),\\n\\t\\tnumberOfWritten );\\n};\\n\\n\\n// ESC[#L Insert # blank lines.\\ntranslateAnsiActions.L = function(args, cHandle, info, pos){\\n\\tvar val = (args[0] | 0) || 1;\\n\\tvar Rect = new SMALL_RECT();\\n\\tvar CharInfo = new CHAR_INFO();\\n\\n\\tRect.Left   = 0;\\n\\tRect.Top    = info.dwCursorPosition.Y;\\n\\tRect.Right  = info.dwSize.X - 1;\\n\\tRect.Bottom = info.dwSize.Y - 1;\\n\\n\\tpos.X = 0;\\n\\tpos.Y = info.dwCursorPosition.Y + val;\\n\\n\\tCharInfo.UnicodeChar = CHAR_BUFF;\\n\\tCharInfo.Attributes  = info.wAttributes;\\n\\tScrollConsoleScreenBuffer( cHandle, Rect, null, C.address(pos), CharInfo );\\n};\\n\\n// ESC[#M Delete # lines.\\ntranslateAnsiActions.M = function(args, cHandle, info, pos){\\n\\tvar val = (args[0] | 0) || 1;\\n\\tvar Rect = new SMALL_RECT();\\n\\tvar CharInfo = new CHAR_INFO();\\n\\n\\tif (val > info.dwSize.Y - info.dwCursorPosition.Y) {\\n\\t\\tval = info.dwSize.Y - info.dwCursorPosition.Y;\\n\\t}\\n\\n\\tRect.Left   = 0;\\n\\tRect.Top    = info.dwCursorPosition.Y + val;\\n\\tRect.Right  = info.dwSize.X - 1;\\n\\tRect.Bottom = info.dwSize.Y - 1;\\n\\n\\tpos.X = 0;\\n\\tpos.Y = info.dwCursorPosition.Y;\\n\\n\\tCharInfo.UnicodeChar = CHAR_BUFF;\\n\\tCharInfo.Attributes  = info.wAttributes;\\n\\tScrollConsoleScreenBuffer( cHandle, Rect, null, C.address(pos), CharInfo );\\n};\\n\\n\\n// ESC[#P Delete # characters.\\ntranslateAnsiActions.P = function(args, cHandle, info, pos){\\n\\tvar val = (args[0] | 0) || 1;\\n\\tvar Rect = new SMALL_RECT();\\n\\tvar CharInfo = new CHAR_INFO();\\n\\n\\tif (info.dwCursorPosition.X + val > info.dwSize.X - 1) {\\n\\t\\tval = info.dwSize.X - info.dwCursorPosition.X;\\n\\t}\\n\\n\\tRect.Left   = info.dwCursorPosition.X + val;\\n\\tRect.Top    = info.dwCursorPosition.Y;\\n\\tRect.Right  = info.dwSize.X - 1;\\n\\tRect.Bottom = info.dwCursorPosition.Y;\\n\\n\\tCharInfo.UnicodeChar = CHAR_BUFF;\\n\\tCharInfo.Attributes  = info.wAttributes;\\n\\tScrollConsoleScreenBuffer( cHandle, Rect, null, info.dwCursorPosition, CharInfo );\\n};\\n\\n\\n // ESC[#@ Insert # blank characters.\\ntranslateAnsiActions['@'] = function(args, cHandle, info, pos){\\n\\tvar val = (args[0] | 0) || 1;\\n\\tvar Rect = new SMALL_RECT();\\n\\tvar CharInfo = new CHAR_INFO();\\n\\n\\tif (info.dwCursorPosition.X + val > info.dwSize.X - 1) {\\n\\t\\tval = info.dwSize.X - info.dwCursorPosition.X;\\n\\t}\\n\\n\\tRect.Left   = info.dwCursorPosition.X;\\n\\tRect.Top    = info.dwCursorPosition.Y;\\n\\tRect.Right  = info.dwSize.X - 1 - val;\\n\\tRect.Bottom = info.dwCursorPosition.Y;\\n\\n\\tpos.X = info.dwCursorPosition.X + val;\\n\\tpos.Y = info.dwCursorPosition.Y;\\n\\n\\tCharInfo.UnicodeChar = CHAR_BUFF;\\n\\tCharInfo.Attributes = info.wAttributes;\\n\\tScrollConsoleScreenBuffer( cHandle, Rect, null, C.address(pos), CharInfo );\\n};\\n\\n\\n// ESC[#A\\n// ESC[#k  - Moves cursor up # lines\\ntranslateAnsiActions.A =\\ntranslateAnsiActions.k = function(args, cHandle, info, pos){\\n\\tvar val = (args[0] | 0) || 1;\\n\\tpos.Y = info.dwCursorPosition.Y - val;\\n\\tif (pos.Y < 0) pos.Y = 0;\\n\\tpos.X = info.dwCursorPosition.X;\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\n};\\n\\n\\n// ESC[#B\\n// ESC[#e Moves cursor down # lines\\ntranslateAnsiActions.B =\\ntranslateAnsiActions.e = function(args, cHandle, info, pos){\\n\\tvar val = (args[0] | 0) || 1;\\n\\tpos.Y = info.dwCursorPosition.Y + val;\\n\\tif (pos.Y >= info.dwSize.Y) pos.Y = info.dwSize.Y - 1;\\n\\tpos.X = info.dwCursorPosition.X;\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\n};\\n\\n\\n\\n// ESC[#C\\n// ESC[#a Moves cursor forward # spaces\\ntranslateAnsiActions.C =\\ntranslateAnsiActions.a = function(args, cHandle, info, pos){\\n\\tvar val = (args[0] | 0) || 1;\\n\\tpos.X = info.dwCursorPosition.X + val;\\n\\tif (pos.X >= info.dwSize.X) pos.X = info.dwSize.X - 1;\\n\\tpos.Y = info.dwCursorPosition.Y;\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\n};\\n\\n\\n// ESC[#j\\n// ESC[#D Moves cursor back # spaces\\ntranslateAnsiActions.D =\\ntranslateAnsiActions.j = function(args, cHandle, info, pos){\\n\\tvar val = (args[0] | 0) || 1;\\n\\tpos.X = info.dwCursorPosition.X - val;\\n\\tif (pos.X < 0) pos.X = 0;\\n\\tpos.Y = info.dwCursorPosition.Y;\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\n};\\n\\n\\n\\n// ESC[#E Moves cursor down # lines, column 1.\\ntranslateAnsiActions.E = function(args, cHandle, info, pos){\\n\\tvar val = (args[0] | 0) || 1;\\n\\tpos.Y = info.dwCursorPosition.Y + val;\\n\\tif (pos.Y >= info.dwSize.Y) pos.Y = info.dwSize.Y - 1;\\n\\tpos.X = 0;\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\n};\\n\\n\\n// ESC[#F Moves cursor up # lines, column 1.\\ntranslateAnsiActions.F = function(args, cHandle, info, pos){\\n\\tvar val = (args[0] | 0) || 1;\\n\\tpos.Y = info.dwCursorPosition.Y - val;\\n\\tif (pos.Y < 0) pos.Y = 0;\\n\\tpos.X = 0;\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\n};\\n\\n\\n// ESC[#`\\n// ESC[#G Moves cursor column # in current row.\\ntranslateAnsiActions.G    =\\ntranslateAnsiActions['`'] = function(args, cHandle, info, pos){\\n\\tvar val = (args[0] | 0) || 1;\\n\\tpos.X = val - 1;\\n\\tif (pos.X >= info.dwSize.X) pos.X = info.dwSize.X - 1;\\n\\tif (pos.X < 0) pos.X = 0;\\n\\tpos.Y = info.dwCursorPosition.Y;\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\n};\\n\\n\\n// ESC[#d Moves cursor row #, current column.\\ntranslateAnsiActions.d = function(args, cHandle, info, pos){\\n\\tvar val  = (args[0] | 0) || 1;\\n\\tpos.Y = val - 1;\\n\\tif (pos.Y < 0) pos.Y = 0;\\n\\tif (pos.Y >= info.dwSize.Y) pos.Y = info.dwSize.Y - 1;\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\n};\\n\\n\\n// ESC[#;#f\\n// ESC[#;#H Moves cursor to line #, column #\\ntranslateAnsiActions.f =\\ntranslateAnsiActions.H = function(args, cHandle, info, pos){\\n\\tvar val  = (args[0] | 0) || 1;\\n\\tvar val2 = (args[1] | 0) || 1;\\n\\n\\tif (args.length > 2) return;\\n\\tpos.X = val2 - 1;\\n\\tif (pos.X < 0) pos.X = 0;\\n\\tif (pos.X >= info.dwSize.X) pos.X = info.dwSize.X - 1;\\n\\tpos.Y = val - 1;\\n\\tif (pos.Y < 0) pos.Y = 0;\\n\\tif (pos.Y >= info.dwSize.Y) pos.Y = info.dwSize.Y - 1;\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\n};\\n\\n\\n// ESC[s Saves cursor position for recall later\\nvar SavePos = new COORD();\\ntranslateAnsiActions.s = function(args, cHandle, info, pos){\\n\\tSavePos.X = info.dwCursorPosition.X;\\n\\tSavePos.Y = info.dwCursorPosition.Y;\\n};\\n\\n\\n// ESC[u Return to saved cursor position\\ntranslateAnsiActions.u = function(args, cHandle, info, pos){\\n\\tSetConsoleCursorPosition( cHandle, C.address(SavePos) );\\n};\\n\\n\\ntranslateAnsiActions.m   = function(args, cHandle, info, pos){\\n\\tfor (var i = 0; i < args.length; i++){\\n\\t\\tvar val = args[i] | 0;\\n\\t\\tvar attr = info.wAttributes;\\n\\t\\tif (val === 0){\\n\\t\\t\\tSetConsoleTextAttribute(cHandle, oldattr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// forground color\\n\\t\\tif (val >= 30 && val <= 37){\\n\\t\\t\\tattr = (attr & BACKGROUND_MASK);\\n\\t\\t\\tif ( ((val - 30) & 1) !== 0 ){\\n\\t\\t\\t\\tattr |= FOREGROUND_RED;\\n\\t\\t\\t}\\n\\t\\t\\tif ( ((val - 30) & 2) !== 0 ){\\n\\t\\t\\t\\tattr |= FOREGROUND_GREEN;\\n\\t\\t\\t}\\n\\t\\t\\tif ( ((val - 30) & 4) !== 0 ) {\\n\\t\\t\\t\\tattr |= FOREGROUND_BLUE;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// reset forground color\\n\\t\\telse if (val === 39){\\n\\t\\t\\tattr &= BACKGROUND_MASK;\\n\\t\\t\\tattr |= oldattr & FOREGROUND_MASK;\\n\\t\\t}\\n\\t\\t// background color\\n\\t\\telse if (val >= 40 && val <= 47){\\n\\t\\t\\tattr = (attr & FOREGROUND_MASK)\\n\\t\\t\\tif ( ((val - 40) & 1) !== 0 ) {\\n\\t\\t\\t\\tattr |= BACKGROUND_GREEN;\\n\\t\\t\\t}\\n\\t\\t\\tif ( ((val - 40) & 2 ) !== 0 ) {\\n\\t\\t\\t\\tattr |= BACKGROUND_GREEN;\\n\\t\\t\\t}\\n\\t\\t\\tif ( ((val - 40) & 4 ) !== 0 ) {\\n\\t\\t\\t\\tattr |= BACKGROUND_BLUE;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// reset background\\n\\t\\telse if (val === 49){\\n\\t\\t\\tattr &= FOREGROUND_MASK;\\n\\t\\t\\tattr |= w.oldattr & BACKGROUND_MASK;\\n\\t\\t}\\n\\t\\tSetConsoleTextAttribute(cHandle, attr);\\n\\t}\\n};\\n\\n\\nfunction _write_string (cHandle, str){\\n\\tvar utf16Buffer = new Buffer(str + '\\\\0', 'ucs2');\\n\\tvar ret = WriteConsole(cHandle, utf16Buffer, str.length, numberOfWritten, null);\\n\\tif (ret === null){\\n\\t\\tthrow new Error(process.errno);\\n\\t}\\n}\\n\\n\\nvar coord = new COORD();\\nvar ansiParserRegex = /([\\\\s\\\\S]*?)\\\\x1b\\\\[([\\\\s\\\\S]*?)([\\\\?|\\\\`|\\\\@|a-zA-Z])/g;\\nfunction write (stdHandle, str){\\n\\tvar match;\\n\\tvar matched = 0;\\n\\twhile (match = ansiParserRegex.exec(str)) {\\n\\t\\tmatched += match[0].length;\\n\\t\\tvar stringToWrite = match[1];\\n\\t\\tvar suffix        = match[3];\\n\\t\\tif (stringToWrite) {\\n\\t\\t\\t_write_string(stdHandle, stringToWrite);\\n\\t\\t};\\n\\n\\t\\tif (translateAnsiActions[suffix]){\\n\\t\\t\\t// get current screen buffer info and pass it\\n\\t\\t\\t// to translateansi action we need to use it\\n\\t\\t\\tif (GetConsoleScreenBufferInfo(stdHandle, info) === null){\\n\\t\\t\\t\\tthrow new Error(\\\"can't get console buffer info\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar args = _splitArgs(match[2]);\\n\\t\\t\\ttranslateAnsiActions[suffix]( args,\\n\\t\\t\\t\\tstdHandle /* console handle */,\\n\\t\\t\\t\\tinfo, /* console buffer info */\\n\\t\\t\\t\\tcoord /* coord struct for position */);\\n\\t\\t}\\n\\t}\\n\\n\\t// nothing matched at all, the whole string\\n\\t// doesn't contain ansi escape sequence\\n\\tif (!matched){\\n\\t\\t_write_string(stdHandle, str);\\n\\t} else {\\n\\t\\t// matched but normal string left without\\n\\t\\t// writing at the end\\n\\t\\tif (str.length > matched){\\n\\t\\t\\t_write_string(stdHandle, str.slice(matched, str.length));\\n\\t\\t}\\n\\t}\\n}\\n\\nexports.write = write;\\n\\n// TODO move all structs and win API functions to syscall\\nexports.GetConsoleScreenBufferInfo = GetConsoleScreenBufferInfo;\\nexports.CONSOLE_SCREEN_BUFFER_INFO = CONSOLE_SCREEN_BUFFER_INFO;\\n\",\"uv/tty/linux\":\"var uv       = require('uv');\\nvar posix    = process.binding('posix');\\nvar stream   = require('uv/stream');\\nvar syscall  = require('syscall');\\nvar C        = require('C');\\nvar sock     = require('socket');\\n\\nvar libc       = syscall.LoadLibrary(null);\\nvar tcsetattr  = libc.GetProcAddress('tcsetattr', -1, 3);\\nvar tcgetattr  = libc.GetProcAddress('tcgetattr', -1, 2);\\nvar cfmakeraw  = libc.GetProcAddress('cfmakeraw', -1, 1);\\n\\nconst IGNBRK  = 0000001;\\nconst BRKINT  = 0000002;\\nconst IGNPAR  = 0000004;\\nconst PARMRK  = 0000010;\\nconst INPCK   = 0000020;\\nconst ISTRIP  = 0000040;\\nconst INLCR   = 0000100;\\nconst IGNCR   = 0000200;\\nconst ICRNL   = 0000400;\\nconst IUCLC   = 0001000;\\nconst IXON    = 0002000;\\nconst IXANY   = 0004000;\\nconst IXOFF   = 0010000;\\nconst IMAXBEL = 0020000;\\nconst IUTF8   = 0040000;\\n\\nconst TCSANOW   = 0;\\nconst TCSADRAIN = 1;\\nconst TCSAFLUSH = 2;\\n\\nvar orig_termios_fd = -1;\\nvar orig_termios;\\n\\nvar termios = C.struct({\\n\\tc_iflag    : 'uint',\\n\\tc_oflag    : 'uint',\\n\\tc_cflag    : 'uint',\\n\\tc_lflag    : 'uint',\\n\\tc_line     : 'uint8',\\n\\tc_cc       : 32,\\n\\t__c_ispeed : 'uint',\\n\\t__c_ospeed : 'uint'\\n});\\n\\n\\nmodule.exports = function (fd, readable){\\n\\tvar self = this;\\n\\n\\tvar newfd = uv.open(\\\"/dev/tty\\\", uv.O_RDWR);\\n\\tvar r = posix.dup2(newfd, fd);\\n\\tif (r === null && process.errno !== errno.EINVAL){\\n\\t\\tuv.close(newfd);\\n\\t\\treturn process.errno;\\n\\t}\\n\\tthis.fd = r;\\n\\tuv.nonblock(this.fd, 1);\\n\\tuv.cloexec(this.fd, 1);\\n\\tif (readable){\\n\\t\\tthis.readable = true;\\n\\t}\\n};\\n\\n\\nuv.TTY.prototype.read_start = function(cb){\\n\\tvar self = this;\\n\\tthis._doread = true;\\n\\tthis.read_cb = cb;\\n\\tif (!this.readable) return;\\n\\tif (this.timer) clearInterval(this.timer);\\n\\n\\tvar b = Buffer(10);\\n\\tself.timer = setInterval(function(){\\n\\t\\twhile (self._doread){\\n\\t\\t\\tvar n = sock.can_read(self.fd, 1);\\n\\t\\t\\tif (n){\\n\\t\\t\\t\\tvar n = posix.read(self.fd, b);\\n\\t\\t\\t\\tself.read_cb(0, b.toString().slice(0, n));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}, 1);\\n};\\n\\n\\nuv.TTY.prototype.read_stop = function(cb){\\n\\tthis._doread = false;\\n\\tif (this.timer) clearInterval(this.timer);\\n\\tthis.timer = false;\\n};\\n\\n\\nuv.TTY.prototype.write = function(data){\\n\\tposix.writeBuffer(this.fd, Buffer(data));\\n};\\n\\n\\nuv.TTY.prototype.stop = function(){\\n\\tthrow new Error('win tty stop');\\n};\\n\\nuv.TTY.prototype.close = function(cb){\\n\\tthis._doread = false;\\n\\tif (this.timer) clearInterval(this.timer);\\n\\tthis.timer = false;\\n};\\n\\nuv.TTY.prototype.get_winsize = function(){\\n\\tvar fd = this.fd;\\n\\tvar ws = new syscall.WinSize();\\n\\tif (syscall.ioctl(fd, syscall.SYS.TIOCGWINSZ, ws) === null){\\n\\t\\treturn null;\\n\\t}\\n\\treturn {\\n\\t\\twidth  :  ws.ws_col,\\n\\t\\theight :  ws.ws_row\\n\\t}\\n};\\n\\n\\nuv.TTY.prototype.set_mode = function(mode){\\n\\tif (this.mode === mode) return;\\n\\tthis.mode = mode;\\n\\n\\tif (!this.orig_termios){\\n\\t\\tthis.orig_termios = new termios();\\n\\t\\tif (tcgetattr(this.fd, this.orig_termios) === null){\\n\\t\\t\\tthrow new Error(process.errno);\\n\\t\\t}\\n\\n\\t\\tif (!orig_termios){\\n\\t\\t\\torig_termios_fd = this.fd;\\n\\t\\t\\torig_termios = new termios(this.orig_termios);\\n\\t\\t}\\n\\t}\\n\\n\\tvar temp = new termios(this.orig_termios);\\n\\n\\tif (mode){\\n\\t\\ttemp.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\\n\\t\\ttemp.c_oflag |= (0000004);\\n\\t\\ttemp.c_cflag |= (0000060);\\n\\t\\ttemp.c_lflag &= ~(0000010 | 0000002 | 0100000 | 0000001);\\n\\t\\ttemp.c_cc[6] = 1;\\n\\t\\ttemp.c_cc[5] = 0;\\n\\t}\\n\\n\\tif (tcsetattr(this.fd, TCSADRAIN, temp) === null) {\\n\\t\\tthrow new Error('cant set raw');\\n\\t}\\n\\n\\treturn 0;\\n};\\n\\n\\nprocess.on('exit', function(){\\n\\tif (orig_termios_fd !== -1){\\n\\t\\ttcsetattr(orig_termios_fd, TCSANOW, orig_termios);\\n\\t}\\n});\\n\",\"internal/util\":\"'use strict';\\n\\nvar prefix = '(node) ';\\n\\n// All the internal deprecations have to use this function only, as this will\\n// prepend the prefix to the actual message.\\nexports.deprecate = function(fn, msg) {\\n  return exports._deprecate(fn, prefix + msg);\\n};\\n\\n// All the internal deprecations have to use this function only, as this will\\n// prepend the prefix to the actual message.\\nexports.printDeprecationMessage = function(msg, warned) {\\n  return exports._printDeprecationMessage(prefix + msg, warned);\\n};\\n\\nexports._printDeprecationMessage = function(msg, warned) {\\n  if (process.noDeprecation)\\n    return true;\\n\\n  if (warned)\\n    return warned;\\n\\n  if (process.throwDeprecation)\\n    throw new Error(msg);\\n  else if (process.traceDeprecation)\\n    console.trace(msg.startsWith(prefix) ? msg.replace(prefix, '') : msg);\\n  else\\n    console.error(msg);\\n\\n  return true;\\n};\\n\\n// Mark that a method should not be used.\\n// Returns a modified function which warns once by default.\\n// If --no-deprecation is set, then it is a no-op.\\nexports._deprecate = function(fn, msg) {\\n  // Allow for deprecating things in the process of starting up.\\n  if (global.process === undefined) {\\n    return function() {\\n      return exports._deprecate(fn, msg).apply(this, arguments);\\n    };\\n  }\\n\\n  if (process.noDeprecation === true) {\\n    return fn;\\n  }\\n\\n  var warned = false;\\n  function deprecated() {\\n    warned = exports._printDeprecationMessage(msg, warned);\\n    return fn.apply(this, arguments);\\n  }\\n\\n  return deprecated;\\n};\\n\",\"internal/linkedlist\":\"'use strict';\\n\\nfunction init(list) {\\n  list._idleNext = list;\\n  list._idlePrev = list;\\n}\\nexports.init = init;\\n\\n\\n// show the most idle item\\nfunction peek(list) {\\n  if (list._idlePrev == list) return null;\\n  return list._idlePrev;\\n}\\nexports.peek = peek;\\n\\n\\n// remove the most idle item from the list\\nfunction shift(list) {\\n  var first = list._idlePrev;\\n  remove(first);\\n  return first;\\n}\\nexports.shift = shift;\\n\\n\\n// remove a item from its list\\nfunction remove(item) {\\n  if (item._idleNext) {\\n    item._idleNext._idlePrev = item._idlePrev;\\n  }\\n\\n  if (item._idlePrev) {\\n    item._idlePrev._idleNext = item._idleNext;\\n  }\\n\\n  item._idleNext = null;\\n  item._idlePrev = null;\\n}\\nexports.remove = remove;\\n\\n\\n// remove a item from its list and place at the end.\\nfunction append(list, item) {\\n  remove(item);\\n  item._idleNext = list._idleNext;\\n  list._idleNext._idlePrev = item;\\n  item._idlePrev = list;\\n  list._idleNext = item;\\n}\\nexports.append = append;\\n\\n\\nfunction isEmpty(list) {\\n  return list._idleNext === list;\\n}\\nexports.isEmpty = isEmpty;\\n\",\"buffer\":\"/* eslint-disable require-buffer */\\n'use strict';\\nexports.Buffer = Buffer;\\nvar binding = process.binding('buffer_wrap');\\n\\nvar internalUtil = require('internal/util');\\nvar bindingObj = {};\\n\\nexports.Buffer = Buffer;\\nexports.SlowBuffer = SlowBuffer;\\nexports.INSPECT_MAX_BYTES = 50;\\nexports.kMaxLength = binding.kMaxLength;\\n\\nBuffer.poolSize = 8 * 1024;\\nvar poolSize, poolOffset, allocPool;\\n\\nbinding.setupBufferJS(Buffer.prototype, bindingObj);\\nvar flags = bindingObj.flags;\\nvar kNoZeroFill = 0;\\n\\n\\nfunction createPool() {\\n\\tpoolSize = Buffer.poolSize;\\n\\tif (poolSize > 0)\\n\\t\\tflags[kNoZeroFill] = 1;\\n\\tallocPool = new Uint8Array(poolSize);\\n\\tObject.setPrototypeOf(allocPool, Buffer.prototype);\\n\\tpoolOffset = 0;\\n}\\ncreatePool();\\n\\nfunction alignPool() {\\n\\t// Ensure aligned slices\\n\\tif (poolOffset & 0x7) {\\n\\t\\tpoolOffset |= 0x7;\\n\\t\\tpoolOffset++;\\n\\t}\\n}\\n\\nfunction Buffer(arg, encoding) {\\n\\t// Common case.\\n\\tif (typeof arg === 'number') {\\n\\t\\t// If less than zero, or NaN.\\n\\t\\tif (arg < 0 || arg !== arg)\\n\\t\\t\\targ = 0;\\n\\n\\t\\tvar t = new Uint8Array(arg);\\n\\t\\tObject.setPrototypeOf(t, Buffer.prototype);\\n\\t\\treturn t;\\n\\t}\\n\\n\\t// Slightly less common case.\\n\\tif (typeof arg === 'string') {\\n\\t\\treturn binding.createFromString(arg, encoding);\\n\\t}\\n\\n\\t// Unusual.\\n\\treturn fromObject(arg);\\n}\\n\\n// function Buffer(arg, encoding) {\\n//   // Common case.\\n//   if (typeof arg === 'number') {\\n//     // If less than zero, or NaN.\\n//     if (arg < 0 || arg !== arg)\\n//       arg = 0;\\n//     return allocate(arg);\\n//   }\\n\\n//   // Slightly less common case.\\n//   if (typeof arg === 'string') {\\n//     return fromString(arg, encoding);\\n//   }\\n\\n//   // Unusual.\\n//   return fromObject(arg);\\n// }\\n\\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\\nObject.setPrototypeOf(Buffer, Uint8Array);\\n\\n\\nfunction SlowBuffer(length) {\\n\\tif (+length != length)\\n\\t\\tlength = 0;\\n\\tif (length > 0)\\n\\t\\tflags[kNoZeroFill] = 1;\\n\\tvar ui8 = new Uint8Array(+length);\\n\\tObject.setPrototypeOf(ui8, Buffer.prototype);\\n\\treturn ui8;\\n}\\n\\nObject.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);\\nObject.setPrototypeOf(SlowBuffer, Uint8Array);\\n\\n\\nfunction allocate(size) {\\n\\tif (size === 0) {\\n\\t\\tvar ui8 = new Uint8Array(size);\\n\\t\\tObject.setPrototypeOf(ui8, Buffer.prototype);\\n\\t\\treturn ui8;\\n\\t}\\n\\tif (size < (Buffer.poolSize >>> 1)) {\\n\\t\\tif (size > (poolSize - poolOffset))\\n\\t\\t\\tcreatePool();\\n\\t\\tvar b = allocPool.slice(poolOffset, poolOffset + size);\\n\\t\\tpoolOffset += size;\\n\\t\\talignPool();\\n\\t\\treturn b;\\n\\t} else {\\n\\t\\t// Even though this is checked above, the conditional is a safety net and\\n\\t\\t// sanity check to prevent any subsequent typed array allocation from not\\n\\t\\t// being zero filled.\\n\\t\\tif (size > 0)\\n\\t\\t\\tflags[kNoZeroFill] = 1;\\n\\t\\tvar ui8 = new Uint8Array(size);\\n\\t\\tObject.setPrototypeOf(ui8, Buffer.prototype);\\n\\t\\treturn ui8;\\n\\t}\\n}\\n\\n\\nfunction fromString(string, encoding) {\\n\\tif (typeof encoding !== 'string' || encoding === '')\\n\\t\\tencoding = 'utf8';\\n\\n\\tvar length = byteLength(string, encoding);\\n\\tif (length >= (Buffer.poolSize >>> 1))\\n\\t\\treturn binding.createFromString(string, encoding);\\n\\n\\tif (length > (poolSize - poolOffset))\\n\\t\\tcreatePool();\\n\\tvar actual = allocPool.write(string, poolOffset, encoding);\\n\\tvar b = allocPool.slice(poolOffset, poolOffset + actual);\\n\\tpoolOffset += actual;\\n\\talignPool();\\n\\treturn b;\\n}\\n\\n\\nfunction fromObject(obj) {\\n\\tif (obj instanceof Buffer) {\\n\\t\\tvar b = allocate(obj.length);\\n\\t\\tobj.copy(b, 0, 0, obj.length);\\n\\t\\treturn b;\\n\\t}\\n\\n\\tif (Array.isArray(obj)) {\\n\\t\\tvar length = obj.length;\\n\\t\\tvar b = allocate(length);\\n\\t\\tfor (var i = 0; i < length; i++)\\n\\t\\t\\tb[i] = obj[i] & 255;\\n\\t\\treturn b;\\n\\t}\\n\\n\\tif (obj == null) {\\n\\t\\tthrow new TypeError('Must start with number, buffer, array or string');\\n\\t}\\n\\n\\tif (obj instanceof ArrayBuffer) {\\n\\t\\treturn binding.createFromArrayBuffer(obj);\\n\\t}\\n\\n\\tif (obj.buffer instanceof ArrayBuffer || obj.length) {\\n\\t\\tvar length;\\n\\t\\tif (typeof obj.length !== 'number' || obj.length !== obj.length)\\n\\t\\t\\tlength = 0;\\n\\t\\telse\\n\\t\\t\\tlength = obj.length;\\n\\t\\tvar b = allocate(length);\\n\\t\\tfor (var i = 0; i < length; i++) {\\n\\t\\t\\tb[i] = obj[i] & 255;\\n\\t\\t}\\n\\t\\treturn b;\\n\\t}\\n\\n\\tif (obj.type === 'Buffer' && Array.isArray(obj.data)) {\\n\\t\\tvar array = obj.data;\\n\\t\\tvar b = allocate(array.length);\\n\\t\\tfor (var i = 0; i < array.length; i++)\\n\\t\\t\\tb[i] = array[i] & 255;\\n\\t\\treturn b;\\n\\t}\\n\\n\\tthrow new TypeError('Must start with number, buffer, array or string');\\n}\\n\\n\\n// Static methods\\n\\nBuffer.isBuffer = function isBuffer(b) {\\n\\treturn b instanceof Buffer;\\n};\\n\\n\\nBuffer.compare = function compare(a, b) {\\n\\tif (!(a instanceof Buffer) ||\\n\\t\\t\\t!(b instanceof Buffer)) {\\n\\t\\tthrow new TypeError('Arguments must be Buffers');\\n\\t}\\n\\n\\tif (a === b) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\treturn binding.compare(a, b);\\n};\\n\\n\\nBuffer.isEncoding = function(encoding) {\\n\\tvar loweredCase = false;\\n\\tfor (;;) {\\n\\t\\tswitch (encoding) {\\n\\t\\t\\tcase 'hex':\\n\\t\\t\\tcase 'utf8':\\n\\t\\t\\tcase 'utf-8':\\n\\t\\t\\tcase 'ascii':\\n\\t\\t\\tcase 'binary':\\n\\t\\t\\tcase 'base64':\\n\\t\\t\\tcase 'ucs2':\\n\\t\\t\\tcase 'ucs-2':\\n\\t\\t\\tcase 'utf16le':\\n\\t\\t\\tcase 'utf-16le':\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tif (loweredCase)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tencoding = ('' + encoding).toLowerCase();\\n\\t\\t\\t\\tloweredCase = true;\\n\\t\\t}\\n\\t}\\n};\\n\\n\\nBuffer.concat = function(list, length) {\\n\\tif (!Array.isArray(list))\\n\\t\\tthrow new TypeError('\\\"list\\\" argument must be an Array of Buffers');\\n\\n\\tif (list.length === 0)\\n\\t\\treturn new Buffer(0);\\n\\n\\tif (length === undefined) {\\n\\t\\tlength = 0;\\n\\t\\tfor (var i = 0; i < list.length; i++)\\n\\t\\t\\tlength += list[i].length;\\n\\t} else {\\n\\t\\tlength = length >>> 0;\\n\\t}\\n\\n\\tvar buffer = new Buffer(length);\\n\\tvar pos = 0;\\n\\tfor (var i = 0; i < list.length; i++) {\\n\\t\\tvar buf = list[i];\\n\\t\\tbuf.copy(buffer, pos);\\n\\t\\tpos += buf.length;\\n\\t}\\n\\n\\treturn buffer;\\n};\\n\\n\\nfunction base64ByteLength(str, bytes) {\\n\\t// Handle padding\\n\\tif (str.charCodeAt(bytes - 1) === 0x3D)\\n\\t\\tbytes--;\\n\\tif (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D)\\n\\t\\tbytes--;\\n\\n\\t// Base64 ratio: 3/4\\n\\treturn (bytes * 3) >>> 2;\\n}\\n\\n\\nfunction byteLength(string, encoding) {\\n\\tif (typeof string !== 'string')\\n\\t\\tstring = '' + string;\\n\\n\\tvar len = string.length;\\n\\tif (len === 0)\\n\\t\\treturn 0;\\n\\n\\t// Use a for loop to avoid recursion\\n\\tvar loweredCase = false;\\n\\tfor (;;) {\\n\\t\\tswitch (encoding) {\\n\\t\\t\\tcase 'ascii':\\n\\t\\t\\tcase 'binary':\\n\\t\\t\\t\\treturn len;\\n\\n\\t\\t\\tcase 'utf8':\\n\\t\\t\\tcase 'utf-8':\\n\\t\\t\\tcase undefined:\\n\\t\\t\\t\\treturn binding.byteLengthUtf8(string);\\n\\n\\t\\t\\tcase 'ucs2':\\n\\t\\t\\tcase 'ucs-2':\\n\\t\\t\\tcase 'utf16le':\\n\\t\\t\\tcase 'utf-16le':\\n\\t\\t\\t\\treturn len * 2;\\n\\n\\t\\t\\tcase 'hex':\\n\\t\\t\\t\\treturn len >>> 1;\\n\\n\\t\\t\\tcase 'base64':\\n\\t\\t\\t\\treturn base64ByteLength(string, len);\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\t// The C++ binding defaulted to UTF8, we should too.\\n\\t\\t\\t\\tif (loweredCase)\\n\\t\\t\\t\\t\\treturn binding.byteLengthUtf8(string);\\n\\n\\t\\t\\t\\tencoding = ('' + encoding).toLowerCase();\\n\\t\\t\\t\\tloweredCase = true;\\n\\t\\t}\\n\\t}\\n}\\n\\nBuffer.byteLength = byteLength;\\n\\n\\n// For backwards compatibility.\\nObject.defineProperty(Buffer.prototype, 'parent', {\\n\\tenumerable: true,\\n\\tget: function() {\\n\\t\\tif (!(this instanceof Buffer))\\n\\t\\t\\treturn undefined;\\n\\t\\tif (this.byteLength === 0 ||\\n\\t\\t\\t\\tthis.byteLength === this.buffer.byteLength) {\\n\\t\\t\\treturn undefined;\\n\\t\\t}\\n\\t\\treturn this.buffer;\\n\\t}\\n});\\nObject.defineProperty(Buffer.prototype, 'offset', {\\n\\tenumerable: true,\\n\\tget: function() {\\n\\t\\tif (!(this instanceof Buffer))\\n\\t\\t\\treturn undefined;\\n\\t\\treturn this.byteOffset;\\n\\t}\\n});\\n\\n\\nfunction slowToString(encoding, start, end) {\\n\\tvar loweredCase = false;\\n\\n\\t// No need to verify that \\\"this.length <= MAX_UINT32\\\" since it's a read-only\\n\\t// property of a typed array.\\n\\n\\t// This behaves neither like String nor Uint8Array in that we set start/end\\n\\t// to their upper/lower bounds if the value passed is out of range.\\n\\t// undefined is handled specially as per ECMA-262 6th Edition,\\n\\t// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\\n\\tif (start === undefined || start < 0)\\n\\t\\tstart = 0;\\n\\t// Return early if start > this.length. Done here to prevent potential uint32\\n\\t// coercion fail below.\\n\\tif (start > this.length)\\n\\t\\treturn '';\\n\\n\\tif (end === undefined || end > this.length)\\n\\t\\tend = this.length;\\n\\n\\tif (end <= 0)\\n\\t\\treturn '';\\n\\n\\t// Force coersion to uint32. This will also coerce falsey/NaN values to 0.\\n\\tend >>>= 0;\\n\\tstart >>>= 0;\\n\\n\\tif (end <= start)\\n\\t\\treturn '';\\n\\n\\tif (!encoding) encoding = 'utf8';\\n\\n\\twhile (true) {\\n\\t\\tswitch (encoding) {\\n\\t\\t\\tcase 'hex':\\n\\t\\t\\t\\treturn this.hexSlice(start, end);\\n\\n\\t\\t\\tcase 'utf8':\\n\\t\\t\\tcase 'utf-8':\\n\\t\\t\\t\\treturn this.utf8Slice(start, end);\\n\\n\\t\\t\\tcase 'ascii':\\n\\t\\t\\t\\treturn this.asciiSlice(start, end);\\n\\n\\t\\t\\tcase 'binary':\\n\\t\\t\\t\\treturn this.binarySlice(start, end);\\n\\n\\t\\t\\tcase 'base64':\\n\\t\\t\\t\\treturn this.base64Slice(start, end);\\n\\n\\t\\t\\tcase 'ucs2':\\n\\t\\t\\tcase 'ucs-2':\\n\\t\\t\\tcase 'utf16le':\\n\\t\\t\\tcase 'utf-16le':\\n\\t\\t\\t\\treturn this.ucs2Slice(start, end);\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tif (loweredCase)\\n\\t\\t\\t\\t\\tthrow new TypeError('Unknown encoding: ' + encoding);\\n\\t\\t\\t\\tencoding = (encoding + '').toLowerCase();\\n\\t\\t\\t\\tloweredCase = true;\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nBuffer.prototype.toString = function() {\\n\\tif (arguments.length === 0) {\\n\\t\\tvar result = this.utf8Slice(0, this.length);\\n\\t} else {\\n\\t\\tvar result = slowToString.apply(this, arguments);\\n\\t}\\n\\tif (result === undefined)\\n\\t\\tthrow new Error('\\\"toString()\\\" failed');\\n\\treturn result;\\n};\\n\\n\\nBuffer.prototype.equals = function equals(b) {\\n\\tif (!(b instanceof Buffer))\\n\\t\\tthrow new TypeError('Argument must be a Buffer');\\n\\n\\tif (this === b)\\n\\t\\treturn true;\\n\\n\\treturn binding.compare(this, b) === 0;\\n};\\n\\n\\n// Inspect\\nBuffer.prototype.inspect = function inspect() {\\n\\tvar str = '';\\n\\tvar max = exports.INSPECT_MAX_BYTES;\\n\\tif (this.length > 0) {\\n\\t\\tstr = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\\n\\t\\tif (this.length > max)\\n\\t\\t\\tstr += ' ... ';\\n\\t}\\n\\treturn '<' + this.constructor.name + ' ' + str + '>';\\n};\\n\\n\\nBuffer.prototype.compare = function compare(b) {\\n\\tif (!(b instanceof Buffer))\\n\\t\\tthrow new TypeError('Argument must be a Buffer');\\n\\n\\tif (this === b)\\n\\t\\treturn 0;\\n\\n\\treturn binding.compare(this, b);\\n};\\n\\nfunction slowIndexOf(buffer, val, byteOffset, encoding) {\\n\\tvar loweredCase = false;\\n\\tfor (;;) {\\n\\t\\tswitch (encoding) {\\n\\t\\t\\tcase 'utf8':\\n\\t\\t\\tcase 'utf-8':\\n\\t\\t\\tcase 'ucs2':\\n\\t\\t\\tcase 'ucs-2':\\n\\t\\t\\tcase 'utf16le':\\n\\t\\t\\tcase 'utf-16le':\\n\\t\\t\\tcase 'binary':\\n\\t\\t\\t\\treturn binding.indexOfString(buffer, val, byteOffset, encoding);\\n\\n\\t\\t\\tcase 'base64':\\n\\t\\t\\tcase 'ascii':\\n\\t\\t\\tcase 'hex':\\n\\t\\t\\t\\treturn binding.indexOfBuffer(\\n\\t\\t\\t\\t\\t\\tbuffer, Buffer(val, encoding), byteOffset, encoding);\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tif (loweredCase) {\\n\\t\\t\\t\\t\\tthrow new TypeError('Unknown encoding: ' + encoding);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tencoding = ('' + encoding).toLowerCase();\\n\\t\\t\\t\\tloweredCase = true;\\n\\t\\t}\\n\\t}\\n}\\n\\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\\n\\tif (byteOffset > 0x7fffffff)\\n\\t\\tbyteOffset = 0x7fffffff;\\n\\telse if (byteOffset < -0x80000000)\\n\\t\\tbyteOffset = -0x80000000;\\n\\tbyteOffset >>= 0;\\n\\n\\tif (typeof val === 'string') {\\n\\t\\tif (encoding === undefined) {\\n\\t\\t\\treturn binding.indexOfString(this, val, byteOffset, encoding);\\n\\t\\t}\\n\\t\\treturn slowIndexOf(this, val, byteOffset, encoding);\\n\\t} else if (val instanceof Buffer) {\\n\\t\\treturn binding.indexOfBuffer(this, val, byteOffset, encoding);\\n\\t} else if (typeof val === 'number') {\\n\\t\\treturn binding.indexOfNumber(this, val, byteOffset);\\n\\t}\\n\\n\\tthrow new TypeError('\\\"val\\\" argument must be string, number or Buffer');\\n};\\n\\n\\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\\n\\treturn this.indexOf(val, byteOffset, encoding) !== -1;\\n};\\n\\n//FIXME: fast implementation\\nif (typeof NODE_BUFFER === 'undefined'){\\n\\tBuffer.prototype.fill = NODE_BUFFER.prototype.fill;\\n} else {\\n\\tBuffer.prototype.fill = function fill(val, start, end) {\\n\\t\\tstart = start >> 0;\\n\\t\\tend = (end === undefined) ? this.length : end >> 0;\\n\\n\\t\\tif (start < 0 || end > this.length)\\n\\t\\t\\tthrow new RangeError('Out of range index');\\n\\t\\tif (end <= start)\\n\\t\\t\\treturn this;\\n\\n\\t\\tif (typeof val !== 'string') {\\n\\t\\t\\tval = val >>> 0;\\n\\t\\t} else if (val.length === 1) {\\n\\t\\t\\tvar code = val.charCodeAt(0);\\n\\t\\t\\tif (code < 256)\\n\\t\\t\\t\\tval = code;\\n\\t\\t}\\n\\n\\t\\tbinding.fill(this, val, start, end);\\n\\n\\t\\treturn this;\\n\\t};\\n}\\n\\n\\n\\n// XXX remove in v0.13\\nBuffer.prototype.get = internalUtil.deprecate(function get(offset) {\\n\\toffset = ~~offset;\\n\\tif (offset < 0 || offset >= this.length)\\n\\t\\tthrow new RangeError('Index out of range');\\n\\treturn this[offset];\\n}, 'Buffer.get is deprecated. Use array indexes instead.');\\n\\n\\n// XXX remove in v0.13\\nBuffer.prototype.set = internalUtil.deprecate(function set(offset, v) {\\n\\toffset = ~~offset;\\n\\tif (offset < 0 || offset >= this.length)\\n\\t\\tthrow new RangeError('Index out of range');\\n\\treturn this[offset] = v;\\n}, 'Buffer.set is deprecated. Use array indexes instead.');\\n\\n\\n// TODO(trevnorris): fix these checks to follow new standard\\n// write(string, offset = 0, length = buffer.length, encoding = 'utf8')\\nvar writeWarned = false;\\nvar writeMsg = 'Buffer.write(string, encoding, offset, length) is ' +\\n\\t\\t\\t\\t\\t\\t\\t\\t 'deprecated. Use write(string[, offset[, length]]' +\\n\\t\\t\\t\\t\\t\\t\\t\\t '[, encoding]) instead.';\\nBuffer.prototype.write = function(string, offset, length, encoding) {\\n\\t// Buffer#write(string);\\n\\tif (offset === undefined) {\\n\\t\\tencoding = 'utf8';\\n\\t\\tlength = this.length;\\n\\t\\toffset = 0;\\n\\n\\t// Buffer#write(string, encoding)\\n\\t} else if (length === undefined && typeof offset === 'string') {\\n\\t\\tencoding = offset;\\n\\t\\tlength = this.length;\\n\\t\\toffset = 0;\\n\\n\\t// Buffer#write(string, offset[, length][, encoding])\\n\\t} else if (isFinite(offset)) {\\n\\t\\toffset = offset >>> 0;\\n\\t\\tif (isFinite(length)) {\\n\\t\\t\\tlength = length >>> 0;\\n\\t\\t\\tif (encoding === undefined)\\n\\t\\t\\t\\tencoding = 'utf8';\\n\\t\\t} else {\\n\\t\\t\\tencoding = length;\\n\\t\\t\\tlength = undefined;\\n\\t\\t}\\n\\n\\t// XXX legacy write(string, encoding, offset, length) - remove in v0.13\\n\\t} else {\\n\\t\\twriteWarned = internalUtil.printDeprecationMessage(writeMsg, writeWarned);\\n\\t\\tvar swap = encoding;\\n\\t\\tencoding = offset;\\n\\t\\toffset = length >>> 0;\\n\\t\\tlength = swap;\\n\\t}\\n\\n\\tvar remaining = this.length - offset;\\n\\tif (length === undefined || length > remaining)\\n\\t\\tlength = remaining;\\n\\n\\tif (string.length > 0 && (length < 0 || offset < 0))\\n\\t\\tthrow new RangeError('Attempt to write outside buffer bounds');\\n\\n\\tif (!encoding)\\n\\t\\tencoding = 'utf8';\\n\\n\\tvar loweredCase = false;\\n\\tfor (;;) {\\n\\t\\tswitch (encoding) {\\n\\t\\t\\tcase 'hex':\\n\\t\\t\\t\\treturn this.hexWrite(string, offset, length);\\n\\n\\t\\t\\tcase 'utf8':\\n\\t\\t\\tcase 'utf-8':\\n\\t\\t\\t\\treturn this.utf8Write(string, offset, length);\\n\\n\\t\\t\\tcase 'ascii':\\n\\t\\t\\t\\treturn this.asciiWrite(string, offset, length);\\n\\n\\t\\t\\tcase 'binary':\\n\\t\\t\\t\\treturn this.binaryWrite(string, offset, length);\\n\\n\\t\\t\\tcase 'base64':\\n\\t\\t\\t\\t// Warning: maxLength not taken into account in base64Write\\n\\t\\t\\t\\treturn this.base64Write(string, offset, length);\\n\\n\\t\\t\\tcase 'ucs2':\\n\\t\\t\\tcase 'ucs-2':\\n\\t\\t\\tcase 'utf16le':\\n\\t\\t\\tcase 'utf-16le':\\n\\t\\t\\t\\treturn this.ucs2Write(string, offset, length);\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tif (loweredCase)\\n\\t\\t\\t\\t\\tthrow new TypeError('Unknown encoding: ' + encoding);\\n\\t\\t\\t\\tencoding = ('' + encoding).toLowerCase();\\n\\t\\t\\t\\tloweredCase = true;\\n\\t\\t}\\n\\t}\\n};\\n\\n\\nBuffer.prototype.toJSON = function() {\\n\\treturn {\\n\\t\\ttype: 'Buffer',\\n\\t\\tdata: Array.prototype.slice.call(this, 0)\\n\\t};\\n};\\n\\n\\n// TODO(trevnorris): currently works like Array.prototype.slice(), which\\n// doesn't follow the new standard for throwing on out of range indexes.\\nBuffer.prototype.slice = function slice(start, end) {\\n\\tvar buffer = this.subarray(start, end);\\n\\tObject.setPrototypeOf(buffer, Buffer.prototype);\\n\\treturn buffer;\\n};\\n\\n\\nfunction checkOffset(offset, ext, length) {\\n\\tif (offset + ext > length)\\n\\t\\tthrow new RangeError('Index out of range');\\n}\\n\\n\\nBuffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tbyteLength = byteLength >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, byteLength, this.length);\\n\\n\\tvar val = this[offset];\\n\\tvar mul = 1;\\n\\tvar i = 0;\\n\\twhile (++i < byteLength && (mul *= 0x100))\\n\\t\\tval += this[offset + i] * mul;\\n\\n\\treturn val;\\n};\\n\\n\\nBuffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tbyteLength = byteLength >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, byteLength, this.length);\\n\\n\\tvar val = this[offset + --byteLength];\\n\\tvar mul = 1;\\n\\twhile (byteLength > 0 && (mul *= 0x100))\\n\\t\\tval += this[offset + --byteLength] * mul;\\n\\n\\treturn val;\\n};\\n\\n\\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 1, this.length);\\n\\treturn this[offset];\\n};\\n\\n\\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 2, this.length);\\n\\treturn this[offset] | (this[offset + 1] << 8);\\n};\\n\\n\\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 2, this.length);\\n\\treturn (this[offset] << 8) | this[offset + 1];\\n};\\n\\n\\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 4, this.length);\\n\\n\\treturn ((this[offset]) |\\n\\t\\t\\t(this[offset + 1] << 8) |\\n\\t\\t\\t(this[offset + 2] << 16)) +\\n\\t\\t\\t(this[offset + 3] * 0x1000000);\\n};\\n\\n\\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 4, this.length);\\n\\n\\treturn (this[offset] * 0x1000000) +\\n\\t\\t\\t((this[offset + 1] << 16) |\\n\\t\\t\\t(this[offset + 2] << 8) |\\n\\t\\t\\tthis[offset + 3]);\\n};\\n\\n\\nBuffer.prototype.readIntLE = function(offset, byteLength, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tbyteLength = byteLength >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, byteLength, this.length);\\n\\n\\tvar val = this[offset];\\n\\tvar mul = 1;\\n\\tvar i = 0;\\n\\twhile (++i < byteLength && (mul *= 0x100))\\n\\t\\tval += this[offset + i] * mul;\\n\\tmul *= 0x80;\\n\\n\\tif (val >= mul)\\n\\t\\tval -= Math.pow(2, 8 * byteLength);\\n\\n\\treturn val;\\n};\\n\\n\\nBuffer.prototype.readIntBE = function(offset, byteLength, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tbyteLength = byteLength >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, byteLength, this.length);\\n\\n\\tvar i = byteLength;\\n\\tvar mul = 1;\\n\\tvar val = this[offset + --i];\\n\\twhile (i > 0 && (mul *= 0x100))\\n\\t\\tval += this[offset + --i] * mul;\\n\\tmul *= 0x80;\\n\\n\\tif (val >= mul)\\n\\t\\tval -= Math.pow(2, 8 * byteLength);\\n\\n\\treturn val;\\n};\\n\\n\\nBuffer.prototype.readInt8 = function(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 1, this.length);\\n\\tvar val = this[offset];\\n\\treturn !(val & 0x80) ? val : (0xff - val + 1) * -1;\\n};\\n\\n\\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 2, this.length);\\n\\tvar val = this[offset] | (this[offset + 1] << 8);\\n\\treturn (val & 0x8000) ? val | 0xFFFF0000 : val;\\n};\\n\\n\\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 2, this.length);\\n\\tvar val = this[offset + 1] | (this[offset] << 8);\\n\\treturn (val & 0x8000) ? val | 0xFFFF0000 : val;\\n};\\n\\n\\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 4, this.length);\\n\\n\\treturn (this[offset]) |\\n\\t\\t\\t(this[offset + 1] << 8) |\\n\\t\\t\\t(this[offset + 2] << 16) |\\n\\t\\t\\t(this[offset + 3] << 24);\\n};\\n\\n\\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 4, this.length);\\n\\n\\treturn (this[offset] << 24) |\\n\\t\\t\\t(this[offset + 1] << 16) |\\n\\t\\t\\t(this[offset + 2] << 8) |\\n\\t\\t\\t(this[offset + 3]);\\n};\\n\\n\\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 4, this.length);\\n\\treturn binding.readFloatLE(this, offset);\\n};\\n\\n\\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 4, this.length);\\n\\treturn binding.readFloatBE(this, offset);\\n};\\n\\n\\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 8, this.length);\\n\\treturn binding.readDoubleLE(this, offset);\\n};\\n\\n\\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckOffset(offset, 8, this.length);\\n\\treturn binding.readDoubleBE(this, offset);\\n};\\n\\n\\nfunction checkInt(buffer, value, offset, ext, max, min) {\\n\\tif (!(buffer instanceof Buffer))\\n\\t\\tthrow new TypeError('\\\"buffer\\\" argument must be a Buffer instance');\\n\\tif (value > max || value < min)\\n\\t\\tthrow new TypeError('\\\"value\\\" argument is out of bounds');\\n\\tif (offset + ext > buffer.length)\\n\\t\\tthrow new RangeError('Index out of range');\\n}\\n\\n\\nBuffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tbyteLength = byteLength >>> 0;\\n\\tif (!noAssert) {\\n\\t\\tvar maxBytes = Math.pow(2, 8 * byteLength) - 1;\\n\\t\\tcheckInt(this, value, offset, byteLength, maxBytes, 0);\\n\\t}\\n\\n\\tvar mul = 1;\\n\\tvar i = 0;\\n\\tthis[offset] = value;\\n\\twhile (++i < byteLength && (mul *= 0x100))\\n\\t\\tthis[offset + i] = (value / mul) >>> 0;\\n\\n\\treturn offset + byteLength;\\n};\\n\\n\\nBuffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tbyteLength = byteLength >>> 0;\\n\\tif (!noAssert) {\\n\\t\\tvar maxBytes = Math.pow(2, 8 * byteLength) - 1;\\n\\t\\tcheckInt(this, value, offset, byteLength, maxBytes, 0);\\n\\t}\\n\\n\\tvar i = byteLength - 1;\\n\\tvar mul = 1;\\n\\tthis[offset + i] = value;\\n\\twhile (--i >= 0 && (mul *= 0x100))\\n\\t\\tthis[offset + i] = (value / mul) >>> 0;\\n\\n\\treturn offset + byteLength;\\n};\\n\\n\\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckInt(this, value, offset, 1, 0xff, 0);\\n\\tthis[offset] = value;\\n\\treturn offset + 1;\\n};\\n\\n\\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckInt(this, value, offset, 2, 0xffff, 0);\\n\\tthis[offset] = value;\\n\\tthis[offset + 1] = (value >>> 8);\\n\\treturn offset + 2;\\n};\\n\\n\\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckInt(this, value, offset, 2, 0xffff, 0);\\n\\tthis[offset] = (value >>> 8);\\n\\tthis[offset + 1] = value;\\n\\treturn offset + 2;\\n};\\n\\nif (typeof NODE_BUFFER !== 'undefined'){\\n\\tBuffer.prototype.writeUInt32LE = NODE_BUFFER.prototype.writeUInt32LE;\\n} else {\\n\\tBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\\n\\t\\tvalue = +value;\\n\\t\\toffset = offset >>> 0;\\n\\t\\tif (!noAssert)\\n\\t\\t\\tcheckInt(this, value, offset, 4, 0xffffffff, 0);\\n\\t\\tthis[offset + 3] = (value >>> 24);\\n\\t\\tthis[offset + 2] = (value >>> 16);\\n\\t\\tthis[offset + 1] = (value >>> 8);\\n\\t\\tthis[offset] = value;\\n\\t\\treturn offset + 4;\\n\\t};\\n}\\n\\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckInt(this, value, offset, 4, 0xffffffff, 0);\\n\\tthis[offset] = (value >>> 24);\\n\\tthis[offset + 1] = (value >>> 16);\\n\\tthis[offset + 2] = (value >>> 8);\\n\\tthis[offset + 3] = value;\\n\\treturn offset + 4;\\n};\\n\\n\\nBuffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert) {\\n\\t\\tcheckInt(this,\\n\\t\\t\\t\\t\\t\\t value,\\n\\t\\t\\t\\t\\t\\t offset,\\n\\t\\t\\t\\t\\t\\t byteLength,\\n\\t\\t\\t\\t\\t\\t Math.pow(2, 8 * byteLength - 1) - 1,\\n\\t\\t\\t\\t\\t\\t -Math.pow(2, 8 * byteLength - 1));\\n\\t}\\n\\n\\tvar i = 0;\\n\\tvar mul = 1;\\n\\tvar sub = 0;\\n\\tthis[offset] = value;\\n\\twhile (++i < byteLength && (mul *= 0x100)) {\\n\\t\\tif (value < 0 && sub === 0 && this[offset + i - 1] !== 0)\\n\\t\\t\\tsub = 1;\\n\\t\\tthis[offset + i] = ((value / mul) >> 0) - sub;\\n\\t}\\n\\n\\treturn offset + byteLength;\\n};\\n\\n\\nBuffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert) {\\n\\t\\tcheckInt(this,\\n\\t\\t\\t\\t\\t\\t value,\\n\\t\\t\\t\\t\\t\\t offset,\\n\\t\\t\\t\\t\\t\\t byteLength,\\n\\t\\t\\t\\t\\t\\t Math.pow(2, 8 * byteLength - 1) - 1,\\n\\t\\t\\t\\t\\t\\t -Math.pow(2, 8 * byteLength - 1));\\n\\t}\\n\\n\\tvar i = byteLength - 1;\\n\\tvar mul = 1;\\n\\tvar sub = 0;\\n\\tthis[offset + i] = value;\\n\\twhile (--i >= 0 && (mul *= 0x100)) {\\n\\t\\tif (value < 0 && sub === 0 && this[offset + i + 1] !== 0)\\n\\t\\t\\tsub = 1;\\n\\t\\tthis[offset + i] = ((value / mul) >> 0) - sub;\\n\\t}\\n\\n\\treturn offset + byteLength;\\n};\\n\\n\\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckInt(this, value, offset, 1, 0x7f, -0x80);\\n\\tthis[offset] = value;\\n\\treturn offset + 1;\\n};\\n\\n\\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckInt(this, value, offset, 2, 0x7fff, -0x8000);\\n\\tthis[offset] = value;\\n\\tthis[offset + 1] = (value >>> 8);\\n\\treturn offset + 2;\\n};\\n\\n\\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckInt(this, value, offset, 2, 0x7fff, -0x8000);\\n\\tthis[offset] = (value >>> 8);\\n\\tthis[offset + 1] = value;\\n\\treturn offset + 2;\\n};\\n\\n\\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\\n\\tthis[offset] = value;\\n\\tthis[offset + 1] = (value >>> 8);\\n\\tthis[offset + 2] = (value >>> 16);\\n\\tthis[offset + 3] = (value >>> 24);\\n\\treturn offset + 4;\\n};\\n\\n\\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\\n\\tvalue = +value;\\n\\toffset = offset >>> 0;\\n\\tif (!noAssert)\\n\\t\\tcheckInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\\n\\tthis[offset] = (value >>> 24);\\n\\tthis[offset + 1] = (value >>> 16);\\n\\tthis[offset + 2] = (value >>> 8);\\n\\tthis[offset + 3] = value;\\n\\treturn offset + 4;\\n};\\n\\nif (typeof NODE_BUFFER !== 'undefined'){\\n\\tBuffer.prototype.writeFloatLE = NODE_BUFFER.prototype.writeFloatLE;\\n} else {\\n\\tBuffer.prototype.writeFloatLE = function writeFloatLE(val, offset, noAssert) {\\n\\t\\tval = +val;\\n\\t\\toffset = offset >>> 0;\\n\\t\\tif (!noAssert)\\n\\t\\t\\tbinding.writeFloatLE(this, val, offset);\\n\\t\\telse\\n\\t\\t\\tbinding.writeFloatLE(this, val, offset, true);\\n\\t\\treturn offset + 4;\\n\\t};\\n}\\n\\nif (typeof NODE_BUFFER !== 'undefined'){\\n\\tBuffer.prototype.writeFloatBE = NODE_BUFFER.prototype.writeFloatBE;\\n} else {\\n\\tBuffer.prototype.writeFloatBE = function writeFloatBE(val, offset, noAssert) {\\n\\t\\tval = +val;\\n\\t\\toffset = offset >>> 0;\\n\\t\\tif (!noAssert)\\n\\t\\t\\tbinding.writeFloatBE(this, val, offset);\\n\\t\\telse\\n\\t\\t\\tbinding.writeFloatBE(this, val, offset, true);\\n\\t\\treturn offset + 4;\\n\\t};\\n}\\n\\nif (typeof NODE_BUFFER !== 'undefined'){\\n\\tBuffer.prototype.writeDoubleLE = NODE_BUFFER.prototype.writeDoubleLE;\\n} else {\\n\\tBuffer.prototype.writeDoubleLE = function writeDoubleLE(val, offset, noAssert) {\\n\\t\\tval = +val;\\n\\t\\toffset = offset >>> 0;\\n\\t\\tif (!noAssert)\\n\\t\\t\\tbinding.writeDoubleLE(this, val, offset);\\n\\t\\telse\\n\\t\\t\\tbinding.writeDoubleLE(this, val, offset, true);\\n\\t\\treturn offset + 8;\\n\\t};\\n}\\n\\nif (typeof NODE_BUFFER !== 'undefined'){\\n\\tBuffer.prototype.writeDoubleBE = NODE_BUFFER.prototype.writeDoubleBE;\\n} else {\\n\\tBuffer.prototype.writeDoubleBE = function writeDoubleBE(val, offset, noAssert) {\\n\\t\\tval = +val;\\n\\t\\toffset = offset >>> 0;\\n\\t\\tif (!noAssert)\\n\\t\\t\\tbinding.writeDoubleBE(this, val, offset);\\n\\t\\telse\\n\\t\\t\\tbinding.writeDoubleBE(this, val, offset, true);\\n\\t\\treturn offset + 8;\\n\\t};\\n}\\n\",\"util\":\"//// Copyright Joyent, Inc. and other Node contributors.\\n////\\n//// Permission is hereby granted, free of charge, to any person obtaining a\\n//// copy of this software and associated documentation files (the\\n//// \\\"Software\\\"), to deal in the Software without restriction, including\\n//// without limitation the rights to use, copy, modify, merge, publish,\\n//// distribute, sublicense, and/or sell copies of the Software, and to permit\\n//// persons to whom the Software is furnished to do so, subject to the\\n//// following conditions:\\n////\\n//// The above copyright notice and this permission notice shall be included\\n//// in all copies or substantial portions of the Software.\\n////\\n//// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n//// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n//// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n//// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n//// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n//// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n//// USE OR OTHER DEALINGS IN THE SOFTWARE.\\nexports._exceptionWithHostPort = function(err,\\n                                          syscall,\\n                                          address,\\n                                          port,\\n                                          additional) {\\n  var details;\\n  if (port && port > 0) {\\n    details = address + ':' + port;\\n  } else {\\n    details = address;\\n  }\\n\\n  if (additional) {\\n    details += ' - Local (' + additional + ')';\\n  }\\n  var ex = exports._errnoException(err, syscall, details);\\n  ex.address = address;\\n  if (port) {\\n    ex.port = port;\\n  }\\n  return ex;\\n};\\n\\nvar formatRegExp = /%[sdj%]/g;\\nexports.format = function(f) {\\n  if (!isString(f)) {\\n    var objects = [];\\n    for (var i = 0; i < arguments.length; i++) {\\n      objects.push(inspect(arguments[i]));\\n    }\\n    return objects.join(' ');\\n  }\\n\\n  var i = 1;\\n  var args = arguments;\\n  var len = args.length;\\n  var str = String(f).replace(formatRegExp, function(x) {\\n    if (x === '%%') return '%';\\n    if (i >= len) return x;\\n    switch (x) {\\n      case '%s': return String(args[i++]);\\n      case '%d': return Number(args[i++]);\\n      case '%j':\\n        try {\\n          return JSON.stringify(args[i++]);\\n        } catch (_) {\\n          return '[Circular]';\\n        }\\n      default:\\n        return x;\\n    }\\n  });\\n  for (var x = args[i]; i < len; x = args[++i]) {\\n    if (isNull(x) || !isObject(x)) {\\n      str += ' ' + x;\\n    } else {\\n      str += ' ' + inspect(x);\\n    }\\n  }\\n  return str;\\n};\\n\\n// Mark that a method should not be used.\\n// Returns a modified function which warns once by default.\\n// If --no-deprecation is set, then it is a no-op.\\nexports.deprecate = function(fn, msg) {\\n  // Allow for deprecating things in the process of starting up.\\n  if (isUndefined(global.process)) {\\n    return function() {\\n      return exports.deprecate(fn, msg).apply(this, arguments);\\n    };\\n  }\\n\\n  if (process.noDeprecation === true) {\\n    return fn;\\n  }\\n\\n  var warned = false;\\n  function deprecated() {\\n    if (!warned) {\\n      if (process.throwDeprecation) {\\n        throw new Error(msg);\\n      } else if (process.traceDeprecation) {\\n        console.trace(msg);\\n      } else {\\n        console.error(msg);\\n      }\\n      warned = true;\\n    }\\n    return fn.apply(this, arguments);\\n  }\\n\\n  return deprecated;\\n};\\n\\n\\nvar debugs = {};\\nvar debugEnviron;\\nexports.debuglog = function(set) {\\n  if (isUndefined(debugEnviron))\\n    debugEnviron = process.env.NODE_DEBUG || '';\\n  set = set.toUpperCase();\\n  if (!debugs[set]) {\\n    if (new RegExp('\\\\\\\\b' + set + '\\\\\\\\b', 'i').test(debugEnviron)) {\\n      var pid = process.pid;\\n      debugs[set] = function() {\\n        var msg = exports.format.apply(exports, arguments);\\n        console.error('%s %d: %s', set, pid, msg);\\n      };\\n    } else {\\n      debugs[set] = function() {};\\n    }\\n  }\\n  return debugs[set];\\n};\\n\\n/**\\n * Echos the value of a value. Trys to print the value out\\n * in the best way possible given the different types.\\n *\\n * @param {Object} obj The object to print out.\\n * @param {Object} opts Optional options object that alters the output.\\n */\\n/* legacy: obj, showHidden, depth, colors*/\\nfunction inspect(obj, opts) {\\n  // default options\\n  var ctx = {\\n    seen: [],\\n    stylize: stylizeNoColor\\n  };\\n  // legacy...\\n  if (arguments.length >= 3) ctx.depth = arguments[2];\\n  if (arguments.length >= 4) ctx.colors = arguments[3];\\n  if (isBoolean(opts)) {\\n    // legacy...\\n    ctx.showHidden = opts;\\n  } else if (opts) {\\n    // got an \\\"options\\\" object\\n    exports._extend(ctx, opts);\\n  }\\n  // set default options\\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\\n  if (isUndefined(ctx.colors)) ctx.colors = false;\\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\\n  return formatValue(ctx, obj, ctx.depth);\\n}\\nexports.inspect = inspect;\\n\\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\\ninspect.colors = {\\n  'bold' : [1, 22],\\n  'italic' : [3, 23],\\n  'underline' : [4, 24],\\n  'inverse' : [7, 27],\\n  'white' : [37, 39],\\n  'grey' : [90, 39],\\n  'black' : [30, 39],\\n  'blue' : [34, 39],\\n  'cyan' : [36, 39],\\n  'green' : [32, 39],\\n  'magenta' : [35, 39],\\n  'red' : [31, 39],\\n  'yellow' : [33, 39]\\n};\\n\\n// Don't use 'blue' not visible on cmd.exe\\ninspect.styles = {\\n  'special': 'cyan',\\n  'number': 'yellow',\\n  'boolean': 'yellow',\\n  'undefined': 'grey',\\n  'null': 'bold',\\n  'string': 'green',\\n  'date': 'magenta',\\n  // \\\"name\\\": intentionally not styling\\n  'regexp': 'red'\\n};\\n\\n\\nfunction stylizeWithColor(str, styleType) {\\n  var style = inspect.styles[styleType];\\n\\n  if (style) {\\n    return '\\\\u001b[' + inspect.colors[style][0] + 'm' + str +\\n           '\\\\u001b[' + inspect.colors[style][1] + 'm';\\n  } else {\\n    return str;\\n  }\\n}\\n\\n\\nfunction stylizeNoColor(str, styleType) {\\n  return str;\\n}\\n\\n\\nfunction arrayToHash(array) {\\n  var hash = {};\\n\\n  array.forEach(function(val, idx) {\\n    hash[val] = true;\\n  });\\n\\n  return hash;\\n}\\n\\n\\nfunction formatValue(ctx, value, recurseTimes) {\\n  // Provide a hook for user-specified inspect functions.\\n  // Check that value is an object with an inspect function on it\\n  if (ctx.customInspect &&\\n      value &&\\n      isFunction(value.inspect) &&\\n      // Filter out the util module, it's inspect function is special\\n      value.inspect !== exports.inspect &&\\n      // Also filter out any prototype objects using the circular check.\\n      !(value.constructor && value.constructor.prototype === value)) {\\n    var ret = value.inspect(recurseTimes, ctx);\\n    if (!isString(ret)) {\\n      ret = formatValue(ctx, ret, recurseTimes);\\n    }\\n    return ret;\\n  }\\n\\n  // Primitive types cannot have properties\\n  var primitive = formatPrimitive(ctx, value);\\n  if (primitive) {\\n    return primitive;\\n  }\\n\\n  // Look up the keys of the object.\\n  var keys = Object.keys(value);\\n  var visibleKeys = arrayToHash(keys);\\n\\n  if (ctx.showHidden) {\\n    keys = Object.getOwnPropertyNames(value);\\n  }\\n\\n  // This could be a boxed primitive (new String(), etc.), check valueOf()\\n  // NOTE: Avoid calling `valueOf` on `Date` instance because it will return\\n  // a number which, when object has some additional user-stored `keys`,\\n  // will be printed out.\\n  var formatted;\\n  var raw = value;\\n  try {\\n    // the .valueOf() call can fail for a multitude of reasons\\n    if (!isDate(value))\\n      raw = value.valueOf();\\n  } catch (e) {\\n    // ignore...\\n  }\\n\\n  if (isString(raw)) {\\n    // for boxed Strings, we have to remove the 0-n indexed entries,\\n    // since they just noisey up the output and are redundant\\n    keys = keys.filter(function(key) {\\n      return !(key >= 0 && key < raw.length);\\n    });\\n  }\\n\\n  // Some type of object without properties can be shortcutted.\\n  if (keys.length === 0) {\\n    if (isFunction(value)) {\\n      var name = value.name ? ': ' + value.name : '';\\n      return ctx.stylize('[Function' + name + ']', 'special');\\n    }\\n    if (isRegExp(value)) {\\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\\n    }\\n    if (isDate(value)) {\\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\\n    }\\n    if (isError(value)) {\\n      return formatError(value);\\n    }\\n    // now check the `raw` value to handle boxed primitives\\n    if (isString(raw)) {\\n      formatted = formatPrimitiveNoColor(ctx, raw);\\n      return ctx.stylize('[String: ' + formatted + ']', 'string');\\n    }\\n    if (isNumber(raw)) {\\n      formatted = formatPrimitiveNoColor(ctx, raw);\\n      return ctx.stylize('[Number: ' + formatted + ']', 'number');\\n    }\\n    if (isBoolean(raw)) {\\n      formatted = formatPrimitiveNoColor(ctx, raw);\\n      return ctx.stylize('[Boolean: ' + formatted + ']', 'boolean');\\n    }\\n  }\\n\\n  var base = '', array = false, braces = ['{', '}'];\\n\\n  // Make Array say that they are Array\\n  if (isArray(value)) {\\n    array = true;\\n    braces = ['[', ']'];\\n  }\\n\\n  // Make functions say that they are functions\\n  if (isFunction(value)) {\\n    var n = value.name ? ': ' + value.name : '';\\n    base = ' [Function' + n + ']';\\n  }\\n\\n  // Make RegExps say that they are RegExps\\n  if (isRegExp(value)) {\\n    base = ' ' + RegExp.prototype.toString.call(value);\\n  }\\n\\n  // Make dates with properties first say the date\\n  if (isDate(value)) {\\n    base = ' ' + Date.prototype.toUTCString.call(value);\\n  }\\n\\n  // Make error with message first say the error\\n  if (isError(value)) {\\n    base = ' ' + formatError(value);\\n  }\\n\\n  // Make boxed primitive Strings look like such\\n  if (isString(raw)) {\\n    formatted = formatPrimitiveNoColor(ctx, raw);\\n    base = ' ' + '[String: ' + formatted + ']';\\n  }\\n\\n  // Make boxed primitive Numbers look like such\\n  if (isNumber(raw)) {\\n    formatted = formatPrimitiveNoColor(ctx, raw);\\n    base = ' ' + '[Number: ' + formatted + ']';\\n  }\\n\\n  // Make boxed primitive Booleans look like such\\n  if (isBoolean(raw)) {\\n    formatted = formatPrimitiveNoColor(ctx, raw);\\n    base = ' ' + '[Boolean: ' + formatted + ']';\\n  }\\n\\n  if (keys.length === 0 && (!array || value.length === 0)) {\\n    return braces[0] + base + braces[1];\\n  }\\n\\n  if (recurseTimes < 0) {\\n    if (isRegExp(value)) {\\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\\n    } else {\\n      return ctx.stylize('[Object]', 'special');\\n    }\\n  }\\n\\n  ctx.seen.push(value);\\n\\n  var output;\\n  if (array) {\\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\\n  } else {\\n    output = keys.map(function(key) {\\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\\n    });\\n  }\\n\\n  ctx.seen.pop();\\n\\n  return reduceToSingleString(output, base, braces);\\n}\\n\\n\\nfunction formatPrimitive(ctx, value) {\\n  if (isUndefined(value))\\n    return ctx.stylize('undefined', 'undefined');\\n  if (isString(value)) {\\n    var simple = '\\\\'' + JSON.stringify(value).replace(/^\\\"|\\\"$/g, '')\\n                                             .replace(/'/g, \\\"\\\\\\\\'\\\")\\n                                             .replace(/\\\\\\\\\\\"/g, '\\\"') + '\\\\'';\\n    return ctx.stylize(simple, 'string');\\n  }\\n  if (isNumber(value)) {\\n    // Format -0 as '-0'. Strict equality won't distinguish 0 from -0,\\n    // so instead we use the fact that 1 / -0 < 0 whereas 1 / 0 > 0 .\\n    if (value === 0 && 1 / value < 0)\\n      return ctx.stylize('-0', 'number');\\n    return ctx.stylize('' + value, 'number');\\n  }\\n  if (isBoolean(value))\\n    return ctx.stylize('' + value, 'boolean');\\n  // For some reason typeof null is \\\"object\\\", so special case here.\\n  if (isNull(value))\\n    return ctx.stylize('null', 'null');\\n\\n  if (typeof value !== 'object' && typeof value !== 'function')\\n    return ctx.stylize('[Pointer: ' + value + ']', 'string');\\n}\\n\\n\\nfunction formatPrimitiveNoColor(ctx, value) {\\n  var stylize = ctx.stylize;\\n  ctx.stylize = stylizeNoColor;\\n  var str = formatPrimitive(ctx, value);\\n  ctx.stylize = stylize;\\n  return str;\\n}\\n\\n\\nfunction formatError(value) {\\n  return '[' + Error.prototype.toString.call(value) + ']';\\n}\\n\\n\\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\\n  var output = [];\\n  for (var i = 0, l = value.length; i < l; ++i) {\\n    if (hasOwnProperty(value, String(i))) {\\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\\n          String(i), true));\\n    } else {\\n      output.push('');\\n    }\\n  }\\n  keys.forEach(function(key) {\\n    if (!key.match(/^\\\\d+$/)) {\\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\\n          key, true));\\n    }\\n  });\\n  return output;\\n}\\n\\n\\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\\n  var name, str, desc;\\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\\n  if (desc.get) {\\n    if (desc.set) {\\n      str = ctx.stylize('[Getter/Setter]', 'special');\\n    } else {\\n      str = ctx.stylize('[Getter]', 'special');\\n    }\\n  } else {\\n    if (desc.set) {\\n      str = ctx.stylize('[Setter]', 'special');\\n    }\\n  }\\n  if (!hasOwnProperty(visibleKeys, key)) {\\n    name = '[' + key + ']';\\n  }\\n  if (!str) {\\n    if (ctx.seen.indexOf(desc.value) < 0) {\\n      if (isNull(recurseTimes)) {\\n        str = formatValue(ctx, desc.value, null);\\n      } else {\\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\\n      }\\n      if (str.indexOf('\\\\n') > -1) {\\n        if (array) {\\n          str = str.split('\\\\n').map(function(line) {\\n            return '  ' + line;\\n          }).join('\\\\n').substr(2);\\n        } else {\\n          str = '\\\\n' + str.split('\\\\n').map(function(line) {\\n            return '   ' + line;\\n          }).join('\\\\n');\\n        }\\n      }\\n    } else {\\n      str = ctx.stylize('[Circular]', 'special');\\n    }\\n  }\\n  if (isUndefined(name)) {\\n    if (array && key.match(/^\\\\d+$/)) {\\n      return str;\\n    }\\n    name = JSON.stringify('' + key);\\n    if (name.match(/^\\\"([a-zA-Z_][a-zA-Z_0-9]*)\\\"$/)) {\\n      name = name.substr(1, name.length - 2);\\n      name = ctx.stylize(name, 'name');\\n    } else {\\n      name = name.replace(/'/g, \\\"\\\\\\\\'\\\")\\n                 .replace(/\\\\\\\\\\\"/g, '\\\"')\\n                 .replace(/(^\\\"|\\\"$)/g, \\\"'\\\")\\n                 .replace(/\\\\\\\\\\\\\\\\/g, '\\\\\\\\');\\n      name = ctx.stylize(name, 'string');\\n    }\\n  }\\n\\n  return name + ': ' + str;\\n}\\n\\n\\nfunction reduceToSingleString(output, base, braces) {\\n  var length = output.reduce(function(prev, cur) {\\n    return prev + cur.replace(/\\\\u001b\\\\[\\\\d\\\\d?m/g, '').length + 1;\\n  }, 0);\\n\\n  if (length > 60) {\\n    return braces[0] +\\n           (base === '' ? '' : base + '\\\\n ') +\\n           ' ' +\\n           output.join(',\\\\n  ') +\\n           ' ' +\\n           braces[1];\\n  }\\n\\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\\n}\\n\\n\\n// NOTE: These type checking functions intentionally don't use `instanceof`\\n// because it is fragile and can be easily faked with `Object.create()`.\\nvar isArray = exports.isArray = Array.isArray;\\n\\nfunction isBoolean(arg) {\\n  return typeof arg === 'boolean';\\n}\\nexports.isBoolean = isBoolean;\\n\\nfunction isNull(arg) {\\n  return arg === null;\\n}\\nexports.isNull = isNull;\\n\\nfunction isNullOrUndefined(arg) {\\n  return arg == null;\\n}\\nexports.isNullOrUndefined = isNullOrUndefined;\\n\\nfunction isNumber(arg) {\\n  return typeof arg === 'number';\\n}\\nexports.isNumber = isNumber;\\n\\nfunction isString(arg) {\\n  return typeof arg === 'string';\\n}\\nexports.isString = isString;\\n\\nfunction isSymbol(arg) {\\n  return typeof arg === 'symbol';\\n}\\nexports.isSymbol = isSymbol;\\n\\nfunction isUndefined(arg) {\\n  return arg === void 0;\\n}\\nexports.isUndefined = isUndefined;\\n\\nfunction isRegExp(re) {\\n  return isObject(re) && objectToString(re) === '[object RegExp]';\\n}\\nexports.isRegExp = isRegExp;\\n\\nfunction isObject(arg) {\\n  return typeof arg === 'object' && arg !== null;\\n}\\nexports.isObject = isObject;\\n\\nfunction isDate(d) {\\n  return isObject(d) && objectToString(d) === '[object Date]';\\n}\\nexports.isDate = isDate;\\n\\nfunction isError(e) {\\n  return isObject(e) &&\\n      (objectToString(e) === '[object Error]' || e instanceof Error);\\n}\\nexports.isError = isError;\\n\\nfunction isFunction(arg) {\\n  return typeof arg === 'function';\\n}\\nexports.isFunction = isFunction;\\n\\nfunction isPrimitive(arg) {\\n  return arg === null ||\\n         typeof arg === 'boolean' ||\\n         typeof arg === 'number' ||\\n         typeof arg === 'string' ||\\n         typeof arg === 'symbol' ||  // ES6 symbol\\n         typeof arg === 'undefined';\\n}\\nexports.isPrimitive = isPrimitive;\\n\\nfunction isBuffer(b) {\\n  return b instanceof Buffer;\\n}\\nexports.isBuffer = isBuffer;\\n\\nfunction objectToString(o) {\\n  return Object.prototype.toString.call(o);\\n}\\n\\n\\nfunction pad(n) {\\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\\n}\\n\\n\\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\\n              'Oct', 'Nov', 'Dec'];\\n\\n// 26 Feb 16:19:34\\nfunction timestamp() {\\n  var d = new Date();\\n  var time = [pad(d.getHours()),\\n              pad(d.getMinutes()),\\n              pad(d.getSeconds())].join(':');\\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\\n}\\n\\n\\n// log is just a thin wrapper to console.log that prepends a timestamp\\nexports.log = function() {\\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\\n};\\n\\n\\n/**\\n * Inherit the prototype methods from one constructor into another.\\n *\\n * The Function.prototype.inherits from lang.js rewritten as a standalone\\n * function (not on Function.prototype). NOTE: If this file is to be loaded\\n * during bootstrapping this function needs to be rewritten using some native\\n * functions as prototype setup using normal JavaScript does not work as\\n * expected during bootstrapping (see mirror.js in r114903).\\n *\\n * @param {function} ctor Constructor function which needs to inherit the\\n *     prototype.\\n * @param {function} superCtor Constructor function to inherit prototype from.\\n */\\nexports.inherits = function(ctor, superCtor) {\\n  ctor.super_ = superCtor;\\n  ctor.prototype = Object.create(superCtor.prototype, {\\n    constructor: {\\n      value: ctor,\\n      enumerable: false,\\n      writable: true,\\n      configurable: true\\n    }\\n  });\\n};\\n\\nexports._extend = function(origin, add) {\\n  // Don't do anything if add isn't an object\\n  if (!add || !isObject(add)) return origin;\\n\\n  var keys = Object.keys(add);\\n  var i = keys.length;\\n  while (i--) {\\n    origin[keys[i]] = add[keys[i]];\\n  }\\n  return origin;\\n};\\n\\nfunction hasOwnProperty(obj, prop) {\\n  return Object.prototype.hasOwnProperty.call(obj, prop);\\n}\\n\\n\\n//Deprecated old stuff.\\n\\nexports.p = exports.deprecate(function() {\\n  for (var i = 0, len = arguments.length; i < len; ++i) {\\n    console.error(exports.inspect(arguments[i]));\\n  }\\n}, 'util.p: Use console.error() instead');\\n\\n\\nexports.exec = exports.deprecate(function() {\\n  return require('child_process').exec.apply(this, arguments);\\n}, 'util.exec is now called `child_process.exec`.');\\n\\n\\nexports.print = exports.deprecate(function() {\\n  for (var i = 0, len = arguments.length; i < len; ++i) {\\n    process.stdout.write(String(arguments[i]));\\n  }\\n}, 'util.print: Use console.log instead');\\n\\n\\nexports.puts = exports.deprecate(function() {\\n  for (var i = 0, len = arguments.length; i < len; ++i) {\\n    process.stdout.write(arguments[i] + '\\\\n');\\n  }\\n}, 'util.puts: Use console.log instead');\\n\\n\\nexports.debug = exports.deprecate(function(x) {\\n  process.stderr.write('DEBUG: ' + x + '\\\\n');\\n}, 'util.debug: Use console.error instead');\\n\\n\\nexports.error = exports.deprecate(function(x) {\\n  for (var i = 0, len = arguments.length; i < len; ++i) {\\n    process.stderr.write(arguments[i] + '\\\\n');\\n  }\\n}, 'util.error: Use console.error instead');\\n\\n\\nexports.pump = exports.deprecate(function(readStream, writeStream, callback) {\\n  var callbackCalled = false;\\n\\n  function call(a, b, c) {\\n    if (callback && !callbackCalled) {\\n      callback(a, b, c);\\n      callbackCalled = true;\\n    }\\n  }\\n\\n  readStream.addListener('data', function(chunk) {\\n    if (writeStream.write(chunk) === false) readStream.pause();\\n  });\\n\\n  writeStream.addListener('drain', function() {\\n    readStream.resume();\\n  });\\n\\n  readStream.addListener('end', function() {\\n    writeStream.end();\\n  });\\n\\n  readStream.addListener('close', function() {\\n    call();\\n  });\\n\\n  readStream.addListener('error', function(err) {\\n    writeStream.end();\\n    call(err);\\n  });\\n\\n  writeStream.addListener('error', function(err) {\\n    readStream.destroy();\\n    call(err);\\n  });\\n}, 'util.pump(): Use readableStream.pipe() instead');\\n\\n\\nvar uv;\\nexports._errnoException = function(err, syscall, original) {\\n  if (isUndefined(uv)) uv = process.binding('uv');\\n  var errname = uv.errname(err);\\n  var message = syscall + ' ' + errname;\\n  if (original)\\n    message += ' ' + original;\\n  var e = new Error(message);\\n  e.code = errname;\\n  e.errno = errname;\\n  e.syscall = syscall;\\n  return e;\\n};\\n\",\"path\":\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n\\nvar isWindows = process.platform === 'win32';\\nvar util = require('util');\\n\\n\\n// resolves . and .. elements in a path array with directory names there\\n// must be no slashes, empty elements, or device names (c:\\\\) in the array\\n// (so also no leading and trailing slashes - it does not distinguish\\n// relative and absolute paths)\\nfunction normalizeArray(parts, allowAboveRoot) {\\n  // if the path tries to go above the root, `up` ends up > 0\\n  var up = 0;\\n  for (var i = parts.length - 1; i >= 0; i--) {\\n    var last = parts[i];\\n    if (last === '.') {\\n      parts.splice(i, 1);\\n    } else if (last === '..') {\\n      parts.splice(i, 1);\\n      up++;\\n    } else if (up) {\\n      parts.splice(i, 1);\\n      up--;\\n    }\\n  }\\n\\n  // if the path is allowed to go above the root, restore leading ..s\\n  if (allowAboveRoot) {\\n    for (; up--; up) {\\n      parts.unshift('..');\\n    }\\n  }\\n\\n  return parts;\\n}\\n\\n\\nif (isWindows) {\\n  // Regex to split a windows path into three parts: [*, device, slash,\\n  // tail] windows-only\\n  var splitDeviceRe =\\n      /^([a-zA-Z]:|[\\\\\\\\\\\\/]{2}[^\\\\\\\\\\\\/]+[\\\\\\\\\\\\/]+[^\\\\\\\\\\\\/]+)?([\\\\\\\\\\\\/])?([\\\\s\\\\S]*?)$/;\\n\\n  // Regex to split the tail part of the above into [*, dir, basename, ext]\\n  var splitTailRe =\\n      /^([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\\\\\\\\\/]+?|)(\\\\.[^.\\\\/\\\\\\\\]*|))(?:[\\\\\\\\\\\\/]*)$/;\\n\\n  // Function to split a filename into [root, dir, basename, ext]\\n  // windows version\\n  var splitPath = function(filename) {\\n    // Separate device+slash from tail\\n    var result = splitDeviceRe.exec(filename),\\n        device = (result[1] || '') + (result[2] || ''),\\n        tail = result[3] || '';\\n    // Split the tail into dir, basename and extension\\n    var result2 = splitTailRe.exec(tail),\\n        dir = result2[1],\\n        basename = result2[2],\\n        ext = result2[3];\\n    return [device, dir, basename, ext];\\n  };\\n\\n  var normalizeUNCRoot = function(device) {\\n    return '\\\\\\\\\\\\\\\\' + device.replace(/^[\\\\\\\\\\\\/]+/, '').replace(/[\\\\\\\\\\\\/]+/g, '\\\\\\\\');\\n  };\\n\\n  // path.resolve([from ...], to)\\n  // windows version\\n  exports.resolve = function() {\\n    var resolvedDevice = '',\\n        resolvedTail = '',\\n        resolvedAbsolute = false;\\n\\n    for (var i = arguments.length - 1; i >= -1; i--) {\\n      var path;\\n      if (i >= 0) {\\n        path = arguments[i];\\n      } else if (!resolvedDevice) {\\n        path = process.cwd();\\n      } else {\\n        // Windows has the concept of drive-specific current working\\n        // directories. If we've resolved a drive letter but not yet an\\n        // absolute path, get cwd for that drive. We're sure the device is not\\n        // an unc path at this points, because unc paths are always absolute.\\n        path = process.env['=' + resolvedDevice];\\n        // Verify that a drive-local cwd was found and that it actually points\\n        // to our drive. If not, default to the drive's root.\\n        if (!path || path.substr(0, 3).toLowerCase() !==\\n            resolvedDevice.toLowerCase() + '\\\\\\\\') {\\n          path = resolvedDevice + '\\\\\\\\';\\n        }\\n      }\\n\\n      // Skip empty and invalid entries\\n      if (!util.isString(path)) {\\n        throw new TypeError('Arguments to path.resolve must be strings');\\n      } else if (!path) {\\n        continue;\\n      }\\n\\n      var result = splitDeviceRe.exec(path),\\n          device = result[1] || '',\\n          isUnc = device && device.charAt(1) !== ':',\\n          isAbsolute = exports.isAbsolute(path),\\n          tail = result[3];\\n\\n      if (device &&\\n          resolvedDevice &&\\n          device.toLowerCase() !== resolvedDevice.toLowerCase()) {\\n        // This path points to another device so it is not applicable\\n        continue;\\n      }\\n\\n      if (!resolvedDevice) {\\n        resolvedDevice = device;\\n      }\\n      if (!resolvedAbsolute) {\\n        resolvedTail = tail + '\\\\\\\\' + resolvedTail;\\n        resolvedAbsolute = isAbsolute;\\n      }\\n\\n      if (resolvedDevice && resolvedAbsolute) {\\n        break;\\n      }\\n    }\\n\\n    // Convert slashes to backslashes when `resolvedDevice` points to an UNC\\n    // root. Also squash multiple slashes into a single one where appropriate.\\n    if (isUnc) {\\n      resolvedDevice = normalizeUNCRoot(resolvedDevice);\\n    }\\n\\n    // At this point the path should be resolved to a full absolute path,\\n    // but handle relative paths to be safe (might happen when process.cwd()\\n    // fails)\\n\\n    // Normalize the tail path\\n\\n    function f(p) {\\n      return !!p;\\n    }\\n\\n    resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\\\\\\\/]+/).filter(f),\\n                                  !resolvedAbsolute).join('\\\\\\\\');\\n\\n    return (resolvedDevice + (resolvedAbsolute ? '\\\\\\\\' : '') + resolvedTail) ||\\n           '.';\\n  };\\n\\n  // windows version\\n  exports.normalize = function(path) {\\n    var result = splitDeviceRe.exec(path),\\n        device = result[1] || '',\\n        isUnc = device && device.charAt(1) !== ':',\\n        isAbsolute = exports.isAbsolute(path),\\n        tail = result[3],\\n        trailingSlash = /[\\\\\\\\\\\\/]$/.test(tail);\\n\\n    // If device is a drive letter, we'll normalize to lower case.\\n    if (device && device.charAt(1) === ':') {\\n      device = device[0].toLowerCase() + device.substr(1);\\n    }\\n\\n    // Normalize the tail path\\n    tail = normalizeArray(tail.split(/[\\\\\\\\\\\\/]+/).filter(function(p) {\\n      return !!p;\\n    }), !isAbsolute).join('\\\\\\\\');\\n\\n    if (!tail && !isAbsolute) {\\n      tail = '.';\\n    }\\n    if (tail && trailingSlash) {\\n      tail += '\\\\\\\\';\\n    }\\n\\n    // Convert slashes to backslashes when `device` points to an UNC root.\\n    // Also squash multiple slashes into a single one where appropriate.\\n    if (isUnc) {\\n      device = normalizeUNCRoot(device);\\n    }\\n\\n    return device + (isAbsolute ? '\\\\\\\\' : '') + tail;\\n  };\\n\\n  // windows version\\n  exports.isAbsolute = function(path) {\\n    var result = splitDeviceRe.exec(path),\\n        device = result[1] || '',\\n        isUnc = !!device && device.charAt(1) !== ':';\\n    // UNC paths are always absolute\\n    return !!result[2] || isUnc;\\n  };\\n\\n  // windows version\\n  exports.join = function() {\\n    function f(p) {\\n      if (!util.isString(p)) {\\n        throw new TypeError('Arguments to path.join must be strings');\\n      }\\n      return p;\\n    }\\n\\n    var paths = Array.prototype.filter.call(arguments, f);\\n    var joined = paths.join('\\\\\\\\');\\n\\n    // Make sure that the joined path doesn't start with two slashes, because\\n    // normalize() will mistake it for an UNC path then.\\n    //\\n    // This step is skipped when it is very clear that the user actually\\n    // intended to point at an UNC path. This is assumed when the first\\n    // non-empty string arguments starts with exactly two slashes followed by\\n    // at least one more non-slash character.\\n    //\\n    // Note that for normalize() to treat a path as an UNC path it needs to\\n    // have at least 2 components, so we don't filter for that here.\\n    // This means that the user can use join to construct UNC paths from\\n    // a server name and a share name; for example:\\n    //   path.join('//server', 'share') -> '\\\\\\\\\\\\\\\\server\\\\\\\\share\\\\')\\n    if (!/^[\\\\\\\\\\\\/]{2}[^\\\\\\\\\\\\/]/.test(paths[0])) {\\n      joined = joined.replace(/^[\\\\\\\\\\\\/]{2,}/, '\\\\\\\\');\\n    }\\n\\n    return exports.normalize(joined);\\n  };\\n\\n  // path.relative(from, to)\\n  // it will solve the relative path from 'from' to 'to', for instance:\\n  // from = 'C:\\\\\\\\orandea\\\\\\\\test\\\\\\\\aaa'\\n  // to = 'C:\\\\\\\\orandea\\\\\\\\impl\\\\\\\\bbb'\\n  // The output of the function should be: '..\\\\\\\\..\\\\\\\\impl\\\\\\\\bbb'\\n  // windows version\\n  exports.relative = function(from, to) {\\n    from = exports.resolve(from);\\n    to = exports.resolve(to);\\n\\n    // windows is not case sensitive\\n    var lowerFrom = from.toLowerCase();\\n    var lowerTo = to.toLowerCase();\\n\\n    function trim(arr) {\\n      var start = 0;\\n      for (; start < arr.length; start++) {\\n        if (arr[start] !== '') break;\\n      }\\n\\n      var end = arr.length - 1;\\n      for (; end >= 0; end--) {\\n        if (arr[end] !== '') break;\\n      }\\n\\n      if (start > end) return [];\\n      return arr.slice(start, end + 1);\\n    }\\n\\n    var toParts = trim(to.split('\\\\\\\\'));\\n\\n    var lowerFromParts = trim(lowerFrom.split('\\\\\\\\'));\\n    var lowerToParts = trim(lowerTo.split('\\\\\\\\'));\\n\\n    var length = Math.min(lowerFromParts.length, lowerToParts.length);\\n    var samePartsLength = length;\\n    for (var i = 0; i < length; i++) {\\n      if (lowerFromParts[i] !== lowerToParts[i]) {\\n        samePartsLength = i;\\n        break;\\n      }\\n    }\\n\\n    if (samePartsLength == 0) {\\n      return to;\\n    }\\n\\n    var outputParts = [];\\n    for (var i = samePartsLength; i < lowerFromParts.length; i++) {\\n      outputParts.push('..');\\n    }\\n\\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\\n\\n    return outputParts.join('\\\\\\\\');\\n  };\\n\\n  exports.sep = '\\\\\\\\';\\n  exports.delimiter = ';';\\n\\n} else /* posix */ {\\n\\n  // Split a filename into [root, dir, basename, ext], unix version\\n  // 'root' is just a slash, or nothing.\\n  var splitPathRe =\\n      /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;\\n  var splitPath = function(filename) {\\n    return splitPathRe.exec(filename).slice(1);\\n  };\\n\\n  // path.resolve([from ...], to)\\n  // posix version\\n  exports.resolve = function() {\\n    var resolvedPath = '',\\n        resolvedAbsolute = false;\\n\\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\\n      var path = (i >= 0) ? arguments[i] : process.cwd();\\n\\n      // Skip empty and invalid entries\\n      if (!util.isString(path)) {\\n        throw new TypeError('Arguments to path.resolve must be strings');\\n      } else if (!path) {\\n        continue;\\n      }\\n\\n      resolvedPath = path + '/' + resolvedPath;\\n      resolvedAbsolute = path.charAt(0) === '/';\\n    }\\n\\n    // At this point the path should be resolved to a full absolute path, but\\n    // handle relative paths to be safe (might happen when process.cwd() fails)\\n\\n    // Normalize the path\\n    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {\\n      return !!p;\\n    }), !resolvedAbsolute).join('/');\\n\\n    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\\n  };\\n\\n  // path.normalize(path)\\n  // posix version\\n  exports.normalize = function(path) {\\n    var isAbsolute = exports.isAbsolute(path),\\n        trailingSlash = path[path.length - 1] === '/',\\n        segments = path.split('/'),\\n        nonEmptySegments = [];\\n\\n    // Normalize the path\\n    for (var i = 0; i < segments.length; i++) {\\n      if (segments[i]) {\\n        nonEmptySegments.push(segments[i]);\\n      }\\n    }\\n    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');\\n\\n    if (!path && !isAbsolute) {\\n      path = '.';\\n    }\\n    if (path && trailingSlash) {\\n      path += '/';\\n    }\\n\\n    return (isAbsolute ? '/' : '') + path;\\n  };\\n\\n  // posix version\\n  exports.isAbsolute = function(path) {\\n    return path.charAt(0) === '/';\\n  };\\n\\n  // posix version\\n  exports.join = function() {\\n    var path = '';\\n    for (var i = 0; i < arguments.length; i++) {\\n      var segment = arguments[i];\\n      if (!util.isString(segment)) {\\n        throw new TypeError('Arguments to path.join must be strings');\\n      }\\n      if (segment) {\\n        if (!path) {\\n          path += segment;\\n        } else {\\n          path += '/' + segment;\\n        }\\n      }\\n    }\\n    return exports.normalize(path);\\n  };\\n\\n\\n  // path.relative(from, to)\\n  // posix version\\n  exports.relative = function(from, to) {\\n    from = exports.resolve(from).substr(1);\\n    to = exports.resolve(to).substr(1);\\n\\n    function trim(arr) {\\n      var start = 0;\\n      for (; start < arr.length; start++) {\\n        if (arr[start] !== '') break;\\n      }\\n\\n      var end = arr.length - 1;\\n      for (; end >= 0; end--) {\\n        if (arr[end] !== '') break;\\n      }\\n\\n      if (start > end) return [];\\n      return arr.slice(start, end + 1);\\n    }\\n\\n    var fromParts = trim(from.split('/'));\\n    var toParts = trim(to.split('/'));\\n\\n    var length = Math.min(fromParts.length, toParts.length);\\n    var samePartsLength = length;\\n    for (var i = 0; i < length; i++) {\\n      if (fromParts[i] !== toParts[i]) {\\n        samePartsLength = i;\\n        break;\\n      }\\n    }\\n\\n    var outputParts = [];\\n    for (var i = samePartsLength; i < fromParts.length; i++) {\\n      outputParts.push('..');\\n    }\\n\\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\\n\\n    return outputParts.join('/');\\n  };\\n\\n  exports.sep = '/';\\n  exports.delimiter = ':';\\n}\\n\\nexports.dirname = function(path) {\\n  var result = splitPath(path),\\n      root = result[0],\\n      dir = result[1];\\n\\n  if (!root && !dir) {\\n    // No dirname whatsoever\\n    return '.';\\n  }\\n\\n  if (dir) {\\n    // It has a dirname, strip trailing slash\\n    dir = dir.substr(0, dir.length - 1);\\n  }\\n\\n  return root + dir;\\n};\\n\\n\\nexports.basename = function(path, ext) {\\n  var f = splitPath(path)[2];\\n  // TODO: make this comparison case-insensitive on windows?\\n  if (ext && f.substr(-1 * ext.length) === ext) {\\n    f = f.substr(0, f.length - ext.length);\\n  }\\n  return f;\\n};\\n\\n\\nexports.extname = function(path) {\\n  return splitPath(path)[3];\\n};\\n\\n\\nexports.exists = util.deprecate(function(path, callback) {\\n  require('fs').exists(path, callback);\\n}, 'path.exists is now called `fs.exists`.');\\n\\n\\nexports.existsSync = util.deprecate(function(path) {\\n  return require('fs').existsSync(path);\\n}, 'path.existsSync is now called `fs.existsSync`.');\\n\\n\\nif (isWindows) {\\n  exports._makeLong = function(path) {\\n    // Note: this will *probably* throw somewhere.\\n    if (!util.isString(path))\\n      return path;\\n\\n    if (!path) {\\n      return '';\\n    }\\n\\n    var resolvedPath = exports.resolve(path);\\n\\n    if (/^[a-zA-Z]\\\\:\\\\\\\\/.test(resolvedPath)) {\\n      // path is local filesystem path, which needs to be converted\\n      // to long UNC path.\\n      return '\\\\\\\\\\\\\\\\?\\\\\\\\' + resolvedPath;\\n    } else if (/^\\\\\\\\\\\\\\\\[^?.]/.test(resolvedPath)) {\\n      // path is network UNC path, which needs to be converted\\n      // to long UNC path.\\n      return '\\\\\\\\\\\\\\\\?\\\\\\\\UNC\\\\\\\\' + resolvedPath.substring(2);\\n    }\\n\\n    return path;\\n  };\\n} else {\\n  exports._makeLong = function(path) {\\n    return path;\\n  };\\n}\\n\",\"fs\":\"// Maintainers, keep in mind that ES1-style octal literals (`0666`) are not\\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\\n\\n//changes const => var\\n//changes 0o666 => 438 [octal represntation]\\n\\n'use strict';\\n\\nvar SlowBuffer = require('buffer').SlowBuffer;\\nvar util = require('util');\\nvar pathModule = require('path');\\n\\nvar binding = process.binding('fs_wrap');\\nvar constants = require('constants');\\nvar fs = exports;\\nvar Buffer = require('buffer').Buffer;\\nvar Stream = require('stream').Stream;\\nvar EventEmitter = require('events');\\nvar FSReqWrap = binding.FSReqWrap;\\nvar FSEvent = process.binding('fs_event_wrap').FSEvent;\\n\\nvar Readable = Stream.Readable;\\nvar Writable = Stream.Writable;\\n\\nvar kMinPoolSpace = 128;\\nvar kMaxLength = require('buffer').kMaxLength;\\n\\nvar O_APPEND = constants.O_APPEND || 0;\\nvar O_CREAT = constants.O_CREAT || 0;\\nvar O_EXCL = constants.O_EXCL || 0;\\nvar O_RDONLY = constants.O_RDONLY || 0;\\nvar O_RDWR = constants.O_RDWR || 0;\\nvar O_SYNC = constants.O_SYNC || 0;\\nvar O_TRUNC = constants.O_TRUNC || 0;\\nvar O_WRONLY = constants.O_WRONLY || 0;\\n\\nvar isWindows = process.platform === 'win32';\\n\\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\\nvar errnoException = util._errnoException;\\n\\nfunction throwOptionsError(options) {\\n  throw new TypeError('Expected options to be either an object or a string, ' +\\n    'but got ' + typeof options + ' instead');\\n}\\n\\nfunction rethrow() {\\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\\n  // is fairly slow to generate.\\n  if (DEBUG) {\\n    var backtrace = new Error();\\n    return function(err) {\\n      if (err) {\\n        backtrace.stack = err.name + ': ' + err.message +\\n                          backtrace.stack.substr(backtrace.name.length);\\n        throw backtrace;\\n      }\\n    };\\n  }\\n\\n  return function(err) {\\n    if (err) {\\n      throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\\n    }\\n  };\\n}\\n\\nfunction maybeCallback(cb) {\\n  return typeof cb === 'function' ? cb : rethrow();\\n}\\n\\n// Ensure that callbacks run in the global context. Only use this function\\n// for callbacks that are passed to the binding layer, callbacks that are\\n// invoked from JS already run in the proper scope.\\nfunction makeCallback(cb) {\\n  if (cb === undefined) {\\n    return rethrow();\\n  }\\n\\n  if (typeof cb !== 'function') {\\n    throw new TypeError('callback must be a function');\\n  }\\n\\n  return function() {\\n    return cb.apply(null, arguments);\\n  };\\n}\\n\\nfunction assertEncoding(encoding) {\\n  if (encoding && !Buffer.isEncoding(encoding)) {\\n    throw new Error('Unknown encoding: ' + encoding);\\n  }\\n}\\n\\nfunction nullCheck(path, callback) {\\n  if (('' + path).indexOf('\\\\u0000') !== -1) {\\n    var er = new Error('Path must be a string without null bytes.');\\n    er.code = 'ENOENT';\\n    if (typeof callback !== 'function')\\n      throw er;\\n    process.nextTick(callback, er);\\n    return false;\\n  }\\n  return true;\\n}\\n\\nfunction isFd(path) {\\n  return (path >>> 0) === path;\\n}\\n\\n// Static method to set the stats properties on a Stats object.\\nfs.Stats = function(\\n    dev,\\n    mode,\\n    nlink,\\n    uid,\\n    gid,\\n    rdev,\\n    blksize,\\n    ino,\\n    size,\\n    blocks,\\n    atim_msec,\\n    mtim_msec,\\n    ctim_msec,\\n    birthtim_msec) {\\n  this.dev = dev;\\n  this.mode = mode;\\n  this.nlink = nlink;\\n  this.uid = uid;\\n  this.gid = gid;\\n  this.rdev = rdev;\\n  this.blksize = blksize;\\n  this.ino = ino;\\n  this.size = size;\\n  this.blocks = blocks;\\n  this.atime = new Date(atim_msec);\\n  this.mtime = new Date(mtim_msec);\\n  this.ctime = new Date(ctim_msec);\\n  this.birthtime = new Date(birthtim_msec);\\n};\\n\\n// Create a C++ binding to the function which creates a Stats object.\\nbinding.FSInitialize(fs.Stats);\\n\\nfs.Stats.prototype._checkModeProperty = function(property) {\\n  return ((this.mode & constants.S_IFMT) === property);\\n};\\n\\nfs.Stats.prototype.isDirectory = function() {\\n  return this._checkModeProperty(constants.S_IFDIR);\\n};\\n\\nfs.Stats.prototype.isFile = function() {\\n  return this._checkModeProperty(constants.S_IFREG);\\n};\\n\\nfs.Stats.prototype.isBlockDevice = function() {\\n  return this._checkModeProperty(constants.S_IFBLK);\\n};\\n\\nfs.Stats.prototype.isCharacterDevice = function() {\\n  return this._checkModeProperty(constants.S_IFCHR);\\n};\\n\\nfs.Stats.prototype.isSymbolicLink = function() {\\n  return this._checkModeProperty(constants.S_IFLNK);\\n};\\n\\nfs.Stats.prototype.isFIFO = function() {\\n  return this._checkModeProperty(constants.S_IFIFO);\\n};\\n\\nfs.Stats.prototype.isSocket = function() {\\n  return this._checkModeProperty(constants.S_IFSOCK);\\n};\\n\\n// Don't allow mode to accidentally be overwritten.\\n['F_OK', 'R_OK', 'W_OK', 'X_OK'].forEach(function(key) {\\n  Object.defineProperty(fs, key, {\\n    enumerable: true, value: constants[key] || 0, writable: false\\n  });\\n});\\n\\nfs.access = function(path, mode, callback) {\\n  if (typeof mode === 'function') {\\n    callback = mode;\\n    mode = fs.F_OK;\\n  } else if (typeof callback !== 'function') {\\n    throw new TypeError('callback must be a function');\\n  }\\n\\n  if (!nullCheck(path, callback))\\n    return;\\n\\n  mode = mode | 0;\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.access(pathModule._makeLong(path), mode, req);\\n};\\n\\nfs.accessSync = function(path, mode) {\\n  nullCheck(path);\\n\\n  if (mode === undefined)\\n    mode = fs.F_OK;\\n  else\\n    mode = mode | 0;\\n\\n  binding.access(pathModule._makeLong(path), mode);\\n};\\n\\nfs.exists = function(path, callback) {\\n  if (!nullCheck(path, cb)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = cb;\\n  binding.stat(pathModule._makeLong(path), req);\\n  function cb(err, stats) {\\n    if (callback) callback(err ? false : true);\\n  }\\n};\\n\\nfs.existsSync = function(path) {\\n  try {\\n    nullCheck(path);\\n    binding.stat(pathModule._makeLong(path));\\n    return true;\\n  } catch (e) {\\n    return false;\\n  }\\n};\\n\\nfs.readFile = function(path, options, callback_) {\\n  var callback = maybeCallback(arguments[arguments.length - 1]);\\n\\n  if (!options || typeof options === 'function') {\\n    options = { encoding: null, flag: 'r' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, flag: 'r' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  var encoding = options.encoding;\\n  assertEncoding(encoding);\\n\\n  var flag = options.flag || 'r';\\n\\n  if (!nullCheck(path, callback))\\n    return;\\n\\n  var context = new ReadFileContext(callback, encoding);\\n  context.isUserFd = isFd(path); // file descriptor ownership\\n  var req = new FSReqWrap();\\n  req.context = context;\\n  req.oncomplete = readFileAfterOpen;\\n\\n  if (context.isUserFd) {\\n    process.nextTick(function() {\\n      req.oncomplete(null, path);\\n    });\\n    return;\\n  }\\n\\n  binding.open(pathModule._makeLong(path),\\n               stringToFlags(flag),\\n               438,\\n               req);\\n};\\n\\nvar kReadFileBufferLength = 8 * 1024;\\n\\nfunction ReadFileContext(callback, encoding) {\\n  this.fd = undefined;\\n  this.isUserFd = undefined;\\n  this.size = undefined;\\n  this.callback = callback;\\n  this.buffers = null;\\n  this.buffer = null;\\n  this.pos = 0;\\n  this.encoding = encoding;\\n  this.err = null;\\n}\\n\\nReadFileContext.prototype.read = function() {\\n  var buffer;\\n  var offset;\\n  var length;\\n\\n  if (this.size === 0) {\\n    buffer = this.buffer = new SlowBuffer(kReadFileBufferLength);\\n    offset = 0;\\n    length = kReadFileBufferLength;\\n  } else {\\n    buffer = this.buffer;\\n    offset = this.pos;\\n    length = this.size - this.pos;\\n  }\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = readFileAfterRead;\\n  req.context = this;\\n\\n  binding.read(this.fd, buffer, offset, length, -1, req);\\n};\\n\\nReadFileContext.prototype.close = function(err) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = readFileAfterClose;\\n  req.context = this;\\n  this.err = err;\\n\\n  if (this.isUserFd) {\\n    process.nextTick(function() {\\n      req.oncomplete(null);\\n    });\\n    return;\\n  }\\n\\n  binding.close(this.fd, req);\\n};\\n\\nfunction readFileAfterOpen(err, fd) {\\n  var context = this.context;\\n\\n  if (err) {\\n    context.callback(err);\\n    return;\\n  }\\n\\n  context.fd = fd;\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = readFileAfterStat;\\n  req.context = context;\\n  binding.fstat(fd, req);\\n}\\n\\nfunction readFileAfterStat(err, st) {\\n  var context = this.context;\\n\\n  if (err)\\n    return context.close(err);\\n\\n  var size = context.size = st.isFile() ? st.size : 0;\\n\\n  if (size === 0) {\\n    context.buffers = [];\\n    context.read();\\n    return;\\n  }\\n\\n  if (size > kMaxLength) {\\n    err = new RangeError('File size is greater than possible Buffer: ');\\n    // err = new RangeError('File size is greater than possible Buffer: ' +\\n    //                      `0x${kMaxLength.toString(16)} bytes`);\\n    return context.close(err);\\n  }\\n\\n  context.buffer = new SlowBuffer(size);\\n  context.read();\\n}\\n\\nfunction readFileAfterRead(err, bytesRead) {\\n  var context = this.context;\\n\\n  if (err)\\n    return context.close(err);\\n\\n  if (bytesRead === 0)\\n    return context.close();\\n\\n  context.pos += bytesRead;\\n\\n  if (context.size !== 0) {\\n    if (context.pos === context.size)\\n      context.close();\\n    else\\n      context.read();\\n  } else {\\n    // unknown size, just read until we don't get bytes.\\n    context.buffers.push(context.buffer.slice(0, bytesRead));\\n    context.read();\\n  }\\n}\\n\\nfunction readFileAfterClose(err) {\\n  var context = this.context;\\n  var buffer = null;\\n  var callback = context.callback;\\n\\n  if (context.err)\\n    return callback(context.err);\\n\\n  if (context.size === 0)\\n    buffer = Buffer.concat(context.buffers, context.pos);\\n  else if (context.pos < context.size)\\n    buffer = context.buffer.slice(0, context.pos);\\n  else\\n    buffer = context.buffer;\\n\\n  if (err) return callback(err, buffer);\\n\\n  if (context.encoding) {\\n    return tryToString(buffer, context.encoding, callback);\\n  }\\n\\n  callback(null, buffer);\\n}\\n\\nfunction tryToString(buf, encoding, callback) {\\n  var e = null;\\n  try {\\n    buf = buf.toString(encoding);\\n  } catch (err) {\\n    e = err;\\n  }\\n  callback(e, buf);\\n}\\n\\nfs.readFileSync = function(path, options) {\\n  if (!options) {\\n    options = { encoding: null, flag: 'r' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, flag: 'r' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  var encoding = options.encoding;\\n  assertEncoding(encoding);\\n\\n  var flag = options.flag || 'r';\\n  var isUserFd = isFd(path); // file descriptor ownership\\n  var fd = isUserFd ? path : fs.openSync(path, flag, 438);\\n\\n  var st;\\n  var size;\\n  var threw = true;\\n  try {\\n    st = fs.fstatSync(fd);\\n    size = st.isFile() ? st.size : 0;\\n    threw = false;\\n  } finally {\\n    if (threw && !isUserFd) fs.closeSync(fd);\\n  }\\n\\n  var pos = 0;\\n  var buffer; // single buffer with file data\\n  var buffers; // list for when size is unknown\\n\\n  if (size === 0) {\\n    buffers = [];\\n  } else {\\n    threw = true;\\n    try {\\n      buffer = Buffer(size);\\n      threw = false;\\n    } finally {\\n      if (threw && !isUserFd) fs.closeSync(fd);\\n    }\\n  }\\n\\n  var done = false;\\n  var bytesRead;\\n\\n  while (!done) {\\n    threw = true;\\n    try {\\n      if (size !== 0) {\\n        bytesRead = fs.readSync(fd, buffer, pos, size - pos);\\n      } else {\\n        // the kernel lies about many files.\\n        // Go ahead and try to read some bytes.\\n        buffer = Buffer(8192);\\n        bytesRead = fs.readSync(fd, buffer, 0, 8192);\\n        if (bytesRead) {\\n          buffers.push(buffer.slice(0, bytesRead));\\n        }\\n      }\\n      threw = false;\\n    } finally {\\n      if (threw && !isUserFd) fs.closeSync(fd);\\n    }\\n\\n    pos += bytesRead;\\n    done = (bytesRead === 0) || (size !== 0 && pos >= size);\\n  }\\n\\n  if (!isUserFd)\\n    fs.closeSync(fd);\\n\\n  if (size === 0) {\\n    // data was collected into the buffers list.\\n    buffer = Buffer.concat(buffers, pos);\\n  } else if (pos < size) {\\n    buffer = buffer.slice(0, pos);\\n  }\\n\\n  if (encoding) buffer = buffer.toString(encoding);\\n  return buffer;\\n};\\n\\n\\n// Used by binding.open and friends\\nfunction stringToFlags(flag) {\\n  // Only mess with strings\\n  if (typeof flag !== 'string') {\\n    return flag;\\n  }\\n\\n  switch (flag) {\\n    case 'r' : return O_RDONLY;\\n    case 'rs' : // fall through\\n    case 'sr' : return O_RDONLY | O_SYNC;\\n    case 'r+' : return O_RDWR;\\n    case 'rs+' : // fall through\\n    case 'sr+' : return O_RDWR | O_SYNC;\\n\\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\\n    case 'wx' : // fall through\\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\\n\\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\\n    case 'wx+': // fall through\\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\\n\\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\\n    case 'ax' : // fall through\\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\\n\\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\\n    case 'ax+': // fall through\\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\\n  }\\n\\n  throw new Error('Unknown file open flag: ' + flag);\\n}\\n\\n// exported but hidden, only used by test/simple/test-fs-open-flags.js\\nObject.defineProperty(exports, '_stringToFlags', {\\n  enumerable: false,\\n  value: stringToFlags\\n});\\n\\n\\n// Yes, the follow could be easily DRYed up but I provide the explicit\\n// list to make the arguments clear.\\n\\nfs.close = function(fd, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.close(fd, req);\\n};\\n\\nfs.closeSync = function(fd) {\\n  return binding.close(fd);\\n};\\n\\nfunction modeNum(m, def) {\\n  if (typeof m === 'number')\\n    return m;\\n  if (typeof m === 'string')\\n    return parseInt(m, 8);\\n  if (def)\\n    return modeNum(def);\\n  return undefined;\\n}\\n\\nfs.open = function(path, flags, mode, callback_) {\\n  var callback = makeCallback(arguments[arguments.length - 1]);\\n  mode = modeNum(mode, 438);\\n\\n  if (!nullCheck(path, callback)) return;\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n\\n  binding.open(pathModule._makeLong(path),\\n               stringToFlags(flags),\\n               mode,\\n               req);\\n};\\n\\nfs.openSync = function(path, flags, mode) {\\n  mode = modeNum(mode, 438);\\n  nullCheck(path);\\n  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);\\n};\\n\\nfs.read = function(fd, buffer, offset, length, position, callback) {\\n  if (!(Buffer.isBuffer(buffer))) {\\n    // legacy string interface (fd, length, position, encoding, callback)\\n    var cb = arguments[4],\\n        encoding = arguments[3];\\n\\n    assertEncoding(encoding);\\n\\n    position = arguments[2];\\n    length = arguments[1];\\n    buffer = Buffer(length);\\n    offset = 0;\\n\\n    callback = function(err, bytesRead) {\\n      if (!cb) return;\\n      if (err) return cb(err);\\n\\n      if (bytesRead > 0) {\\n        tryToStringWithEnd(buffer, encoding, bytesRead, cb);\\n      } else {\\n        (cb)(err, '', bytesRead);\\n      }\\n    };\\n  }\\n\\n  function wrapper(err, bytesRead) {\\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\\n    callback && callback(err, bytesRead || 0, buffer);\\n  }\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = wrapper;\\n\\n  binding.read(fd, buffer, offset, length, position, req);\\n};\\n\\nfunction tryToStringWithEnd(buf, encoding, end, callback) {\\n  var e;\\n  try {\\n    buf = buf.toString(encoding, 0, end);\\n  } catch (err) {\\n    e = err;\\n  }\\n  callback(e, buf, end);\\n}\\n\\nfs.readSync = function(fd, buffer, offset, length, position) {\\n  var legacy = false;\\n  var encoding;\\n\\n  if (!(util.isBuffer(buffer))) {\\n    // legacy string interface (fd, length, position, encoding, callback)\\n    legacy = true;\\n    encoding = arguments[3];\\n\\n    assertEncoding(encoding);\\n\\n    position = arguments[2];\\n    length = arguments[1];\\n    buffer = Buffer(length);\\n\\n    offset = 0;\\n  }\\n\\n  var r = binding.read(fd, buffer, offset, length, position);\\n  if (!legacy) {\\n    return r;\\n  }\\n\\n  var str = (r > 0) ? buffer.toString(encoding, 0, r) : '';\\n  return [str, r];\\n};\\n\\n// usage:\\n//  fs.write(fd, buffer, offset, length[, position], callback);\\n// OR\\n//  fs.write(fd, string[, position[, encoding]], callback);\\nfs.write = function(fd, buffer, offset, length, position, callback) {\\n  function wrapper(err, written) {\\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\\n    callback(err, written || 0, buffer);\\n  }\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = wrapper;\\n\\n  if (util.isBuffer(buffer)) {\\n    // if no position is passed then assume null\\n    if (typeof position === 'function') {\\n      callback = position;\\n      position = null;\\n    }\\n    callback = maybeCallback(callback);\\n    return binding.writeBuffer(fd, buffer, offset, length, position, req);\\n  }\\n\\n  if (typeof buffer !== 'string')\\n    buffer += '';\\n  if (typeof position !== 'function') {\\n    if (typeof offset === 'function') {\\n      position = offset;\\n      offset = null;\\n    } else {\\n      position = length;\\n    }\\n    length = 'utf8';\\n  }\\n  callback = maybeCallback(position);\\n  return binding.writeString(fd, buffer, offset, length, req);\\n};\\n\\n// usage:\\n//  fs.writeSync(fd, buffer, offset, length[, position]);\\n// OR\\n//  fs.writeSync(fd, string[, position[, encoding]]);\\nfs.writeSync = function(fd, buffer, offset, length, position) {\\n  if (util.isBuffer(buffer)) {\\n    if (position === undefined)\\n      position = null;\\n    return binding.writeBuffer(fd, buffer, offset, length, position);\\n  }\\n  if (typeof buffer !== 'string')\\n    buffer += '';\\n  if (offset === undefined)\\n    offset = null;\\n  return binding.writeString(fd, buffer, offset, length, position);\\n};\\n\\nfs.rename = function(oldPath, newPath, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(oldPath, callback)) return;\\n  if (!nullCheck(newPath, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.rename(pathModule._makeLong(oldPath),\\n                 pathModule._makeLong(newPath),\\n                 req);\\n};\\n\\nfs.renameSync = function(oldPath, newPath) {\\n  nullCheck(oldPath);\\n  nullCheck(newPath);\\n  return binding.rename(pathModule._makeLong(oldPath),\\n                        pathModule._makeLong(newPath));\\n};\\n\\nfs.truncate = function(path, len, callback) {\\n  if (typeof path === 'number') {\\n    return fs.ftruncate(path, len, callback);\\n  }\\n  if (typeof len === 'function') {\\n    callback = len;\\n    len = 0;\\n  } else if (len === undefined) {\\n    len = 0;\\n  }\\n\\n  callback = maybeCallback(callback);\\n  fs.open(path, 'r+', function(er, fd) {\\n    if (er) return callback(er);\\n    var req = new FSReqWrap();\\n    req.oncomplete = function ftruncateCb(er) {\\n      fs.close(fd, function(er2) {\\n        callback(er || er2);\\n      });\\n    };\\n    binding.ftruncate(fd, len, req);\\n  });\\n};\\n\\nfs.truncateSync = function(path, len) {\\n  if (typeof path === 'number') {\\n    // legacy\\n    return fs.ftruncateSync(path, len);\\n  }\\n  if (len === undefined) {\\n    len = 0;\\n  }\\n  // allow error to be thrown, but still close fd.\\n  var fd = fs.openSync(path, 'r+');\\n  var ret;\\n\\n  try {\\n    ret = fs.ftruncateSync(fd, len);\\n  } finally {\\n    fs.closeSync(fd);\\n  }\\n  return ret;\\n};\\n\\nfs.ftruncate = function(fd, len, callback) {\\n  if (typeof len === 'function') {\\n    callback = len;\\n    len = 0;\\n  } else if (len === undefined) {\\n    len = 0;\\n  }\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.ftruncate(fd, len, req);\\n};\\n\\nfs.ftruncateSync = function(fd, len) {\\n  if (len === undefined) {\\n    len = 0;\\n  }\\n  return binding.ftruncate(fd, len);\\n};\\n\\nfs.rmdir = function(path, callback) {\\n  callback = maybeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.rmdir(pathModule._makeLong(path), req);\\n};\\n\\nfs.rmdirSync = function(path) {\\n  nullCheck(path);\\n  return binding.rmdir(pathModule._makeLong(path));\\n};\\n\\nfs.fdatasync = function(fd, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fdatasync(fd, req);\\n};\\n\\nfs.fdatasyncSync = function(fd) {\\n  return binding.fdatasync(fd);\\n};\\n\\nfs.fsync = function(fd, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fsync(fd, req);\\n};\\n\\nfs.fsyncSync = function(fd) {\\n  return binding.fsync(fd);\\n};\\n\\nfs.mkdir = function(path, mode, callback) {\\n  if (typeof mode === 'function') callback = mode;\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.mkdir(pathModule._makeLong(path),\\n                modeNum(mode, 511),\\n                req);\\n};\\n\\nfs.mkdirSync = function(path, mode) {\\n  nullCheck(path);\\n  return binding.mkdir(pathModule._makeLong(path),\\n                       modeNum(mode, 511));\\n};\\n\\nfs.readdir = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.readdir(pathModule._makeLong(path), req);\\n};\\n\\nfs.readdirSync = function(path) {\\n  nullCheck(path);\\n  return binding.readdir(pathModule._makeLong(path));\\n};\\n\\nfs.fstat = function(fd, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fstat(fd, req);\\n};\\n\\nfs.lstat = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.lstat(pathModule._makeLong(path), req);\\n};\\n\\nfs.stat = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.stat(pathModule._makeLong(path), req);\\n};\\n\\nfs.fstatSync = function(fd) {\\n  return binding.fstat(fd);\\n};\\n\\nfs.lstatSync = function(path) {\\n  nullCheck(path);\\n  return binding.lstat(pathModule._makeLong(path));\\n};\\n\\nfs.statSync = function(path) {\\n  nullCheck(path);\\n  return binding.stat(pathModule._makeLong(path));\\n};\\n\\nfs.readlink = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.readlink(pathModule._makeLong(path), req);\\n};\\n\\nfs.readlinkSync = function(path) {\\n  nullCheck(path);\\n  return binding.readlink(pathModule._makeLong(path));\\n};\\n\\nfunction preprocessSymlinkDestination(path, type, linkPath) {\\n  if (!isWindows) {\\n    // No preprocessing is needed on Unix.\\n    return path;\\n  } else if (type === 'junction') {\\n    // Junctions paths need to be absolute and \\\\\\\\?\\\\-prefixed.\\n    // A relative target is relative to the link's parent directory.\\n    path = pathModule.resolve(linkPath, '..', path);\\n    return pathModule._makeLong(path);\\n  } else {\\n    // Windows symlinks don't tolerate forward slashes.\\n    return ('' + path).replace(/\\\\//g, '\\\\\\\\');\\n  }\\n}\\n\\nfs.symlink = function(target, path, type_, callback_) {\\n  var type = (typeof type_ === 'string' ? type_ : null);\\n  var callback = makeCallback(arguments[arguments.length - 1]);\\n\\n  if (!nullCheck(target, callback)) return;\\n  if (!nullCheck(path, callback)) return;\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n\\n  binding.symlink(preprocessSymlinkDestination(target, type, path),\\n                  pathModule._makeLong(path),\\n                  type,\\n                  req);\\n};\\n\\nfs.symlinkSync = function(target, path, type) {\\n  type = (typeof type === 'string' ? type : null);\\n\\n  nullCheck(target);\\n  nullCheck(path);\\n\\n  return binding.symlink(preprocessSymlinkDestination(target, type, path),\\n                         pathModule._makeLong(path),\\n                         type);\\n};\\n\\nfs.link = function(srcpath, dstpath, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(srcpath, callback)) return;\\n  if (!nullCheck(dstpath, callback)) return;\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n\\n  binding.link(pathModule._makeLong(srcpath),\\n               pathModule._makeLong(dstpath),\\n               req);\\n};\\n\\nfs.linkSync = function(srcpath, dstpath) {\\n  nullCheck(srcpath);\\n  nullCheck(dstpath);\\n  return binding.link(pathModule._makeLong(srcpath),\\n                      pathModule._makeLong(dstpath));\\n};\\n\\nfs.unlink = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.unlink(pathModule._makeLong(path), req);\\n};\\n\\nfs.unlinkSync = function(path) {\\n  nullCheck(path);\\n  return binding.unlink(pathModule._makeLong(path));\\n};\\n\\nfs.fchmod = function(fd, mode, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fchmod(fd, modeNum(mode), req);\\n};\\n\\nfs.fchmodSync = function(fd, mode) {\\n  return binding.fchmod(fd, modeNum(mode));\\n};\\n\\nif (constants.hasOwnProperty('O_SYMLINK')) {\\n  fs.lchmod = function(path, mode, callback) {\\n    callback = maybeCallback(callback);\\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\\n      if (err) {\\n        callback(err);\\n        return;\\n      }\\n      // prefer to return the chmod error, if one occurs,\\n      // but still try to close, and report closing errors if they occur.\\n      fs.fchmod(fd, mode, function(err) {\\n        fs.close(fd, function(err2) {\\n          callback(err || err2);\\n        });\\n      });\\n    });\\n  };\\n\\n  fs.lchmodSync = function(path, mode) {\\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\\n\\n    // prefer to return the chmod error, if one occurs,\\n    // but still try to close, and report closing errors if they occur.\\n    var err, err2, ret;\\n    try {\\n      ret = fs.fchmodSync(fd, mode);\\n    } catch (er) {\\n      err = er;\\n    }\\n    try {\\n      fs.closeSync(fd);\\n    } catch (er) {\\n      err2 = er;\\n    }\\n    if (err || err2) throw (err || err2);\\n    return ret;\\n  };\\n}\\n\\n\\nfs.chmod = function(path, mode, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.chmod(pathModule._makeLong(path),\\n                modeNum(mode),\\n                req);\\n};\\n\\nfs.chmodSync = function(path, mode) {\\n  nullCheck(path);\\n  return binding.chmod(pathModule._makeLong(path), modeNum(mode));\\n};\\n\\nif (constants.hasOwnProperty('O_SYMLINK')) {\\n  fs.lchown = function(path, uid, gid, callback) {\\n    callback = maybeCallback(callback);\\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\\n      if (err) {\\n        callback(err);\\n        return;\\n      }\\n      fs.fchown(fd, uid, gid, callback);\\n    });\\n  };\\n\\n  fs.lchownSync = function(path, uid, gid) {\\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\\n    return fs.fchownSync(fd, uid, gid);\\n  };\\n}\\n\\nfs.fchown = function(fd, uid, gid, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fchown(fd, uid, gid, req);\\n};\\n\\nfs.fchownSync = function(fd, uid, gid) {\\n  return binding.fchown(fd, uid, gid);\\n};\\n\\nfs.chown = function(path, uid, gid, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.chown(pathModule._makeLong(path), uid, gid, req);\\n};\\n\\nfs.chownSync = function(path, uid, gid) {\\n  nullCheck(path);\\n  return binding.chown(pathModule._makeLong(path), uid, gid);\\n};\\n\\n// converts Date or number to a fractional UNIX timestamp\\nfunction toUnixTimestamp(time) {\\n  if (typeof time === 'string' && +time == time) {\\n    return +time;\\n  }\\n  if (typeof time === 'number') {\\n    if (!Number.isFinite(time) || time < 0) {\\n      return Date.now() / 1000;\\n    }\\n    return time;\\n  }\\n  if (util.isDate(time)) {\\n    // convert to 123.456 UNIX timestamp\\n    return time.getTime() / 1000;\\n  }\\n  throw new Error('Cannot parse time: ' + time);\\n}\\n\\n// exported for unit tests, not for public consumption\\nfs._toUnixTimestamp = toUnixTimestamp;\\n\\nfs.utimes = function(path, atime, mtime, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.utimes(pathModule._makeLong(path),\\n                 toUnixTimestamp(atime),\\n                 toUnixTimestamp(mtime),\\n                 req);\\n};\\n\\nfs.utimesSync = function(path, atime, mtime) {\\n  nullCheck(path);\\n  atime = toUnixTimestamp(atime);\\n  mtime = toUnixTimestamp(mtime);\\n  binding.utimes(pathModule._makeLong(path), atime, mtime);\\n};\\n\\nfs.futimes = function(fd, atime, mtime, callback) {\\n  atime = toUnixTimestamp(atime);\\n  mtime = toUnixTimestamp(mtime);\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.futimes(fd, atime, mtime, req);\\n};\\n\\nfs.futimesSync = function(fd, atime, mtime) {\\n  atime = toUnixTimestamp(atime);\\n  mtime = toUnixTimestamp(mtime);\\n  binding.futimes(fd, atime, mtime);\\n};\\n\\nfunction writeAll(fd, isUserFd, buffer, offset, length, position, callback_) {\\n  var callback = maybeCallback(arguments[arguments.length - 1]);\\n\\n  // write(fd, buffer, offset, length, position, callback)\\n  fs.write(fd, buffer, offset, length, position, function(writeErr, written) {\\n    if (writeErr) {\\n      if (isUserFd) {\\n        if (callback) callback(writeErr);\\n      } else {\\n        fs.close(fd, function() {\\n          if (callback) callback(writeErr);\\n        });\\n      }\\n    } else {\\n      if (written === length) {\\n        if (isUserFd) {\\n          if (callback) callback(null);\\n        } else {\\n          fs.close(fd, callback);\\n        }\\n      } else {\\n        offset += written;\\n        length -= written;\\n        if (position !== null) {\\n          position += written;\\n        }\\n        writeAll(fd, isUserFd, buffer, offset, length, position, callback);\\n      }\\n    }\\n  });\\n}\\n\\nfs.writeFile = function(path, data, options, callback_) {\\n  var callback = maybeCallback(arguments[arguments.length - 1]);\\n\\n  if (!options || typeof options === 'function') {\\n    options = { encoding: 'utf8', mode: 438, flag: 'w' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, mode: 438, flag: 'w' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  assertEncoding(options.encoding);\\n\\n  var flag = options.flag || 'w';\\n\\n  if (isFd(path)) {\\n    writeFd(path, true);\\n    return;\\n  }\\n\\n  fs.open(path, flag, options.mode, function(openErr, fd) {\\n    if (openErr) {\\n      if (callback) callback(openErr);\\n    } else {\\n      writeFd(fd, false);\\n    }\\n  });\\n\\n  function writeFd(fd, isUserFd) {\\n    var buffer = (util.isBuffer(data)) ? data : Buffer('' + data,\\n        options.encoding || 'utf8');\\n    var position = /a/.test(flag) ? null : 0;\\n\\n    writeAll(fd, isUserFd, buffer, 0, buffer.length, position, callback);\\n  }\\n};\\n\\nfs.writeFileSync = function(path, data, options) {\\n  if (!options) {\\n    options = { encoding: 'utf8', mode: 438, flag: 'w' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, mode: 438, flag: 'w' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  assertEncoding(options.encoding);\\n\\n  var flag = options.flag || 'w';\\n  var isUserFd = isFd(path); // file descriptor ownership\\n  var fd = isUserFd ? path : fs.openSync(path, flag, options.mode);\\n\\n  if (!(util.isBuffer(data))) {\\n    data = Buffer('' + data, options.encoding || 'utf8');\\n  }\\n  var offset = 0;\\n  var length = data.length;\\n  var position = /a/.test(flag) ? null : 0;\\n  try {\\n    while (length > 0) {\\n      var written = fs.writeSync(fd, data, offset, length, position);\\n      offset += written;\\n      length -= written;\\n      if (position !== null) {\\n        position += written;\\n      }\\n    }\\n  } finally {\\n    if (!isUserFd) fs.closeSync(fd);\\n  }\\n};\\n\\nfs.appendFile = function(path, data, options, callback_) {\\n  var callback = maybeCallback(arguments[arguments.length - 1]);\\n\\n  if (!options || typeof options === 'function') {\\n    options = { encoding: 'utf8', mode: 438, flag: 'a' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, mode: 438, flag: 'a' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  if (!options.flag)\\n    options = util._extend({ flag: 'a' }, options);\\n\\n  // force append behavior when using a supplied file descriptor\\n  if (isFd(path))\\n    options.flag = 'a';\\n\\n  fs.writeFile(path, data, options, callback);\\n};\\n\\nfs.appendFileSync = function(path, data, options) {\\n  if (!options) {\\n    options = { encoding: 'utf8', mode: 438, flag: 'a' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, mode: 438, flag: 'a' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  if (!options.flag)\\n    options = util._extend({ flag: 'a' }, options);\\n\\n  // force append behavior when using a supplied file descriptor\\n  if (isFd(path))\\n    options.flag = 'a';\\n\\n  fs.writeFileSync(path, data, options);\\n};\\n\\nfunction FSWatcher() {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n  this._handle = new FSEvent();\\n  this._handle.owner = this;\\n\\n  this._handle.onchange = function(status, event, filename) {\\n    if (status < 0) {\\n      self._handle.close();\\n      var error = errnoException(status, 'watch ' + filename);\\n      error.filename = filename;\\n      self.emit('error', error);\\n    } else {\\n      self.emit('change', event, filename);\\n    }\\n  };\\n}\\nutil.inherits(FSWatcher, EventEmitter);\\n\\nFSWatcher.prototype.start = function(filename, persistent, recursive) {\\n  nullCheck(filename);\\n  var err = this._handle.start(pathModule._makeLong(filename),\\n                               persistent,\\n                               recursive);\\n  if (err) {\\n    this._handle.close();\\n    var error = errnoException(err, 'watch ' + filename);\\n    error.filename = filename;\\n    throw error;\\n  }\\n};\\n\\nFSWatcher.prototype.close = function() {\\n  this._handle.close();\\n};\\n\\nfs.watch = function(filename) {\\n  nullCheck(filename);\\n  var watcher;\\n  var options;\\n  var listener;\\n\\n  if (arguments[1] !== null && typeof arguments[1] === 'object') {\\n    options = arguments[1];\\n    listener = arguments[2];\\n  } else {\\n    options = {};\\n    listener = arguments[1];\\n  }\\n\\n  if (options.persistent === undefined) options.persistent = true;\\n  if (options.recursive === undefined) options.recursive = false;\\n\\n  watcher = new FSWatcher();\\n  watcher.start(filename, options.persistent, options.recursive);\\n\\n  if (listener) {\\n    watcher.addListener('change', listener);\\n  }\\n\\n  return watcher;\\n};\\n\\n\\n// Stat Change Watchers\\n\\nfunction StatWatcher() {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n  this._handle = new binding.StatWatcher();\\n\\n  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\\n  // the sake of backwards compatibility\\n  var oldStatus = -1;\\n\\n  this._handle.onchange = function(current, previous, newStatus) {\\n    if (oldStatus === -1 &&\\n        newStatus === -1 &&\\n        current.nlink === previous.nlink) return;\\n\\n    oldStatus = newStatus;\\n    self.emit('change', current, previous);\\n  };\\n\\n  this._handle.onstop = function() {\\n    self.emit('stop');\\n  };\\n}\\nutil.inherits(StatWatcher, EventEmitter);\\n\\n\\nStatWatcher.prototype.start = function(filename, persistent, interval) {\\n  nullCheck(filename);\\n  this._handle.start(pathModule._makeLong(filename), persistent, interval);\\n};\\n\\n\\nStatWatcher.prototype.stop = function() {\\n  this._handle.stop();\\n};\\n\\n\\nfunction _Map (){\\n  this.list = {};\\n  this.set = function(name, val){\\n    this.list[name] = val;\\n  };\\n\\n  this.get = function(name){\\n    return this.list[name];\\n  };\\n\\n  this.delete = function(name){\\n    delete this.list[name];\\n  };\\n}\\n\\nvar statWatchers = new _Map();\\n\\nfs.watchFile = function(filename, options, listener) {\\n  nullCheck(filename);\\n  filename = pathModule.resolve(filename);\\n  var stat;\\n\\n  var defaults = {\\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\\n    // a little on the slow side but let's stick with it for now to keep\\n    // behavioral changes to a minimum.\\n    interval: 5007,\\n    persistent: true\\n  };\\n\\n  if (options !== null && typeof options === 'object') {\\n    options = util._extend(defaults, options);\\n  } else {\\n    listener = options;\\n    options = defaults;\\n  }\\n\\n  if (typeof listener !== 'function') {\\n    throw new Error('watchFile requires a listener function');\\n  }\\n\\n  stat = statWatchers.get(filename);\\n\\n  if (stat === undefined) {\\n    stat = new StatWatcher();\\n    stat.start(filename, options.persistent, options.interval);\\n    statWatchers.set(filename, stat);\\n  }\\n\\n  stat.addListener('change', listener);\\n  return stat;\\n};\\n\\nfs.unwatchFile = function(filename, listener) {\\n  nullCheck(filename);\\n  filename = pathModule.resolve(filename);\\n  var stat = statWatchers.get(filename);\\n\\n  if (stat === undefined) return;\\n\\n  if (typeof listener === 'function') {\\n    stat.removeListener('change', listener);\\n  } else {\\n    stat.removeAllListeners('change');\\n  }\\n\\n  if (stat.listenerCount('change') === 0) {\\n    stat.stop();\\n    statWatchers.delete(filename);\\n  }\\n};\\n\\n// Regexp that finds the next partion of a (partial) path\\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\\nif (isWindows) {\\n  var nextPartRe = /(.*?)(?:[\\\\/\\\\\\\\]+|$)/g;\\n} else {\\n  var nextPartRe = /(.*?)(?:[\\\\/]+|$)/g;\\n}\\n\\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\\\\\'.\\nif (isWindows) {\\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\\\\\\\/]{2}[^\\\\\\\\\\\\/]+[\\\\\\\\\\\\/][^\\\\\\\\\\\\/]+)?[\\\\\\\\\\\\/]*/;\\n} else {\\n  var splitRootRe = /^[\\\\/]*/;\\n}\\n\\nfs.realpathSync = function realpathSync(p, cache) {\\n  // make p is absolute\\n  p = pathModule.resolve(p);\\n\\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\\n    return cache[p];\\n  }\\n\\n  var original = p,\\n      seenLinks = {},\\n      knownHard = {};\\n\\n  // current character position in p\\n  var pos;\\n  // the partial path so far, including a trailing slash if any\\n  var current;\\n  // the partial path without a trailing slash (except when pointing at a root)\\n  var base;\\n  // the partial path scanned in the previous round, with slash\\n  var previous;\\n\\n  start();\\n\\n  function start() {\\n    // Skip over roots\\n    var m = splitRootRe.exec(p);\\n    pos = m[0].length;\\n    current = m[0];\\n    base = m[0];\\n    previous = '';\\n\\n    // On windows, check that the root exists. On unix there is no need.\\n    if (isWindows && !knownHard[base]) {\\n      fs.lstatSync(base);\\n      knownHard[base] = true;\\n    }\\n  }\\n\\n  // walk down the path, swapping out linked pathparts for their real\\n  // values\\n  // NB: p.length changes.\\n  while (pos < p.length) {\\n    // find the next part\\n    nextPartRe.lastIndex = pos;\\n    var result = nextPartRe.exec(p);\\n    previous = current;\\n    current += result[0];\\n    base = previous + result[1];\\n    pos = nextPartRe.lastIndex;\\n\\n    // continue if not a symlink\\n    if (knownHard[base] || (cache && cache[base] === base)) {\\n      continue;\\n    }\\n\\n    var resolvedLink;\\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\\n      // some known symbolic link.  no need to stat again.\\n      resolvedLink = cache[base];\\n    } else {\\n      var stat = fs.lstatSync(base);\\n      if (!stat.isSymbolicLink()) {\\n        knownHard[base] = true;\\n        if (cache) cache[base] = base;\\n        continue;\\n      }\\n\\n      // read the link if it wasn't read before\\n      // dev/ino always return 0 on windows, so skip the check.\\n      var linkTarget = null;\\n      if (!isWindows) {\\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\\n        if (seenLinks.hasOwnProperty(id)) {\\n          linkTarget = seenLinks[id];\\n        }\\n      }\\n      if (linkTarget === null) {\\n        fs.statSync(base);\\n        linkTarget = fs.readlinkSync(base);\\n      }\\n      resolvedLink = pathModule.resolve(previous, linkTarget);\\n      // track this, if given a cache.\\n      if (cache) cache[base] = resolvedLink;\\n      if (!isWindows) seenLinks[id] = linkTarget;\\n    }\\n\\n    // resolve the link, then start over\\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\\n    start();\\n  }\\n\\n  if (cache) cache[original] = p;\\n\\n  return p;\\n};\\n\\n\\nfs.realpath = function realpath(p, cache, cb) {\\n  if (typeof cb !== 'function') {\\n    cb = maybeCallback(cache);\\n    cache = null;\\n  }\\n\\n  // make p is absolute\\n  p = pathModule.resolve(p);\\n\\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\\n    return process.nextTick(cb.bind(null, null, cache[p]));\\n  }\\n\\n  var original = p,\\n      seenLinks = {},\\n      knownHard = {};\\n\\n  // current character position in p\\n  var pos;\\n  // the partial path so far, including a trailing slash if any\\n  var current;\\n  // the partial path without a trailing slash (except when pointing at a root)\\n  var base;\\n  // the partial path scanned in the previous round, with slash\\n  var previous;\\n\\n  start();\\n\\n  function start() {\\n    // Skip over roots\\n    var m = splitRootRe.exec(p);\\n    pos = m[0].length;\\n    current = m[0];\\n    base = m[0];\\n    previous = '';\\n\\n    // On windows, check that the root exists. On unix there is no need.\\n    if (isWindows && !knownHard[base]) {\\n      fs.lstat(base, function(err) {\\n        if (err) return cb(err);\\n        knownHard[base] = true;\\n        LOOP();\\n      });\\n    } else {\\n      process.nextTick(LOOP);\\n    }\\n  }\\n\\n  // walk down the path, swapping out linked pathparts for their real\\n  // values\\n  function LOOP() {\\n    // stop if scanned past end of path\\n    if (pos >= p.length) {\\n      if (cache) cache[original] = p;\\n      return cb(null, p);\\n    }\\n\\n    // find the next part\\n    nextPartRe.lastIndex = pos;\\n    var result = nextPartRe.exec(p);\\n    previous = current;\\n    current += result[0];\\n    base = previous + result[1];\\n    pos = nextPartRe.lastIndex;\\n\\n    // continue if not a symlink\\n    if (knownHard[base] || (cache && cache[base] === base)) {\\n      return process.nextTick(LOOP);\\n    }\\n\\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\\n      // known symbolic link.  no need to stat again.\\n      return gotResolvedLink(cache[base]);\\n    }\\n\\n    return fs.lstat(base, gotStat);\\n  }\\n\\n  function gotStat(err, stat) {\\n    if (err) return cb(err);\\n\\n    // if not a symlink, skip to the next path part\\n    if (!stat.isSymbolicLink()) {\\n      knownHard[base] = true;\\n      if (cache) cache[base] = base;\\n      return process.nextTick(LOOP);\\n    }\\n\\n    // stat & read the link if not read before\\n    // call gotTarget as soon as the link target is known\\n    // dev/ino always return 0 on windows, so skip the check.\\n    if (!isWindows) {\\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\\n      if (seenLinks.hasOwnProperty(id)) {\\n        return gotTarget(null, seenLinks[id], base);\\n      }\\n    }\\n    fs.stat(base, function(err) {\\n      if (err) return cb(err);\\n\\n      fs.readlink(base, function(err, target) {\\n        if (!isWindows) seenLinks[id] = target;\\n        gotTarget(err, target);\\n      });\\n    });\\n  }\\n\\n  function gotTarget(err, target, base) {\\n    if (err) return cb(err);\\n\\n    var resolvedLink = pathModule.resolve(previous, target);\\n    if (cache) cache[base] = resolvedLink;\\n    gotResolvedLink(resolvedLink);\\n  }\\n\\n  function gotResolvedLink(resolvedLink) {\\n    // resolve the link, then start over\\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\\n    start();\\n  }\\n};\\n\\n\\nvar pool;\\nvar poolUsed = 0;\\nfunction allocNewPool(poolSize) {\\n  pool = Buffer(poolSize);\\n  poolUsed = 0;\\n}\\n\\n\\nfs.createReadStream = function(path, options) {\\n  return new ReadStream(path, options);\\n};\\n\\nutil.inherits(ReadStream, Readable);\\nfs.ReadStream = ReadStream;\\n\\nfunction ReadStream(path, options) {\\n  if (!(this instanceof ReadStream))\\n    return new ReadStream(path, options);\\n\\n  if (options === undefined)\\n    options = {};\\n  else if (typeof options === 'string')\\n    options = { encoding: options };\\n  else if (options === null || typeof options !== 'object')\\n    throw new TypeError('\\\"options\\\" argument must be a string or an object');\\n\\n  // a little bit bigger buffer and water marks by default\\n  options = Object.create(options);\\n  if (options.highWaterMark === undefined)\\n    options.highWaterMark = 64 * 1024;\\n\\n  Readable.call(this, options);\\n\\n  this.path = path;\\n  this.fd = options.fd === undefined ? null : options.fd;\\n  this.flags = options.flags === undefined ? 'r' : options.flags;\\n  this.mode = options.mode === undefined ? 438 : options.mode;\\n\\n  this.start = options.start;\\n  this.end = options.end;\\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\\n  this.pos = undefined;\\n\\n  if (this.start !== undefined) {\\n    if (typeof this.start !== 'number') {\\n      throw new TypeError('start must be a Number');\\n    }\\n    if (this.end === undefined) {\\n      this.end = Infinity;\\n    } else if (typeof this.end !== 'number') {\\n      throw new TypeError('end must be a Number');\\n    }\\n\\n    if (this.start > this.end) {\\n      throw new Error('start must be <= end');\\n    }\\n\\n    this.pos = this.start;\\n  }\\n\\n  if (typeof this.fd !== 'number')\\n    this.open();\\n\\n  this.on('end', function() {\\n    if (this.autoClose) {\\n      this.destroy();\\n    }\\n  });\\n}\\n\\nfs.FileReadStream = fs.ReadStream; // support the legacy name\\n\\nReadStream.prototype.open = function() {\\n  var self = this;\\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\\n    if (er) {\\n      if (self.autoClose) {\\n        self.destroy();\\n      }\\n      self.emit('error', er);\\n      return;\\n    }\\n\\n    self.fd = fd;\\n    self.emit('open', fd);\\n    // start the flow of data.\\n    self.read();\\n  });\\n};\\n\\nReadStream.prototype._read = function(n) {\\n  if (typeof this.fd !== 'number')\\n    return this.once('open', function() {\\n      this._read(n);\\n    });\\n\\n  if (this.destroyed)\\n    return;\\n\\n  if (!pool || pool.length - poolUsed < kMinPoolSpace) {\\n    // discard the old pool.\\n    pool = null;\\n    allocNewPool(this._readableState.highWaterMark);\\n  }\\n\\n  // Grab another reference to the pool in the case that while we're\\n  // in the thread pool another read() finishes up the pool, and\\n  // allocates a new one.\\n  var thisPool = pool;\\n  var toRead = Math.min(pool.length - poolUsed, n);\\n  var start = poolUsed;\\n\\n  if (this.pos !== undefined)\\n    toRead = Math.min(this.end - this.pos + 1, toRead);\\n\\n  // already read everything we were supposed to read!\\n  // treat as EOF.\\n  if (toRead <= 0)\\n    return this.push(null);\\n\\n  // the actual read.\\n  var self = this;\\n  fs.read(this.fd, pool, poolUsed, toRead, this.pos, onread);\\n\\n  // move the pool positions, and internal position for reading.\\n  if (this.pos !== undefined)\\n    this.pos += toRead;\\n  poolUsed += toRead;\\n\\n  function onread(er, bytesRead) {\\n    if (er) {\\n      if (self.autoClose) {\\n        self.destroy();\\n      }\\n      self.emit('error', er);\\n    } else {\\n      var b = null;\\n      if (bytesRead > 0)\\n        b = thisPool.slice(start, start + bytesRead);\\n\\n      self.push(b);\\n    }\\n  }\\n};\\n\\n\\nReadStream.prototype.destroy = function() {\\n  if (this.destroyed)\\n    return;\\n  this.destroyed = true;\\n  this.close();\\n};\\n\\n\\nReadStream.prototype.close = function(cb) {\\n  var self = this;\\n  if (cb)\\n    this.once('close', cb);\\n  if (this.closed || typeof this.fd !== 'number') {\\n    if (typeof this.fd !== 'number') {\\n      this.once('open', close);\\n      return;\\n    }\\n    return process.nextTick(this.emit.bind(this, 'close'));\\n  }\\n  this.closed = true;\\n  close();\\n\\n  function close(fd) {\\n    fs.close(fd || self.fd, function(er) {\\n      if (er)\\n        self.emit('error', er);\\n      else\\n        self.emit('close');\\n    });\\n    self.fd = null;\\n  }\\n};\\n\\n\\nfs.createWriteStream = function(path, options) {\\n  return new WriteStream(path, options);\\n};\\n\\nutil.inherits(WriteStream, Writable);\\nfs.WriteStream = WriteStream;\\nfunction WriteStream(path, options) {\\n  if (!(this instanceof WriteStream))\\n    return new WriteStream(path, options);\\n\\n  if (options === undefined)\\n    options = {};\\n  else if (typeof options === 'string')\\n    options = { encoding: options };\\n  else if (options === null || typeof options !== 'object')\\n    throw new TypeError('\\\"options\\\" argument must be a string or an object');\\n\\n  options = Object.create(options);\\n\\n  Writable.call(this, options);\\n\\n  this.path = path;\\n  this.fd = options.fd === undefined ? null : options.fd;\\n  this.flags = options.flags === undefined ? 'w' : options.flags;\\n  this.mode = options.mode === undefined ? 438 : options.mode;\\n\\n  this.start = options.start;\\n  this.pos = undefined;\\n  this.bytesWritten = 0;\\n\\n  if (this.start !== undefined) {\\n    if (typeof this.start !== 'number') {\\n      throw new TypeError('start must be a Number');\\n    }\\n    if (this.start < 0) {\\n      throw new Error('start must be >= zero');\\n    }\\n\\n    this.pos = this.start;\\n  }\\n\\n  if (options.encoding)\\n    this.setDefaultEncoding(options.encoding);\\n\\n  if (typeof this.fd !== 'number')\\n    this.open();\\n\\n  // dispose on finish.\\n  this.once('finish', this.close);\\n}\\n\\nfs.FileWriteStream = fs.WriteStream; // support the legacy name\\n\\n\\nWriteStream.prototype.open = function() {\\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\\n    if (er) {\\n      this.destroy();\\n      this.emit('error', er);\\n      return;\\n    }\\n\\n    this.fd = fd;\\n    this.emit('open', fd);\\n  }.bind(this));\\n};\\n\\n\\nWriteStream.prototype._write = function(data, encoding, cb) {\\n  if (!(util.isBuffer(data)))\\n    return this.emit('error', new Error('Invalid data'));\\n\\n  if (typeof this.fd !== 'number')\\n    return this.once('open', function() {\\n      this._write(data, encoding, cb);\\n    });\\n\\n  var self = this;\\n  fs.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {\\n    if (er) {\\n      self.destroy();\\n      return cb(er);\\n    }\\n    self.bytesWritten += bytes;\\n    cb();\\n  });\\n\\n  if (this.pos !== undefined)\\n    this.pos += data.length;\\n};\\n\\n\\nfunction writev(fd, chunks, position, callback) {\\n  function wrapper(err, written) {\\n    // Retain a reference to chunks so that they can't be GC'ed too soon.\\n    callback(err, written || 0, chunks);\\n  }\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = wrapper;\\n  binding.writeBuffers(fd, chunks, position, req);\\n}\\n\\n\\nWriteStream.prototype._writev = function(data, cb) {\\n  if (typeof this.fd !== 'number')\\n    return this.once('open', function() {\\n      this._writev(data, cb);\\n    });\\n\\n  var self = this;\\n  var len = data.length;\\n  var chunks = new Array(len);\\n  var size = 0;\\n\\n  for (var i = 0; i < len; i++) {\\n    var chunk = data[i].chunk;\\n\\n    chunks[i] = chunk;\\n    size += chunk.length;\\n  }\\n\\n  writev(this.fd, chunks, this.pos, function(er, bytes) {\\n    if (er) {\\n      self.destroy();\\n      return cb(er);\\n    }\\n    self.bytesWritten += bytes;\\n    cb();\\n  });\\n\\n  if (this.pos !== undefined)\\n    this.pos += size;\\n};\\n\\n\\nWriteStream.prototype.destroy = ReadStream.prototype.destroy;\\nWriteStream.prototype.close = ReadStream.prototype.close;\\n\\n// There is no shutdown() for files.\\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\\n\\n\\n// SyncWriteStream is internal. DO NOT USE.\\n// Temporary hack for process.stdout and process.stderr when piped to files.\\nfunction SyncWriteStream(fd, options) {\\n  Stream.call(this);\\n\\n  options = options || {};\\n\\n  this.fd = fd;\\n  this.writable = true;\\n  this.readable = false;\\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\\n}\\n\\nutil.inherits(SyncWriteStream, Stream);\\n\\n\\n// Export\\nObject.defineProperty(fs, 'SyncWriteStream', {\\n    configurable: true,\\n    writable: true,\\n    value: SyncWriteStream\\n});\\n\\nSyncWriteStream.prototype.write = function(data, arg1, arg2) {\\n  var encoding, cb;\\n\\n  // parse arguments\\n  if (arg1) {\\n    if (typeof arg1 === 'string') {\\n      encoding = arg1;\\n      cb = arg2;\\n    } else if (typeof arg1 === 'function') {\\n      cb = arg1;\\n    } else {\\n      throw new Error('bad arg');\\n    }\\n  }\\n  assertEncoding(encoding);\\n\\n  // Change strings to buffers. SLOW\\n  if (typeof data === 'string') {\\n    data = Buffer(data, encoding);\\n  }\\n\\n  fs.writeSync(this.fd, data, 0, data.length);\\n\\n  if (cb) {\\n    process.nextTick(cb);\\n  }\\n\\n  return true;\\n};\\n\\n\\nSyncWriteStream.prototype.end = function(data, arg1, arg2) {\\n  if (data) {\\n    this.write(data, arg1, arg2);\\n  }\\n  this.destroy();\\n};\\n\\n\\nSyncWriteStream.prototype.destroy = function() {\\n  if (this.autoClose)\\n    fs.closeSync(this.fd);\\n  this.fd = null;\\n  this.emit('close');\\n  return true;\\n};\\n\\nSyncWriteStream.prototype.destroySoon = SyncWriteStream.prototype.destroy;\\n\",\"url\":\"'use strict';\\n\\n// var punycode = require('punycode');\\n\\nexports.parse = urlParse;\\nexports.resolve = urlResolve;\\nexports.resolveObject = urlResolveObject;\\nexports.format = urlFormat;\\n\\nexports.Url = Url;\\n\\nfunction Url() {\\n  this.protocol = null;\\n  this.slashes = null;\\n  this.auth = null;\\n  this.host = null;\\n  this.port = null;\\n  this.hostname = null;\\n  this.hash = null;\\n  this.search = null;\\n  this.query = null;\\n  this.pathname = null;\\n  this.path = null;\\n  this.href = null;\\n}\\n\\n// Reference: RFC 3986, RFC 1808, RFC 2396\\n\\n// define these here so at least they only have to be\\n// compiled once on the first module load.\\nvar protocolPattern = /^([a-z0-9.+-]+:)/i;\\nvar portPattern = /:[0-9]*$/;\\n\\n// Special case for a simple path URL\\nvar simplePathPattern = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/;\\n\\n// RFC 2396: characters reserved for delimiting URLs.\\n// We actually just auto-escape these.\\nvar delims = ['<', '>', '\\\"', '`', ' ', '\\\\r', '\\\\n', '\\\\t'];\\n\\n// RFC 2396: characters not allowed for various reasons.\\nvar unwise = ['{', '}', '|', '\\\\\\\\', '^', '`'].concat(delims);\\n\\n// Allowed by RFCs, but cause of XSS attacks.  Always escape these.\\nvar autoEscape = ['\\\\''].concat(unwise);\\n\\n// Characters that are never ever allowed in a hostname.\\n// Note that any invalid chars are also handled, but these\\n// are the ones that are *expected* to be seen, so we fast-path them.\\nvar nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape);\\nvar hostEndingChars = ['/', '?', '#'];\\nvar hostnameMaxLen = 255;\\nvar hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;\\nvar hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;\\n// protocols that can allow \\\"unsafe\\\" and \\\"unwise\\\" chars.\\nvar unsafeProtocol = {\\n  'javascript': true,\\n  'javascript:': true\\n};\\n// protocols that never have a hostname.\\nvar hostlessProtocol = {\\n  'javascript': true,\\n  'javascript:': true\\n};\\n// protocols that always contain a // bit.\\nvar slashedProtocol = {\\n  'http': true,\\n  'https': true,\\n  'ftp': true,\\n  'gopher': true,\\n  'file': true,\\n  'http:': true,\\n  'https:': true,\\n  'ftp:': true,\\n  'gopher:': true,\\n  'file:': true\\n};\\nvar querystring = require('querystring');\\n\\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\\n  if (url instanceof Url) return url;\\n\\n  var u = new Url();\\n  u.parse(url, parseQueryString, slashesDenoteHost);\\n  return u;\\n}\\n\\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\\n  if (typeof url !== 'string') {\\n    throw new TypeError('Parameter \\\"url\\\" must be a string, not ' + typeof url);\\n  }\\n\\n  // Copy chrome, IE, opera backslash-handling behavior.\\n  // Back slashes before the query string get converted to forward slashes\\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\\n  var queryIndex = url.indexOf('?'),\\n      splitter =\\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\\n      uSplit = url.split(splitter),\\n      slashRegex = /\\\\\\\\/g;\\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\\n  url = uSplit.join(splitter);\\n\\n  var rest = url;\\n\\n  // trim before proceeding.\\n  // This is to support parse stuff like \\\"  http://foo.com  \\\\n\\\"\\n  rest = rest.trim();\\n\\n  if (!slashesDenoteHost && url.split('#').length === 1) {\\n    // Try fast path regexp\\n    var simplePath = simplePathPattern.exec(rest);\\n    if (simplePath) {\\n      this.path = rest;\\n      this.href = rest;\\n      this.pathname = simplePath[1];\\n      if (simplePath[2]) {\\n        this.search = simplePath[2];\\n        if (parseQueryString) {\\n          this.query = querystring.parse(this.search.substr(1));\\n        } else {\\n          this.query = this.search.substr(1);\\n        }\\n      } else if (parseQueryString) {\\n        this.search = '';\\n        this.query = {};\\n      }\\n      return this;\\n    }\\n  }\\n\\n  var proto = protocolPattern.exec(rest);\\n  if (proto) {\\n    proto = proto[0];\\n    var lowerProto = proto.toLowerCase();\\n    this.protocol = lowerProto;\\n    rest = rest.substr(proto.length);\\n  }\\n\\n  // figure out if it's got a host\\n  // user@server is *always* interpreted as a hostname, and url\\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\\n  // how the browser resolves relative URLs.\\n  if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {\\n    var slashes = rest.substr(0, 2) === '//';\\n    if (slashes && !(proto && hostlessProtocol[proto])) {\\n      rest = rest.substr(2);\\n      this.slashes = true;\\n    }\\n  }\\n\\n  if (!hostlessProtocol[proto] &&\\n      (slashes || (proto && !slashedProtocol[proto]))) {\\n\\n    // there's a hostname.\\n    // the first instance of /, ?, ;, or # ends the host.\\n    //\\n    // If there is an @ in the hostname, then non-host chars *are* allowed\\n    // to the left of the last @ sign, unless some host-ending character\\n    // comes *before* the @-sign.\\n    // URLs are obnoxious.\\n    //\\n    // ex:\\n    // http://a@b@c/ => user:a@b host:c\\n    // http://a@b?@c => user:a host:b path:/?@c\\n\\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\\n    // Review our test case against browsers more comprehensively.\\n\\n    // find the first instance of any hostEndingChars\\n    var hostEnd = -1;\\n    for (var i = 0; i < hostEndingChars.length; i++) {\\n      var hec = rest.indexOf(hostEndingChars[i]);\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\\n        hostEnd = hec;\\n    }\\n\\n    // at this point, either we have an explicit point where the\\n    // auth portion cannot go past, or the last @ char is the decider.\\n    var auth, atSign;\\n    if (hostEnd === -1) {\\n      // atSign can be anywhere.\\n      atSign = rest.lastIndexOf('@');\\n    } else {\\n      // atSign must be in auth portion.\\n      // http://a@b/c@d => host:b auth:a path:/c@d\\n      atSign = rest.lastIndexOf('@', hostEnd);\\n    }\\n\\n    // Now we have a portion which is definitely the auth.\\n    // Pull that off.\\n    if (atSign !== -1) {\\n      auth = rest.slice(0, atSign);\\n      rest = rest.slice(atSign + 1);\\n      this.auth = decodeURIComponent(auth);\\n    }\\n\\n    // the host is the remaining to the left of the first non-host char\\n    hostEnd = -1;\\n    for (var i = 0; i < nonHostChars.length; i++) {\\n      var hec = rest.indexOf(nonHostChars[i]);\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\\n        hostEnd = hec;\\n    }\\n    // if we still have not hit it, then the entire thing is a host.\\n    if (hostEnd === -1)\\n      hostEnd = rest.length;\\n\\n    this.host = rest.slice(0, hostEnd);\\n    rest = rest.slice(hostEnd);\\n\\n    // pull out port.\\n    this.parseHost();\\n\\n    // we've indicated that there is a hostname,\\n    // so even if it's empty, it has to be present.\\n    this.hostname = this.hostname || '';\\n\\n    // if hostname begins with [ and ends with ]\\n    // assume that it's an IPv6 address.\\n    var ipv6Hostname = this.hostname[0] === '[' &&\\n        this.hostname[this.hostname.length - 1] === ']';\\n\\n    // validate a little.\\n    if (!ipv6Hostname) {\\n      var hostparts = this.hostname.split(/\\\\./);\\n      for (var i = 0, l = hostparts.length; i < l; i++) {\\n        var part = hostparts[i];\\n        if (!part) continue;\\n        if (!part.match(hostnamePartPattern)) {\\n          var newpart = '';\\n          for (var j = 0, k = part.length; j < k; j++) {\\n            if (part.charCodeAt(j) > 127) {\\n              // we replace non-ASCII char with a temporary placeholder\\n              // we need this to make sure size of hostname is not\\n              // broken by replacing non-ASCII by nothing\\n              newpart += 'x';\\n            } else {\\n              newpart += part[j];\\n            }\\n          }\\n          // we test again with ASCII char only\\n          if (!newpart.match(hostnamePartPattern)) {\\n            var validParts = hostparts.slice(0, i);\\n            var notHost = hostparts.slice(i + 1);\\n            var bit = part.match(hostnamePartStart);\\n            if (bit) {\\n              validParts.push(bit[1]);\\n              notHost.unshift(bit[2]);\\n            }\\n            if (notHost.length) {\\n              rest = '/' + notHost.join('.') + rest;\\n            }\\n            this.hostname = validParts.join('.');\\n            break;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (this.hostname.length > hostnameMaxLen) {\\n      this.hostname = '';\\n    } else {\\n      // hostnames are always lower case.\\n      this.hostname = this.hostname.toLowerCase();\\n    }\\n\\n    if (!ipv6Hostname) {\\n      // IDNA Support: Returns a punycoded representation of \\\"domain\\\".\\n      // It only converts parts of the domain name that\\n      // have non-ASCII characters, i.e. it doesn't matter if\\n      // you call it with a domain that already is ASCII-only.\\n      // this.hostname = punycode.toASCII(this.hostname);\\n    }\\n\\n    var p = this.port ? ':' + this.port : '';\\n    var h = this.hostname || '';\\n    this.host = h + p;\\n\\n    // strip [ and ] from the hostname\\n    // the host field still retains them, though\\n    if (ipv6Hostname) {\\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\\n      if (rest[0] !== '/') {\\n        rest = '/' + rest;\\n      }\\n    }\\n  }\\n\\n  // now rest is set to the post-host stuff.\\n  // chop off any delim chars.\\n  if (!unsafeProtocol[lowerProto]) {\\n\\n    // First, make 100% sure that any \\\"autoEscape\\\" chars get\\n    // escaped, even if encodeURIComponent doesn't think they\\n    // need to be.\\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\\n      var ae = autoEscape[i];\\n      if (rest.indexOf(ae) === -1)\\n        continue;\\n      var esc = encodeURIComponent(ae);\\n      if (esc === ae) {\\n        esc = escape(ae);\\n      }\\n      rest = rest.split(ae).join(esc);\\n    }\\n  }\\n\\n\\n  // chop off from the tail first.\\n  var hash = rest.indexOf('#');\\n  if (hash !== -1) {\\n    // got a fragment string.\\n    this.hash = rest.substr(hash);\\n    rest = rest.slice(0, hash);\\n  }\\n  var qm = rest.indexOf('?');\\n  if (qm !== -1) {\\n    this.search = rest.substr(qm);\\n    this.query = rest.substr(qm + 1);\\n    if (parseQueryString) {\\n      this.query = querystring.parse(this.query);\\n    }\\n    rest = rest.slice(0, qm);\\n  } else if (parseQueryString) {\\n    // no query string, but parseQueryString still requested\\n    this.search = '';\\n    this.query = {};\\n  }\\n  if (rest) this.pathname = rest;\\n  if (slashedProtocol[lowerProto] &&\\n      this.hostname && !this.pathname) {\\n    this.pathname = '/';\\n  }\\n\\n  //to support http.request\\n  if (this.pathname || this.search) {\\n    var p = this.pathname || '';\\n    var s = this.search || '';\\n    this.path = p + s;\\n  }\\n\\n  // finally, reconstruct the href based on what has been validated.\\n  this.href = this.format();\\n  return this;\\n};\\n\\n// format a parsed object into a url string\\nfunction urlFormat(obj) {\\n  // ensure it's an object, and not a string url.\\n  // If it's an obj, this is a no-op.\\n  // this way, you can call url_format() on strings\\n  // to clean up potentially wonky urls.\\n  if (typeof obj === 'string') obj = urlParse(obj);\\n\\n  else if (typeof obj !== 'object' || obj === null)\\n    throw new TypeError('Parameter \\\"urlObj\\\" must be an object, not ' +\\n                        obj === null ? 'null' : typeof obj);\\n\\n  else if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\\n\\n  return obj.format();\\n}\\n\\nUrl.prototype.format = function() {\\n  var auth = this.auth || '';\\n  if (auth) {\\n    auth = encodeURIComponent(auth);\\n    auth = auth.replace(/%3A/i, ':');\\n    auth += '@';\\n  }\\n\\n  var protocol = this.protocol || '',\\n      pathname = this.pathname || '',\\n      hash = this.hash || '',\\n      host = false,\\n      query = '';\\n\\n  if (this.host) {\\n    host = auth + this.host;\\n  } else if (this.hostname) {\\n    host = auth + (this.hostname.indexOf(':') === -1 ?\\n        this.hostname :\\n        '[' + this.hostname + ']');\\n    if (this.port) {\\n      host += ':' + this.port;\\n    }\\n  }\\n\\n  if (this.query !== null &&\\n      typeof this.query === 'object' &&\\n      Object.keys(this.query).length) {\\n    query = querystring.stringify(this.query);\\n  }\\n\\n  var search = this.search || (query && ('?' + query)) || '';\\n\\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\\n\\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\\n  // unless they had them to begin with.\\n  if (this.slashes ||\\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\\n    host = '//' + (host || '');\\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\\n  } else if (!host) {\\n    host = '';\\n  }\\n\\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\\n  if (search && search.charAt(0) !== '?') search = '?' + search;\\n\\n  pathname = pathname.replace(/[?#]/g, function(match) {\\n    return encodeURIComponent(match);\\n  });\\n  search = search.replace('#', '%23');\\n\\n  return protocol + host + pathname + search + hash;\\n};\\n\\nfunction urlResolve(source, relative) {\\n  return urlParse(source, false, true).resolve(relative);\\n}\\n\\nUrl.prototype.resolve = function(relative) {\\n  return this.resolveObject(urlParse(relative, false, true)).format();\\n};\\n\\nfunction urlResolveObject(source, relative) {\\n  if (!source) return relative;\\n  return urlParse(source, false, true).resolveObject(relative);\\n}\\n\\nUrl.prototype.resolveObject = function(relative) {\\n  if (typeof relative === 'string') {\\n    var rel = new Url();\\n    rel.parse(relative, false, true);\\n    relative = rel;\\n  }\\n\\n  var result = new Url();\\n  var tkeys = Object.keys(this);\\n  for (var tk = 0; tk < tkeys.length; tk++) {\\n    var tkey = tkeys[tk];\\n    result[tkey] = this[tkey];\\n  }\\n\\n  // hash is always overridden, no matter what.\\n  // even href=\\\"\\\" will remove it.\\n  result.hash = relative.hash;\\n\\n  // if the relative url is empty, then there's nothing left to do here.\\n  if (relative.href === '') {\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  // hrefs like //foo/bar always cut to the protocol.\\n  if (relative.slashes && !relative.protocol) {\\n    // take everything except the protocol from relative\\n    var rkeys = Object.keys(relative);\\n    for (var rk = 0; rk < rkeys.length; rk++) {\\n      var rkey = rkeys[rk];\\n      if (rkey !== 'protocol')\\n        result[rkey] = relative[rkey];\\n    }\\n\\n    //urlParse appends trailing / to urls like http://www.example.com\\n    if (slashedProtocol[result.protocol] &&\\n        result.hostname && !result.pathname) {\\n      result.path = result.pathname = '/';\\n    }\\n\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  if (relative.protocol && relative.protocol !== result.protocol) {\\n    // if it's a known url protocol, then changing\\n    // the protocol does weird things\\n    // first, if it's not file:, then we MUST have a host,\\n    // and if there was a path\\n    // to begin with, then we MUST have a path.\\n    // if it is file:, then the host is dropped,\\n    // because that's known to be hostless.\\n    // anything else is assumed to be absolute.\\n    if (!slashedProtocol[relative.protocol]) {\\n      var keys = Object.keys(relative);\\n      for (var v = 0; v < keys.length; v++) {\\n        var k = keys[v];\\n        result[k] = relative[k];\\n      }\\n      result.href = result.format();\\n      return result;\\n    }\\n\\n    result.protocol = relative.protocol;\\n    if (!relative.host &&\\n        !/^file:?$/.test(relative.protocol) &&\\n        !hostlessProtocol[relative.protocol]) {\\n      var relPath = (relative.pathname || '').split('/');\\n      while (relPath.length && !(relative.host = relPath.shift()));\\n      if (!relative.host) relative.host = '';\\n      if (!relative.hostname) relative.hostname = '';\\n      if (relPath[0] !== '') relPath.unshift('');\\n      if (relPath.length < 2) relPath.unshift('');\\n      result.pathname = relPath.join('/');\\n    } else {\\n      result.pathname = relative.pathname;\\n    }\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    result.host = relative.host || '';\\n    result.auth = relative.auth;\\n    result.hostname = relative.hostname || relative.host;\\n    result.port = relative.port;\\n    // to support http.request\\n    if (result.pathname || result.search) {\\n      var p = result.pathname || '';\\n      var s = result.search || '';\\n      result.path = p + s;\\n    }\\n    result.slashes = result.slashes || relative.slashes;\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\\n      isRelAbs = (\\n          relative.host ||\\n          relative.pathname && relative.pathname.charAt(0) === '/'\\n      ),\\n      mustEndAbs = (isRelAbs || isSourceAbs ||\\n                    (result.host && relative.pathname)),\\n      removeAllDots = mustEndAbs,\\n      srcPath = result.pathname && result.pathname.split('/') || [],\\n      relPath = relative.pathname && relative.pathname.split('/') || [],\\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\\n\\n  // if the url is a non-slashed url, then relative\\n  // links like ../.. should be able\\n  // to crawl up to the hostname, as well.  This is strange.\\n  // result.protocol has already been set by now.\\n  // Later on, put the first path part into the host field.\\n  if (psychotic) {\\n    result.hostname = '';\\n    result.port = null;\\n    if (result.host) {\\n      if (srcPath[0] === '') srcPath[0] = result.host;\\n      else srcPath.unshift(result.host);\\n    }\\n    result.host = '';\\n    if (relative.protocol) {\\n      relative.hostname = null;\\n      relative.port = null;\\n      if (relative.host) {\\n        if (relPath[0] === '') relPath[0] = relative.host;\\n        else relPath.unshift(relative.host);\\n      }\\n      relative.host = null;\\n    }\\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\\n  }\\n\\n  if (isRelAbs) {\\n    // it's absolute.\\n    result.host = (relative.host || relative.host === '') ?\\n                  relative.host : result.host;\\n    result.hostname = (relative.hostname || relative.hostname === '') ?\\n                      relative.hostname : result.hostname;\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    srcPath = relPath;\\n    // fall through to the dot-handling below.\\n  } else if (relPath.length) {\\n    // it's relative\\n    // throw away the existing file, and take the new path instead.\\n    if (!srcPath) srcPath = [];\\n    srcPath.pop();\\n    srcPath = srcPath.concat(relPath);\\n    result.search = relative.search;\\n    result.query = relative.query;\\n  } else if (relative.search !== null && relative.search !== undefined) {\\n    // just pull out the search.\\n    // like href='?foo'.\\n    // Put this after the other two cases because it simplifies the booleans\\n    if (psychotic) {\\n      result.hostname = result.host = srcPath.shift();\\n      //occationaly the auth can get stuck only in host\\n      //this especially happens in cases like\\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\\n                       result.host.split('@') : false;\\n      if (authInHost) {\\n        result.auth = authInHost.shift();\\n        result.host = result.hostname = authInHost.shift();\\n      }\\n    }\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    //to support http.request\\n    if (result.pathname !== null || result.search !== null) {\\n      result.path = (result.pathname ? result.pathname : '') +\\n                    (result.search ? result.search : '');\\n    }\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  if (!srcPath.length) {\\n    // no path at all.  easy.\\n    // we've already handled the other stuff above.\\n    result.pathname = null;\\n    //to support http.request\\n    if (result.search) {\\n      result.path = '/' + result.search;\\n    } else {\\n      result.path = null;\\n    }\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  // if a url ENDs in . or .., then it must get a trailing slash.\\n  // however, if it ends in anything else non-slashy,\\n  // then it must NOT get a trailing slash.\\n  var last = srcPath.slice(-1)[0];\\n  var hasTrailingSlash = (\\n      (result.host || relative.host || srcPath.length > 1) &&\\n      (last === '.' || last === '..') || last === '');\\n\\n  // strip single dots, resolve double dots to parent dir\\n  // if the path tries to go above the root, `up` ends up > 0\\n  var up = 0;\\n  for (var i = srcPath.length; i >= 0; i--) {\\n    last = srcPath[i];\\n    if (last === '.') {\\n      spliceOne(srcPath, i);\\n    } else if (last === '..') {\\n      spliceOne(srcPath, i);\\n      up++;\\n    } else if (up) {\\n      spliceOne(srcPath, i);\\n      up--;\\n    }\\n  }\\n\\n  // if the path is allowed to go above the root, restore leading ..s\\n  if (!mustEndAbs && !removeAllDots) {\\n    for (; up--; up) {\\n      srcPath.unshift('..');\\n    }\\n  }\\n\\n  if (mustEndAbs && srcPath[0] !== '' &&\\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\\n    srcPath.unshift('');\\n  }\\n\\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\\n    srcPath.push('');\\n  }\\n\\n  var isAbsolute = srcPath[0] === '' ||\\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\\n\\n  // put the host back\\n  if (psychotic) {\\n    result.hostname = result.host = isAbsolute ? '' :\\n                                    srcPath.length ? srcPath.shift() : '';\\n    //occationaly the auth can get stuck only in host\\n    //this especially happens in cases like\\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\\n                     result.host.split('@') : false;\\n    if (authInHost) {\\n      result.auth = authInHost.shift();\\n      result.host = result.hostname = authInHost.shift();\\n    }\\n  }\\n\\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\\n\\n  if (mustEndAbs && !isAbsolute) {\\n    srcPath.unshift('');\\n  }\\n\\n  if (!srcPath.length) {\\n    result.pathname = null;\\n    result.path = null;\\n  } else {\\n    result.pathname = srcPath.join('/');\\n  }\\n\\n  //to support request.http\\n  if (result.pathname !== null || result.search !== null) {\\n    result.path = (result.pathname ? result.pathname : '') +\\n                  (result.search ? result.search : '');\\n  }\\n  result.auth = relative.auth || result.auth;\\n  result.slashes = result.slashes || relative.slashes;\\n  result.href = result.format();\\n  return result;\\n};\\n\\nUrl.prototype.parseHost = function() {\\n  var host = this.host;\\n  var port = portPattern.exec(host);\\n  if (port) {\\n    port = port[0];\\n    if (port !== ':') {\\n      this.port = port.substr(1);\\n    }\\n    host = host.substr(0, host.length - port.length);\\n  }\\n  if (host) this.hostname = host;\\n};\\n\\n// About 1.5x faster than the two-arg version of Array#splice().\\nfunction spliceOne(list, index) {\\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\\n    list[i] = list[k];\\n  list.pop();\\n}\\n\",\"readline\":\"// Inspiration for this code comes from Salvatore Sanfilippo's linenoise.\\n// https://github.com/antirez/linenoise\\n// Reference:\\n// * http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\\n// * http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html\\n\\n'use strict';\\n\\n/*! https://mths.be/codepointat v0.2.0 by @mathias */\\nif (!String.prototype.codePointAt) {\\n  (function() {\\n    'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\\n    var defineProperty = (function() {\\n      // IE 8 only supports `Object.defineProperty` on DOM elements\\n      try {\\n        var object = {};\\n        var $defineProperty = Object.defineProperty;\\n        var result = $defineProperty(object, object, object) && $defineProperty;\\n      } catch(error) {}\\n      return result;\\n    }());\\n    var codePointAt = function(position) {\\n      if (this == null) {\\n        throw TypeError();\\n      }\\n      var string = String(this);\\n      var size = string.length;\\n      // `ToInteger`\\n      var index = position ? Number(position) : 0;\\n      if (index != index) { // better `isNaN`\\n        index = 0;\\n      }\\n      // Account for out-of-bounds indices:\\n      if (index < 0 || index >= size) {\\n        return undefined;\\n      }\\n      // Get the first code unit\\n      var first = string.charCodeAt(index);\\n      var second;\\n      if ( // check if it’s the start of a surrogate pair\\n        first >= 0xD800 && first <= 0xDBFF && // high surrogate\\n        size > index + 1 // there is a next code unit\\n      ) {\\n        second = string.charCodeAt(index + 1);\\n        if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\\n          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\\n          return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\\n        }\\n      }\\n      return first;\\n    };\\n    if (defineProperty) {\\n      defineProperty(String.prototype, 'codePointAt', {\\n        'value': codePointAt,\\n        'configurable': true,\\n        'writable': true\\n      });\\n    } else {\\n      String.prototype.codePointAt = codePointAt;\\n    }\\n  }());\\n}\\n\\nvar kHistorySize = 30;\\n\\nvar util = require('util');\\nvar inherits = util.inherits;\\nvar EventEmitter = require('events').EventEmitter;\\n\\n\\nexports.createInterface = function(input, output, completer, terminal) {\\n  var rl;\\n  if (arguments.length === 1) {\\n    rl = new Interface(input);\\n  } else {\\n    rl = new Interface(input, output, completer, terminal);\\n  }\\n  return rl;\\n};\\n\\n\\nfunction Interface(input, output, completer, terminal) {\\n  if (!(this instanceof Interface)) {\\n    // call the varructor preserving original number of arguments\\n    var self = Object.create(Interface.prototype);\\n    Interface.apply(self, arguments);\\n    return self;\\n  }\\n\\n  this._sawReturn = false;\\n\\n  EventEmitter.call(this);\\n\\n  if (arguments.length === 1) {\\n    // an options object was given\\n    output = input.output;\\n    completer = input.completer;\\n    terminal = input.terminal;\\n    input = input.input;\\n  }\\n\\n  completer = completer || function() { return []; };\\n\\n  if (typeof completer !== 'function') {\\n    throw new TypeError('Argument \\\\'completer\\\\' must be a function');\\n  }\\n\\n  // backwards compat; check the isTTY prop of the output stream\\n  //  when `terminal` was not specified\\n  if (terminal === undefined && !(output === null || output === undefined)) {\\n    terminal = !!output.isTTY;\\n  }\\n\\n  var self = this;\\n\\n  this.output = output;\\n  this.input = input;\\n\\n  // Check arity, 2 - for async, 1 for sync\\n  this.completer = completer.length === 2 ? completer : function(v, callback) {\\n    callback(null, completer(v));\\n  };\\n\\n  this.setPrompt('> ');\\n\\n  this.terminal = !!terminal;\\n\\n  function ondata(data) {\\n    self._normalWrite(data);\\n  }\\n\\n  function onend() {\\n    if (typeof self._line_buffer === 'string' &&\\n        self._line_buffer.length > 0) {\\n      self.emit('line', self._line_buffer);\\n    }\\n    self.close();\\n  }\\n\\n  function ontermend() {\\n    if (typeof self.line === 'string' && self.line.length > 0) {\\n      self.emit('line', self.line);\\n    }\\n    self.close();\\n  }\\n\\n  function onkeypress(s, key) {\\n    self._ttyWrite(s, key);\\n  }\\n\\n  function onresize() {\\n    self._refreshLine();\\n  }\\n\\n  if (!this.terminal) {\\n    input.on('data', ondata);\\n    input.on('end', onend);\\n    self.once('close', function() {\\n      input.removeListener('data', ondata);\\n      input.removeListener('end', onend);\\n    });\\n    var StringDecoder = require('string_decoder').StringDecoder; // lazy load\\n    this._decoder = new StringDecoder('utf8');\\n\\n  } else {\\n\\n    exports.emitKeypressEvents(input);\\n\\n    // input usually refers to stdin\\n    input.on('keypress', onkeypress);\\n    input.on('end', ontermend);\\n\\n    // Current line\\n    this.line = '';\\n\\n    this._setRawMode(true);\\n    this.terminal = true;\\n\\n    // Cursor position on the line.\\n    this.cursor = 0;\\n\\n    this.history = [];\\n    this.historyIndex = -1;\\n\\n    if (output !== null && output !== undefined)\\n      output.on('resize', onresize);\\n\\n    self.once('close', function() {\\n      input.removeListener('keypress', onkeypress);\\n      input.removeListener('end', ontermend);\\n      if (output !== null && output !== undefined) {\\n        output.removeListener('resize', onresize);\\n      }\\n    });\\n  }\\n\\n  input.resume();\\n}\\n\\ninherits(Interface, EventEmitter);\\n\\nInterface.prototype.__defineGetter__('columns', function() {\\n  var columns = Infinity;\\n  if (this.output && this.output.columns)\\n    columns = this.output.columns;\\n  return columns;\\n});\\n\\nInterface.prototype.setPrompt = function(prompt) {\\n  this._prompt = prompt;\\n};\\n\\n\\nInterface.prototype._setRawMode = function(mode) {\\n  if (typeof this.input.setRawMode === 'function') {\\n    return this.input.setRawMode(mode);\\n  }\\n};\\n\\n\\nInterface.prototype.prompt = function(preserveCursor) {\\n  if (this.paused) this.resume();\\n  if (this.terminal) {\\n    if (!preserveCursor) this.cursor = 0;\\n    this._refreshLine();\\n  } else {\\n    this._writeToOutput(this._prompt);\\n  }\\n};\\n\\n\\nInterface.prototype.question = function(query, cb) {\\n  if (typeof cb === 'function') {\\n    if (this._questionCallback) {\\n      this.prompt();\\n    } else {\\n      this._oldPrompt = this._prompt;\\n      this.setPrompt(query);\\n      this._questionCallback = cb;\\n      this.prompt();\\n    }\\n  }\\n};\\n\\n\\nInterface.prototype._onLine = function(line) {\\n  if (this._questionCallback) {\\n    var cb = this._questionCallback;\\n    this._questionCallback = null;\\n    this.setPrompt(this._oldPrompt);\\n    cb(line);\\n  } else {\\n    this.emit('line', line);\\n  }\\n};\\n\\nInterface.prototype._writeToOutput = function _writeToOutput(stringToWrite) {\\n  if (typeof stringToWrite !== 'string')\\n    throw new TypeError('stringToWrite must be a string');\\n\\n  if (this.output !== null && this.output !== undefined)\\n    this.output.write(stringToWrite);\\n};\\n\\nInterface.prototype._addHistory = function() {\\n  if (this.line.length === 0) return '';\\n\\n  if (this.history.length === 0 || this.history[0] !== this.line) {\\n    this.history.unshift(this.line);\\n\\n    // Only store so many\\n    if (this.history.length > kHistorySize) this.history.pop();\\n  }\\n\\n  this.historyIndex = -1;\\n  return this.history[0];\\n};\\n\\n\\nInterface.prototype._refreshLine = function() {\\n  // line length\\n  var line = this._prompt + this.line;\\n  var dispPos = this._getDisplayPos(line);\\n  var lineCols = dispPos.cols;\\n  var lineRows = dispPos.rows;\\n\\n  // cursor position\\n  var cursorPos = this._getCursorPos();\\n\\n  // first move to the bottom of the current line, based on cursor pos\\n  var prevRows = this.prevRows || 0;\\n  if (prevRows > 0) {\\n    exports.moveCursor(this.output, 0, -prevRows);\\n  }\\n\\n  // Cursor to left edge.\\n  exports.cursorTo(this.output, 0);\\n  // erase data\\n  exports.clearScreenDown(this.output);\\n\\n  // Write the prompt and the current buffer content.\\n  this._writeToOutput(line);\\n\\n  // Force terminal to allocate a new line\\n  if (lineCols === 0) {\\n    this._writeToOutput(' ');\\n  }\\n\\n  // Move cursor to original position.\\n  exports.cursorTo(this.output, cursorPos.cols);\\n\\n  var diff = lineRows - cursorPos.rows;\\n  if (diff > 0) {\\n    exports.moveCursor(this.output, 0, -diff);\\n  }\\n\\n  this.prevRows = cursorPos.rows;\\n};\\n\\n\\nInterface.prototype.close = function() {\\n  if (this.closed) return;\\n  this.pause();\\n  if (this.terminal) {\\n    this._setRawMode(false);\\n  }\\n  this.closed = true;\\n  this.emit('close');\\n};\\n\\n\\nInterface.prototype.pause = function() {\\n  if (this.paused) return;\\n  this.input.pause();\\n  this.paused = true;\\n  this.emit('pause');\\n  return this;\\n};\\n\\n\\nInterface.prototype.resume = function() {\\n  if (!this.paused) return;\\n  this.input.resume();\\n  this.paused = false;\\n  this.emit('resume');\\n  return this;\\n};\\n\\n\\nInterface.prototype.write = function(d, key) {\\n  if (this.paused) this.resume();\\n  this.terminal ? this._ttyWrite(d, key) : this._normalWrite(d);\\n};\\n\\n// \\\\r\\\\n, \\\\n, or \\\\r followed by something other than \\\\n\\nvar lineEnding = /\\\\r?\\\\n|\\\\r(?!\\\\n)/;\\nInterface.prototype._normalWrite = function(b) {\\n  if (b === undefined) {\\n    return;\\n  }\\n  var string = this._decoder.write(b);\\n  if (this._sawReturn) {\\n    string = string.replace(/^\\\\n/, '');\\n    this._sawReturn = false;\\n  }\\n\\n  // Run test() on the new string chunk, not on the entire line buffer.\\n  var newPartContainsEnding = lineEnding.test(string);\\n\\n  if (this._line_buffer) {\\n    string = this._line_buffer + string;\\n    this._line_buffer = null;\\n  }\\n  if (newPartContainsEnding) {\\n    this._sawReturn = /\\\\r$/.test(string);\\n\\n    // got one or more newlines; process into \\\"line\\\" events\\n    var lines = string.split(lineEnding);\\n    // either '' or (concievably) the unfinished portion of the next line\\n    string = lines.pop();\\n    this._line_buffer = string;\\n    lines.forEach(function(line) {\\n      this._onLine(line);\\n    }, this);\\n  } else if (string) {\\n    // no newlines this time, save what we have for next time\\n    this._line_buffer = string;\\n  }\\n};\\n\\nInterface.prototype._insertString = function(c) {\\n  //BUG: Problem when adding tabs with following content.\\n  //     Perhaps the bug is in _refreshLine(). Not sure.\\n  //     A hack would be to insert spaces instead of literal '\\\\t'.\\n  if (this.cursor < this.line.length) {\\n    var beg = this.line.slice(0, this.cursor);\\n    var end = this.line.slice(this.cursor, this.line.length);\\n    this.line = beg + c + end;\\n    this.cursor += c.length;\\n    this._refreshLine();\\n  } else {\\n    this.line += c;\\n    this.cursor += c.length;\\n\\n    if (this._getCursorPos().cols === 0) {\\n      this._refreshLine();\\n    } else {\\n      this._writeToOutput(c);\\n    }\\n\\n    // a hack to get the line refreshed if it's needed\\n    this._moveCursor(0);\\n  }\\n};\\n\\nInterface.prototype._tabComplete = function() {\\n  var self = this;\\n\\n  self.pause();\\n  self.completer(self.line.slice(0, self.cursor), function(err, rv) {\\n    self.resume();\\n\\n    if (err) {\\n      // XXX Log it somewhere?\\n      return;\\n    }\\n\\n    var completions = rv[0],\\n        completeOn = rv[1];  // the text that was completed\\n    if (completions && completions.length) {\\n      // Apply/show completions.\\n      if (completions.length === 1) {\\n        self._insertString(completions[0].slice(completeOn.length));\\n      } else {\\n        self._writeToOutput('\\\\r\\\\n');\\n        var width = completions.reduce(function(a, b) {\\n          return a.length > b.length ? a : b;\\n        }).length + 2;  // 2 space padding\\n        var maxColumns = Math.floor(self.columns / width) || 1;\\n        var group = [], c;\\n        for (var i = 0, compLen = completions.length; i < compLen; i++) {\\n          c = completions[i];\\n          if (c === '') {\\n            handleGroup(self, group, width, maxColumns);\\n            group = [];\\n          } else {\\n            group.push(c);\\n          }\\n        }\\n        handleGroup(self, group, width, maxColumns);\\n\\n        // If there is a common prefix to all matches, then apply that\\n        // portion.\\n        var f = completions.filter(function(e) { if (e) return e; });\\n        var prefix = commonPrefix(f);\\n        if (prefix.length > completeOn.length) {\\n          self._insertString(prefix.slice(completeOn.length));\\n        }\\n\\n      }\\n      self._refreshLine();\\n    }\\n  });\\n};\\n\\n// this = Interface instance\\nfunction handleGroup(self, group, width, maxColumns) {\\n  if (group.length == 0) {\\n    return;\\n  }\\n  var minRows = Math.ceil(group.length / maxColumns);\\n  for (var row = 0; row < minRows; row++) {\\n    for (var col = 0; col < maxColumns; col++) {\\n      var idx = row * maxColumns + col;\\n      if (idx >= group.length) {\\n        break;\\n      }\\n      var item = group[idx];\\n      self._writeToOutput(item);\\n      if (col < maxColumns - 1) {\\n        for (var s = 0, itemLen = item.length; s < width - itemLen;\\n             s++) {\\n          self._writeToOutput(' ');\\n        }\\n      }\\n    }\\n    self._writeToOutput('\\\\r\\\\n');\\n  }\\n  self._writeToOutput('\\\\r\\\\n');\\n}\\n\\nfunction commonPrefix(strings) {\\n  if (!strings || strings.length == 0) {\\n    return '';\\n  }\\n  var sorted = strings.slice().sort();\\n  var min = sorted[0];\\n  var max = sorted[sorted.length - 1];\\n  for (var i = 0, len = min.length; i < len; i++) {\\n    if (min[i] != max[i]) {\\n      return min.slice(0, i);\\n    }\\n  }\\n  return min;\\n}\\n\\n\\nInterface.prototype._wordLeft = function() {\\n  if (this.cursor > 0) {\\n    var leading = this.line.slice(0, this.cursor);\\n    var match = leading.match(/([^\\\\w\\\\s]+|\\\\w+|)\\\\s*$/);\\n    this._moveCursor(-match[0].length);\\n  }\\n};\\n\\n\\nInterface.prototype._wordRight = function() {\\n  if (this.cursor < this.line.length) {\\n    var trailing = this.line.slice(this.cursor);\\n    var match = trailing.match(/^(\\\\s+|\\\\W+|\\\\w+)\\\\s*/);\\n    this._moveCursor(match[0].length);\\n  }\\n};\\n\\n\\nInterface.prototype._deleteLeft = function() {\\n  if (this.cursor > 0 && this.line.length > 0) {\\n    this.line = this.line.slice(0, this.cursor - 1) +\\n                this.line.slice(this.cursor, this.line.length);\\n\\n    this.cursor--;\\n    this._refreshLine();\\n  }\\n};\\n\\n\\nInterface.prototype._deleteRight = function() {\\n  this.line = this.line.slice(0, this.cursor) +\\n              this.line.slice(this.cursor + 1, this.line.length);\\n  this._refreshLine();\\n};\\n\\n\\nInterface.prototype._deleteWordLeft = function() {\\n  if (this.cursor > 0) {\\n    var leading = this.line.slice(0, this.cursor);\\n    var match = leading.match(/([^\\\\w\\\\s]+|\\\\w+|)\\\\s*$/);\\n    leading = leading.slice(0, leading.length - match[0].length);\\n    this.line = leading + this.line.slice(this.cursor, this.line.length);\\n    this.cursor = leading.length;\\n    this._refreshLine();\\n  }\\n};\\n\\n\\nInterface.prototype._deleteWordRight = function() {\\n  if (this.cursor < this.line.length) {\\n    var trailing = this.line.slice(this.cursor);\\n    var match = trailing.match(/^(\\\\s+|\\\\W+|\\\\w+)\\\\s*/);\\n    this.line = this.line.slice(0, this.cursor) +\\n                trailing.slice(match[0].length);\\n    this._refreshLine();\\n  }\\n};\\n\\n\\nInterface.prototype._deleteLineLeft = function() {\\n  this.line = this.line.slice(this.cursor);\\n  this.cursor = 0;\\n  this._refreshLine();\\n};\\n\\n\\nInterface.prototype._deleteLineRight = function() {\\n  this.line = this.line.slice(0, this.cursor);\\n  this._refreshLine();\\n};\\n\\n\\nInterface.prototype.clearLine = function() {\\n  this._moveCursor(+Infinity);\\n  this._writeToOutput('\\\\r\\\\n');\\n  this.line = '';\\n  this.cursor = 0;\\n  this.prevRows = 0;\\n};\\n\\n\\nInterface.prototype._line = function() {\\n  var line = this._addHistory();\\n  this.clearLine();\\n  this._onLine(line);\\n};\\n\\n\\nInterface.prototype._historyNext = function() {\\n  if (this.historyIndex > 0) {\\n    this.historyIndex--;\\n    this.line = this.history[this.historyIndex];\\n    this.cursor = this.line.length; // set cursor to end of line.\\n    this._refreshLine();\\n\\n  } else if (this.historyIndex === 0) {\\n    this.historyIndex = -1;\\n    this.cursor = 0;\\n    this.line = '';\\n    this._refreshLine();\\n  }\\n};\\n\\n\\nInterface.prototype._historyPrev = function() {\\n  if (this.historyIndex + 1 < this.history.length) {\\n    this.historyIndex++;\\n    this.line = this.history[this.historyIndex];\\n    this.cursor = this.line.length; // set cursor to end of line.\\n\\n    this._refreshLine();\\n  }\\n};\\n\\n\\n// Returns the last character's display position of the given string\\nInterface.prototype._getDisplayPos = function(str) {\\n  var offset = 0;\\n  var col = this.columns;\\n  var row = 0;\\n  var code;\\n  str = stripVTControlCharacters(str);\\n  for (var i = 0, len = str.length; i < len; i++) {\\n    code = str.codePointAt(i);\\n    if (code >= 0x10000) { // surrogates\\n      i++;\\n    }\\n    if (code === 0x0a) { // new line \\\\n\\n      offset = 0;\\n      row += 1;\\n      continue;\\n    }\\n    if (isFullWidthCodePoint(code)) {\\n      if ((offset + 1) % col === 0) {\\n        offset++;\\n      }\\n      offset += 2;\\n    } else {\\n      offset++;\\n    }\\n  }\\n  var cols = offset % col;\\n  var rows = row + (offset - cols) / col;\\n  return {cols: cols, rows: rows};\\n};\\n\\n\\n// Returns current cursor's position and line\\nInterface.prototype._getCursorPos = function() {\\n  var columns = this.columns;\\n  var strBeforeCursor = this._prompt + this.line.substring(0, this.cursor);\\n  var dispPos = this._getDisplayPos(stripVTControlCharacters(strBeforeCursor));\\n  var cols = dispPos.cols;\\n  var rows = dispPos.rows;\\n  // If the cursor is on a full-width character which steps over the line,\\n  // move the cursor to the beginning of the next line.\\n  if (cols + 1 === columns &&\\n      this.cursor < this.line.length &&\\n      isFullWidthCodePoint(this.line.codePointAt(this.cursor))) {\\n    rows++;\\n    cols = 0;\\n  }\\n  return {cols: cols, rows: rows};\\n};\\n\\n\\n// This function moves cursor dx places to the right\\n// (-dx for left) and refreshes the line if it is needed\\nInterface.prototype._moveCursor = function(dx) {\\n  var oldcursor = this.cursor;\\n  var oldPos = this._getCursorPos();\\n  this.cursor += dx;\\n\\n  // bounds check\\n  if (this.cursor < 0) this.cursor = 0;\\n  else if (this.cursor > this.line.length) this.cursor = this.line.length;\\n\\n  var newPos = this._getCursorPos();\\n\\n  // check if cursors are in the same line\\n  if (oldPos.rows === newPos.rows) {\\n    var diffCursor = this.cursor - oldcursor;\\n    var diffWidth;\\n    if (diffCursor < 0) {\\n      diffWidth = -getStringWidth(\\n          this.line.substring(this.cursor, oldcursor)\\n          );\\n    } else if (diffCursor > 0) {\\n      diffWidth = getStringWidth(\\n          this.line.substring(this.cursor, oldcursor)\\n          );\\n    }\\n    exports.moveCursor(this.output, diffWidth, 0);\\n    this.prevRows = newPos.rows;\\n  } else {\\n    this._refreshLine();\\n  }\\n};\\n\\n// handle a write from the tty\\nInterface.prototype._ttyWrite = function(s, key) {\\n  key = key || {};\\n  // Ignore escape key - Fixes #2876\\n  if (key.name == 'escape') return;\\n\\n  if (key.ctrl && key.shift) {\\n    /* Control and shift pressed */\\n    switch (key.name) {\\n      case 'backspace':\\n        this._deleteLineLeft();\\n        break;\\n\\n      case 'delete':\\n        this._deleteLineRight();\\n        break;\\n    }\\n\\n  } else if (key.ctrl) {\\n    /* Control key pressed */\\n\\n    switch (key.name) {\\n      case 'c':\\n        if (EventEmitter.listenerCount(this, 'SIGINT') > 0) {\\n          this.emit('SIGINT');\\n        } else {\\n          // This readline instance is finished\\n          this.close();\\n        }\\n        break;\\n\\n      case 'h': // delete left\\n        this._deleteLeft();\\n        break;\\n\\n      case 'd': // delete right or EOF\\n        if (this.cursor === 0 && this.line.length === 0) {\\n          // This readline instance is finished\\n          this.close();\\n        } else if (this.cursor < this.line.length) {\\n          this._deleteRight();\\n        }\\n        break;\\n\\n      case 'u': // delete the whole line\\n        this.cursor = 0;\\n        this.line = '';\\n        this._refreshLine();\\n        break;\\n\\n      case 'k': // delete from current to end of line\\n        this._deleteLineRight();\\n        break;\\n\\n      case 'a': // go to the start of the line\\n        this._moveCursor(-Infinity);\\n        break;\\n\\n      case 'e': // go to the end of the line\\n        this._moveCursor(+Infinity);\\n        break;\\n\\n      case 'b': // back one character\\n        this._moveCursor(-1);\\n        break;\\n\\n      case 'f': // forward one character\\n        this._moveCursor(+1);\\n        break;\\n\\n      case 'l': // clear the whole screen\\n        exports.cursorTo(this.output, 0, 0);\\n        exports.clearScreenDown(this.output);\\n        this._refreshLine();\\n        break;\\n\\n      case 'n': // next history item\\n        this._historyNext();\\n        break;\\n\\n      case 'p': // previous history item\\n        this._historyPrev();\\n        break;\\n\\n      case 'z':\\n        if (process.platform == 'win32') break;\\n        if (EventEmitter.listenerCount(this, 'SIGTSTP') > 0) {\\n          this.emit('SIGTSTP');\\n        } else {\\n          process.once('SIGCONT', (function(self) {\\n            return function() {\\n              // Don't raise events if stream has already been abandoned.\\n              if (!self.paused) {\\n                // Stream must be paused and resumed after SIGCONT to catch\\n                // SIGINT, SIGTSTP, and EOF.\\n                self.pause();\\n                self.emit('SIGCONT');\\n              }\\n              // explicitly re-enable \\\"raw mode\\\" and move the cursor to\\n              // the correct position.\\n              // See https://github.com/joyent/node/issues/3295.\\n              self._setRawMode(true);\\n              self._refreshLine();\\n            };\\n          })(this));\\n          this._setRawMode(false);\\n          process.kill(process.pid, 'SIGTSTP');\\n        }\\n        break;\\n\\n      case 'w': // delete backwards to a word boundary\\n      case 'backspace':\\n        this._deleteWordLeft();\\n        break;\\n\\n      case 'delete': // delete forward to a word boundary\\n        this._deleteWordRight();\\n        break;\\n\\n      case 'left':\\n        this._wordLeft();\\n        break;\\n\\n      case 'right':\\n        this._wordRight();\\n        break;\\n    }\\n\\n  } else if (key.meta) {\\n    /* Meta key pressed */\\n\\n    switch (key.name) {\\n      case 'b': // backward word\\n        this._wordLeft();\\n        break;\\n\\n      case 'f': // forward word\\n        this._wordRight();\\n        break;\\n\\n      case 'd': // delete forward word\\n      case 'delete':\\n        this._deleteWordRight();\\n        break;\\n\\n      case 'backspace': // delete backwards to a word boundary\\n        this._deleteWordLeft();\\n        break;\\n    }\\n\\n  } else {\\n    /* No modifier keys used */\\n\\n    // \\\\r bookkeeping is only relevant if a \\\\n comes right after.\\n    if (this._sawReturn && key.name !== 'enter')\\n      this._sawReturn = false;\\n\\n    switch (key.name) {\\n      case 'return':  // carriage return, i.e. \\\\r\\n        this._sawReturn = true;\\n        this._line();\\n        break;\\n\\n      case 'enter':\\n        if (this._sawReturn)\\n          this._sawReturn = false;\\n        else\\n          this._line();\\n        break;\\n\\n      case 'backspace':\\n        this._deleteLeft();\\n        break;\\n\\n      case 'delete':\\n        this._deleteRight();\\n        break;\\n\\n      case 'tab': // tab completion\\n        this._tabComplete();\\n        break;\\n\\n      case 'left':\\n        this._moveCursor(-1);\\n        break;\\n\\n      case 'right':\\n        this._moveCursor(+1);\\n        break;\\n\\n      case 'home':\\n        this._moveCursor(-Infinity);\\n        break;\\n\\n      case 'end':\\n        this._moveCursor(+Infinity);\\n        break;\\n\\n      case 'up':\\n        this._historyPrev();\\n        break;\\n\\n      case 'down':\\n        this._historyNext();\\n        break;\\n\\n      default:\\n        if (s instanceof Buffer)\\n          s = s.toString('utf-8');\\n\\n        if (s) {\\n          var lines = s.split(/\\\\r\\\\n|\\\\n|\\\\r/);\\n          for (var i = 0, len = lines.length; i < len; i++) {\\n            if (i > 0) {\\n              this._line();\\n            }\\n            this._insertString(lines[i]);\\n          }\\n        }\\n    }\\n  }\\n};\\n\\n\\nexports.Interface = Interface;\\n\\n\\n\\n/**\\n * accepts a readable Stream instance and makes it emit \\\"keypress\\\" events\\n */\\n\\nfunction emitKeypressEvents(stream) {\\n  if (stream._keypressDecoder) return;\\n  var StringDecoder = require('string_decoder').StringDecoder; // lazy load\\n  stream._keypressDecoder = new StringDecoder('utf8');\\n\\n  function onData(b) {\\n    if (EventEmitter.listenerCount(stream, 'keypress') > 0) {\\n      var r = stream._keypressDecoder.write(b);\\n      if (r) emitKeys(stream, r);\\n    } else {\\n      // Nobody's watching anyway\\n      stream.removeListener('data', onData);\\n      stream.on('newListener', onNewListener);\\n    }\\n  }\\n\\n  function onNewListener(event) {\\n    if (event == 'keypress') {\\n      stream.on('data', onData);\\n      stream.removeListener('newListener', onNewListener);\\n    }\\n  }\\n\\n  if (EventEmitter.listenerCount(stream, 'keypress') > 0) {\\n    stream.on('data', onData);\\n  } else {\\n    stream.on('newListener', onNewListener);\\n  }\\n}\\nexports.emitKeypressEvents = emitKeypressEvents;\\n\\n/*\\n  Some patterns seen in terminal key escape codes, derived from combos seen\\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\\n\\n  ESC letter\\n  ESC [ letter\\n  ESC [ modifier letter\\n  ESC [ 1 ; modifier letter\\n  ESC [ num char\\n  ESC [ num ; modifier char\\n  ESC O letter\\n  ESC O modifier letter\\n  ESC O 1 ; modifier letter\\n  ESC N letter\\n  ESC [ [ num ; modifier char\\n  ESC [ [ 1 ; modifier letter\\n  ESC ESC [ num char\\n  ESC ESC O letter\\n\\n  - char is usually ~ but $ and ^ also happen with rxvt\\n  - modifier is 1 +\\n                (shift     * 1) +\\n                (left_alt  * 2) +\\n                (ctrl      * 4) +\\n                (right_alt * 8)\\n  - two leading ESCs apparently mean the same as one leading ESC\\n*/\\n\\n// Regexes used for ansi escape code splitting\\nvar metaKeyCodeReAnywhere = /(?:\\\\x1b)([a-zA-Z0-9])/;\\nvar metaKeyCodeRe = new RegExp('^' + metaKeyCodeReAnywhere.source + '$');\\nvar functionKeyCodeReAnywhere = new RegExp('(?:\\\\x1b+)(O|N|\\\\\\\\[|\\\\\\\\[\\\\\\\\[)(?:' + [\\n  '(\\\\\\\\d+)(?:;(\\\\\\\\d+))?([~^$])',\\n  '(?:M([@ #!a`])(.)(.))', // mouse\\n  '(?:1;)?(\\\\\\\\d+)?([a-zA-Z])'\\n].join('|') + ')');\\nvar functionKeyCodeRe = new RegExp('^' + functionKeyCodeReAnywhere.source);\\nvar escapeCodeReAnywhere = new RegExp([\\n  functionKeyCodeReAnywhere.source, metaKeyCodeReAnywhere.source, /\\\\x1b./.source\\n].join('|'));\\n\\nfunction emitKeys(stream, s) {\\n  if (s instanceof Buffer) {\\n    if (s[0] > 127 && s[1] === undefined) {\\n      s[0] -= 128;\\n      s = '\\\\x1b' + s.toString(stream.encoding || 'utf-8');\\n    } else {\\n      s = s.toString(stream.encoding || 'utf-8');\\n    }\\n  }\\n\\n  var buffer = [];\\n  var match;\\n  while (match = escapeCodeReAnywhere.exec(s)) {\\n    buffer = buffer.concat(s.slice(0, match.index).split(''));\\n    buffer.push(match[0]);\\n    s = s.slice(match.index + match[0].length);\\n  }\\n  buffer = buffer.concat(s.split(''));\\n\\n  buffer.forEach(function(s) {\\n    var ch,\\n        key = {\\n          sequence: s,\\n          name: undefined,\\n          ctrl: false,\\n          meta: false,\\n          shift: false\\n        },\\n        parts;\\n\\n    if (s === '\\\\r') {\\n      // carriage return\\n      key.name = 'return';\\n\\n    } else if (s === '\\\\n') {\\n      // enter, should have been called linefeed\\n      key.name = 'enter';\\n\\n    } else if (s === '\\\\t') {\\n      // tab\\n      key.name = 'tab';\\n\\n    } else if (s === '\\\\b' || s === '\\\\x7f' ||\\n               s === '\\\\x1b\\\\x7f' || s === '\\\\x1b\\\\b') {\\n      // backspace or ctrl+h\\n      key.name = 'backspace';\\n      key.meta = (s.charAt(0) === '\\\\x1b');\\n\\n    } else if (s === '\\\\x1b' || s === '\\\\x1b\\\\x1b') {\\n      // escape key\\n      key.name = 'escape';\\n      key.meta = (s.length === 2);\\n\\n    } else if (s === ' ' || s === '\\\\x1b ') {\\n      key.name = 'space';\\n      key.meta = (s.length === 2);\\n\\n    } else if (s.length === 1 && s <= '\\\\x1a') {\\n      // ctrl+letter\\n      key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);\\n      key.ctrl = true;\\n\\n    } else if (s.length === 1 && s >= 'a' && s <= 'z') {\\n      // lowercase letter\\n      key.name = s;\\n\\n    } else if (s.length === 1 && s >= 'A' && s <= 'Z') {\\n      // shift+letter\\n      key.name = s.toLowerCase();\\n      key.shift = true;\\n\\n    } else if (parts = metaKeyCodeRe.exec(s)) {\\n      // meta+character key\\n      key.name = parts[1].toLowerCase();\\n      key.meta = true;\\n      key.shift = /^[A-Z]$/.test(parts[1]);\\n\\n    } else if (parts = functionKeyCodeRe.exec(s)) {\\n      // ansi escape sequence\\n\\n      // reassemble the key code leaving out leading \\\\x1b's,\\n      // the modifier key bitflag and any meaningless \\\"1;\\\" sequence\\n      var code = (parts[1] || '') + (parts[2] || '') +\\n                 (parts[4] || '') + (parts[9] || ''),\\n          modifier = (parts[3] || parts[8] || 1) - 1;\\n\\n      // Parse the key modifier\\n      key.ctrl = !!(modifier & 4);\\n      key.meta = !!(modifier & 10);\\n      key.shift = !!(modifier & 1);\\n      key.code = code;\\n\\n      // Parse the key itself\\n      switch (code) {\\n        /* xterm/gnome ESC O letter */\\n        case 'OP': key.name = 'f1'; break;\\n        case 'OQ': key.name = 'f2'; break;\\n        case 'OR': key.name = 'f3'; break;\\n        case 'OS': key.name = 'f4'; break;\\n\\n        /* xterm/rxvt ESC [ number ~ */\\n        case '[11~': key.name = 'f1'; break;\\n        case '[12~': key.name = 'f2'; break;\\n        case '[13~': key.name = 'f3'; break;\\n        case '[14~': key.name = 'f4'; break;\\n\\n        /* from Cygwin and used in libuv */\\n        case '[[A': key.name = 'f1'; break;\\n        case '[[B': key.name = 'f2'; break;\\n        case '[[C': key.name = 'f3'; break;\\n        case '[[D': key.name = 'f4'; break;\\n        case '[[E': key.name = 'f5'; break;\\n\\n        /* common */\\n        case '[15~': key.name = 'f5'; break;\\n        case '[17~': key.name = 'f6'; break;\\n        case '[18~': key.name = 'f7'; break;\\n        case '[19~': key.name = 'f8'; break;\\n        case '[20~': key.name = 'f9'; break;\\n        case '[21~': key.name = 'f10'; break;\\n        case '[23~': key.name = 'f11'; break;\\n        case '[24~': key.name = 'f12'; break;\\n\\n        /* xterm ESC [ letter */\\n        case '[A': key.name = 'up'; break;\\n        case '[B': key.name = 'down'; break;\\n        case '[C': key.name = 'right'; break;\\n        case '[D': key.name = 'left'; break;\\n        case '[E': key.name = 'clear'; break;\\n        case '[F': key.name = 'end'; break;\\n        case '[H': key.name = 'home'; break;\\n\\n        /* xterm/gnome ESC O letter */\\n        case 'OA': key.name = 'up'; break;\\n        case 'OB': key.name = 'down'; break;\\n        case 'OC': key.name = 'right'; break;\\n        case 'OD': key.name = 'left'; break;\\n        case 'OE': key.name = 'clear'; break;\\n        case 'OF': key.name = 'end'; break;\\n        case 'OH': key.name = 'home'; break;\\n\\n        /* xterm/rxvt ESC [ number ~ */\\n        case '[1~': key.name = 'home'; break;\\n        case '[2~': key.name = 'insert'; break;\\n        case '[3~': key.name = 'delete'; break;\\n        case '[4~': key.name = 'end'; break;\\n        case '[5~': key.name = 'pageup'; break;\\n        case '[6~': key.name = 'pagedown'; break;\\n\\n        /* putty */\\n        case '[[5~': key.name = 'pageup'; break;\\n        case '[[6~': key.name = 'pagedown'; break;\\n\\n        /* rxvt */\\n        case '[7~': key.name = 'home'; break;\\n        case '[8~': key.name = 'end'; break;\\n\\n        /* rxvt keys with modifiers */\\n        case '[a': key.name = 'up'; key.shift = true; break;\\n        case '[b': key.name = 'down'; key.shift = true; break;\\n        case '[c': key.name = 'right'; key.shift = true; break;\\n        case '[d': key.name = 'left'; key.shift = true; break;\\n        case '[e': key.name = 'clear'; key.shift = true; break;\\n\\n        case '[2$': key.name = 'insert'; key.shift = true; break;\\n        case '[3$': key.name = 'delete'; key.shift = true; break;\\n        case '[5$': key.name = 'pageup'; key.shift = true; break;\\n        case '[6$': key.name = 'pagedown'; key.shift = true; break;\\n        case '[7$': key.name = 'home'; key.shift = true; break;\\n        case '[8$': key.name = 'end'; key.shift = true; break;\\n\\n        case 'Oa': key.name = 'up'; key.ctrl = true; break;\\n        case 'Ob': key.name = 'down'; key.ctrl = true; break;\\n        case 'Oc': key.name = 'right'; key.ctrl = true; break;\\n        case 'Od': key.name = 'left'; key.ctrl = true; break;\\n        case 'Oe': key.name = 'clear'; key.ctrl = true; break;\\n\\n        case '[2^': key.name = 'insert'; key.ctrl = true; break;\\n        case '[3^': key.name = 'delete'; key.ctrl = true; break;\\n        case '[5^': key.name = 'pageup'; key.ctrl = true; break;\\n        case '[6^': key.name = 'pagedown'; key.ctrl = true; break;\\n        case '[7^': key.name = 'home'; key.ctrl = true; break;\\n        case '[8^': key.name = 'end'; key.ctrl = true; break;\\n\\n        /* misc. */\\n        case '[Z': key.name = 'tab'; key.shift = true; break;\\n        default: key.name = 'undefined'; break;\\n\\n      }\\n    }\\n\\n    // Don't emit a key if no name was found\\n    if (key.name === undefined) {\\n      key = undefined;\\n    }\\n\\n    if (s.length === 1) {\\n      ch = s;\\n    }\\n\\n    if (key || ch) {\\n      stream.emit('keypress', ch, key);\\n    }\\n  });\\n}\\n\\n\\n/**\\n * moves the cursor to the x and y coordinate on the given stream\\n */\\n\\nfunction cursorTo(stream, x, y) {\\n  if (stream === null || stream === undefined)\\n    return;\\n\\n  if (typeof x !== 'number' && typeof y !== 'number')\\n    return;\\n\\n  if (typeof x !== 'number')\\n    throw new Error(\\\"Can't set cursor row without also setting it's column\\\");\\n\\n  if (typeof y !== 'number') {\\n    stream.write('\\\\x1b[' + (x + 1) + 'G');\\n  } else {\\n    stream.write('\\\\x1b[' + (y + 1) + ';' + (x + 1) + 'H');\\n  }\\n}\\nexports.cursorTo = cursorTo;\\n\\n\\n/**\\n * moves the cursor relative to its current location\\n */\\n\\nfunction moveCursor(stream, dx, dy) {\\n  if (stream === null || stream === undefined)\\n    return;\\n\\n  if (dx < 0) {\\n    stream.write('\\\\x1b[' + (-dx) + 'D');\\n  } else if (dx > 0) {\\n    stream.write('\\\\x1b[' + dx + 'C');\\n  }\\n\\n  if (dy < 0) {\\n    stream.write('\\\\x1b[' + (-dy) + 'A');\\n  } else if (dy > 0) {\\n    stream.write('\\\\x1b[' + dy + 'B');\\n  }\\n}\\nexports.moveCursor = moveCursor;\\n\\n\\n/**\\n * clears the current line the cursor is on:\\n *   -1 for left of the cursor\\n *   +1 for right of the cursor\\n *    0 for the entire line\\n */\\n\\nfunction clearLine(stream, dir) {\\n  if (stream === null || stream === undefined)\\n    return;\\n\\n  if (dir < 0) {\\n    // to the beginning\\n    stream.write('\\\\x1b[1K');\\n  } else if (dir > 0) {\\n    // to the end\\n    stream.write('\\\\x1b[0K');\\n  } else {\\n    // entire line\\n    stream.write('\\\\x1b[2K');\\n  }\\n}\\nexports.clearLine = clearLine;\\n\\n\\n/**\\n * clears the screen from the current position of the cursor down\\n */\\n\\nfunction clearScreenDown(stream) {\\n  if (stream === null || stream === undefined)\\n    return;\\n\\n  stream.write('\\\\x1b[0J');\\n}\\nexports.clearScreenDown = clearScreenDown;\\n\\n\\n/**\\n * Returns the number of columns required to display the given string.\\n */\\n\\nfunction getStringWidth(str) {\\n  var width = 0;\\n  str = stripVTControlCharacters(str);\\n  for (var i = 0, len = str.length; i < len; i++) {\\n    var code = str.codePointAt(i);\\n    if (code >= 0x10000) { // surrogates\\n      i++;\\n    }\\n    if (isFullWidthCodePoint(code)) {\\n      width += 2;\\n    } else {\\n      width++;\\n    }\\n  }\\n  return width;\\n}\\nexports.getStringWidth = getStringWidth;\\n\\n\\n/**\\n * Returns true if the character represented by a given\\n * Unicode code point is full-width. Otherwise returns false.\\n */\\n\\nfunction isFullWidthCodePoint(code) {\\n  if (isNaN(code)) {\\n    return false;\\n  }\\n\\n  // Code points are derived from:\\n  // http://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\\n  if (code >= 0x1100 && (\\n      code <= 0x115f ||  // Hangul Jamo\\n      0x2329 === code || // LEFT-POINTING ANGLE BRACKET\\n      0x232a === code || // RIGHT-POINTING ANGLE BRACKET\\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\\n      (0x2e80 <= code && code <= 0x3247 && code !== 0x303f) ||\\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\\n      0x3250 <= code && code <= 0x4dbf ||\\n      // CJK Unified Ideographs .. Yi Radicals\\n      0x4e00 <= code && code <= 0xa4c6 ||\\n      // Hangul Jamo Extended-A\\n      0xa960 <= code && code <= 0xa97c ||\\n      // Hangul Syllables\\n      0xac00 <= code && code <= 0xd7a3 ||\\n      // CJK Compatibility Ideographs\\n      0xf900 <= code && code <= 0xfaff ||\\n      // Vertical Forms\\n      0xfe10 <= code && code <= 0xfe19 ||\\n      // CJK Compatibility Forms .. Small Form Variants\\n      0xfe30 <= code && code <= 0xfe6b ||\\n      // Halfwidth and Fullwidth Forms\\n      0xff01 <= code && code <= 0xff60 ||\\n      0xffe0 <= code && code <= 0xffe6 ||\\n      // Kana Supplement\\n      0x1b000 <= code && code <= 0x1b001 ||\\n      // Enclosed Ideographic Supplement\\n      0x1f200 <= code && code <= 0x1f251 ||\\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\\n      0x20000 <= code && code <= 0x3fffd)) {\\n    return true;\\n  }\\n  return false;\\n}\\nexports.isFullWidthCodePoint = isFullWidthCodePoint;\\n\\n\\n/**\\n * Returns the Unicode code point for the character at the\\n * given index in the given string. Similar to String.charCodeAt(),\\n * but this function handles surrogates (code point >= 0x10000).\\n */\\n\\nfunction codePointAt(str, index) {\\n  var code = str.charCodeAt(index);\\n  var low;\\n  if (0xd800 <= code && code <= 0xdbff) { // High surrogate\\n    low = str.charCodeAt(index + 1);\\n    if (!isNaN(low)) {\\n      code = 0x10000 + (code - 0xd800) * 0x400 + (low - 0xdc00);\\n    }\\n  }\\n  return code;\\n}\\nexports.codePointAt = util.deprecate(codePointAt,\\n    'codePointAt() is deprecated. Use String.prototype.codePointAt');\\n\\n\\n/**\\n * Tries to remove all VT control characters. Use to estimate displayed\\n * string width. May be buggy due to not running a real state machine\\n */\\nfunction stripVTControlCharacters(str) {\\n  str = str.replace(new RegExp(functionKeyCodeReAnywhere.source, 'g'), '');\\n  return str.replace(new RegExp(metaKeyCodeReAnywhere.source, 'g'), '');\\n}\\nexports.stripVTControlCharacters = stripVTControlCharacters;\\n\",\"querystring\":\"// Query String Utilities\\n\\n'use strict';\\n\\nvar QueryString = exports;\\nvar Buffer = require('buffer').Buffer;\\n\\n\\nfunction charCode(c) {\\n  return c.charCodeAt(0);\\n}\\n\\n\\n// a safe fast alternative to decodeURIComponent\\nQueryString.unescapeBuffer = function(s, decodeSpaces) {\\n  var out = new Buffer(s.length);\\n  var state = 'CHAR'; // states: CHAR, HEX0, HEX1\\n  var n, m, hexchar;\\n\\n  for (var inIndex = 0, outIndex = 0; inIndex <= s.length; inIndex++) {\\n    var c = s.charCodeAt(inIndex);\\n    switch (state) {\\n      case 'CHAR':\\n        switch (c) {\\n          case charCode('%'):\\n            n = 0;\\n            m = 0;\\n            state = 'HEX0';\\n            break;\\n          case charCode('+'):\\n            if (decodeSpaces) c = charCode(' ');\\n            // falls through\\n          default:\\n            out[outIndex++] = c;\\n            break;\\n        }\\n        break;\\n\\n      case 'HEX0':\\n        state = 'HEX1';\\n        hexchar = c;\\n        if (charCode('0') <= c && c <= charCode('9')) {\\n          n = c - charCode('0');\\n        } else if (charCode('a') <= c && c <= charCode('f')) {\\n          n = c - charCode('a') + 10;\\n        } else if (charCode('A') <= c && c <= charCode('F')) {\\n          n = c - charCode('A') + 10;\\n        } else {\\n          out[outIndex++] = charCode('%');\\n          out[outIndex++] = c;\\n          state = 'CHAR';\\n          break;\\n        }\\n        break;\\n\\n      case 'HEX1':\\n        state = 'CHAR';\\n        if (charCode('0') <= c && c <= charCode('9')) {\\n          m = c - charCode('0');\\n        } else if (charCode('a') <= c && c <= charCode('f')) {\\n          m = c - charCode('a') + 10;\\n        } else if (charCode('A') <= c && c <= charCode('F')) {\\n          m = c - charCode('A') + 10;\\n        } else {\\n          out[outIndex++] = charCode('%');\\n          out[outIndex++] = hexchar;\\n          out[outIndex++] = c;\\n          break;\\n        }\\n        out[outIndex++] = 16 * n + m;\\n        break;\\n    }\\n  }\\n\\n  // TODO support returning arbitrary buffers.\\n\\n  return out.slice(0, outIndex - 1);\\n};\\n\\n\\nQueryString.unescape = function(s, decodeSpaces) {\\n  try {\\n    return decodeURIComponent(s);\\n  } catch (e) {\\n    return QueryString.unescapeBuffer(s, decodeSpaces).toString();\\n  }\\n};\\n\\n\\nvar hexTable = new Array(256);\\nfor (var i = 0; i < 256; ++i)\\n  hexTable[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\\nQueryString.escape = function(str) {\\n  // replaces encodeURIComponent\\n  // http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3.4\\n  str = '' + str;\\n  var len = str.length;\\n  var out = '';\\n  var i, c;\\n\\n  if (len === 0)\\n    return str;\\n\\n  for (i = 0; i < len; ++i) {\\n    c = str.charCodeAt(i);\\n\\n    // These characters do not need escaping (in order):\\n    // ! - . _ ~\\n    // ' ( ) *\\n    // digits\\n    // alpha (uppercase)\\n    // alpha (lowercase)\\n    if (c === 0x21 || c === 0x2D || c === 0x2E || c === 0x5F || c === 0x7E ||\\n        (c >= 0x27 && c <= 0x2A) ||\\n        (c >= 0x30 && c <= 0x39) ||\\n        (c >= 0x41 && c <= 0x5A) ||\\n        (c >= 0x61 && c <= 0x7A)) {\\n      out += str[i];\\n      continue;\\n    }\\n\\n    // Other ASCII characters\\n    if (c < 0x80) {\\n      out += hexTable[c];\\n      continue;\\n    }\\n\\n    // Multi-byte characters ...\\n    if (c < 0x800) {\\n      out += hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)];\\n      continue;\\n    }\\n    if (c < 0xD800 || c >= 0xE000) {\\n      out += hexTable[0xE0 | (c >> 12)] +\\n             hexTable[0x80 | ((c >> 6) & 0x3F)] +\\n             hexTable[0x80 | (c & 0x3F)];\\n      continue;\\n    }\\n    // Surrogate pair\\n    ++i;\\n    c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));\\n    out += hexTable[0xF0 | (c >> 18)] +\\n           hexTable[0x80 | ((c >> 12) & 0x3F)] +\\n           hexTable[0x80 | ((c >> 6) & 0x3F)] +\\n           hexTable[0x80 | (c & 0x3F)];\\n  }\\n  return out;\\n};\\n\\nvar stringifyPrimitive = function(v) {\\n  if (typeof v === 'string')\\n    return v;\\n  if (typeof v === 'number' && isFinite(v))\\n    return '' + v;\\n  if (typeof v === 'boolean')\\n    return v ? 'true' : 'false';\\n  return '';\\n};\\n\\n\\nQueryString.stringify = QueryString.encode = function(obj, sep, eq, options) {\\n  sep = sep || '&';\\n  eq = eq || '=';\\n\\n  var encode = QueryString.escape;\\n  if (options && typeof options.encodeURIComponent === 'function') {\\n    encode = options.encodeURIComponent;\\n  }\\n\\n  if (obj !== null && typeof obj === 'object') {\\n    var keys = Object.keys(obj);\\n    var len = keys.length;\\n    var flast = len - 1;\\n    var fields = '';\\n    for (var i = 0; i < len; ++i) {\\n      var k = keys[i];\\n      var v = obj[k];\\n      var ks = encode(stringifyPrimitive(k)) + eq;\\n\\n      if (Array.isArray(v)) {\\n        var vlen = v.length;\\n        var vlast = vlen - 1;\\n        for (var j = 0; j < vlen; ++j) {\\n          fields += ks + encode(stringifyPrimitive(v[j]));\\n          if (j < vlast)\\n            fields += sep;\\n        }\\n        if (vlen && i < flast)\\n          fields += sep;\\n      } else {\\n        fields += ks + encode(stringifyPrimitive(v));\\n        if (i < flast)\\n          fields += sep;\\n      }\\n    }\\n    return fields;\\n  }\\n  return '';\\n};\\n\\n// Parse a key=val string.\\nQueryString.parse = QueryString.decode = function(qs, sep, eq, options) {\\n  sep = sep || '&';\\n  eq = eq || '=';\\n  var eqLen = eq.length;\\n  var obj = {};\\n\\n  if (typeof qs !== 'string' || qs.length === 0) {\\n    return obj;\\n  }\\n\\n  var regexp = /\\\\+/g;\\n  qs = qs.split(sep);\\n\\n  var maxKeys = 1000;\\n  if (options && typeof options.maxKeys === 'number') {\\n    maxKeys = options.maxKeys;\\n  }\\n\\n  var len = qs.length;\\n  // maxKeys <= 0 means that we should not limit keys count\\n  if (maxKeys > 0 && len > maxKeys) {\\n    len = maxKeys;\\n  }\\n\\n  var decode = QueryString.unescape;\\n  if (options && typeof options.decodeURIComponent === 'function') {\\n    decode = options.decodeURIComponent;\\n  }\\n\\n  var keys = [];\\n  for (var i = 0; i < len; ++i) {\\n    var x = qs[i].replace(regexp, '%20'),\\n        idx = x.indexOf(eq),\\n        k, v;\\n\\n    if (idx >= 0) {\\n      k = decodeStr(x.substring(0, idx), decode);\\n      v = decodeStr(x.substring(idx + eqLen), decode);\\n    } else {\\n      k = decodeStr(x, decode);\\n      v = '';\\n    }\\n\\n    if (keys.indexOf(k) === -1) {\\n      obj[k] = v;\\n      keys.push(k);\\n    } else if (Array.isArray(obj[k])) {\\n      obj[k].push(v);\\n    } else {\\n      obj[k] = [obj[k], v];\\n    }\\n  }\\n\\n  return obj;\\n};\\n\\n\\nfunction decodeStr(s, decoder) {\\n  try {\\n    return decoder(s);\\n  } catch (e) {\\n    return QueryString.unescape(s, true);\\n  }\\n}\\n\",\"assert\":\"// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\\n//\\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\\n//\\n// Originally from narwhal.js (http://narwhaljs.org)\\n// Copyright (c) 2009 Thomas Robinson <280north.com>\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the 'Software'), to\\n// deal in the Software without restriction, including without limitation the\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\\n// sell copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// UTILITY\\nvar util = require('util');\\nvar pSlice = Array.prototype.slice;\\n\\n// 1. The assert module provides functions that throw\\n// AssertionError's when particular conditions are not met. The\\n// assert module must conform to the following interface.\\n\\nvar assert = module.exports = ok;\\n\\n// 2. The AssertionError is defined in assert.\\n// new assert.AssertionError({ message: message,\\n//                             actual: actual,\\n//                             expected: expected })\\n\\nassert.AssertionError = function AssertionError(options) {\\n  this.name = 'AssertionError';\\n  this.actual = options.actual;\\n  this.expected = options.expected;\\n  this.operator = options.operator;\\n  if (options.message) {\\n    this.message = options.message;\\n    this.generatedMessage = false;\\n  } else {\\n    this.message = getMessage(this);\\n    this.generatedMessage = true;\\n  }\\n  var stackStartFunction = options.stackStartFunction || fail;\\n  //Error.captureStackTrace(this, stackStartFunction);\\n};\\n\\n// assert.AssertionError instanceof Error\\nutil.inherits(assert.AssertionError, Error);\\n\\nfunction replacer(key, value) {\\n  if (util.isUndefined(value)) {\\n    return '' + value;\\n  }\\n  if (util.isNumber(value) && !isFinite(value)) {\\n    return value.toString();\\n  }\\n  if (util.isFunction(value) || util.isRegExp(value)) {\\n    return value.toString();\\n  }\\n  return value;\\n}\\n\\nfunction truncate(s, n) {\\n  if (util.isString(s)) {\\n    return s.length < n ? s : s.slice(0, n);\\n  } else {\\n    return s;\\n  }\\n}\\n\\nfunction getMessage(self) {\\n  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +\\n         self.operator + ' ' +\\n         truncate(JSON.stringify(self.expected, replacer), 128);\\n}\\n\\n// At present only the three keys mentioned above are used and\\n// understood by the spec. Implementations or sub modules can pass\\n// other keys to the AssertionError's constructor - they will be\\n// ignored.\\n\\n// 3. All of the following functions must throw an AssertionError\\n// when a corresponding condition is not met, with a message that\\n// may be undefined if not provided.  All assertion methods provide\\n// both the actual and expected values to the assertion error for\\n// display purposes.\\n\\nfunction fail(actual, expected, message, operator, stackStartFunction) {\\n  throw new assert.AssertionError({\\n    message: message,\\n    actual: actual,\\n    expected: expected,\\n    operator: operator,\\n    stackStartFunction: stackStartFunction\\n  });\\n}\\n\\n// EXTENSION! allows for well behaved errors defined elsewhere.\\nassert.fail = fail;\\n\\n// 4. Pure assertion tests whether a value is truthy, as determined\\n// by !!guard.\\n// assert.ok(guard, message_opt);\\n// This statement is equivalent to assert.equal(true, !!guard,\\n// message_opt);. To test strictly for the value true, use\\n// assert.strictEqual(true, guard, message_opt);.\\n\\nfunction ok(value, message) {\\n  if (!value) fail(value, true, message, '==', assert.ok);\\n}\\nassert.ok = ok;\\n\\n// 5. The equality assertion tests shallow, coercive equality with\\n// ==.\\n// assert.equal(actual, expected, message_opt);\\n\\nassert.equal = function equal(actual, expected, message) {\\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\\n};\\n\\n// 6. The non-equality assertion tests for whether two objects are not equal\\n// with != assert.notEqual(actual, expected, message_opt);\\n\\nassert.notEqual = function notEqual(actual, expected, message) {\\n  if (actual == expected) {\\n    fail(actual, expected, message, '!=', assert.notEqual);\\n  }\\n};\\n\\n// 7. The equivalence assertion tests a deep equality relation.\\n// assert.deepEqual(actual, expected, message_opt);\\n\\nassert.deepEqual = function deepEqual(actual, expected, message) {\\n  if (!_deepEqual(actual, expected)) {\\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\\n  }\\n};\\n\\nfunction _deepEqual(actual, expected) {\\n  // 7.1. All identical values are equivalent, as determined by ===.\\n  if (actual === expected) {\\n    return true;\\n\\n  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {\\n    if (actual.length != expected.length) return false;\\n\\n    for (var i = 0; i < actual.length; i++) {\\n      if (actual[i] !== expected[i]) return false;\\n    }\\n\\n    return true;\\n\\n  // 7.2. If the expected value is a Date object, the actual value is\\n  // equivalent if it is also a Date object that refers to the same time.\\n  } else if (util.isDate(actual) && util.isDate(expected)) {\\n    return actual.getTime() === expected.getTime();\\n\\n  // 7.3 If the expected value is a RegExp object, the actual value is\\n  // equivalent if it is also a RegExp object with the same source and\\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\\n    return actual.source === expected.source &&\\n           actual.global === expected.global &&\\n           actual.multiline === expected.multiline &&\\n           actual.lastIndex === expected.lastIndex &&\\n           actual.ignoreCase === expected.ignoreCase;\\n\\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\\n  // equivalence is determined by ==.\\n  } else if (!util.isObject(actual) && !util.isObject(expected)) {\\n    return actual == expected;\\n\\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\\n  // determined by having the same number of owned properties (as verified\\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\\n  // (although not necessarily the same order), equivalent values for every\\n  // corresponding key, and an identical 'prototype' property. Note: this\\n  // accounts for both named and indexed properties on Arrays.\\n  } else {\\n    return objEquiv(actual, expected);\\n  }\\n}\\n\\nfunction isArguments(object) {\\n  return Object.prototype.toString.call(object) == '[object Arguments]';\\n}\\n\\nfunction objEquiv(a, b) {\\n  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))\\n    return false;\\n  // an identical 'prototype' property.\\n  if (a.prototype !== b.prototype) return false;\\n  //~~~I've managed to break Object.keys through screwy arguments passing.\\n  //   Converting to array solves the problem.\\n  var aIsArgs = isArguments(a),\\n      bIsArgs = isArguments(b);\\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\\n    return false;\\n  if (aIsArgs) {\\n    a = pSlice.call(a);\\n    b = pSlice.call(b);\\n    return _deepEqual(a, b);\\n  }\\n  try {\\n    var ka = Object.keys(a),\\n        kb = Object.keys(b),\\n        key, i;\\n  } catch (e) {//happens when one is a string literal and the other isn't\\n    return false;\\n  }\\n  // having the same number of owned properties (keys incorporates\\n  // hasOwnProperty)\\n  if (ka.length != kb.length)\\n    return false;\\n  //the same set of keys (although not necessarily the same order),\\n  ka.sort();\\n  kb.sort();\\n  //~~~cheap key test\\n  for (i = ka.length - 1; i >= 0; i--) {\\n    if (ka[i] != kb[i])\\n      return false;\\n  }\\n  //equivalent values for every corresponding key, and\\n  //~~~possibly expensive deep test\\n  for (i = ka.length - 1; i >= 0; i--) {\\n    key = ka[i];\\n    if (!_deepEqual(a[key], b[key])) return false;\\n  }\\n  return true;\\n}\\n\\n// 8. The non-equivalence assertion tests for any deep inequality.\\n// assert.notDeepEqual(actual, expected, message_opt);\\n\\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\\n  if (_deepEqual(actual, expected)) {\\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\\n  }\\n};\\n\\n// 9. The strict equality assertion tests strict equality, as determined by ===.\\n// assert.strictEqual(actual, expected, message_opt);\\n\\nassert.strictEqual = function strictEqual(actual, expected, message) {\\n  if (actual !== expected) {\\n    fail(actual, expected, message, '===', assert.strictEqual);\\n  }\\n};\\n\\n// 10. The strict non-equality assertion tests for strict inequality, as\\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\\n\\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\\n  if (actual === expected) {\\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\\n  }\\n};\\n\\nfunction expectedException(actual, expected) {\\n  if (!actual || !expected) {\\n    return false;\\n  }\\n\\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\\n    return expected.test(actual);\\n  } else if (actual instanceof expected) {\\n    return true;\\n  } else if (expected.call({}, actual) === true) {\\n    return true;\\n  }\\n\\n  return false;\\n}\\n\\nfunction _throws(shouldThrow, block, expected, message) {\\n  var actual;\\n\\n  if (util.isString(expected)) {\\n    message = expected;\\n    expected = null;\\n  }\\n\\n  try {\\n    block();\\n  } catch (e) {\\n    actual = e;\\n  }\\n\\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\\n            (message ? ' ' + message : '.');\\n\\n  if (shouldThrow && !actual) {\\n    fail(actual, expected, 'Missing expected exception' + message);\\n  }\\n\\n  if (!shouldThrow && expectedException(actual, expected)) {\\n    fail(actual, expected, 'Got unwanted exception' + message);\\n  }\\n\\n  if ((shouldThrow && actual && expected &&\\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\\n    throw actual;\\n  }\\n}\\n\\n// 11. Expected to throw an error:\\n// assert.throws(block, Error_opt, message_opt);\\n\\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\\n};\\n\\n// EXTENSION! This is annoying to write outside this module.\\nassert.doesNotThrow = function(block, /*optional*/message) {\\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\\n};\\n\\nassert.ifError = function(err) {\\n  if (err) {throw new Error(err);}\\n};\\n\",\"console\":\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nvar util = require('util');\\nvar NEWLINE = '';\\n\\nfunction Console(stdout, stderr) {\\n  if (!(this instanceof Console)) {\\n    return new Console(stdout, stderr);\\n  }\\n  if (!stdout || !util.isFunction(stdout.write)) {\\n    throw new TypeError('Console expects a writable stream instance');\\n  }\\n  if (!stderr) {\\n    stderr = stdout;\\n  }\\n  var prop = {\\n    writable: true,\\n    enumerable: false,\\n    configurable: true\\n  };\\n  prop.value = stdout;\\n  Object.defineProperty(this, '_stdout', prop);\\n  prop.value = stderr;\\n  Object.defineProperty(this, '_stderr', prop);\\n  prop.value = {};\\n  Object.defineProperty(this, '_times', prop);\\n\\n  // bind the prototype functions to this Console instance\\n  Object.keys(Console.prototype).forEach(function(k) {\\n    this[k] = this[k].bind(this);\\n  }, this);\\n}\\n\\nConsole.prototype.log = function() {\\n  this._stdout.write(util.format.apply(this, arguments) + NEWLINE );\\n};\\n\\n\\nConsole.prototype.info = Console.prototype.log;\\n\\n\\nConsole.prototype.warn = function() {\\n  this._stderr.write(util.format.apply(this, arguments) + NEWLINE );\\n};\\n\\n\\nConsole.prototype.error = Console.prototype.warn;\\n\\n\\nConsole.prototype.dir = function(object, options) {\\n  this._stdout.write(util.inspect(object, util._extend({\\n    customInspect: false\\n  }, options)) + NEWLINE );\\n};\\n\\n\\nConsole.prototype.time = function(label) {\\n  this._times[label] = Date.now();\\n};\\n\\n\\nConsole.prototype.timeEnd = function(label) {\\n  var time = this._times[label];\\n  if (!time) {\\n    throw new Error('No such label: ' + label);\\n  }\\n  var duration = Date.now() - time;\\n  this.log('%s: %dms', label, duration);\\n};\\n\\n\\nConsole.prototype.trace = function() {\\n  // TODO probably can to do this better with V8's debug object once that is\\n  // exposed.\\n  var err = new Error;\\n  err.name = 'Trace';\\n  err.message = util.format.apply(this, arguments);\\n  Error.captureStackTrace(err, arguments.callee);\\n  this.error(err.stack);\\n};\\n\\n\\nConsole.prototype.assert = function(expression) {\\n  if (!expression) {\\n    var arr = Array.prototype.slice.call(arguments, 1);\\n    require('assert').ok(false, util.format.apply(this, arr));\\n  }\\n};\\n\\nvar std = {\\n  write : print\\n};\\n\\nmodule.exports = new Console(std, std);\\nmodule.exports.Console = Console;\\n\",\"constants\":\"'use strict';\\n\\nmodule.exports = process.binding('constants');\\n\",\"events\":\"'use strict';\\n\\nvar domain;\\n\\nfunction EventEmitter() {\\n  EventEmitter.init.call(this);\\n}\\nmodule.exports = EventEmitter;\\n\\n// Backwards-compat with node 0.10.x\\nEventEmitter.EventEmitter = EventEmitter;\\n\\nEventEmitter.usingDomains = false;\\n\\nEventEmitter.prototype.domain = undefined;\\nEventEmitter.prototype._events = undefined;\\nEventEmitter.prototype._maxListeners = undefined;\\n\\n// By default EventEmitters will print a warning if more than 10 listeners are\\n// added to it. This is a useful default which helps finding memory leaks.\\nEventEmitter.defaultMaxListeners = 10;\\n\\nEventEmitter.init = function() {\\n  this.domain = null;\\n  if (EventEmitter.usingDomains) {\\n    // if there is an active domain, then attach to it.\\n    domain = domain || require('domain');\\n    if (domain.active && !(this instanceof domain.Domain)) {\\n      this.domain = domain.active;\\n    }\\n  }\\n\\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\\n    this._events = {};\\n    this._eventsCount = 0;\\n  }\\n\\n  this._maxListeners = this._maxListeners || undefined;\\n};\\n\\n// Obviously not all Emitters should be limited to 10. This function allows\\n// that to be increased. Set to zero for unlimited.\\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\\n    throw new TypeError('\\\"n\\\" argument must be a positive number');\\n  this._maxListeners = n;\\n  return this;\\n};\\n\\nfunction $getMaxListeners(that) {\\n  if (that._maxListeners === undefined)\\n    return EventEmitter.defaultMaxListeners;\\n  return that._maxListeners;\\n}\\n\\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\\n  return $getMaxListeners(this);\\n};\\n\\n// These standalone emit* functions are used to optimize calling of event\\n// handlers for fast cases because emit() itself often has a variable number of\\n// arguments and can be deoptimized because of that. These functions always have\\n// the same number of arguments and thus do not get deoptimized, so the code\\n// inside them can execute faster.\\nfunction emitNone(handler, isFn, self) {\\n  if (isFn)\\n    handler.call(self);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].call(self);\\n  }\\n}\\nfunction emitOne(handler, isFn, self, arg1) {\\n  if (isFn)\\n    handler.call(self, arg1);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].call(self, arg1);\\n  }\\n}\\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\\n  if (isFn)\\n    handler.call(self, arg1, arg2);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].call(self, arg1, arg2);\\n  }\\n}\\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\\n  if (isFn)\\n    handler.call(self, arg1, arg2, arg3);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].call(self, arg1, arg2, arg3);\\n  }\\n}\\n\\nfunction emitMany(handler, isFn, self, args) {\\n  if (isFn)\\n    handler.apply(self, args);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].apply(self, args);\\n  }\\n}\\n\\nEventEmitter.prototype.emit = function emit(type) {\\n  var er, handler, len, args, i, events, domain;\\n  var needDomainExit = false;\\n  var doError = (type === 'error');\\n\\n  events = this._events;\\n  if (events)\\n    doError = (doError && events.error == null);\\n  else if (!doError)\\n    return false;\\n\\n  domain = this.domain;\\n\\n  // If there is no 'error' event listener then throw.\\n  if (doError) {\\n    er = arguments[1];\\n    if (domain) {\\n      if (!er)\\n        er = new Error('Uncaught, unspecified \\\"error\\\" event');\\n      er.domainEmitter = this;\\n      er.domain = domain;\\n      er.domainThrown = false;\\n      domain.emit('error', er);\\n    } else if (er instanceof Error) {\\n      throw er; // Unhandled 'error' event\\n    } else {\\n      // At least give some kind of context to the user\\n      var err = new Error('Uncaught, unspecified \\\"error\\\" event. (' + er + ')');\\n      err.context = er;\\n      throw err;\\n    }\\n    return false;\\n  }\\n\\n  handler = events[type];\\n\\n  if (!handler)\\n    return false;\\n\\n  if (domain && this !== process) {\\n    domain.enter();\\n    needDomainExit = true;\\n  }\\n\\n  var isFn = typeof handler === 'function';\\n  len = arguments.length;\\n  switch (len) {\\n    // fast cases\\n    case 1:\\n      emitNone(handler, isFn, this);\\n      break;\\n    case 2:\\n      emitOne(handler, isFn, this, arguments[1]);\\n      break;\\n    case 3:\\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\\n      break;\\n    case 4:\\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\\n      break;\\n    // slower\\n    default:\\n      args = new Array(len - 1);\\n      for (i = 1; i < len; i++)\\n        args[i - 1] = arguments[i];\\n      emitMany(handler, isFn, this, args);\\n  }\\n\\n  if (needDomainExit)\\n    domain.exit();\\n\\n  return true;\\n};\\n\\nEventEmitter.prototype.addListener = function addListener(type, listener) {\\n  var m;\\n  var events;\\n  var existing;\\n\\n  if (typeof listener !== 'function')\\n    throw new TypeError('\\\"listener\\\" argument must be a function');\\n\\n  events = this._events;\\n  if (!events) {\\n    events = this._events = {};\\n    this._eventsCount = 0;\\n  } else {\\n    // To avoid recursion in the case that type === \\\"newListener\\\"! Before\\n    // adding it to the listeners, first emit \\\"newListener\\\".\\n    if (events.newListener) {\\n      this.emit('newListener', type,\\n                listener.listener ? listener.listener : listener);\\n\\n      // Re-assign `events` because a newListener handler could have caused the\\n      // this._events to be assigned to a new object\\n      events = this._events;\\n    }\\n    existing = events[type];\\n  }\\n\\n  if (!existing) {\\n    // Optimize the case of one listener. Don't need the extra array object.\\n    existing = events[type] = listener;\\n    ++this._eventsCount;\\n  } else {\\n    if (typeof existing === 'function') {\\n      // Adding the second element, need to change to array.\\n      existing = events[type] = [existing, listener];\\n    } else {\\n      // If we've already got an array, just append.\\n      existing.push(listener);\\n    }\\n\\n    // Check for listener leak\\n    if (!existing.warned) {\\n      m = $getMaxListeners(this);\\n      if (m && m > 0 && existing.length > m) {\\n        existing.warned = true;\\n        console.error('(node) warning: possible EventEmitter memory ' +\\n                      'leak detected. %d %s listeners added. ' +\\n                      'Use emitter.setMaxListeners() to increase limit.',\\n                      existing.length, type);\\n        console.trace();\\n      }\\n    }\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\\n\\nEventEmitter.prototype.once = function once(type, listener) {\\n  if (typeof listener !== 'function')\\n    throw new TypeError('\\\"listener\\\" argument must be a function');\\n\\n  var fired = false;\\n\\n  function g() {\\n    this.removeListener(type, g);\\n\\n    if (!fired) {\\n      fired = true;\\n      listener.apply(this, arguments);\\n    }\\n  }\\n\\n  g.listener = listener;\\n  this.on(type, g);\\n\\n  return this;\\n};\\n\\n// emits a 'removeListener' event iff the listener was removed\\nEventEmitter.prototype.removeListener =\\n    function removeListener(type, listener) {\\n      var list, events, position, i;\\n\\n      if (typeof listener !== 'function')\\n        throw new TypeError('\\\"listener\\\" argument must be a function');\\n\\n      events = this._events;\\n      if (!events)\\n        return this;\\n\\n      list = events[type];\\n      if (!list)\\n        return this;\\n\\n      if (list === listener || (list.listener && list.listener === listener)) {\\n        if (--this._eventsCount === 0)\\n          this._events = {};\\n        else {\\n          delete events[type];\\n          if (events.removeListener)\\n            this.emit('removeListener', type, listener);\\n        }\\n      } else if (typeof list !== 'function') {\\n        position = -1;\\n\\n        for (i = list.length; i-- > 0;) {\\n          if (list[i] === listener ||\\n              (list[i].listener && list[i].listener === listener)) {\\n            position = i;\\n            break;\\n          }\\n        }\\n\\n        if (position < 0)\\n          return this;\\n\\n        if (list.length === 1) {\\n          list[0] = undefined;\\n          if (--this._eventsCount === 0) {\\n            this._events = {};\\n            return this;\\n          } else {\\n            delete events[type];\\n          }\\n        } else {\\n          spliceOne(list, position);\\n        }\\n\\n        if (events.removeListener)\\n          this.emit('removeListener', type, listener);\\n      }\\n\\n      return this;\\n    };\\n\\nEventEmitter.prototype.removeAllListeners =\\n    function removeAllListeners(type) {\\n      var listeners, events;\\n\\n      events = this._events;\\n      if (!events)\\n        return this;\\n\\n      // not listening for removeListener, no need to emit\\n      if (!events.removeListener) {\\n        if (arguments.length === 0) {\\n          this._events = {};\\n          this._eventsCount = 0;\\n        } else if (events[type]) {\\n          if (--this._eventsCount === 0)\\n            this._events = {};\\n          else\\n            delete events[type];\\n        }\\n        return this;\\n      }\\n\\n      // emit removeListener for all listeners on all events\\n      if (arguments.length === 0) {\\n        var keys = Object.keys(events);\\n        for (var i = 0, key; i < keys.length; ++i) {\\n          key = keys[i];\\n          if (key === 'removeListener') continue;\\n          this.removeAllListeners(key);\\n        }\\n        this.removeAllListeners('removeListener');\\n        this._events = {};\\n        this._eventsCount = 0;\\n        return this;\\n      }\\n\\n      listeners = events[type];\\n\\n      if (typeof listeners === 'function') {\\n        this.removeListener(type, listeners);\\n      } else if (listeners) {\\n        // LIFO order\\n        do {\\n          this.removeListener(type, listeners[listeners.length - 1]);\\n        } while (listeners[0]);\\n      }\\n\\n      return this;\\n    };\\n\\nEventEmitter.prototype.listeners = function listeners(type) {\\n  var evlistener;\\n  var ret;\\n  var events = this._events;\\n\\n  if (!events)\\n    ret = [];\\n  else {\\n    evlistener = events[type];\\n    if (!evlistener)\\n      ret = [];\\n    else if (typeof evlistener === 'function')\\n      ret = [evlistener];\\n    else\\n      ret = arrayClone(evlistener, evlistener.length);\\n  }\\n\\n  return ret;\\n};\\n\\nEventEmitter.listenerCount = function(emitter, type) {\\n  if (typeof emitter.listenerCount === 'function') {\\n    return emitter.listenerCount(type);\\n  } else {\\n    return listenerCount.call(emitter, type);\\n  }\\n};\\n\\nEventEmitter.prototype.listenerCount = listenerCount;\\nfunction listenerCount(type) {\\n  var events = this._events;\\n\\n  if (events) {\\n    var evlistener = events[type];\\n\\n    if (typeof evlistener === 'function') {\\n      return 1;\\n    } else if (evlistener) {\\n      return evlistener.length;\\n    }\\n  }\\n\\n  return 0;\\n};\\n\\n// About 1.5x faster than the two-arg version of Array#splice().\\nfunction spliceOne(list, index) {\\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\\n    list[i] = list[k];\\n  list.pop();\\n}\\n\\nfunction arrayClone(arr, i) {\\n  var copy = new Array(i);\\n  while (i--)\\n    copy[i] = arr[i];\\n  return copy;\\n}\\n\",\"timers\":\"'use strict';\\n\\nvar Timer = process.binding('timer_wrap').Timer;\\nvar L = require('internal/linkedlist');\\nvar assert = require('assert').ok;\\nvar util = require('util');\\nvar debug = util.debuglog('timer');\\nvar kOnTimeout = Timer.kOnTimeout;\\n\\n// Timeout values > TIMEOUT_MAX are set to 1.\\nvar TIMEOUT_MAX = 2147483647; // 2^31-1\\n\\n// IDLE TIMEOUTS\\n//\\n// Because often many sockets will have the same idle timeout we will not\\n// use one timeout watcher per item. It is too much overhead.  Instead\\n// we'll use a single watcher for all sockets with the same timeout value\\n// and a linked list. This technique is described in the libev manual:\\n// http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts\\n\\n// Object containing all lists, timers\\n// key = time in milliseconds\\n// value = list\\nvar lists = {};\\n\\n\\n// call this whenever the item is active (not idle)\\n// it will reset its timeout.\\n// the main function - creates lists on demand and the watchers associated\\n// with them.\\nexports.active = function(item) {\\n  var msecs = item._idleTimeout;\\n  if (msecs < 0 || msecs === undefined) return;\\n\\n  item._idleStart = Timer.now();\\n\\n  var list;\\n\\n  if (lists[msecs]) {\\n    list = lists[msecs];\\n  } else {\\n    list = new Timer();\\n    list.start(msecs, 0);\\n\\n    L.init(list);\\n\\n    lists[msecs] = list;\\n    list.msecs = msecs;\\n    list[kOnTimeout] = listOnTimeout;\\n  }\\n\\n  L.append(list, item);\\n  assert(!L.isEmpty(list)); // list is not empty\\n};\\n\\nfunction listOnTimeout() {\\n  var msecs = this.msecs;\\n  var list = this;\\n\\n  debug('timeout callback %d', msecs);\\n\\n  var now = Timer.now();\\n  debug('now: %s', now);\\n\\n  var diff, first, threw;\\n  while (first = L.peek(list)) {\\n    diff = now - first._idleStart;\\n    if (diff < msecs) {\\n      list.start(msecs - diff, 0);\\n      debug('%d list wait because diff is %d', msecs, diff);\\n      return;\\n    } else {\\n      L.remove(first);\\n      assert(first !== L.peek(list));\\n\\n      if (!first._onTimeout) continue;\\n\\n      // v0.4 compatibility: if the timer callback throws and the\\n      // domain or uncaughtException handler ignore the exception,\\n      // other timers that expire on this tick should still run.\\n      //\\n      // https://github.com/joyent/node/issues/2631\\n      var domain = first.domain;\\n      if (domain && domain._disposed)\\n        continue;\\n\\n      try {\\n        if (domain)\\n          domain.enter();\\n        threw = true;\\n        first._called = true;\\n        first._onTimeout();\\n        if (domain)\\n          domain.exit();\\n        threw = false;\\n      } finally {\\n        if (threw) {\\n          // We need to continue processing after domain error handling\\n          // is complete, but not by using whatever domain was left over\\n          // when the timeout threw its exception.\\n          var oldDomain = process.domain;\\n          process.domain = null;\\n          process.nextTick(listOnTimeoutNT, list);\\n          process.domain = oldDomain;\\n        }\\n      }\\n    }\\n  }\\n\\n  debug('%d list empty', msecs);\\n  assert(L.isEmpty(list));\\n  list.close();\\n  delete lists[msecs];\\n}\\n\\n\\nfunction listOnTimeoutNT(list) {\\n  list[kOnTimeout]();\\n}\\n\\n\\nfunction reuse(item) {\\n  L.remove(item);\\n\\n  var list = lists[item._idleTimeout];\\n  // if empty - reuse the watcher\\n  if (list && L.isEmpty(list)) {\\n    debug('reuse hit');\\n    list.stop();\\n    delete lists[item._idleTimeout];\\n    return list;\\n  }\\n\\n  return null;\\n}\\n\\n\\nvar unenroll = exports.unenroll = function(item) {\\n  var list = reuse(item);\\n  if (list) {\\n    debug('unenroll: list empty');\\n    list.close();\\n  }\\n  // if active is called later, then we want to make sure not to insert again\\n  item._idleTimeout = -1;\\n};\\n\\n\\n// Does not start the time, just sets up the members needed.\\nexports.enroll = function(item, msecs) {\\n  if (typeof msecs !== 'number') {\\n    throw new TypeError('\\\"msecs\\\" argument must be a number');\\n  }\\n\\n  if (msecs < 0 || !isFinite(msecs)) {\\n    throw new RangeError('\\\"msecs\\\" argument must be ' +\\n                         'a non-negative finite number');\\n  }\\n\\n  // if this item was already in a list somewhere\\n  // then we should unenroll it from that\\n  if (item._idleNext) unenroll(item);\\n\\n  // Ensure that msecs fits into signed int32\\n  if (msecs > TIMEOUT_MAX) {\\n    msecs = TIMEOUT_MAX;\\n  }\\n\\n  item._idleTimeout = msecs;\\n  L.init(item);\\n};\\n\\n\\n/*\\n * DOM-style timers\\n */\\n\\n\\nexports.setTimeout = function(callback, after) {\\n  after *= 1; // coalesce to number or NaN\\n\\n  if (!(after >= 1 && after <= TIMEOUT_MAX)) {\\n    after = 1; // schedule on next tick, follows browser behaviour\\n  }\\n\\n  var timer = new Timeout(after);\\n  var length = arguments.length;\\n  var ontimeout = callback;\\n  switch (length) {\\n    // fast cases\\n    case 0:\\n    case 1:\\n    case 2:\\n      break;\\n    case 3:\\n      ontimeout = callback.bind(timer, arguments[2]);\\n      break;\\n    case 4:\\n      ontimeout = callback.bind(timer, arguments[2], arguments[3]);\\n      break;\\n    case 5:\\n      ontimeout =\\n          callback.bind(timer, arguments[2], arguments[3], arguments[4]);\\n      break;\\n    // slow case\\n    default:\\n      var args = new Array(length - 2);\\n      for (var i = 2; i < length; i++)\\n        args[i - 2] = arguments[i];\\n      ontimeout = callback.apply.bind(callback, timer, args);\\n      break;\\n  }\\n  timer._onTimeout = ontimeout;\\n\\n  if (process.domain) timer.domain = process.domain;\\n\\n  exports.active(timer);\\n\\n  return timer;\\n};\\n\\n\\nexports.clearTimeout = function(timer) {\\n  if (timer && (timer[kOnTimeout] || timer._onTimeout)) {\\n    timer[kOnTimeout] = timer._onTimeout = null;\\n    if (timer instanceof Timeout) {\\n      timer.close(); // for after === 0\\n    } else {\\n      exports.unenroll(timer);\\n    }\\n  }\\n};\\n\\n\\nexports.setInterval = function(callback, repeat) {\\n  repeat *= 1; // coalesce to number or NaN\\n\\n  if (!(repeat >= 1 && repeat <= TIMEOUT_MAX)) {\\n    repeat = 1; // schedule on next tick, follows browser behaviour\\n  }\\n\\n  var timer = new Timeout(repeat);\\n  var length = arguments.length;\\n  var ontimeout = callback;\\n  switch (length) {\\n    case 0:\\n    case 1:\\n    case 2:\\n      break;\\n    case 3:\\n      ontimeout = callback.bind(timer, arguments[2]);\\n      break;\\n    case 4:\\n      ontimeout = callback.bind(timer, arguments[2], arguments[3]);\\n      break;\\n    case 5:\\n      ontimeout =\\n          callback.bind(timer, arguments[2], arguments[3], arguments[4]);\\n      break;\\n    default:\\n      var args = new Array(length - 2);\\n      for (var i = 2; i < length; i += 1)\\n        args[i - 2] = arguments[i];\\n      ontimeout = callback.apply.bind(callback, timer, args);\\n      break;\\n  }\\n  timer._onTimeout = wrapper;\\n  timer._repeat = ontimeout;\\n\\n  if (process.domain) timer.domain = process.domain;\\n  exports.active(timer);\\n\\n  return timer;\\n\\n  function wrapper() {\\n    timer._repeat.call(this);\\n\\n    // Timer might be closed - no point in restarting it\\n    if (!timer._repeat)\\n      return;\\n\\n    // If timer is unref'd (or was - it's permanently removed from the list.)\\n    if (this._handle) {\\n      this._handle.start(repeat, 0);\\n    } else {\\n      timer._idleTimeout = repeat;\\n      exports.active(timer);\\n    }\\n  }\\n};\\n\\n\\nexports.clearInterval = function(timer) {\\n  if (timer && timer._repeat) {\\n    timer._repeat = null;\\n    clearTimeout(timer);\\n  }\\n};\\n\\n\\nvar Timeout = function(after) {\\n  this._called = false;\\n  this._idleTimeout = after;\\n  this._idlePrev = this;\\n  this._idleNext = this;\\n  this._idleStart = null;\\n  this._onTimeout = null;\\n  this._repeat = null;\\n};\\n\\n\\nfunction unrefdHandle() {\\n  this.owner._onTimeout();\\n  if (!this.owner._repeat)\\n    this.owner.close();\\n}\\n\\n\\nTimeout.prototype.unref = function() {\\n  if (this._handle) {\\n    this._handle.unref();\\n  } else if (typeof(this._onTimeout) === 'function') {\\n    var now = Timer.now();\\n    if (!this._idleStart) this._idleStart = now;\\n    var delay = this._idleStart + this._idleTimeout - now;\\n    if (delay < 0) delay = 0;\\n\\n    // Prevent running cb again when unref() is called during the same cb\\n    if (this._called && !this._repeat) {\\n      exports.unenroll(this);\\n      return;\\n    }\\n\\n    var handle = reuse(this);\\n\\n    this._handle = handle || new Timer();\\n    this._handle.owner = this;\\n    this._handle[kOnTimeout] = unrefdHandle;\\n    this._handle.start(delay, 0);\\n    this._handle.domain = this.domain;\\n    this._handle.unref();\\n  }\\n  return this;\\n};\\n\\nTimeout.prototype.ref = function() {\\n  if (this._handle)\\n    this._handle.ref();\\n  return this;\\n};\\n\\nTimeout.prototype.close = function() {\\n  this._onTimeout = null;\\n  if (this._handle) {\\n    this._handle[kOnTimeout] = null;\\n    this._handle.close();\\n  } else {\\n    exports.unenroll(this);\\n  }\\n  return this;\\n};\\n\\n\\nvar immediateQueue = {};\\nL.init(immediateQueue);\\n\\n\\nfunction processImmediate() {\\n  var queue = immediateQueue;\\n  var domain, immediate;\\n\\n  immediateQueue = {};\\n  L.init(immediateQueue);\\n\\n  while (L.isEmpty(queue) === false) {\\n    immediate = L.shift(queue);\\n    domain = immediate.domain;\\n\\n    if (domain)\\n      domain.enter();\\n\\n    var threw = true;\\n    try {\\n      immediate._onImmediate();\\n      threw = false;\\n    } finally {\\n      if (threw) {\\n        if (!L.isEmpty(queue)) {\\n          // Handle any remaining on next tick, assuming we're still\\n          // alive to do so.\\n          while (!L.isEmpty(immediateQueue)) {\\n            L.append(queue, L.shift(immediateQueue));\\n          }\\n          immediateQueue = queue;\\n          process.nextTick(processImmediate);\\n        }\\n      }\\n    }\\n\\n    if (domain)\\n      domain.exit();\\n  }\\n\\n  // Only round-trip to C++ land if we have to. Calling clearImmediate() on an\\n  // immediate that's in |queue| is okay. Worst case is we make a superfluous\\n  // call to NeedImmediateCallbackSetter().\\n  if (L.isEmpty(immediateQueue)) {\\n    process._needImmediateCallback = false;\\n  }\\n}\\n\\n\\nfunction Immediate() { }\\n\\nImmediate.prototype.domain = undefined;\\nImmediate.prototype._onImmediate = undefined;\\nImmediate.prototype._idleNext = undefined;\\nImmediate.prototype._idlePrev = undefined;\\n\\n\\nexports.setImmediate = function(callback, arg1, arg2, arg3) {\\n  var i, args;\\n  var len = arguments.length;\\n  var immediate = new Immediate();\\n\\n  L.init(immediate);\\n\\n  switch (len) {\\n    // fast cases\\n    case 0:\\n    case 1:\\n      immediate._onImmediate = callback;\\n      break;\\n    case 2:\\n      immediate._onImmediate = function() {\\n        callback.call(immediate, arg1);\\n      };\\n      break;\\n    case 3:\\n      immediate._onImmediate = function() {\\n        callback.call(immediate, arg1, arg2);\\n      };\\n      break;\\n    case 4:\\n      immediate._onImmediate = function() {\\n        callback.call(immediate, arg1, arg2, arg3);\\n      };\\n      break;\\n    // slow case\\n    default:\\n      args = new Array(len - 1);\\n      for (i = 1; i < len; i++)\\n        args[i - 1] = arguments[i];\\n\\n      immediate._onImmediate = function() {\\n        callback.apply(immediate, args);\\n      };\\n      break;\\n  }\\n\\n  if (!process._needImmediateCallback) {\\n    process._needImmediateCallback = true;\\n    process._immediateCallback = processImmediate;\\n  }\\n\\n  if (process.domain)\\n    immediate.domain = process.domain;\\n\\n  L.append(immediateQueue, immediate);\\n\\n  return immediate;\\n};\\n\\n\\nexports.clearImmediate = function(immediate) {\\n  if (!immediate) return;\\n\\n  immediate._onImmediate = undefined;\\n\\n  L.remove(immediate);\\n\\n  if (L.isEmpty(immediateQueue)) {\\n    process._needImmediateCallback = false;\\n  }\\n};\\n\\n\\n// Internal APIs that need timeouts should use timers._unrefActive instead of\\n// timers.active as internal timeouts shouldn't hold the loop open\\n\\nvar unrefList, unrefTimer;\\n\\nfunction _makeTimerTimeout(timer) {\\n  var domain = timer.domain;\\n  var msecs = timer._idleTimeout;\\n\\n  L.remove(timer);\\n\\n  // Timer has been unenrolled by another timer that fired at the same time,\\n  // so don't make it timeout.\\n  if (msecs <= 0)\\n    return;\\n\\n  if (!timer._onTimeout)\\n    return;\\n\\n  if (domain) {\\n    if (domain._disposed)\\n      return;\\n\\n    domain.enter();\\n  }\\n\\n  debug('unreftimer firing timeout');\\n  timer._called = true;\\n  _runOnTimeout(timer);\\n\\n  if (domain)\\n    domain.exit();\\n}\\n\\nfunction _runOnTimeout(timer) {\\n  var threw = true;\\n  try {\\n    timer._onTimeout();\\n    threw = false;\\n  } finally {\\n    if (threw) process.nextTick(unrefTimeout);\\n  }\\n}\\n\\nfunction unrefTimeout() {\\n  var now = Timer.now();\\n\\n  debug('unrefTimer fired');\\n\\n  var timeSinceLastActive;\\n  var nextTimeoutTime;\\n  var nextTimeoutDuration;\\n  var minNextTimeoutTime = TIMEOUT_MAX;\\n  var timersToTimeout = [];\\n\\n  // The actual timer fired and has not yet been rearmed,\\n  // let's consider its next firing time is invalid for now.\\n  // It may be set to a relevant time in the future once\\n  // we scanned through the whole list of timeouts and if\\n  // we find a timeout that needs to expire.\\n  unrefTimer.when = -1;\\n\\n  // Iterate over the list of timeouts,\\n  // call the onTimeout callback for those expired,\\n  // and rearm the actual timer if the next timeout to expire\\n  // will expire before the current actual timer.\\n  var cur = unrefList._idlePrev;\\n  while (cur !== unrefList) {\\n    timeSinceLastActive = now - cur._idleStart;\\n\\n    if (timeSinceLastActive < cur._idleTimeout) {\\n      // This timer hasn't expired yet, but check if its expiring time is\\n      // earlier than the actual timer's expiring time\\n\\n      nextTimeoutDuration = cur._idleTimeout - timeSinceLastActive;\\n      nextTimeoutTime = now + nextTimeoutDuration;\\n      if (minNextTimeoutTime === TIMEOUT_MAX ||\\n          (nextTimeoutTime < minNextTimeoutTime)) {\\n        // We found a timeout that will expire earlier,\\n        // store its next timeout time now so that we\\n        // can rearm the actual timer accordingly when\\n        // we scanned through the whole list.\\n        minNextTimeoutTime = nextTimeoutTime;\\n      }\\n    } else {\\n      // We found a timer that expired. Do not call its _onTimeout callback\\n      // right now, as it could mutate any item of the list (including itself).\\n      // Instead, add it to another list that will be processed once the list\\n      // of current timers has been fully traversed.\\n      timersToTimeout.push(cur);\\n    }\\n\\n    cur = cur._idlePrev;\\n  }\\n\\n  var nbTimersToTimeout = timersToTimeout.length;\\n  for (var timerIdx = 0; timerIdx < nbTimersToTimeout; ++timerIdx)\\n    _makeTimerTimeout(timersToTimeout[timerIdx]);\\n\\n\\n  // Rearm the actual timer with the timeout delay\\n  // of the earliest timeout found.\\n  if (minNextTimeoutTime !== TIMEOUT_MAX) {\\n    unrefTimer.start(minNextTimeoutTime - now, 0);\\n    unrefTimer.when = minNextTimeoutTime;\\n    debug('unrefTimer rescheduled');\\n  } else if (L.isEmpty(unrefList)) {\\n    debug('unrefList is empty');\\n  }\\n}\\n\\n\\nexports._unrefActive = function(item) {\\n  var msecs = item._idleTimeout;\\n  if (!msecs || msecs < 0) return;\\n  assert(msecs >= 0);\\n\\n  L.remove(item);\\n\\n  if (!unrefList) {\\n    debug('unrefList initialized');\\n    unrefList = {};\\n    L.init(unrefList);\\n\\n    debug('unrefTimer initialized');\\n    unrefTimer = new Timer();\\n    unrefTimer.unref();\\n    unrefTimer.when = -1;\\n    unrefTimer[kOnTimeout] = unrefTimeout;\\n  }\\n\\n  var now = Timer.now();\\n  item._idleStart = now;\\n\\n  var when = now + msecs;\\n\\n  // If the actual timer is set to fire too late, or not set to fire at all,\\n  // we need to make it fire earlier\\n  if (unrefTimer.when === -1 || unrefTimer.when > when) {\\n    unrefTimer.start(msecs, 0);\\n    unrefTimer.when = when;\\n    debug('unrefTimer scheduled');\\n  }\\n\\n  debug('unrefList append to end');\\n  L.append(unrefList, item);\\n};\\n\",\"net\":\"'use strict';\\n\\nvar EventEmitter = require('events');\\nvar stream = require('stream');\\nvar timers = require('timers');\\nvar util = require('util');\\nvar internalUtil = require('internal/util');\\nvar assert = require('assert');\\nvar cares = process.binding('cares_wrap');\\nvar uv = process.binding('uv');\\n\\nvar Buffer = require('buffer').Buffer;\\nvar TTYWrap = process.binding('tty_wrap');\\nvar TCP = process.binding('tcp_wrap').TCP;\\nvar Pipe = process.binding('pipe_wrap').Pipe;\\nvar TCPConnectWrap = process.binding('tcp_wrap').TCPConnectWrap;\\nvar PipeConnectWrap = process.binding('pipe_wrap').PipeConnectWrap;\\nvar ShutdownWrap = process.binding('stream_wrap').ShutdownWrap;\\nvar WriteWrap = process.binding('stream_wrap').WriteWrap;\\n\\n\\nvar cluster;\\nvar errnoException = util._errnoException;\\nvar exceptionWithHostPort = util._exceptionWithHostPort;\\n\\nfunction noop() {}\\n\\nfunction createHandle(fd) {\\n  var type = TTYWrap.guessHandleType(fd);\\n  if (type === 'PIPE') return new Pipe();\\n  if (type === 'TCP') return new TCP();\\n  throw new TypeError('Unsupported fd type: ' + type);\\n}\\n\\n\\nvar debug = util.debuglog('net');\\n\\nfunction isPipeName(s) {\\n  return typeof s === 'string' && toNumber(s) === false;\\n}\\n\\nexports.createServer = function(options, connectionListener) {\\n  return new Server(options, connectionListener);\\n};\\n\\n\\n// Target API:\\n//\\n// var s = net.connect({port: 80, host: 'google.com'}, function() {\\n//   ...\\n// });\\n//\\n// There are various forms:\\n//\\n// connect(options, [cb])\\n// connect(port, [host], [cb])\\n// connect(path, [cb]);\\n//\\nexports.connect = exports.createConnection = function() {\\n  var args = normalizeConnectArgs(arguments);\\n  debug('createConnection', args);\\n  var s = new Socket(args[0]);\\n  return Socket.prototype.connect.apply(s, args);\\n};\\n\\n// Returns an array [options] or [options, cb]\\n// It is the same as the argument of Socket.prototype.connect().\\nfunction normalizeConnectArgs(args) {\\n  var options = {};\\n\\n  if (args[0] !== null && typeof args[0] === 'object') {\\n    // connect(options, [cb])\\n    options = args[0];\\n  } else if (isPipeName(args[0])) {\\n    // connect(path, [cb]);\\n    options.path = args[0];\\n  } else {\\n    // connect(port, [host], [cb])\\n    options.port = args[0];\\n    if (typeof args[1] === 'string') {\\n      options.host = args[1];\\n    }\\n  }\\n\\n  var cb = args[args.length - 1];\\n  return typeof cb === 'function' ? [options, cb] : [options];\\n}\\nexports._normalizeConnectArgs = normalizeConnectArgs;\\n\\n\\n// called when creating new Socket, or when re-using a closed Socket\\nfunction initSocketHandle(self) {\\n  self.destroyed = false;\\n  self.bytesRead = 0;\\n  self._bytesDispatched = 0;\\n  self._sockname = null;\\n\\n  // Handle creation may be deferred to bind() or connect() time.\\n  if (self._handle) {\\n    self._handle.owner = self;\\n    self._handle.onread = onread;\\n\\n    // If handle doesn't support writev - neither do we\\n    if (!self._handle.writev)\\n      self._writev = null;\\n  }\\n}\\n\\nfunction Socket(options) {\\n  if (!(this instanceof Socket)) return new Socket(options);\\n\\n  this._connecting = false;\\n  this._hadError = false;\\n  this._handle = null;\\n  this._parent = null;\\n  this._host = null;\\n\\n  if (typeof options === 'number')\\n    options = { fd: options }; // Legacy interface.\\n  else if (options === undefined)\\n    options = {};\\n\\n  stream.Duplex.call(this, options);\\n\\n  if (options.handle) {\\n    this._handle = options.handle; // private\\n  } else if (options.fd !== undefined) {\\n    this._handle = createHandle(options.fd);\\n    this._handle.open(options.fd);\\n    if ((options.fd == 1 || options.fd == 2) &&\\n        (this._handle instanceof Pipe) &&\\n        process.platform === 'win32') {\\n      // Make stdout and stderr blocking on Windows\\n      var err = this._handle.setBlocking(true);\\n      if (err)\\n        throw errnoException(err, 'setBlocking');\\n    }\\n    this.readable = options.readable !== false;\\n    this.writable = options.writable !== false;\\n  } else {\\n    // these will be set once there is a connection\\n    this.readable = this.writable = false;\\n  }\\n\\n  // shut down the socket when we're finished with it.\\n  this.on('finish', onSocketFinish);\\n  this.on('_socketEnd', onSocketEnd);\\n\\n  initSocketHandle(this);\\n\\n  this._pendingData = null;\\n  this._pendingEncoding = '';\\n\\n  // handle strings directly\\n  this._writableState.decodeStrings = false;\\n\\n  // default to *not* allowing half open sockets\\n  this.allowHalfOpen = options && options.allowHalfOpen || false;\\n\\n  // if we have a handle, then start the flow of data into the\\n  // buffer.  if not, then this will happen when we connect\\n  if (this._handle && options.readable !== false) {\\n    if (options.pauseOnCreate) {\\n      // stop the handle from reading and pause the stream\\n      this._handle.reading = false;\\n      this._handle.readStop();\\n      this._readableState.flowing = false;\\n    } else {\\n      this.read(0);\\n    }\\n  }\\n}\\nutil.inherits(Socket, stream.Duplex);\\n\\nSocket.prototype._unrefTimer = function unrefTimer() {\\n  for (var s = this; s !== null; s = s._parent)\\n    timers._unrefActive(s);\\n};\\n\\n// the user has called .end(), and all the bytes have been\\n// sent out to the other side.\\n// If allowHalfOpen is false, or if the readable side has\\n// ended already, then destroy.\\n// If allowHalfOpen is true, then we need to do a shutdown,\\n// so that only the writable side will be cleaned up.\\nfunction onSocketFinish() {\\n  // If still connecting - defer handling 'finish' until 'connect' will happen\\n  if (this._connecting) {\\n    debug('osF: not yet connected');\\n    return this.once('connect', onSocketFinish);\\n  }\\n\\n  debug('onSocketFinish');\\n  if (!this.readable || this._readableState.ended) {\\n    debug('oSF: ended, destroy', this._readableState);\\n    return this.destroy();\\n  }\\n\\n  debug('oSF: not ended, call shutdown()');\\n\\n  // otherwise, just shutdown, or destroy() if not possible\\n  if (!this._handle || !this._handle.shutdown)\\n    return this.destroy();\\n\\n  var req = new ShutdownWrap();\\n  req.oncomplete = afterShutdown;\\n  req.handle = this._handle;\\n  var err = this._handle.shutdown(req);\\n\\n  if (err)\\n    return this._destroy(errnoException(err, 'shutdown'));\\n}\\n\\n\\nfunction afterShutdown(status, handle, req) {\\n  var self = handle.owner;\\n\\n  debug('afterShutdown destroyed=%j', self.destroyed,\\n        self._readableState);\\n\\n  // callback may come after call to destroy.\\n  if (self.destroyed)\\n    return;\\n\\n  if (self._readableState.ended) {\\n    debug('readableState ended, destroying');\\n    self.destroy();\\n  } else {\\n    self.once('_socketEnd', self.destroy);\\n  }\\n}\\n\\n// the EOF has been received, and no more bytes are coming.\\n// if the writable side has ended already, then clean everything\\n// up.\\nfunction onSocketEnd() {\\n  // XXX Should not have to do as much crap in this function.\\n  // ended should already be true, since this is called *after*\\n  // the EOF errno and onread has eof'ed\\n  debug('onSocketEnd', this._readableState);\\n  this._readableState.ended = true;\\n  if (this._readableState.endEmitted) {\\n    this.readable = false;\\n    maybeDestroy(this);\\n  } else {\\n    this.once('end', function() {\\n      this.readable = false;\\n      maybeDestroy(this);\\n    });\\n    this.read(0);\\n  }\\n\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    this.destroySoon();\\n  }\\n}\\n\\n// Provide a better error message when we call end() as a result\\n// of the other side sending a FIN.  The standard 'write after end'\\n// is overly vague, and makes it seem like the user's code is to blame.\\nfunction writeAfterFIN(chunk, encoding, cb) {\\n  if (typeof encoding === 'function') {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n\\n  var er = new Error('This socket has been ended by the other party');\\n  er.code = 'EPIPE';\\n  var self = this;\\n  // TODO: defer error events consistently everywhere, not just the cb\\n  self.emit('error', er);\\n  if (typeof cb === 'function') {\\n    process.nextTick(cb, er);\\n  }\\n}\\n\\nexports.Socket = Socket;\\nexports.Stream = Socket; // Legacy naming.\\n\\nSocket.prototype.read = function(n) {\\n  if (n === 0)\\n    return stream.Readable.prototype.read.call(this, n);\\n\\n  this.read = stream.Readable.prototype.read;\\n  this._consuming = true;\\n  return this.read(n);\\n};\\n\\n\\nSocket.prototype.listen = function() {\\n  debug('socket.listen');\\n  var self = this;\\n  self.on('connection', arguments[0]);\\n  listen(self, null, null, null);\\n};\\n\\n\\nSocket.prototype.setTimeout = function(msecs, callback) {\\n  if (msecs === 0) {\\n    timers.unenroll(this);\\n    if (callback) {\\n      this.removeListener('timeout', callback);\\n    }\\n  } else {\\n    timers.enroll(this, msecs);\\n    timers._unrefActive(this);\\n    if (callback) {\\n      this.once('timeout', callback);\\n    }\\n  }\\n  return this;\\n};\\n\\n\\nSocket.prototype._onTimeout = function() {\\n  debug('_onTimeout');\\n  this.emit('timeout');\\n};\\n\\n\\nSocket.prototype.setNoDelay = function(enable) {\\n  if (!this._handle) {\\n    this.once('connect',\\n              enable ? this.setNoDelay : this.setNoDelay.bind(this, enable));\\n    return this;\\n  }\\n\\n  // backwards compatibility: assume true when `enable` is omitted\\n  if (this._handle.setNoDelay)\\n    this._handle.setNoDelay(enable === undefined ? true : !!enable);\\n\\n  return this;\\n};\\n\\n\\nSocket.prototype.setKeepAlive = function(setting, msecs) {\\n  if (!this._handle) {\\n    this.once('connect', this.setKeepAlive.bind(this, setting, msecs));\\n    return this;\\n  }\\n\\n  if (this._handle.setKeepAlive)\\n    this._handle.setKeepAlive(setting, ~~(msecs / 1000));\\n\\n  return this;\\n};\\n\\n\\nSocket.prototype.address = function() {\\n  return this._getsockname();\\n};\\n\\n\\nObject.defineProperty(Socket.prototype, 'readyState', {\\n  get: function() {\\n    if (this._connecting) {\\n      return 'opening';\\n    } else if (this.readable && this.writable) {\\n      return 'open';\\n    } else if (this.readable && !this.writable) {\\n      return 'readOnly';\\n    } else if (!this.readable && this.writable) {\\n      return 'writeOnly';\\n    } else {\\n      return 'closed';\\n    }\\n  }\\n});\\n\\n\\nObject.defineProperty(Socket.prototype, 'bufferSize', {\\n  get: function() {\\n    if (this._handle) {\\n      return this._handle.writeQueueSize + this._writableState.length;\\n    }\\n  }\\n});\\n\\n\\n// Just call handle.readStart until we have enough in the buffer\\nSocket.prototype._read = function(n) {\\n  debug('_read');\\n\\n  if (this._connecting || !this._handle) {\\n    debug('_read wait for connection');\\n    this.once('connect', this._read.bind(this, n));\\n  } else if (!this._handle.reading) {\\n    // not already reading, start the flow\\n    debug('Socket._read readStart');\\n    this._handle.reading = true;\\n    var err = this._handle.readStart();\\n    if (err)\\n      this._destroy(errnoException(err, 'read'));\\n  }\\n};\\n\\n\\nSocket.prototype.end = function(data, encoding) {\\n  stream.Duplex.prototype.end.call(this, data, encoding);\\n  this.writable = false;\\n  DTRACE_NET_STREAM_END(this);\\n  LTTNG_NET_STREAM_END(this);\\n\\n  // just in case we're waiting for an EOF.\\n  if (this.readable && !this._readableState.endEmitted)\\n    this.read(0);\\n  else\\n    maybeDestroy(this);\\n};\\n\\n\\n// Call whenever we set writable=false or readable=false\\nfunction maybeDestroy(socket) {\\n  if (!socket.readable &&\\n      !socket.writable &&\\n      !socket.destroyed &&\\n      !socket._connecting &&\\n      !socket._writableState.length) {\\n    socket.destroy();\\n  }\\n}\\n\\n\\nSocket.prototype.destroySoon = function() {\\n  if (this.writable)\\n    this.end();\\n\\n  if (this._writableState.finished)\\n    this.destroy();\\n  else\\n    this.once('finish', this.destroy);\\n};\\n\\n\\nSocket.prototype._destroy = function(exception, cb) {\\n  debug('destroy');\\n\\n  var self = this;\\n\\n  function fireErrorCallbacks() {\\n    if (cb) cb(exception);\\n    if (exception && !self._writableState.errorEmitted) {\\n      process.nextTick(emitErrorNT, self, exception);\\n      self._writableState.errorEmitted = true;\\n    }\\n  }\\n\\n  if (this.destroyed) {\\n    debug('already destroyed, fire error callbacks');\\n    fireErrorCallbacks();\\n    return;\\n  }\\n\\n  self._connecting = false;\\n\\n  this.readable = this.writable = false;\\n\\n  for (var s = this; s !== null; s = s._parent)\\n    timers.unenroll(s);\\n\\n  debug('close');\\n  if (this._handle) {\\n    if (this !== process.stderr)\\n      debug('close handle');\\n    var isException = exception ? true : false;\\n    this._handle.close(function() {\\n      debug('emit close');\\n      self.emit('close', isException);\\n    });\\n    this._handle.onread = noop;\\n    this._handle = null;\\n    this._sockname = null;\\n  }\\n\\n  // we set destroyed to true before firing error callbacks in order\\n  // to make it re-entrance safe in case Socket.prototype.destroy()\\n  // is called within callbacks\\n  this.destroyed = true;\\n  fireErrorCallbacks();\\n\\n  if (this.server) {\\n    COUNTER_NET_SERVER_CONNECTION_CLOSE(this);\\n    debug('has server');\\n    this.server._connections--;\\n    if (this.server._emitCloseIfDrained) {\\n      this.server._emitCloseIfDrained();\\n    }\\n  }\\n};\\n\\n\\nSocket.prototype.destroy = function(exception) {\\n  debug('destroy', exception);\\n  this._destroy(exception);\\n};\\n\\n\\n// This function is called whenever the handle gets a\\n// buffer, or when there's an error reading.\\nfunction onread(nread, buffer) {\\n  var handle = this;\\n  var self = handle.owner;\\n  assert(handle === self._handle, 'handle != self._handle');\\n\\n  self._unrefTimer();\\n\\n  debug('onread', nread);\\n\\n  if (nread > 0) {\\n    debug('got data');\\n    // read success.\\n    // In theory (and in practice) calling readStop right now\\n    // will prevent this from being called again until _read() gets\\n    // called again.\\n\\n    // if it's not enough data, we'll just call handle.readStart()\\n    // again right away.\\n    self.bytesRead += nread;\\n\\n    // Optimization: emit the original buffer with end points\\n    var ret = self.push(buffer);\\n\\n    if (handle.reading && !ret) {\\n      handle.reading = false;\\n      debug('readStop');\\n      var err = handle.readStop();\\n      if (err)\\n        self._destroy(errnoException(err, 'read'));\\n    }\\n    return;\\n  }\\n\\n  // if we didn't get any bytes, that doesn't necessarily mean EOF.\\n  // wait for the next one.\\n  if (nread === 0) {\\n    debug('not any data, keep waiting');\\n    return;\\n  }\\n\\n  // Error, possibly EOF.\\n  if (nread !== uv.UV_EOF) {\\n    return self._destroy(errnoException(nread, 'read'));\\n  }\\n\\n  debug('EOF');\\n\\n  if (self._readableState.length === 0) {\\n    self.readable = false;\\n    maybeDestroy(self);\\n  }\\n\\n  // push a null to signal the end of data.\\n  self.push(null);\\n\\n  // internal end event so that we know that the actual socket\\n  // is no longer readable, and we can start the shutdown\\n  // procedure. No need to wait for all the data to be consumed.\\n  self.emit('_socketEnd');\\n}\\n\\n\\nSocket.prototype._getpeername = function() {\\n  if (!this._peername) {\\n    if (!this._handle || !this._handle.getpeername) {\\n      return {};\\n    }\\n    var out = {};\\n    var err = this._handle.getpeername(out);\\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\\n    this._peername = out;\\n  }\\n  return this._peername;\\n};\\n\\n\\nSocket.prototype.__defineGetter__('remoteAddress', function() {\\n  return this._getpeername().address;\\n});\\n\\nSocket.prototype.__defineGetter__('remoteFamily', function() {\\n  return this._getpeername().family;\\n});\\n\\nSocket.prototype.__defineGetter__('remotePort', function() {\\n  return this._getpeername().port;\\n});\\n\\n\\nSocket.prototype._getsockname = function() {\\n  if (!this._handle || !this._handle.getsockname) {\\n    return {};\\n  }\\n  if (!this._sockname) {\\n    var out = {};\\n    var err = this._handle.getsockname(out);\\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\\n    this._sockname = out;\\n  }\\n  return this._sockname;\\n};\\n\\n\\nSocket.prototype.__defineGetter__('localAddress', function() {\\n  return this._getsockname().address;\\n});\\n\\n\\nSocket.prototype.__defineGetter__('localPort', function() {\\n  return this._getsockname().port;\\n});\\n\\n\\nSocket.prototype.write = function(chunk, encoding, cb) {\\n  if (typeof chunk !== 'string' && (!Buffer.isBuffer(chunk)))\\n    throw new TypeError('Invalid data');\\n  return stream.Duplex.prototype.write.apply(this, arguments);\\n};\\n\\n\\nSocket.prototype._writeGeneric = function(writev, data, encoding, cb) {\\n  // If we are still connecting, then buffer this for later.\\n  // The Writable logic will buffer up any more writes while\\n  // waiting for this one to be done.\\n  if (this._connecting) {\\n    this._pendingData = data;\\n    this._pendingEncoding = encoding;\\n    this.once('connect', function() {\\n      this._writeGeneric(writev, data, encoding, cb);\\n    });\\n    return;\\n  }\\n  this._pendingData = null;\\n  this._pendingEncoding = '';\\n\\n  this._unrefTimer();\\n\\n  if (!this._handle) {\\n    this._destroy(new Error('This socket is closed'), cb);\\n    return false;\\n  }\\n\\n  var req = new WriteWrap();\\n  req.handle = this._handle;\\n  req.oncomplete = afterWrite;\\n  req.async = false;\\n  var err;\\n\\n  if (writev) {\\n    var chunks = new Array(data.length << 1);\\n    for (var i = 0; i < data.length; i++) {\\n      var entry = data[i];\\n      var chunk = entry.chunk;\\n      var enc = entry.encoding;\\n      chunks[i * 2] = chunk;\\n      chunks[i * 2 + 1] = enc;\\n    }\\n    err = this._handle.writev(req, chunks);\\n\\n    // Retain chunks\\n    if (err === 0) req._chunks = chunks;\\n  } else {\\n    var enc;\\n    if (typeof data === 'buffer') {\\n      req.buffer = data;  // Keep reference alive.\\n      enc = 'buffer';\\n    } else {\\n      enc = encoding;\\n    }\\n    err = createWriteReq(req, this._handle, data, enc);\\n  }\\n\\n  if (err)\\n    return this._destroy(errnoException(err, 'write', req.error), cb);\\n\\n  this._bytesDispatched += req.bytes;\\n\\n  // If it was entirely flushed, we can write some more right now.\\n  // However, if more is left in the queue, then wait until that clears.\\n  if (req.async && this._handle.writeQueueSize != 0)\\n    req.cb = cb;\\n  else\\n    cb();\\n};\\n\\n\\nSocket.prototype._writev = function(chunks, cb) {\\n  this._writeGeneric(true, chunks, '', cb);\\n};\\n\\n\\nSocket.prototype._write = function(data, encoding, cb) {\\n  this._writeGeneric(false, data, encoding, cb);\\n};\\n\\nfunction createWriteReq(req, handle, data, encoding) {\\n  switch (encoding) {\\n    case 'binary':\\n      return handle.writeBinaryString(req, data);\\n\\n    case 'buffer':\\n      return handle.writeBuffer(req, data);\\n\\n    case 'utf8':\\n    case 'utf-8':\\n      return handle.writeUtf8String(req, data);\\n\\n    case 'ascii':\\n      return handle.writeAsciiString(req, data);\\n\\n    case 'ucs2':\\n    case 'ucs-2':\\n    case 'utf16le':\\n    case 'utf-16le':\\n      return handle.writeUcs2String(req, data);\\n\\n    default:\\n      return handle.writeBuffer(req, Buffer(data, encoding));\\n  }\\n}\\n\\n\\nSocket.prototype.__defineGetter__('bytesWritten', function() {\\n  var bytes = this._bytesDispatched,\\n      state = this._writableState,\\n      data = this._pendingData,\\n      encoding = this._pendingEncoding;\\n\\n  if (!state)\\n    return undefined;\\n\\n  state.getBuffer().forEach(function(el) {\\n    if (el.chunk instanceof Buffer)\\n      bytes += el.chunk.length;\\n    else\\n      bytes += Buffer.byteLength(el.chunk, el.encoding);\\n  });\\n\\n  if (data) {\\n    if (data instanceof Buffer)\\n      bytes += data.length;\\n    else\\n      bytes += Buffer.byteLength(data, encoding);\\n  }\\n\\n  return bytes;\\n});\\n\\n\\nfunction afterWrite(status, handle, req, err) {\\n  var self = handle.owner;\\n  if (self !== process.stderr && self !== process.stdout)\\n    debug('afterWrite', status);\\n\\n  // callback may come after call to destroy.\\n  if (self.destroyed) {\\n    debug('afterWrite destroyed');\\n    return;\\n  }\\n\\n  if (status < 0) {\\n    var ex = exceptionWithHostPort(status, 'write', req.address, req.port);\\n    debug('write failure', ex);\\n    self._destroy(ex, req.cb);\\n    return;\\n  }\\n\\n  self._unrefTimer();\\n\\n  if (self !== process.stderr && self !== process.stdout)\\n    debug('afterWrite call cb');\\n\\n  if (req.cb)\\n    req.cb.call(self);\\n}\\n\\n\\nfunction connect(self, address, port, addressType, localAddress, localPort) {\\n  // TODO return promise from Socket.prototype.connect which\\n  // wraps _connectReq.\\n\\n  assert.ok(self._connecting);\\n\\n  var err;\\n\\n  if (localAddress || localPort) {\\n    var bind;\\n\\n    if (addressType === 4) {\\n      localAddress = localAddress || '0.0.0.0';\\n      bind = self._handle.bind;\\n    } else if (addressType === 6) {\\n      localAddress = localAddress || '::';\\n      bind = self._handle.bind6;\\n    } else {\\n      self._destroy(new TypeError('Invalid addressType: ' + addressType));\\n      return;\\n    }\\n\\n    debug('binding to localAddress: %s and localPort: %d',\\n          localAddress,\\n          localPort);\\n\\n    bind = bind.bind(self._handle);\\n    err = bind(localAddress, localPort);\\n\\n    if (err) {\\n      var ex = exceptionWithHostPort(err, 'bind', localAddress, localPort);\\n      self._destroy(ex);\\n      return;\\n    }\\n  }\\n\\n  if (addressType === 6 || addressType === 4) {\\n    var req = new TCPConnectWrap();\\n    req.oncomplete = afterConnect;\\n    req.address = address;\\n    req.port = port;\\n\\n    if (addressType === 4)\\n      err = self._handle.connect(req, address, port);\\n    else\\n      err = self._handle.connect6(req, address, port);\\n\\n  } else {\\n    var req = new PipeConnectWrap();\\n    req.address = address;\\n    req.oncomplete = afterConnect;\\n    err = self._handle.connect(req, address, afterConnect);\\n  }\\n\\n  if (err) {\\n    var sockname = self._getsockname();\\n    var details;\\n\\n    if (sockname) {\\n      details = sockname.address + ':' + sockname.port;\\n    }\\n\\n    var ex = exceptionWithHostPort(err, 'connect', address, port, details);\\n    self._destroy(ex);\\n  }\\n}\\n\\n\\n// Check that the port number is not NaN when coerced to a number,\\n// is an integer and that it falls within the legal range of port numbers.\\nfunction isLegalPort(port) {\\n  if (typeof port === 'string' && port.trim() === '')\\n    return false;\\n  return +port === (port >>> 0) && port >= 0 && port <= 0xFFFF;\\n}\\n\\n\\nSocket.prototype.connect = function(options, cb) {\\n  if (this.write !== Socket.prototype.write)\\n    this.write = Socket.prototype.write;\\n\\n  if (options === null || typeof options !== 'object') {\\n    // Old API:\\n    // connect(port, [host], [cb])\\n    // connect(path, [cb]);\\n    var args = normalizeConnectArgs(arguments);\\n    return Socket.prototype.connect.apply(this, args);\\n  }\\n\\n  if (this.destroyed) {\\n    this._readableState.reading = false;\\n    this._readableState.ended = false;\\n    this._readableState.endEmitted = false;\\n    this._writableState.ended = false;\\n    this._writableState.ending = false;\\n    this._writableState.finished = false;\\n    this._writableState.errorEmitted = false;\\n    this.destroyed = false;\\n    this._handle = null;\\n    this._peername = null;\\n    this._sockname = null;\\n  }\\n\\n  var self = this;\\n  var pipe = !!options.path;\\n  debug('pipe', pipe, options.path);\\n\\n  if (!this._handle) {\\n    this._handle = pipe ? new Pipe() : new TCP();\\n    initSocketHandle(this);\\n  }\\n\\n  if (typeof cb === 'function') {\\n    self.once('connect', cb);\\n  }\\n\\n  this._unrefTimer();\\n\\n  self._connecting = true;\\n  self.writable = true;\\n\\n  if (pipe) {\\n    connect(self, options.path);\\n\\n  } else {\\n    lookupAndConnect(self, options);\\n  }\\n  return self;\\n};\\n\\n\\nfunction lookupAndConnect(self, options) {\\n  var dns = require('dns');\\n  var host = options.host || 'localhost';\\n  var port = options.port;\\n  var localAddress = options.localAddress;\\n  var localPort = options.localPort;\\n\\n  if (localAddress && !exports.isIP(localAddress))\\n    throw new TypeError('\\\"localAddress\\\" option must be a valid IP: ' +\\n                        localAddress);\\n\\n  if (localPort && typeof localPort !== 'number')\\n    throw new TypeError('\\\"localPort\\\" option should be a number: ' + localPort);\\n\\n  if (typeof port !== 'undefined') {\\n    if (typeof port !== 'number' && typeof port !== 'string')\\n      throw new TypeError('\\\"port\\\" option should be a number or string: ' +\\n                          port);\\n    if (!isLegalPort(port))\\n      throw new RangeError('\\\"port\\\" option should be >= 0 and < 65536: ' + port);\\n  }\\n  port |= 0;\\n\\n  // If host is an IP, skip performing a lookup\\n  // TODO(evanlucas) should we hot path this for localhost?\\n  var addressType = exports.isIP(host);\\n  if (addressType) {\\n    process.nextTick(function() {\\n      if (self._connecting)\\n        connect(self, host, port, addressType, localAddress, localPort);\\n    });\\n    return;\\n  }\\n\\n  if (options.lookup && typeof options.lookup !== 'function')\\n    throw new TypeError('\\\"lookup\\\" option should be a function');\\n\\n  var dnsopts = {\\n    family: options.family,\\n    hints: 0\\n  };\\n\\n  if (dnsopts.family !== 4 && dnsopts.family !== 6) {\\n    dnsopts.hints = dns.ADDRCONFIG;\\n    // The AI_V4MAPPED hint is not supported on FreeBSD, and getaddrinfo\\n    // returns EAI_BADFLAGS. However, it seems to be supported on most other\\n    // systems. See\\n    // http://lists.freebsd.org/pipermail/freebsd-bugs/2008-February/028260.html\\n    // for more information on the lack of support for FreeBSD.\\n    if (process.platform !== 'freebsd')\\n      dnsopts.hints |= dns.V4MAPPED;\\n  }\\n\\n  debug('connect: find host ' + host);\\n  debug('connect: dns options', dnsopts);\\n  self._host = host;\\n  var lookup = options.lookup || dns.lookup;\\n  lookup(host, dnsopts, function(err, ip, addressType) {\\n    self.emit('lookup', err, ip, addressType);\\n\\n    // It's possible we were destroyed while looking this up.\\n    // XXX it would be great if we could cancel the promise returned by\\n    // the look up.\\n    if (!self._connecting) return;\\n\\n    if (err) {\\n      // net.createConnection() creates a net.Socket object and\\n      // immediately calls net.Socket.connect() on it (that's us).\\n      // There are no event listeners registered yet so defer the\\n      // error event to the next tick.\\n      err.host = options.host;\\n      err.port = options.port;\\n      err.message = err.message + ' ' + options.host + ':' + options.port;\\n      process.nextTick(connectErrorNT, self, err);\\n    } else {\\n      self._unrefTimer();\\n      connect(self,\\n              ip,\\n              port,\\n              addressType,\\n              localAddress,\\n              localPort);\\n    }\\n  });\\n}\\n\\n\\nfunction connectErrorNT(self, err) {\\n  self.emit('error', err);\\n  self._destroy();\\n}\\n\\n\\nSocket.prototype.ref = function() {\\n  if (!this._handle) {\\n    this.once('connect', this.ref);\\n    return this;\\n  }\\n\\n  this._handle.ref();\\n\\n  return this;\\n};\\n\\n\\nSocket.prototype.unref = function() {\\n  if (!this._handle) {\\n    this.once('connect', this.unref);\\n    return this;\\n  }\\n\\n  this._handle.unref();\\n\\n  return this;\\n};\\n\\n\\nfunction afterConnect(status, handle, req, readable, writable) {\\n  var self = handle.owner;\\n\\n  // callback may come after call to destroy\\n  if (self.destroyed) {\\n    return;\\n  }\\n\\n  // Update handle if it was wrapped\\n  // TODO(indutny): assert that the handle is actually an ancestor of old one\\n  handle = self._handle;\\n\\n  debug('afterConnect');\\n\\n  assert.ok(self._connecting);\\n  self._connecting = false;\\n  self._sockname = null;\\n\\n  if (status == 0) {\\n    self.readable = readable;\\n    self.writable = writable;\\n    self._unrefTimer();\\n\\n    self.emit('connect');\\n\\n    // start the first read, or get an immediate EOF.\\n    // this doesn't actually consume any bytes, because len=0.\\n    if (readable && !self.isPaused())\\n      self.read(0);\\n\\n  } else {\\n    self._connecting = false;\\n    var details;\\n    if (req.localAddress && req.localPort) {\\n      ex.localAddress = req.localAddress;\\n      ex.localPort = req.localPort;\\n      details = ex.localAddress + ':' + ex.localPort;\\n    }\\n    var ex = exceptionWithHostPort(status,\\n                                   'connect',\\n                                   req.address,\\n                                   req.port,\\n                                   details);\\n    self._destroy(ex);\\n  }\\n}\\n\\n\\nfunction Server(options, connectionListener) {\\n  if (!(this instanceof Server))\\n    return new Server(options, connectionListener);\\n\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n  var options;\\n\\n  if (typeof options === 'function') {\\n    connectionListener = options;\\n    options = {};\\n    self.on('connection', connectionListener);\\n  } else {\\n    options = options || {};\\n\\n    if (typeof connectionListener === 'function') {\\n      self.on('connection', connectionListener);\\n    }\\n  }\\n\\n  this._connections = 0;\\n\\n  Object.defineProperty(this, 'connections', {\\n    get: internalUtil.deprecate(function() {\\n\\n      if (self._usingSlaves) {\\n        return null;\\n      }\\n      return self._connections;\\n    }, 'Server.connections property is deprecated. ' +\\n       'Use Server.getConnections method instead.'),\\n    set: internalUtil.deprecate(function(val) {\\n      return (self._connections = val);\\n    }, 'Server.connections property is deprecated.'),\\n    configurable: true, enumerable: false\\n  });\\n\\n  this._handle = null;\\n  this._usingSlaves = false;\\n  this._slaves = [];\\n  this._unref = false;\\n\\n  this.allowHalfOpen = options.allowHalfOpen || false;\\n  this.pauseOnConnect = !!options.pauseOnConnect;\\n}\\nutil.inherits(Server, EventEmitter);\\nexports.Server = Server;\\n\\n\\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\\n\\nfunction _listen(handle, backlog) {\\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\\n  // which will thus give us a backlog of 512 entries.\\n  return handle.listen(backlog || 511);\\n}\\n\\nvar createServerHandle = exports._createServerHandle =\\n    function(address, port, addressType, fd) {\\n  var err = 0;\\n  // assign handle in listen, and clean up if bind or listen fails\\n  var handle;\\n\\n  var isTCP = false;\\n  if (typeof fd === 'number' && fd >= 0) {\\n    try {\\n      handle = createHandle(fd);\\n    }\\n    catch (e) {\\n      // Not a fd we can listen on.  This will trigger an error.\\n      debug('listen invalid fd=' + fd + ': ' + e.message);\\n      return uv.UV_EINVAL;\\n    }\\n    handle.open(fd);\\n    handle.readable = true;\\n    handle.writable = true;\\n    assert(!address && !port);\\n  } else if (port === -1 && addressType === -1) {\\n    handle = new Pipe();\\n    if (process.platform === 'win32') {\\n      var instances = parseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\\n      if (!isNaN(instances)) {\\n        handle.setPendingInstances(instances);\\n      }\\n    }\\n  } else {\\n    handle = new TCP();\\n    isTCP = true;\\n  }\\n\\n  if (address || port || isTCP) {\\n    debug('bind to ' + (address || 'anycast'));\\n    if (!address) {\\n      // Try binding to ipv6 first\\n      err = handle.bind6('::', port);\\n      if (err) {\\n        handle.close();\\n        // Fallback to ipv4\\n        return createServerHandle('0.0.0.0', port);\\n      }\\n    } else if (addressType === 6) {\\n      err = handle.bind6(address, port);\\n    } else {\\n      err = handle.bind(address, port);\\n    }\\n  }\\n\\n  if (err) {\\n    handle.close();\\n    return err;\\n  }\\n\\n  return handle;\\n};\\n\\n\\nServer.prototype._listen2 = function(address, port, addressType, backlog, fd) {\\n  debug('listen2', address, port, addressType, backlog, fd);\\n  var self = this;\\n\\n  // If there is not yet a handle, we need to create one and bind.\\n  // In the case of a server sent via IPC, we don't need to do this.\\n  if (self._handle) {\\n    debug('_listen2: have a handle already');\\n  } else {\\n    debug('_listen2: create a handle');\\n\\n    var rval = null;\\n\\n    if (!address && typeof fd !== 'number') {\\n      rval = createServerHandle('::', port, 6, fd);\\n\\n      if (typeof rval === 'number') {\\n        rval = null;\\n        address = '0.0.0.0';\\n        addressType = 4;\\n      } else {\\n        address = '::';\\n        addressType = 6;\\n      }\\n    }\\n\\n    if (rval === null)\\n      rval = createServerHandle(address, port, addressType, fd);\\n\\n    if (typeof rval === 'number') {\\n      var error = exceptionWithHostPort(rval, 'listen', address, port);\\n      process.nextTick(emitErrorNT, self, error);\\n      return;\\n    }\\n    self._handle = rval;\\n  }\\n\\n  self._handle.onconnection = onconnection;\\n  self._handle.owner = self;\\n\\n  var err = _listen(self._handle, backlog);\\n\\n  if (err) {\\n    var ex = exceptionWithHostPort(err, 'listen', address, port);\\n    self._handle.close();\\n    self._handle = null;\\n    process.nextTick(emitErrorNT, self, ex);\\n    return;\\n  }\\n\\n  // generate connection key, this should be unique to the connection\\n  this._connectionKey = addressType + ':' + address + ':' + port;\\n\\n  // unref the handle if the server was unref'ed prior to listening\\n  if (this._unref)\\n    this.unref();\\n\\n  process.nextTick(emitListeningNT, self);\\n};\\n\\n\\nfunction emitErrorNT(self, err) {\\n  self.emit('error', err);\\n}\\n\\n\\nfunction emitListeningNT(self) {\\n  // ensure handle hasn't closed\\n  if (self._handle)\\n    self.emit('listening');\\n}\\n\\n\\nfunction listen(self, address, port, addressType, backlog, fd, exclusive) {\\n  exclusive = !!exclusive;\\n\\n  if (!cluster) cluster = require('cluster');\\n\\n  if (cluster.isMaster || exclusive) {\\n    self._listen2(address, port, addressType, backlog, fd);\\n    return;\\n  }\\n\\n  cluster._getServer(self, {\\n    address: address,\\n    port: port,\\n    addressType: addressType,\\n    fd: fd,\\n    flags: 0\\n  }, cb);\\n\\n  function cb(err, handle) {\\n    // EADDRINUSE may not be reported until we call listen(). To complicate\\n    // matters, a failed bind() followed by listen() will implicitly bind to\\n    // a random port. Ergo, check that the socket is bound to the expected\\n    // port before calling listen().\\n    //\\n    // FIXME(bnoordhuis) Doesn't work for pipe handles, they don't have a\\n    // getsockname() method. Non-issue for now, the cluster module doesn't\\n    // really support pipes anyway.\\n    if (err === 0 && port > 0 && handle.getsockname) {\\n      var out = {};\\n      err = handle.getsockname(out);\\n      if (err === 0 && port !== out.port)\\n        err = uv.UV_EADDRINUSE;\\n    }\\n\\n    if (err) {\\n      var ex = exceptionWithHostPort(err, 'bind', address, port);\\n      return self.emit('error', ex);\\n    }\\n\\n    self._handle = handle;\\n    self._listen2(address, port, addressType, backlog, fd);\\n  }\\n}\\n\\n\\nServer.prototype.listen = function() {\\n  var self = this;\\n\\n  var lastArg = arguments[arguments.length - 1];\\n  if (typeof lastArg === 'function') {\\n    self.once('listening', lastArg);\\n  }\\n\\n  var port = toNumber(arguments[0]);\\n\\n  // The third optional argument is the backlog size.\\n  // When the ip is omitted it can be the second argument.\\n  var backlog = toNumber(arguments[1]) || toNumber(arguments[2]);\\n\\n  if (arguments.length === 0 || typeof arguments[0] === 'function') {\\n    // Bind to a random port.\\n    listen(self, null, 0, null, backlog);\\n  } else if (arguments[0] !== null && typeof arguments[0] === 'object') {\\n    var h = arguments[0];\\n    h = h._handle || h.handle || h;\\n\\n    if (h instanceof TCP) {\\n      self._handle = h;\\n      listen(self, null, -1, -1, backlog);\\n    } else if (typeof h.fd === 'number' && h.fd >= 0) {\\n      listen(self, null, null, null, backlog, h.fd);\\n    } else {\\n      // The first argument is a configuration object\\n      if (h.backlog)\\n        backlog = h.backlog;\\n\\n      if (typeof h.port === 'number' || typeof h.port === 'string' ||\\n          (typeof h.port === 'undefined' && 'port' in h)) {\\n        // Undefined is interpreted as zero (random port) for consistency\\n        // with net.connect().\\n        if (typeof h.port !== 'undefined' && !isLegalPort(h.port))\\n          throw new RangeError('\\\"port\\\" option should be >= 0 and < 65536: ' +\\n                               h.port);\\n        if (h.host)\\n          listenAfterLookup(h.port | 0, h.host, backlog, h.exclusive);\\n        else\\n          listen(self, null, h.port | 0, 4, backlog, undefined, h.exclusive);\\n      } else if (h.path && isPipeName(h.path)) {\\n        var pipeName = self._pipeName = h.path;\\n        listen(self, pipeName, -1, -1, backlog, undefined, h.exclusive);\\n      } else {\\n        throw new Error('Invalid listen argument: ' + h);\\n      }\\n    }\\n  } else if (isPipeName(arguments[0])) {\\n    // UNIX socket or Windows pipe.\\n    var pipeName = self._pipeName = arguments[0];\\n    listen(self, pipeName, -1, -1, backlog);\\n\\n  } else if (arguments[1] === undefined ||\\n             typeof arguments[1] === 'function' ||\\n             typeof arguments[1] === 'number') {\\n    // The first argument is the port, no IP given.\\n    listen(self, null, port, 4, backlog);\\n\\n  } else {\\n    // The first argument is the port, the second an IP.\\n    listenAfterLookup(port, arguments[1], backlog);\\n  }\\n\\n  function listenAfterLookup(port, address, backlog, exclusive) {\\n    require('dns').lookup(address, function(err, ip, addressType) {\\n      if (err) {\\n        self.emit('error', err);\\n      } else {\\n        addressType = ip ? addressType : 4;\\n        listen(self, ip, port, addressType, backlog, undefined, exclusive);\\n      }\\n    });\\n  }\\n\\n  return self;\\n};\\n\\nServer.prototype.address = function() {\\n  if (this._handle && this._handle.getsockname) {\\n    var out = {};\\n    this._handle.getsockname(out);\\n    // TODO(bnoordhuis) Check err and throw?\\n    return out;\\n  } else if (this._pipeName) {\\n    return this._pipeName;\\n  } else {\\n    return null;\\n  }\\n};\\n\\nfunction onconnection(err, clientHandle) {\\n  var handle = this;\\n  var self = handle.owner;\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  var socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect\\n  });\\n  socket.readable = socket.writable = true;\\n\\n\\n  self._connections++;\\n  socket.server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  LTTNG_NET_SERVER_CONNECTION(socket);\\n  COUNTER_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\\n\\n\\nServer.prototype.getConnections = function(cb) {\\n  function end(err, connections) {\\n    process.nextTick(cb, err, connections);\\n  }\\n\\n  if (!this._usingSlaves) {\\n    return end(null, this._connections);\\n  }\\n\\n  // Poll slaves\\n  var left = this._slaves.length,\\n      total = this._connections;\\n\\n  function oncount(err, count) {\\n    if (err) {\\n      left = -1;\\n      return end(err);\\n    }\\n\\n    total += count;\\n    if (--left === 0) return end(null, total);\\n  }\\n\\n  this._slaves.forEach(function(slave) {\\n    slave.getConnections(oncount);\\n  });\\n};\\n\\n\\nServer.prototype.close = function(cb) {\\n  function onSlaveClose() {\\n    if (--left !== 0) return;\\n\\n    self._connections = 0;\\n    self._emitCloseIfDrained();\\n  }\\n\\n  if (typeof cb === 'function') {\\n    if (!this._handle) {\\n      this.once('close', function() {\\n        cb(new Error('Not running'));\\n      });\\n    } else {\\n      this.once('close', cb);\\n    }\\n  }\\n\\n  if (this._handle) {\\n    this._handle.close();\\n    this._handle = null;\\n  }\\n\\n  if (this._usingSlaves) {\\n    var self = this,\\n        left = this._slaves.length;\\n\\n    // Increment connections to be sure that, even if all sockets will be closed\\n    // during polling of slaves, `close` event will be emitted only once.\\n    this._connections++;\\n\\n    // Poll slaves\\n    this._slaves.forEach(function(slave) {\\n      slave.close(onSlaveClose);\\n    });\\n  } else {\\n    this._emitCloseIfDrained();\\n  }\\n\\n  return this;\\n};\\n\\nServer.prototype._emitCloseIfDrained = function() {\\n  debug('SERVER _emitCloseIfDrained');\\n  var self = this;\\n\\n  if (self._handle || self._connections) {\\n    debug('SERVER handle? %j   connections? %d',\\n          !!self._handle, self._connections);\\n    return;\\n  }\\n\\n  process.nextTick(emitCloseNT, self);\\n};\\n\\n\\nfunction emitCloseNT(self) {\\n  debug('SERVER: emit close');\\n  self.emit('close');\\n}\\n\\n\\nServer.prototype.listenFD = internalUtil.deprecate(function(fd, type) {\\n  return this.listen({ fd: fd });\\n}, 'Server.listenFD is deprecated. Use Server.listen({fd: <number>}) instead.');\\n\\nServer.prototype._setupSlave = function(socketList) {\\n  this._usingSlaves = true;\\n  this._slaves.push(socketList);\\n};\\n\\nServer.prototype.ref = function() {\\n  this._unref = false;\\n\\n  if (this._handle)\\n    this._handle.ref();\\n\\n  return this;\\n};\\n\\nServer.prototype.unref = function() {\\n  this._unref = true;\\n\\n  if (this._handle)\\n    this._handle.unref();\\n\\n  return this;\\n};\\n\\n\\nexports.isIP = cares.isIP;\\n\\n\\nexports.isIPv4 = function(input) {\\n  return exports.isIP(input) === 4;\\n};\\n\\n\\nexports.isIPv6 = function(input) {\\n  return exports.isIP(input) === 6;\\n};\\n\\n\\nif (process.platform === 'win32') {\\n  var simultaneousAccepts;\\n\\n  exports._setSimultaneousAccepts = function(handle) {\\n    if (handle === undefined) {\\n      return;\\n    }\\n\\n    if (simultaneousAccepts === undefined) {\\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\\n                             process.env.NODE_MANY_ACCEPTS !== '0');\\n    }\\n\\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\\n      handle.setSimultaneousAccepts(simultaneousAccepts);\\n      handle._simultaneousAccepts = simultaneousAccepts;\\n    }\\n  };\\n} else {\\n  exports._setSimultaneousAccepts = function(handle) {};\\n}\\n\",\"dns\":\"'use strict';\\n\\nvar net = require('net');\\nvar util = require('util');\\n\\nvar cares = process.binding('cares_wrap');\\nvar uv = process.binding('uv');\\n\\nvar GetAddrInfoReqWrap = cares.GetAddrInfoReqWrap;\\nvar GetNameInfoReqWrap = cares.GetNameInfoReqWrap;\\nvar QueryReqWrap = cares.QueryReqWrap;\\n\\nvar isIp = net.isIP;\\n\\n\\nfunction errnoException(err, syscall, hostname) {\\n  // FIXME(bnoordhuis) Remove this backwards compatibility nonsense and pass\\n  // the true error to the user. ENOTFOUND is not even a proper POSIX error!\\n  if (err === uv.UV_EAI_MEMORY ||\\n      err === uv.UV_EAI_NODATA ||\\n      err === uv.UV_EAI_NONAME) {\\n    err = 'ENOTFOUND';\\n  }\\n  var ex = null;\\n  if (typeof err === 'string') {  // c-ares error code.\\n    ex = new Error(syscall + ' ' + err + (hostname ? ' ' + hostname : ''));\\n    ex.code = err;\\n    ex.errno = err;\\n    ex.syscall = syscall;\\n  } else {\\n    ex = util._errnoException(err, syscall);\\n  }\\n  if (hostname) {\\n    ex.hostname = hostname;\\n  }\\n  return ex;\\n}\\n\\n\\n// c-ares invokes a callback either synchronously or asynchronously,\\n// but the dns API should always invoke a callback asynchronously.\\n//\\n// This function makes sure that the callback is invoked asynchronously.\\n// It returns a function that invokes the callback within nextTick().\\n//\\n// To avoid invoking unnecessary nextTick(), `immediately` property of\\n// returned function should be set to true after c-ares returned.\\n//\\n// Usage:\\n//\\n// function someAPI(callback) {\\n//   callback = makeAsync(callback);\\n//   channel.someAPI(..., callback);\\n//   callback.immediately = true;\\n// }\\nfunction makeAsync(callback) {\\n  if (typeof callback !== 'function') {\\n    return callback;\\n  }\\n  return function asyncCallback() {\\n    if (asyncCallback.immediately) {\\n      // The API already returned, we can invoke the callback immediately.\\n      callback.apply(null, arguments);\\n    } else {\\n      var args = new Array(arguments.length + 1);\\n      args[0] = callback;\\n      for (var i = 1, a = 0; a < arguments.length; ++i, ++a)\\n        args[i] = arguments[a];\\n      process.nextTick.apply(null, args);\\n    }\\n  };\\n}\\n\\n\\nfunction onlookup(err, addresses) {\\n  if (err) {\\n    return this.callback(errnoException(err, 'getaddrinfo', this.hostname));\\n  }\\n  if (this.family) {\\n    this.callback(null, addresses[0], this.family);\\n  } else {\\n    this.callback(null, addresses[0], addresses[0].indexOf(':') >= 0 ? 6 : 4);\\n  }\\n}\\n\\n\\nfunction onlookupall(err, addresses) {\\n  var results = [];\\n  if (err) {\\n    return this.callback(errnoException(err, 'getaddrinfo', this.hostname));\\n  }\\n\\n  for (var i = 0; i < addresses.length; i++) {\\n    results.push({\\n      address: addresses[i],\\n      family: this.family || (addresses[i].indexOf(':') >= 0 ? 6 : 4)\\n    });\\n  }\\n\\n  this.callback(null, results);\\n}\\n\\n\\n// Easy DNS A/AAAA look up\\n// lookup(hostname, [options,] callback)\\nexports.lookup = function lookup(hostname, options, callback) {\\n  var hints = 0;\\n  var family = -1;\\n  var all = false;\\n\\n  // Parse arguments\\n  if (hostname && typeof hostname !== 'string') {\\n    throw new TypeError('Invalid arguments: ' +\\n                        'hostname must be a string or falsey');\\n  } else if (typeof options === 'function') {\\n    callback = options;\\n    family = 0;\\n  } else if (typeof callback !== 'function') {\\n    throw new TypeError('Invalid arguments: callback must be passed');\\n  } else if (options !== null && typeof options === 'object') {\\n    hints = options.hints >>> 0;\\n    family = options.family >>> 0;\\n    all = options.all === true;\\n\\n    if (hints !== 0 &&\\n        hints !== exports.ADDRCONFIG &&\\n        hints !== exports.V4MAPPED &&\\n        hints !== (exports.ADDRCONFIG | exports.V4MAPPED)) {\\n      throw new TypeError('Invalid argument: hints must use valid flags');\\n    }\\n  } else {\\n    family = options >>> 0;\\n  }\\n\\n  if (family !== 0 && family !== 4 && family !== 6)\\n    throw new TypeError('Invalid argument: family must be 4 or 6');\\n\\n  callback = makeAsync(callback);\\n\\n  if (!hostname) {\\n    if (all) {\\n      callback(null, []);\\n    } else {\\n      callback(null, null, family === 6 ? 6 : 4);\\n    }\\n    return {};\\n  }\\n\\n  var matchedFamily = net.isIP(hostname);\\n  if (matchedFamily) {\\n    if (all) {\\n      callback(null, [{address: hostname, family: matchedFamily}]);\\n    } else {\\n      callback(null, hostname, matchedFamily);\\n    }\\n    return {};\\n  }\\n\\n  var req = new GetAddrInfoReqWrap();\\n  req.callback = callback;\\n  req.family = family;\\n  req.hostname = hostname;\\n  req.oncomplete = all ? onlookupall : onlookup;\\n\\n  var err = cares.getaddrinfo(req, hostname, family, hints);\\n  if (err) {\\n    callback(errnoException(err, 'getaddrinfo', hostname));\\n    return {};\\n  }\\n\\n  callback.immediately = true;\\n  return req;\\n};\\n\\n\\nfunction onlookupservice(err, host, service) {\\n  if (err)\\n    return this.callback(errnoException(err, 'getnameinfo', this.host));\\n\\n  this.callback(null, host, service);\\n}\\n\\n\\n// lookupService(address, port, callback)\\nexports.lookupService = function(host, port, callback) {\\n  if (arguments.length !== 3)\\n    throw new Error('Invalid arguments');\\n\\n  if (cares.isIP(host) === 0)\\n    throw new TypeError('\\\"host\\\" argument needs to be a valid IP address');\\n\\n  callback = makeAsync(callback);\\n\\n  var req = new GetNameInfoReqWrap();\\n  req.callback = callback;\\n  req.host = host;\\n  req.port = port;\\n  req.oncomplete = onlookupservice;\\n\\n  var err = cares.getnameinfo(req, host, port);\\n  if (err) throw errnoException(err, 'getnameinfo', host);\\n\\n  callback.immediately = true;\\n  return req;\\n};\\n\\n\\nfunction onresolve(err, result) {\\n  if (err)\\n    this.callback(errnoException(err, this.bindingName, this.hostname));\\n  else\\n    this.callback(null, result);\\n}\\n\\n\\nfunction resolver(bindingName) {\\n  var binding = cares[bindingName];\\n  return function query(name, callback) {\\n    if (typeof name !== 'string') {\\n      throw new Error('\\\"name\\\" argument must be a string');\\n    } else if (typeof callback !== 'function') {\\n      throw new Error('\\\"callback\\\" argument must be a function');\\n    }\\n\\n    callback = makeAsync(callback);\\n    var req = new QueryReqWrap();\\n    req.bindingName = bindingName;\\n    req.callback = callback;\\n    req.hostname = name;\\n    req.oncomplete = onresolve;\\n    var err = binding(req, name);\\n    if (err) throw errnoException(err, bindingName);\\n    callback.immediately = true;\\n    return req;\\n  };\\n}\\n\\n\\nvar resolveMap = {};\\nexports.resolve4 = resolveMap.A = resolver('queryA');\\nexports.resolve6 = resolveMap.AAAA = resolver('queryAaaa');\\nexports.resolveCname = resolveMap.CNAME = resolver('queryCname');\\nexports.resolveMx = resolveMap.MX = resolver('queryMx');\\nexports.resolveNs = resolveMap.NS = resolver('queryNs');\\nexports.resolveTxt = resolveMap.TXT = resolver('queryTxt');\\nexports.resolveSrv = resolveMap.SRV = resolver('querySrv');\\nexports.resolveNaptr = resolveMap.NAPTR = resolver('queryNaptr');\\nexports.resolveSoa = resolveMap.SOA = resolver('querySoa');\\nexports.reverse = resolveMap.PTR = resolver('getHostByAddr');\\n\\n\\nexports.resolve = function(hostname, type_, callback_) {\\n  var resolver, callback;\\n  if (typeof type_ === 'string') {\\n    resolver = resolveMap[type_];\\n    callback = callback_;\\n  } else if (typeof type_ === 'function') {\\n    resolver = exports.resolve4;\\n    callback = type_;\\n  } else {\\n    throw new Error('\\\"type\\\" argument must be a string');\\n  }\\n\\n  if (typeof resolver === 'function') {\\n    return resolver(hostname, callback);\\n  } else {\\n    throw new Error('Unknown type \\\"' + type_ + '\\\"');\\n  }\\n};\\n\\n\\nexports.getServers = function() {\\n  return cares.getServers();\\n};\\n\\n\\nexports.setServers = function(servers) {\\n  // cache the original servers because in the event of an error setting the\\n  // servers cares won't have any servers available for resolution\\n  var orig = cares.getServers();\\n\\n  var newSet = [];\\n\\n  servers.forEach(function(serv) {\\n    var ver = isIp(serv);\\n\\n    if (ver)\\n      return newSet.push([ver, serv]);\\n\\n    var match = serv.match(/\\\\[(.*)\\\\](:\\\\d+)?/);\\n\\n    // we have an IPv6 in brackets\\n    if (match) {\\n      ver = isIp(match[1]);\\n      if (ver)\\n        return newSet.push([ver, match[1]]);\\n    }\\n\\n    var s = serv.split(/:\\\\d+$/)[0];\\n    ver = isIp(s);\\n\\n    if (ver)\\n      return newSet.push([ver, s]);\\n\\n    throw new Error('IP address is not properly formatted: ' + serv);\\n  });\\n\\n  var r = cares.setServers(newSet);\\n\\n  if (r) {\\n    // reset the servers to the old servers, because ares probably unset them\\n    cares.setServers(orig.join(','));\\n\\n    var err = cares.strerror(r);\\n    throw new Error('c-ares failed to set servers: \\\"' + err +\\n                    '\\\" [' + servers + ']');\\n  }\\n};\\n\\n// uv_getaddrinfo flags\\nexports.ADDRCONFIG = cares.AI_ADDRCONFIG;\\nexports.V4MAPPED = cares.AI_V4MAPPED;\\n\\n// ERROR CODES\\nexports.NODATA = 'ENODATA';\\nexports.FORMERR = 'EFORMERR';\\nexports.SERVFAIL = 'ESERVFAIL';\\nexports.NOTFOUND = 'ENOTFOUND';\\nexports.NOTIMP = 'ENOTIMP';\\nexports.REFUSED = 'EREFUSED';\\nexports.BADQUERY = 'EBADQUERY';\\nexports.BADNAME = 'EBADNAME';\\nexports.BADFAMILY = 'EBADFAMILY';\\nexports.BADRESP = 'EBADRESP';\\nexports.CONNREFUSED = 'ECONNREFUSED';\\nexports.TIMEOUT = 'ETIMEOUT';\\nexports.EOF = 'EOF';\\nexports.FILE = 'EFILE';\\nexports.NOMEM = 'ENOMEM';\\nexports.DESTRUCTION = 'EDESTRUCTION';\\nexports.BADSTR = 'EBADSTR';\\nexports.BADFLAGS = 'EBADFLAGS';\\nexports.NONAME = 'ENONAME';\\nexports.BADHINTS = 'EBADHINTS';\\nexports.NOTINITIALIZED = 'ENOTINITIALIZED';\\nexports.LOADIPHLPAPI = 'ELOADIPHLPAPI';\\nexports.ADDRGETNETWORKPARAMS = 'EADDRGETNETWORKPARAMS';\\nexports.CANCELLED = 'ECANCELLED';\\n\",\"cluster\":\"exports.isMaster = true;\\n\",\"string_decoder\":\"'use strict';\\n\\nvar Buffer = require('buffer').Buffer;\\n\\nfunction assertEncoding(encoding) {\\n  // Do not cache `Buffer.isEncoding`, some modules monkey-patch it to support\\n  // additional encodings\\n  if (encoding && !Buffer.isEncoding(encoding)) {\\n    throw new Error('Unknown encoding: ' + encoding);\\n  }\\n}\\n\\n// StringDecoder provides an interface for efficiently splitting a series of\\n// buffers into a series of JS strings without breaking apart multi-byte\\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\\n//\\n// @TODO Handling all encodings inside a single object makes it very difficult\\n// to reason about this code, so it should be split up in the future.\\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\\n// points as used by CESU-8.\\nvar StringDecoder = exports.StringDecoder = function(encoding) {\\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\\n  assertEncoding(encoding);\\n  switch (this.encoding) {\\n    case 'utf8':\\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\\n      this.surrogateSize = 3;\\n      break;\\n    case 'ucs2':\\n    case 'utf16le':\\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\\n      this.surrogateSize = 2;\\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\\n      break;\\n    case 'base64':\\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\\n      this.surrogateSize = 3;\\n      this.detectIncompleteChar = base64DetectIncompleteChar;\\n      break;\\n    default:\\n      this.write = passThroughWrite;\\n      return;\\n  }\\n\\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\\n  this.charBuffer = Buffer(6);\\n  // Number of bytes received for the current incomplete multi-byte character.\\n  this.charReceived = 0;\\n  // Number of bytes expected for the current incomplete multi-byte character.\\n  this.charLength = 0;\\n};\\n\\n\\n// write decodes the given buffer and returns it as JS string that is\\n// guaranteed to not contain any partial multi-byte characters. Any partial\\n// character found at the end of the buffer is buffered up, and will be\\n// returned when calling write again with the remaining bytes.\\n//\\n// Note: Converting a Buffer containing an orphan surrogate to a String\\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\\n// Buffer#write) will replace incomplete surrogates with the unicode\\n// replacement character. See https://codereview.chromium.org/121173009/ .\\nStringDecoder.prototype.write = function(buffer) {\\n  var charStr = '';\\n  var buflen = buffer.length;\\n  var charBuffer = this.charBuffer;\\n  var charLength = this.charLength;\\n  var charReceived = this.charReceived;\\n  var surrogateSize = this.surrogateSize;\\n  var encoding = this.encoding;\\n  // if our last write ended with an incomplete multibyte character\\n  while (charLength) {\\n    // determine how many remaining bytes this buffer has to offer for this char\\n    var diff = charLength - charReceived;\\n    var available = (buflen >= diff) ? diff : buflen;\\n\\n    // add the new bytes to the char buffer\\n    buffer.copy(charBuffer, charReceived, 0, available);\\n    charReceived += available;\\n\\n    if (charReceived < charLength) {\\n      // still not enough chars in this buffer? wait for more ...\\n\\n      this.charLength = charLength;\\n      this.charReceived = charReceived;\\n\\n      return '';\\n    }\\n\\n    // remove bytes belonging to the current character from the buffer\\n    buffer = buffer.slice(available, buflen);\\n    buflen = buffer.length;\\n\\n    // get the character that was split\\n    charStr = charBuffer.toString(encoding, 0, charLength);\\n\\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\\n    var charCode = charStr.charCodeAt(charStr.length - 1);\\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\\n      charLength += surrogateSize;\\n      charStr = '';\\n      continue;\\n    }\\n    charReceived = charLength = 0;\\n\\n    // if there are no more bytes in this buffer, just emit our char\\n    if (buflen === 0) {\\n      this.charLength = charLength;\\n      this.charReceived = charReceived;\\n\\n      return charStr;\\n    }\\n  }\\n\\n  // determine and set charLength / charReceived\\n  if (this.detectIncompleteChar(buffer))\\n    charLength = this.charLength;\\n  charReceived = this.charReceived;\\n\\n  var end = buflen;\\n  if (charLength) {\\n    // buffer the incomplete character bytes we got\\n    buffer.copy(charBuffer, 0, buflen - charReceived, end);\\n    end -= charReceived;\\n  }\\n\\n  this.charLength = charLength;\\n  charStr += buffer.toString(encoding, 0, end);\\n\\n  var end = charStr.length - 1;\\n  var charCode = charStr.charCodeAt(end);\\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\\n    charLength += surrogateSize;\\n    charReceived += surrogateSize;\\n    charBuffer.copy(charBuffer, surrogateSize, 0, surrogateSize);\\n    buffer.copy(charBuffer, 0, 0, surrogateSize);\\n\\n    this.charLength = charLength;\\n    this.charReceived = charReceived;\\n\\n    return charStr.substring(0, end);\\n  }\\n\\n  // or just emit the charStr\\n  return charStr;\\n};\\n\\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\\n// the end of the given buffer. If so, it sets this.charLength to the byte\\n// length that character, and sets this.charReceived to the number of bytes\\n// that are available for this character.\\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\\n  var buflen = buffer.length;\\n  // determine how many bytes we have to check at the end of this buffer\\n  var i = (buflen >= 3) ? 3 : buflen;\\n  var newlen = false;\\n\\n  // Figure out if one of the last i bytes of our buffer announces an\\n  // incomplete char.\\n  for (; i > 0; i--) {\\n    var c = buffer[buflen - i];\\n\\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\\n\\n    // 110XXXXX\\n    if (i === 1 && c >> 5 === 0x06) {\\n      this.charLength = 2;\\n      newlen = true;\\n      break;\\n    }\\n\\n    // 1110XXXX\\n    if (i <= 2 && c >> 4 === 0x0E) {\\n      this.charLength = 3;\\n      newlen = true;\\n      break;\\n    }\\n\\n    // 11110XXX\\n    if (i <= 3 && c >> 3 === 0x1E) {\\n      this.charLength = 4;\\n      newlen = true;\\n      break;\\n    }\\n  }\\n\\n  this.charReceived = i;\\n\\n  return newlen;\\n};\\n\\nStringDecoder.prototype.end = function(buffer) {\\n  var res = '';\\n  if (buffer && buffer.length)\\n    res = this.write(buffer);\\n\\n  var charReceived = this.charReceived;\\n  if (charReceived) {\\n    var cr = charReceived;\\n    var buf = this.charBuffer;\\n    var enc = this.encoding;\\n    res += buf.toString(enc, 0, cr);\\n  }\\n\\n  return res;\\n};\\n\\nfunction passThroughWrite(buffer) {\\n  return buffer.toString(this.encoding);\\n}\\n\\nfunction utf16DetectIncompleteChar(buffer) {\\n  var charReceived = this.charReceived = buffer.length % 2;\\n  this.charLength = charReceived ? 2 : 0;\\n  return true;\\n}\\n\\nfunction base64DetectIncompleteChar(buffer) {\\n  var charReceived = this.charReceived = buffer.length % 3;\\n  this.charLength = charReceived ? 3 : 0;\\n  return true;\\n}\\n\",\"tty\":\"'use strict';\\n\\nvar util = require('util');\\nvar internalUtil = require('internal/util');\\nvar net = require('net');\\nvar TTY = process.binding('tty_wrap').TTY;\\nvar isTTY = process.binding('tty_wrap').isTTY;\\nvar inherits = util.inherits;\\nvar errnoException = util._errnoException;\\n\\n\\nexports.isatty = function(fd) {\\n  return isTTY(fd);\\n};\\n\\n\\n// backwards-compat\\nexports.setRawMode = internalUtil.deprecate(function(flag) {\\n  if (!process.stdin.isTTY) {\\n    throw new Error('Can\\\\'t set raw mode on non-tty');\\n  }\\n  process.stdin.setRawMode(flag);\\n}, 'tty.setRawMode is deprecated. ' +\\n   'Use process.stdin.setRawMode instead.');\\n\\n\\nfunction ReadStream(fd, options) {\\n  if (!(this instanceof ReadStream))\\n    return new ReadStream(fd, options);\\n\\n  options = util._extend({\\n    highWaterMark: 0,\\n    readable: true,\\n    writable: false,\\n    handle: new TTY(fd, true)\\n  }, options);\\n\\n  net.Socket.call(this, options);\\n\\n  this.isRaw = false;\\n  this.isTTY = true;\\n}\\ninherits(ReadStream, net.Socket);\\n\\nexports.ReadStream = ReadStream;\\n\\nReadStream.prototype.setRawMode = function(flag) {\\n  flag = !!flag;\\n  this._handle.setRawMode(flag);\\n  this.isRaw = flag;\\n};\\n\\n\\nfunction WriteStream(fd) {\\n  if (!(this instanceof WriteStream)) return new WriteStream(fd);\\n  net.Socket.call(this, {\\n    handle: new TTY(fd, false),\\n    readable: false,\\n    writable: true\\n  });\\n\\n  var winSize = [];\\n  var err = this._handle.getWindowSize(winSize);\\n  if (!err) {\\n    this.columns = winSize[0];\\n    this.rows = winSize[1];\\n  }\\n}\\ninherits(WriteStream, net.Socket);\\nexports.WriteStream = WriteStream;\\n\\n\\nWriteStream.prototype.isTTY = true;\\n\\n\\nWriteStream.prototype._refreshSize = function() {\\n  var oldCols = this.columns;\\n  var oldRows = this.rows;\\n  var winSize = [];\\n  var err = this._handle.getWindowSize(winSize);\\n  if (err) {\\n    this.emit('error', errnoException(err, 'getWindowSize'));\\n    return;\\n  }\\n  var newCols = winSize[0];\\n  var newRows = winSize[1];\\n  if (oldCols !== newCols || oldRows !== newRows) {\\n    this.columns = newCols;\\n    this.rows = newRows;\\n    this.emit('resize');\\n  }\\n};\\n\\n\\n// backwards-compat\\nWriteStream.prototype.cursorTo = function(x, y) {\\n  require('readline').cursorTo(this, x, y);\\n};\\nWriteStream.prototype.moveCursor = function(dx, dy) {\\n  require('readline').moveCursor(this, dx, dy);\\n};\\nWriteStream.prototype.clearLine = function(dir) {\\n  require('readline').clearLine(this, dir);\\n};\\nWriteStream.prototype.clearScreenDown = function() {\\n  require('readline').clearScreenDown(this);\\n};\\nWriteStream.prototype.getWindowSize = function() {\\n  return [this.columns, this.rows];\\n};\\n\",\"internal/child_process\":\"'use strict';\\n\\nvar StringDecoder = require('string_decoder').StringDecoder;\\nvar Buffer = require('buffer').Buffer;\\nvar EventEmitter = require('events');\\nvar net = require('net');\\n//FIXME: dgram\\n// var dgram = require('dgram');\\nvar util = require('util');\\nvar constants = require('constants');\\nvar assert = require('assert');\\n\\nvar Process = process.binding('process_wrap').Process;\\nvar WriteWrap = process.binding('stream_wrap').WriteWrap;\\nvar uv = process.binding('uv');\\nvar Pipe = process.binding('pipe_wrap').Pipe;\\nvar TTY = process.binding('tty_wrap').TTY;\\nvar TCP = process.binding('tcp_wrap').TCP;\\n//FIXME udp\\n// var UDP = process.binding('udp_wrap').UDP;\\nvar SocketList = require('internal/socket_list');\\n\\nvar errnoException = util._errnoException;\\nvar SocketListSend = SocketList.SocketListSend;\\nvar SocketListReceive = SocketList.SocketListReceive;\\n\\nexports.ChildProcess = ChildProcess;\\nexports.setupChannel = setupChannel;\\nexports._validateStdio = _validateStdio;\\nexports.getSocketList = getSocketList;\\n\\n// module.exports = {\\n//   ChildProcess,\\n//   setupChannel,\\n//   _validateStdio,\\n//   getSocketList\\n// };\\n\\n// this object contain function to convert TCP objects to native handle objects\\n// and back again.\\nvar handleConversion = {\\n  'net.Native': {\\n    simultaneousAccepts: true,\\n\\n    send: function(message, handle) {\\n      return handle;\\n    },\\n\\n    got: function(message, handle, emit) {\\n      emit(handle);\\n    }\\n  },\\n\\n  'net.Server': {\\n    simultaneousAccepts: true,\\n\\n    send: function(message, server) {\\n      return server._handle;\\n    },\\n\\n    got: function(message, handle, emit) {\\n      var server = new net.Server();\\n      server.listen(handle, function() {\\n        emit(server);\\n      });\\n    }\\n  },\\n\\n  'net.Socket': {\\n    send: function(message, socket) {\\n      if (!socket._handle)\\n        return;\\n\\n      // if the socket was created by net.Server\\n      if (socket.server) {\\n        // the slave should keep track of the socket\\n        message.key = socket.server._connectionKey;\\n\\n        var firstTime = !this._channel.sockets.send[message.key];\\n        var socketList = getSocketList('send', this, message.key);\\n\\n        // the server should no longer expose a .connection property\\n        // and when asked to close it should query the socket status from\\n        // the slaves\\n        if (firstTime) socket.server._setupSlave(socketList);\\n\\n        // Act like socket is detached\\n        socket.server._connections--;\\n      }\\n\\n      // remove handle from socket object, it will be closed when the socket\\n      // will be sent\\n      var handle = socket._handle;\\n      handle.onread = function() {};\\n      socket._handle = null;\\n\\n      return handle;\\n    },\\n\\n    postSend: function(handle) {\\n      // Close the Socket handle after sending it\\n      if (handle)\\n        handle.close();\\n    },\\n\\n    got: function(message, handle, emit) {\\n      var socket = new net.Socket({handle: handle});\\n      socket.readable = socket.writable = true;\\n\\n      // if the socket was created by net.Server we will track the socket\\n      if (message.key) {\\n\\n        // add socket to connections list\\n        var socketList = getSocketList('got', this, message.key);\\n        socketList.add({\\n          socket: socket\\n        });\\n      }\\n\\n      emit(socket);\\n    }\\n  },\\n\\n  'dgram.Native': {\\n    simultaneousAccepts: false,\\n\\n    send: function(message, handle) {\\n      return handle;\\n    },\\n\\n    got: function(message, handle, emit) {\\n      emit(handle);\\n    }\\n  },\\n\\n  'dgram.Socket': {\\n    simultaneousAccepts: false,\\n\\n    send: function(message, socket) {\\n      message.dgramType = socket.type;\\n\\n      return socket._handle;\\n    },\\n\\n    got: function(message, handle, emit) {\\n      var socket = new dgram.Socket(message.dgramType);\\n\\n      socket.bind(handle, function() {\\n        emit(socket);\\n      });\\n    }\\n  }\\n};\\n\\n\\nfunction ChildProcess() {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n\\n  this._closesNeeded = 1;\\n  this._closesGot = 0;\\n  this.connected = false;\\n\\n  this.signalCode = null;\\n  this.exitCode = null;\\n  this.killed = false;\\n  this.spawnfile = null;\\n\\n  this._handle = new Process();\\n  this._handle.owner = this;\\n\\n  this._handle.onexit = function(exitCode, signalCode) {\\n    //\\n    // follow 0.4.x behaviour:\\n    //\\n    // - normally terminated processes don't touch this.signalCode\\n    // - signaled processes don't touch this.exitCode\\n    //\\n    // new in 0.9.x:\\n    //\\n    // - spawn failures are reported with exitCode < 0\\n    //\\n    var syscall = self.spawnfile ? 'spawn ' + self.spawnfile : 'spawn';\\n    var err = (exitCode < 0) ? errnoException(exitCode, syscall) : null;\\n\\n    if (signalCode) {\\n      self.signalCode = signalCode;\\n    } else {\\n      self.exitCode = exitCode;\\n    }\\n\\n    if (self.stdin) {\\n      self.stdin.destroy();\\n    }\\n\\n    self._handle.close();\\n    self._handle = null;\\n\\n    if (exitCode < 0) {\\n      if (self.spawnfile)\\n        err.path = self.spawnfile;\\n\\n      err.spawnargs = self.spawnargs.slice(1);\\n      self.emit('error', err);\\n    } else {\\n      self.emit('exit', self.exitCode, self.signalCode);\\n    }\\n\\n    // if any of the stdio streams have not been touched,\\n    // then pull all the data through so that it can get the\\n    // eof and emit a 'close' event.\\n    // Do it on nextTick so that the user has one last chance\\n    // to consume the output, if for example they only want to\\n    // start reading the data once the process exits.\\n    process.nextTick(flushStdio, self);\\n\\n    maybeClose(self);\\n  };\\n}\\nutil.inherits(ChildProcess, EventEmitter);\\n\\n\\nfunction flushStdio(subprocess) {\\n  if (subprocess.stdio == null) return;\\n  subprocess.stdio.forEach(function(stream, fd, stdio) {\\n    if (!stream || !stream.readable)\\n      return;\\n    stream.resume();\\n  });\\n}\\n\\n\\nfunction createSocket(pipe, readable) {\\n  var s = new net.Socket({ handle: pipe });\\n\\n  if (readable) {\\n    s.writable = false;\\n    s.readable = true;\\n  } else {\\n    s.writable = true;\\n    s.readable = false;\\n  }\\n\\n  return s;\\n}\\n\\n\\nfunction getHandleWrapType(stream) {\\n  if (stream instanceof Pipe) return 'pipe';\\n  if (stream instanceof TTY) return 'tty';\\n  if (stream instanceof TCP) return 'tcp';\\n  if (stream instanceof UDP) return 'udp';\\n\\n  return false;\\n}\\n\\n\\nChildProcess.prototype.spawn = function(options) {\\n  var self = this,\\n      ipc,\\n      ipcFd,\\n      // If no `stdio` option was given - use default\\n      stdio = options.stdio || 'pipe';\\n\\n  stdio = _validateStdio(stdio, false);\\n\\n  ipc = stdio.ipc;\\n  ipcFd = stdio.ipcFd;\\n  stdio = options.stdio = stdio.stdio;\\n\\n  if (ipc !== undefined) {\\n    // Let child process know about opened IPC channel\\n    options.envPairs = options.envPairs || [];\\n    options.envPairs.push('NODE_CHANNEL_FD=' + ipcFd);\\n  }\\n\\n  this.spawnfile = options.file;\\n  this.spawnargs = options.args;\\n\\n  var err = this._handle.spawn(options);\\n\\n  // Run-time errors should emit an error, not throw an exception.\\n  if (err === uv.UV_EAGAIN ||\\n      err === uv.UV_EMFILE ||\\n      err === uv.UV_ENFILE ||\\n      err === uv.UV_ENOENT) {\\n    process.nextTick(onErrorNT, self, err);\\n    // There is no point in continuing when we've hit EMFILE or ENFILE\\n    // because we won't be able to set up the stdio file descriptors.\\n    // It's kind of silly that the de facto spec for ENOENT (the test suite)\\n    // mandates that stdio _is_ set up, even if there is no process on the\\n    // receiving end, but it is what it is.\\n    if (err !== uv.UV_ENOENT) return err;\\n  } else if (err) {\\n    // Close all opened fds on error\\n    stdio.forEach(function(stdio) {\\n      if (stdio.type === 'pipe') {\\n        stdio.handle.close();\\n      }\\n    });\\n\\n    this._handle.close();\\n    this._handle = null;\\n    throw errnoException(err, 'spawn');\\n  }\\n\\n  this.pid = this._handle.pid;\\n\\n  stdio.forEach(function(stdio, i) {\\n    if (stdio.type === 'ignore') return;\\n\\n    if (stdio.ipc) {\\n      self._closesNeeded++;\\n      return;\\n    }\\n\\n    if (stdio.handle) {\\n      // when i === 0 - we're dealing with stdin\\n      // (which is the only one writable pipe)\\n      stdio.socket = createSocket(self.pid !== 0 ? stdio.handle : null, i > 0);\\n\\n      if (i > 0 && self.pid !== 0) {\\n        self._closesNeeded++;\\n        stdio.socket.on('close', function() {\\n          maybeClose(self);\\n        });\\n      }\\n    }\\n  });\\n\\n  this.stdin = stdio.length >= 1 && stdio[0].socket !== undefined ?\\n      stdio[0].socket : null;\\n  this.stdout = stdio.length >= 2 && stdio[1].socket !== undefined ?\\n      stdio[1].socket : null;\\n  this.stderr = stdio.length >= 3 && stdio[2].socket !== undefined ?\\n      stdio[2].socket : null;\\n\\n  this.stdio = stdio.map(function(stdio) {\\n    return stdio.socket === undefined ? null : stdio.socket;\\n  });\\n\\n  // Add .send() method and start listening for IPC data\\n  if (ipc !== undefined) setupChannel(this, ipc);\\n\\n  return err;\\n};\\n\\n\\nfunction onErrorNT(self, err) {\\n  self._handle.onexit(err);\\n}\\n\\n\\nChildProcess.prototype.kill = function(sig) {\\n  var signal;\\n\\n  if (sig === 0) {\\n    signal = 0;\\n  } else if (!sig) {\\n    signal = constants['SIGTERM'];\\n  } else {\\n    signal = constants[sig];\\n  }\\n\\n  if (signal === undefined) {\\n    throw new Error('Unknown signal: ' + sig);\\n  }\\n\\n  if (this._handle) {\\n    var err = this._handle.kill(signal);\\n    if (err === 0) {\\n      /* Success. */\\n      this.killed = true;\\n      return true;\\n    }\\n    if (err === uv.UV_ESRCH) {\\n      /* Already dead. */\\n    } else if (err === uv.UV_EINVAL || err === uv.UV_ENOSYS) {\\n      /* The underlying platform doesn't support this signal. */\\n      throw errnoException(err, 'kill');\\n    } else {\\n      /* Other error, almost certainly EPERM. */\\n      this.emit('error', errnoException(err, 'kill'));\\n    }\\n  }\\n\\n  /* Kill didn't succeed. */\\n  return false;\\n};\\n\\n\\nChildProcess.prototype.ref = function() {\\n  if (this._handle) this._handle.ref();\\n};\\n\\n\\nChildProcess.prototype.unref = function() {\\n  if (this._handle) this._handle.unref();\\n};\\n\\n// COMO nodejs code modification\\n// modified code here from es6 to es5\\nutil.inherits(ClassExtends, EventEmitter);\\nfunction ClassExtends (channel){\\n  EventEmitter.call(this);\\n  this.channel = channel;\\n  this.refs = 0;\\n\\n  this.ref = function() {\\n    if (++this.refs === 1) {\\n      this.channel.ref();\\n    }\\n  };\\n\\n  this.unref = function() {\\n    if (--this.refs === 0) {\\n      this.channel.unref();\\n      this.emit('unref');\\n    }\\n  };\\n}\\n\\nfunction setupChannel(target, channel) {\\n  target._channel = channel;\\n  target._handleQueue = null;\\n  var control = new ClassExtends(channel);\\n  // Object.setPrototypeOf(control, EventEmitter);\\n  // console.log(control);\\n  // var control = new class extends EventEmitter {\\n  //   constructor() {\\n  //     super();\\n  //     this.channel = channel;\\n  //     this.refs = 0;\\n  //   }\\n  //   ref() {\\n  //     if (++this.refs === 1) {\\n  //       this.channel.ref();\\n  //     }\\n  //   }\\n  //   unref() {\\n  //     if (--this.refs === 0) {\\n  //       this.channel.unref();\\n  //       this.emit('unref');\\n  //     }\\n  //   }\\n  // };\\n\\n  var decoder = new StringDecoder('utf8');\\n  var jsonBuffer = '';\\n  channel.buffering = false;\\n  channel.onread = function(nread, pool, recvHandle) {\\n    // TODO(bnoordhuis) Check that nread > 0.\\n    if (pool) {\\n      jsonBuffer += decoder.write(pool);\\n\\n      var i, start = 0;\\n\\n      //Linebreak is used as a message end sign\\n      while ((i = jsonBuffer.indexOf('\\\\n', start)) >= 0) {\\n        var json = jsonBuffer.slice(start, i);\\n        var message = JSON.parse(json);\\n\\n        // There will be at most one NODE_HANDLE message in every chunk we\\n        // read because SCM_RIGHTS messages don't get coalesced. Make sure\\n        // that we deliver the handle with the right message however.\\n        if (message && message.cmd === 'NODE_HANDLE')\\n          handleMessage(target, message, recvHandle);\\n        else\\n          handleMessage(target, message, undefined);\\n\\n        start = i + 1;\\n      }\\n      jsonBuffer = jsonBuffer.slice(start);\\n      this.buffering = jsonBuffer.length !== 0;\\n\\n    } else {\\n      this.buffering = false;\\n      target.disconnect();\\n      channel.onread = nop;\\n      channel.close();\\n      target._channel = null;\\n      maybeClose(target);\\n    }\\n  };\\n\\n  // object where socket lists will live\\n  channel.sockets = { got: {}, send: {} };\\n\\n  // handlers will go through this\\n  target.on('internalMessage', function(message, handle) {\\n    // Once acknowledged - continue sending handles.\\n    if (message.cmd === 'NODE_HANDLE_ACK') {\\n      assert(Array.isArray(target._handleQueue));\\n      var queue = target._handleQueue;\\n      target._handleQueue = null;\\n\\n      queue.forEach(function(args) {\\n        target._send(args.message, args.handle, false, args.callback);\\n      });\\n\\n      // Process a pending disconnect (if any).\\n      if (!target.connected && target._channel && !target._handleQueue)\\n        target._disconnect();\\n\\n      return;\\n    }\\n\\n    if (message.cmd !== 'NODE_HANDLE') return;\\n\\n    // Acknowledge handle receival. Don't emit error events (for example if\\n    // the other side has disconnected) because this call to send() is not\\n    // initiated by the user and it shouldn't be fatal to be unable to ACK\\n    // a message.\\n    target._send({ cmd: 'NODE_HANDLE_ACK' }, null, true);\\n\\n    var obj = handleConversion[message.type];\\n\\n    // Update simultaneous accepts on Windows\\n    if (process.platform === 'win32') {\\n      handle._simultaneousAccepts = false;\\n      net._setSimultaneousAccepts(handle);\\n    }\\n\\n    // Convert handle object\\n    obj.got.call(this, message, handle, function(handle) {\\n      handleMessage(target, message.msg, handle);\\n    });\\n  });\\n\\n  target.send = function(message, handle, callback) {\\n    if (typeof handle === 'function') {\\n      callback = handle;\\n      handle = undefined;\\n    }\\n    if (this.connected) {\\n      return this._send(message, handle, false, callback);\\n    }\\n    var ex = new Error('channel closed');\\n    if (typeof callback === 'function') {\\n      process.nextTick(callback, ex);\\n    } else {\\n      this.emit('error', ex);  // FIXME(bnoordhuis) Defer to next tick.\\n    }\\n    return false;\\n  };\\n\\n  target._send = function(message, handle, swallowErrors, callback) {\\n    assert(this.connected || this._channel);\\n\\n    if (message === undefined)\\n      throw new TypeError('\\\"message\\\" argument cannot be undefined');\\n\\n    // package messages with a handle object\\n    if (handle) {\\n      // this message will be handled by an internalMessage event handler\\n      message = {\\n        cmd: 'NODE_HANDLE',\\n        type: null,\\n        msg: message\\n      };\\n\\n      if (handle instanceof net.Socket) {\\n        message.type = 'net.Socket';\\n      } else if (handle instanceof net.Server) {\\n        message.type = 'net.Server';\\n      } else if (handle instanceof TCP || handle instanceof Pipe) {\\n        message.type = 'net.Native';\\n      } else if (handle instanceof dgram.Socket) {\\n        message.type = 'dgram.Socket';\\n      } else if (handle instanceof UDP) {\\n        message.type = 'dgram.Native';\\n      } else {\\n        throw new TypeError('This handle type can\\\\'t be sent');\\n      }\\n\\n      // Queue-up message and handle if we haven't received ACK yet.\\n      if (this._handleQueue) {\\n        this._handleQueue.push({\\n          callback: callback,\\n          handle: handle,\\n          message: message.msg,\\n        });\\n        return this._handleQueue.length === 1;\\n      }\\n\\n      var obj = handleConversion[message.type];\\n\\n      // convert TCP object to native handle object\\n      handle =\\n          handleConversion[message.type].send.call(target, message, handle);\\n\\n      // If handle was sent twice, or it is impossible to get native handle\\n      // out of it - just send a text without the handle.\\n      if (!handle)\\n        message = message.msg;\\n\\n      // Update simultaneous accepts on Windows\\n      if (obj.simultaneousAccepts) {\\n        net._setSimultaneousAccepts(handle);\\n      }\\n    } else if (this._handleQueue &&\\n               !(message && message.cmd === 'NODE_HANDLE_ACK')) {\\n      // Queue request anyway to avoid out-of-order messages.\\n      this._handleQueue.push({\\n        callback: callback,\\n        handle: null,\\n        message: message,\\n      });\\n      return this._handleQueue.length === 1;\\n    }\\n\\n    var req = new WriteWrap();\\n    req.async = false;\\n\\n    var string = JSON.stringify(message) + '\\\\n';\\n    var err = channel.writeUtf8String(req, string, handle);\\n\\n    if (err === 0) {\\n      if (handle && !this._handleQueue)\\n        this._handleQueue = [];\\n      req.oncomplete = function() {\\n        if (this.async === true)\\n          control.unref();\\n        if (obj && obj.postSend)\\n          obj.postSend(handle);\\n        if (typeof callback === 'function')\\n          callback(null);\\n      };\\n      if (req.async === true) {\\n        control.ref();\\n      } else {\\n        process.nextTick(function() { req.oncomplete(); });\\n      }\\n    } else if (!swallowErrors) {\\n      var ex = errnoException(err, 'write');\\n      if (typeof callback === 'function') {\\n        process.nextTick(callback, ex);\\n      } else {\\n        this.emit('error', ex);  // FIXME(bnoordhuis) Defer to next tick.\\n      }\\n    }\\n\\n    /* If the master is > 2 read() calls behind, please stop sending. */\\n    return channel.writeQueueSize < (65536 * 2);\\n  };\\n\\n  // connected will be set to false immediately when a disconnect() is\\n  // requested, even though the channel might still be alive internally to\\n  // process queued messages. The three states are distinguished as follows:\\n  // - disconnect() never requested: _channel is not null and connected\\n  //   is true\\n  // - disconnect() requested, messages in the queue: _channel is not null\\n  //   and connected is false\\n  // - disconnect() requested, channel actually disconnected: _channel is\\n  //   null and connected is false\\n  target.connected = true;\\n\\n  target.disconnect = function() {\\n    if (!this.connected) {\\n      this.emit('error', new Error('IPC channel is already disconnected'));\\n      return;\\n    }\\n\\n    // Do not allow any new messages to be written.\\n    this.connected = false;\\n\\n    // If there are no queued messages, disconnect immediately. Otherwise,\\n    // postpone the disconnect so that it happens internally after the\\n    // queue is flushed.\\n    if (!this._handleQueue)\\n      this._disconnect();\\n  };\\n\\n  target._disconnect = function() {\\n    assert(this._channel);\\n\\n    // This marks the fact that the channel is actually disconnected.\\n    this._channel = null;\\n\\n    var fired = false;\\n    function finish() {\\n      if (fired) return;\\n      fired = true;\\n\\n      channel.close();\\n      target.emit('disconnect');\\n    }\\n\\n    // If a message is being read, then wait for it to complete.\\n    if (channel.buffering) {\\n      this.once('message', finish);\\n      this.once('internalMessage', finish);\\n\\n      return;\\n    }\\n\\n    process.nextTick(finish);\\n  };\\n\\n  channel.readStart();\\n  return control;\\n}\\n\\n\\nvar INTERNAL_PREFIX = 'NODE_';\\nfunction handleMessage(target, message, handle) {\\n  var eventName = 'message';\\n  if (message !== null &&\\n      typeof message === 'object' &&\\n      typeof message.cmd === 'string' &&\\n      message.cmd.length > INTERNAL_PREFIX.length &&\\n      message.cmd.slice(0, INTERNAL_PREFIX.length) === INTERNAL_PREFIX) {\\n    eventName = 'internalMessage';\\n  }\\n  target.emit(eventName, message, handle);\\n}\\n\\nfunction nop() { }\\n\\nfunction _validateStdio(stdio, sync) {\\n  var ipc,\\n      ipcFd;\\n\\n  // Replace shortcut with an array\\n  if (typeof stdio === 'string') {\\n    switch (stdio) {\\n      case 'ignore': stdio = ['ignore', 'ignore', 'ignore']; break;\\n      case 'pipe': stdio = ['pipe', 'pipe', 'pipe']; break;\\n      case 'inherit': stdio = [0, 1, 2]; break;\\n      default: throw new TypeError('Incorrect value of stdio option: ' + stdio);\\n    }\\n  } else if (!Array.isArray(stdio)) {\\n    throw new TypeError('Incorrect value of stdio option: ' +\\n        util.inspect(stdio));\\n  }\\n\\n  // At least 3 stdio will be created\\n  // Don't concat() a new Array() because it would be sparse, and\\n  // stdio.reduce() would skip the sparse elements of stdio.\\n  // See http://stackoverflow.com/a/5501711/3561\\n  while (stdio.length < 3) stdio.push(undefined);\\n\\n  // Translate stdio into C++-readable form\\n  // (i.e. PipeWraps or fds)\\n  stdio = stdio.reduce(function(acc, stdio, i) {\\n    function cleanup() {\\n      acc.filter(function(stdio) {\\n        return stdio.type === 'pipe' || stdio.type === 'ipc';\\n      }).forEach(function(stdio) {\\n        if (stdio.handle)\\n          stdio.handle.close();\\n      });\\n    }\\n\\n    // Defaults\\n    if (stdio === null || stdio === undefined) {\\n      stdio = i < 3 ? 'pipe' : 'ignore';\\n    }\\n\\n    if (stdio === null || stdio === 'ignore') {\\n      acc.push({type: 'ignore'});\\n    } else if (stdio === 'pipe' || typeof stdio === 'number' && stdio < 0) {\\n      var a = {\\n        type: 'pipe',\\n        readable: i === 0,\\n        writable: i !== 0\\n      };\\n\\n      if (!sync)\\n        a.handle = new Pipe();\\n\\n      acc.push(a);\\n    } else if (stdio === 'ipc') {\\n      if (sync || ipc !== undefined) {\\n        // Cleanup previously created pipes\\n        cleanup();\\n        if (!sync)\\n          throw new Error('Child process can have only one IPC pipe');\\n        else\\n          throw new Error('You cannot use IPC with synchronous forks');\\n      }\\n\\n      ipc = new Pipe(true);\\n      ipcFd = i;\\n\\n      acc.push({\\n        type: 'pipe',\\n        handle: ipc,\\n        ipc: true\\n      });\\n    } else if (stdio === 'inherit') {\\n      acc.push({\\n        type: 'inherit',\\n        fd: i\\n      });\\n    } else if (typeof stdio === 'number' || typeof stdio.fd === 'number') {\\n      acc.push({\\n        type: 'fd',\\n        fd: typeof stdio === 'number' ? stdio : stdio.fd\\n      });\\n    } else if (getHandleWrapType(stdio) || getHandleWrapType(stdio.handle) ||\\n               getHandleWrapType(stdio._handle)) {\\n      var handle = getHandleWrapType(stdio) ?\\n          stdio :\\n          getHandleWrapType(stdio.handle) ? stdio.handle : stdio._handle;\\n\\n      acc.push({\\n        type: 'wrap',\\n        wrapType: getHandleWrapType(handle),\\n        handle: handle\\n      });\\n    } else if (stdio instanceof Buffer || typeof stdio === 'string') {\\n      if (!sync) {\\n        cleanup();\\n        throw new TypeError('Asynchronous forks do not support Buffer input: ' +\\n            util.inspect(stdio));\\n      }\\n    } else {\\n      // Cleanup\\n      cleanup();\\n      throw new TypeError('Incorrect value for stdio stream: ' +\\n          util.inspect(stdio));\\n    }\\n\\n    return acc;\\n  }, []);\\n\\n  return {stdio: stdio, ipc: ipc, ipcFd: ipcFd};\\n}\\n\\n\\nfunction getSocketList(type, slave, key) {\\n  var sockets = slave._channel.sockets[type];\\n  var socketList = sockets[key];\\n  if (!socketList) {\\n    var Construct = type === 'send' ? SocketListSend : SocketListReceive;\\n    socketList = sockets[key] = new Construct(slave, key);\\n  }\\n  return socketList;\\n}\\n\\n\\nfunction maybeClose(subprocess) {\\n  subprocess._closesGot++;\\n\\n  if (subprocess._closesGot == subprocess._closesNeeded) {\\n    subprocess.emit('close', subprocess.exitCode, subprocess.signalCode);\\n  }\\n}\\n\",\"internal/socket_list\":\"'use strict';\\n\\nexports.SocketListSend = SocketListSend;\\nexports.SocketListReceive = SocketListReceive;\\n\\nvar EventEmitter = require('events');\\nvar util = require('util');\\n\\n// This object keep track of the socket there are sended\\nfunction SocketListSend(slave, key) {\\n  EventEmitter.call(this);\\n\\n  this.key = key;\\n  this.slave = slave;\\n}\\nutil.inherits(SocketListSend, EventEmitter);\\n\\nSocketListSend.prototype._request = function(msg, cmd, callback) {\\n  var self = this;\\n\\n  if (!this.slave.connected) return onclose();\\n  this.slave.send(msg);\\n\\n  function onclose() {\\n    self.slave.removeListener('internalMessage', onreply);\\n    callback(new Error('Slave closed before reply'));\\n  }\\n\\n  function onreply(msg) {\\n    if (!(msg.cmd === cmd && msg.key === self.key)) return;\\n    self.slave.removeListener('disconnect', onclose);\\n    self.slave.removeListener('internalMessage', onreply);\\n\\n    callback(null, msg);\\n  }\\n\\n  this.slave.once('disconnect', onclose);\\n  this.slave.on('internalMessage', onreply);\\n};\\n\\nSocketListSend.prototype.close = function close(callback) {\\n  this._request({\\n    cmd: 'NODE_SOCKET_NOTIFY_CLOSE',\\n    key: this.key\\n  }, 'NODE_SOCKET_ALL_CLOSED', callback);\\n};\\n\\nSocketListSend.prototype.getConnections = function getConnections(callback) {\\n  this._request({\\n    cmd: 'NODE_SOCKET_GET_COUNT',\\n    key: this.key\\n  }, 'NODE_SOCKET_COUNT', function(err, msg) {\\n    if (err) return callback(err);\\n    callback(null, msg.count);\\n  });\\n};\\n\\n// This object keep track of the socket there are received\\nfunction SocketListReceive(slave, key) {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n\\n  this.connections = 0;\\n  this.key = key;\\n  this.slave = slave;\\n\\n  function onempty() {\\n    if (!self.slave.connected) return;\\n\\n    self.slave.send({\\n      cmd: 'NODE_SOCKET_ALL_CLOSED',\\n      key: self.key\\n    });\\n  }\\n\\n  this.slave.on('internalMessage', function(msg) {\\n    if (msg.key !== self.key) return;\\n\\n    if (msg.cmd === 'NODE_SOCKET_NOTIFY_CLOSE') {\\n      // Already empty\\n      if (self.connections === 0) return onempty();\\n\\n      // Wait for sockets to get closed\\n      self.once('empty', onempty);\\n    } else if (msg.cmd === 'NODE_SOCKET_GET_COUNT') {\\n      if (!self.slave.connected) return;\\n      self.slave.send({\\n        cmd: 'NODE_SOCKET_COUNT',\\n        key: self.key,\\n        count: self.connections\\n      });\\n    }\\n  });\\n}\\nutil.inherits(SocketListReceive, EventEmitter);\\n\\nSocketListReceive.prototype.add = function(obj) {\\n  var self = this;\\n\\n  this.connections++;\\n\\n  // Notify previous owner of socket about its state change\\n  obj.socket.once('close', function() {\\n    self.connections--;\\n\\n    if (self.connections === 0) self.emit('empty');\\n  });\\n};\\n\",\"child_process\":\"'use strict';\\n\\nvar util = require('util');\\nvar internalUtil = require('internal/util');\\nvar debug = util.debuglog('child_process');\\nvar constants = require('constants');\\n\\nvar uv = process.binding('uv');\\nvar spawn_sync = require('spawn_sync');\\nvar Buffer = require('buffer').Buffer;\\nvar Pipe = process.binding('pipe_wrap').Pipe;\\nvar child_process = require('internal/child_process');\\n\\nvar errnoException = util._errnoException;\\nvar _validateStdio = child_process._validateStdio;\\nvar setupChannel = child_process.setupChannel;\\nvar ChildProcess = exports.ChildProcess = child_process.ChildProcess;\\n\\nexports.fork = function(modulePath /*, args, options*/) {\\n\\n  // Get options and args arguments.\\n  var options, args, execArgv;\\n  if (Array.isArray(arguments[1])) {\\n    args = arguments[1];\\n    options = util._extend({}, arguments[2]);\\n  } else if (arguments[1] && typeof arguments[1] !== 'object') {\\n    throw new TypeError('Incorrect value of args option');\\n  } else {\\n    args = [];\\n    options = util._extend({}, arguments[1]);\\n  }\\n\\n  // Prepare arguments for fork:\\n  execArgv = options.execArgv || process.execArgv;\\n\\n  if (execArgv === process.execArgv && process._eval != null) {\\n    var index = execArgv.lastIndexOf(process._eval);\\n    if (index > 0) {\\n      // Remove the -e switch to avoid fork bombing ourselves.\\n      execArgv = execArgv.slice();\\n      execArgv.splice(index - 1, 2);\\n    }\\n  }\\n\\n  args = execArgv.concat([modulePath], args);\\n\\n  // Leave stdin open for the IPC channel. stdout and stderr should be the\\n  // same as the parent's if silent isn't set.\\n  options.stdio = options.silent ? ['pipe', 'pipe', 'pipe', 'ipc'] :\\n      [0, 1, 2, 'ipc'];\\n\\n  options.execPath = options.execPath || process.execPath;\\n\\n  return spawn(options.execPath, args, options);\\n};\\n\\n\\nexports._forkChild = function(fd) {\\n  // set process.send()\\n  var p = new Pipe(true);\\n  p.open(fd);\\n  p.unref();\\n  var control = setupChannel(process, p);\\n  process.on('newListener', function(name) {\\n    if (name === 'message' || name === 'disconnect') control.ref();\\n  });\\n  process.on('removeListener', function(name) {\\n    if (name === 'message' || name === 'disconnect') control.unref();\\n  });\\n};\\n\\n\\nfunction normalizeExecArgs(command /*, options, callback*/) {\\n  var file, args, options, callback;\\n\\n  if (typeof arguments[1] === 'function') {\\n    options = undefined;\\n    callback = arguments[1];\\n  } else {\\n    options = arguments[1];\\n    callback = arguments[2];\\n  }\\n\\n  if (process.platform === 'win32') {\\n    file = process.env.comspec || 'cmd.exe';\\n    args = ['/s', '/c', '\\\"' + command + '\\\"'];\\n    // Make a shallow copy before patching so we don't clobber the user's\\n    // options object.\\n    options = util._extend({}, options);\\n    options.windowsVerbatimArguments = true;\\n  } else {\\n    file = '/bin/sh';\\n    args = ['-c', command];\\n  }\\n\\n  if (options && options.shell)\\n    file = options.shell;\\n\\n  return {\\n    cmd: command,\\n    file: file,\\n    args: args,\\n    options: options,\\n    callback: callback\\n  };\\n}\\n\\n\\nexports.exec = function(command /*, options, callback*/) {\\n  var opts = normalizeExecArgs.apply(null, arguments);\\n  return exports.execFile(opts.file,\\n                          opts.args,\\n                          opts.options,\\n                          opts.callback);\\n};\\n\\n\\nexports.execFile = function(file /*, args, options, callback*/) {\\n  var args = [], callback;\\n  var options = {\\n    encoding: 'utf8',\\n    timeout: 0,\\n    maxBuffer: 200 * 1024,\\n    killSignal: 'SIGTERM',\\n    cwd: null,\\n    env: null\\n  };\\n\\n  // Parse the optional positional parameters.\\n  var pos = 1;\\n  if (pos < arguments.length && Array.isArray(arguments[pos])) {\\n    args = arguments[pos++];\\n  } else if (pos < arguments.length && arguments[pos] == null) {\\n    pos++;\\n  }\\n\\n  if (pos < arguments.length && typeof arguments[pos] === 'object') {\\n    options = util._extend(options, arguments[pos++]);\\n  } else if (pos < arguments.length && arguments[pos] == null) {\\n    pos++;\\n  }\\n\\n  if (pos < arguments.length && typeof arguments[pos] === 'function') {\\n    callback = arguments[pos++];\\n  }\\n\\n  if (pos === 1 && arguments.length > 1) {\\n    throw new TypeError('Incorrect value of args option');\\n  }\\n\\n  var child = spawn(file, args, {\\n    cwd: options.cwd,\\n    env: options.env,\\n    gid: options.gid,\\n    uid: options.uid,\\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments\\n  });\\n\\n  var encoding;\\n  var _stdout;\\n  var _stderr;\\n  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {\\n    encoding = options.encoding;\\n    _stdout = '';\\n    _stderr = '';\\n  } else {\\n    _stdout = [];\\n    _stderr = [];\\n    encoding = null;\\n  }\\n  var stdoutLen = 0;\\n  var stderrLen = 0;\\n  var killed = false;\\n  var exited = false;\\n  var timeoutId;\\n\\n  var ex = null;\\n\\n  function exithandler(code, signal) {\\n    if (exited) return;\\n    exited = true;\\n\\n    if (timeoutId) {\\n      clearTimeout(timeoutId);\\n      timeoutId = null;\\n    }\\n\\n    if (!callback) return;\\n\\n    // merge chunks\\n    var stdout;\\n    var stderr;\\n    if (!encoding) {\\n      stdout = Buffer.concat(_stdout);\\n      stderr = Buffer.concat(_stderr);\\n    } else {\\n      stdout = _stdout;\\n      stderr = _stderr;\\n    }\\n\\n    if (ex) {\\n      // Will be handled later\\n    } else if (code === 0 && signal === null) {\\n      callback(null, stdout, stderr);\\n      return;\\n    }\\n\\n    var cmd = file;\\n    if (args.length !== 0)\\n      cmd += ' ' + args.join(' ');\\n\\n    if (!ex) {\\n      ex = new Error('Command failed: ' + cmd + '\\\\n' + stderr);\\n      ex.killed = child.killed || killed;\\n      ex.code = code < 0 ? uv.errname(code) : code;\\n      ex.signal = signal;\\n    }\\n\\n    ex.cmd = cmd;\\n    callback(ex, stdout, stderr);\\n  }\\n\\n  function errorhandler(e) {\\n    ex = e;\\n\\n    if (child.stdout)\\n      child.stdout.destroy();\\n\\n    if (child.stderr)\\n      child.stderr.destroy();\\n\\n    exithandler();\\n  }\\n\\n  function kill() {\\n    if (child.stdout)\\n      child.stdout.destroy();\\n\\n    if (child.stderr)\\n      child.stderr.destroy();\\n\\n    killed = true;\\n    try {\\n      child.kill(options.killSignal);\\n    } catch (e) {\\n      ex = e;\\n      exithandler();\\n    }\\n  }\\n\\n  if (options.timeout > 0) {\\n    timeoutId = setTimeout(function() {\\n      kill();\\n      timeoutId = null;\\n    }, options.timeout);\\n  }\\n\\n  if (child.stdout) {\\n    if (encoding)\\n      child.stdout.setEncoding(encoding);\\n\\n    child.stdout.addListener('data', function(chunk) {\\n      stdoutLen += chunk.length;\\n\\n      if (stdoutLen > options.maxBuffer) {\\n        ex = new Error('stdout maxBuffer exceeded');\\n        kill();\\n      } else {\\n        if (!encoding)\\n          _stdout.push(chunk);\\n        else\\n          _stdout += chunk;\\n      }\\n    });\\n  }\\n\\n  if (child.stderr) {\\n    if (encoding)\\n      child.stderr.setEncoding(encoding);\\n\\n    child.stderr.addListener('data', function(chunk) {\\n      stderrLen += chunk.length;\\n\\n      if (stderrLen > options.maxBuffer) {\\n        ex = new Error('stderr maxBuffer exceeded');\\n        kill();\\n      } else {\\n        if (!encoding)\\n          _stderr.push(chunk);\\n        else\\n          _stderr += chunk;\\n      }\\n    });\\n  }\\n\\n  child.addListener('close', exithandler);\\n  child.addListener('error', errorhandler);\\n\\n  return child;\\n};\\n\\nvar _deprecatedCustomFds = internalUtil.deprecate(function(options) {\\n  options.stdio = options.customFds.map(function(fd) {\\n    return fd === -1 ? 'pipe' : fd;\\n  });\\n}, 'child_process: options.customFds option is deprecated. ' +\\n   'Use options.stdio instead.');\\n\\nfunction _convertCustomFds(options) {\\n  if (options && options.customFds && !options.stdio) {\\n    _deprecatedCustomFds(options);\\n  }\\n}\\n\\nfunction normalizeSpawnArguments(file /*, args, options*/) {\\n  var args, options;\\n\\n  if (Array.isArray(arguments[1])) {\\n    args = arguments[1].slice(0);\\n    options = arguments[2];\\n  } else if (arguments[1] !== undefined &&\\n             (arguments[1] === null || typeof arguments[1] !== 'object')) {\\n    throw new TypeError('Incorrect value of args option');\\n  } else {\\n    args = [];\\n    options = arguments[1];\\n  }\\n\\n  if (options === undefined)\\n    options = {};\\n  else if (options === null || typeof options !== 'object')\\n    throw new TypeError('\\\"options\\\" argument must be an object');\\n\\n  options = util._extend({}, options);\\n  args.unshift(file);\\n\\n  var env = options.env || process.env;\\n  var envPairs = [];\\n\\n  for (var key in env) {\\n    envPairs.push(key + '=' + env[key]);\\n  }\\n\\n  _convertCustomFds(options);\\n\\n  return {\\n    file: file,\\n    args: args,\\n    options: options,\\n    envPairs: envPairs\\n  };\\n}\\n\\n\\nvar spawn = exports.spawn = function(/*file, args, options*/) {\\n  var opts = normalizeSpawnArguments.apply(null, arguments);\\n  var options = opts.options;\\n  var child = new ChildProcess();\\n\\n  debug('spawn', opts.args, options);\\n\\n  child.spawn({\\n    file: opts.file,\\n    args: opts.args,\\n    cwd: options.cwd,\\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments,\\n    detached: !!options.detached,\\n    envPairs: opts.envPairs,\\n    stdio: options.stdio,\\n    uid: options.uid,\\n    gid: options.gid\\n  });\\n\\n  return child;\\n};\\n\\n\\nfunction lookupSignal(signal) {\\n  if (typeof signal === 'number')\\n    return signal;\\n\\n  if (!(signal in constants))\\n    throw new Error('Unknown signal: ' + signal);\\n\\n  return constants[signal];\\n}\\n\\n\\n//node to como modification\\nfunction spawnSync(/*file, args, options*/) {\\n  var opts = normalizeSpawnArguments.apply(null, arguments);\\n\\n  var options = opts.options;\\n\\n  // var i;\\n\\n  // debug('spawnSync', opts.args, options);\\n\\n  // options.file = opts.file;\\n  // options.args = opts.args;\\n  // options.envPairs = opts.envPairs;\\n\\n  // if (options.killSignal)\\n  //   options.killSignal = lookupSignal(options.killSignal);\\n\\n  // options.stdio = _validateStdio(options.stdio || 'pipe', true).stdio;\\n\\n  // if (options.input) {\\n  //   var stdin = options.stdio[0] = util._extend({}, options.stdio[0]);\\n  //   stdin.input = options.input;\\n  // }\\n\\n  // // We may want to pass data in on any given fd, ensure it is a valid buffer\\n  // for (i = 0; i < options.stdio.length; i++) {\\n  //   var input = options.stdio[i] && options.stdio[i].input;\\n  //   if (input != null) {\\n  //     var pipe = options.stdio[i] = util._extend({}, options.stdio[i]);\\n  //     if (Buffer.isBuffer(input))\\n  //       pipe.input = input;\\n  //     else if (typeof input === 'string')\\n  //       pipe.input = new Buffer(input, options.encoding);\\n  //     else\\n  //       throw new TypeError(util.format(\\n  //           'stdio[%d] should be Buffer or string not %s',\\n  //           i,\\n  //           typeof input));\\n  //   }\\n  // }\\n\\n\\n  // var result = spawn_sync.spawn(options);\\n\\n  var result = spawn_sync.spawn.apply(null, arguments);\\n  if (result.output && options.encoding) {\\n    for (i = 0; i < result.output.length; i++) {\\n      if (!result.output[i])\\n        continue;\\n      result.output[i] = result.output[i].toString(options.encoding);\\n    }\\n  }\\n\\n  result.stdout = result.output && result.output[1];\\n  result.stderr = result.output && result.output[2];\\n\\n  // if (result.error) {\\n  //   result.error = errnoException(result.error, 'spawnSync ' + opts.file);\\n  //   result.error.path = opts.file;\\n  //   result.error.spawnargs = opts.args.slice(1);\\n  // }\\n\\n  util._extend(result, opts);\\n\\n  return result;\\n}\\nexports.spawnSync = spawnSync;\\n\\n\\nfunction checkExecSyncError(ret) {\\n  if (ret.error || ret.status !== 0) {\\n    var err = ret.error;\\n    ret.error = null;\\n\\n    if (!err) {\\n      var msg = 'Command failed: ' +\\n                (ret.cmd ? ret.cmd : ret.args.join(' ')) +\\n                (ret.stderr ? '\\\\n' + ret.stderr.toString() : '');\\n      err = new Error(msg);\\n    }\\n\\n    util._extend(err, ret);\\n    return err;\\n  }\\n\\n  return false;\\n}\\n\\n\\nfunction execFileSync(/*command, args, options*/) {\\n  var opts = normalizeSpawnArguments.apply(null, arguments);\\n  var inheritStderr = !opts.options.stdio;\\n\\n  var ret = spawnSync(opts.file, opts.args.slice(1), opts.options);\\n\\n  if (inheritStderr)\\n    process.stderr.write(ret.stderr);\\n\\n  var err = checkExecSyncError(ret);\\n\\n  if (err)\\n    throw err;\\n  else\\n    return ret.stdout;\\n}\\nexports.execFileSync = execFileSync;\\n\\n\\nfunction execSync(/*command, options*/) {\\n  var opts = normalizeExecArgs.apply(null, arguments);\\n  var inheritStderr = opts.options ? !opts.options.stdio : true;\\n\\n  var ret = spawnSync(opts.file, opts.args, opts.options);\\n  ret.cmd = opts.cmd;\\n\\n  if (inheritStderr)\\n    process.stderr.write(ret.stderr);\\n\\n  var err = checkExecSyncError(ret);\\n\\n  if (err)\\n    throw err;\\n  else\\n    return ret.stdout;\\n}\\nexports.execSync = execSync;\\n\",\"stream\":\"'use strict';\\n\\nmodule.exports = Stream;\\n\\nvar EE = require('events');\\nvar util = require('util');\\n\\nutil.inherits(Stream, EE);\\nStream.Readable = require('_stream_readable');\\nStream.Writable = require('_stream_writable');\\nStream.Duplex = require('_stream_duplex');\\nStream.Transform = require('_stream_transform');\\nStream.PassThrough = require('_stream_passthrough');\\n\\n// Backwards-compat with node 0.4.x\\nStream.Stream = Stream;\\n\\n\\n// old-style streams.  Note that the pipe method (the only relevant\\n// part of this class) is overridden in the Readable class.\\n\\nfunction Stream() {\\n  EE.call(this);\\n}\\n\\nStream.prototype.pipe = function(dest, options) {\\n  var source = this;\\n\\n  function ondata(chunk) {\\n    if (dest.writable) {\\n      if (false === dest.write(chunk) && source.pause) {\\n        source.pause();\\n      }\\n    }\\n  }\\n\\n  source.on('data', ondata);\\n\\n  function ondrain() {\\n    if (source.readable && source.resume) {\\n      source.resume();\\n    }\\n  }\\n\\n  dest.on('drain', ondrain);\\n\\n  // If the 'end' option is not supplied, dest.end() will be called when\\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\\n  if (!dest._isStdio && (!options || options.end !== false)) {\\n    source.on('end', onend);\\n    source.on('close', onclose);\\n  }\\n\\n  var didOnEnd = false;\\n  function onend() {\\n    if (didOnEnd) return;\\n    didOnEnd = true;\\n\\n    dest.end();\\n  }\\n\\n\\n  function onclose() {\\n    if (didOnEnd) return;\\n    didOnEnd = true;\\n\\n    if (typeof dest.destroy === 'function') dest.destroy();\\n  }\\n\\n  // don't leave dangling pipes when there are errors.\\n  function onerror(er) {\\n    cleanup();\\n    if (EE.listenerCount(this, 'error') === 0) {\\n      throw er; // Unhandled stream error in pipe.\\n    }\\n  }\\n\\n  source.on('error', onerror);\\n  dest.on('error', onerror);\\n\\n  // remove all the event listeners that were added.\\n  function cleanup() {\\n    source.removeListener('data', ondata);\\n    dest.removeListener('drain', ondrain);\\n\\n    source.removeListener('end', onend);\\n    source.removeListener('close', onclose);\\n\\n    source.removeListener('error', onerror);\\n    dest.removeListener('error', onerror);\\n\\n    source.removeListener('end', cleanup);\\n    source.removeListener('close', cleanup);\\n\\n    dest.removeListener('close', cleanup);\\n  }\\n\\n  source.on('end', cleanup);\\n  source.on('close', cleanup);\\n\\n  dest.on('close', cleanup);\\n\\n  dest.emit('pipe', source);\\n\\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\\n  return dest;\\n};\\n\",\"_stream_readable\":\"'use strict';\\n\\nmodule.exports = Readable;\\nReadable.ReadableState = ReadableState;\\n\\nvar EE = require('events');\\nvar Stream = require('stream');\\nvar Buffer = require('buffer').Buffer;\\nvar util = require('util');\\nvar debug = util.debuglog('stream');\\nvar StringDecoder;\\n\\nutil.inherits(Readable, Stream);\\n\\nfunction ReadableState(options, stream) {\\n  options = options || {};\\n\\n  // object stream flag. Used to make read(n) ignore n and to\\n  // make all the buffer merging and length checks go away\\n  this.objectMode = !!options.objectMode;\\n\\n  if (stream instanceof Stream.Duplex)\\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\\n\\n  // the point at which it stops calling _read() to fill the buffer\\n  // Note: 0 is a valid value, means \\\"don't call _read preemptively ever\\\"\\n  var hwm = options.highWaterMark;\\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\\n\\n  // cast to ints.\\n  this.highWaterMark = ~~this.highWaterMark;\\n\\n  this.buffer = [];\\n  this.length = 0;\\n  this.pipes = null;\\n  this.pipesCount = 0;\\n  this.flowing = null;\\n  this.ended = false;\\n  this.endEmitted = false;\\n  this.reading = false;\\n\\n  // a flag to be able to tell if the onwrite cb is called immediately,\\n  // or on a later tick.  We set this to true at first, because any\\n  // actions that shouldn't happen until \\\"later\\\" should generally also\\n  // not happen before the first write call.\\n  this.sync = true;\\n\\n  // whenever we return null, then we set a flag to say\\n  // that we're awaiting a 'readable' event emission.\\n  this.needReadable = false;\\n  this.emittedReadable = false;\\n  this.readableListening = false;\\n\\n  // Crypto is kind of old and crusty.  Historically, its default string\\n  // encoding is 'binary' so we have to make this configurable.\\n  // Everything else in the universe uses 'utf8', though.\\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\\n\\n  // when piping, we only care about 'readable' events that happen\\n  // after read()ing all the bytes and not getting any pushback.\\n  this.ranOut = false;\\n\\n  // the number of writers that are awaiting a drain event in .pipe()s\\n  this.awaitDrain = 0;\\n\\n  // if true, a maybeReadMore has been scheduled\\n  this.readingMore = false;\\n\\n  this.decoder = null;\\n  this.encoding = null;\\n  if (options.encoding) {\\n    if (!StringDecoder)\\n      StringDecoder = require('string_decoder').StringDecoder;\\n    this.decoder = new StringDecoder(options.encoding);\\n    this.encoding = options.encoding;\\n  }\\n}\\n\\nfunction Readable(options) {\\n  if (!(this instanceof Readable))\\n    return new Readable(options);\\n\\n  this._readableState = new ReadableState(options, this);\\n\\n  // legacy\\n  this.readable = true;\\n\\n  if (options && typeof options.read === 'function')\\n    this._read = options.read;\\n\\n  Stream.call(this);\\n}\\n\\n// Manually shove something into the read() buffer.\\n// This returns true if the highWaterMark has not been hit yet,\\n// similar to how Writable.write() returns true if you should\\n// write() some more.\\nReadable.prototype.push = function(chunk, encoding) {\\n  var state = this._readableState;\\n\\n  if (!state.objectMode && typeof chunk === 'string') {\\n    encoding = encoding || state.defaultEncoding;\\n    if (encoding !== state.encoding) {\\n      chunk = Buffer(chunk, encoding);\\n      encoding = '';\\n    }\\n  }\\n\\n  return readableAddChunk(this, state, chunk, encoding, false);\\n};\\n\\n// Unshift should *always* be something directly out of read()\\nReadable.prototype.unshift = function(chunk) {\\n  var state = this._readableState;\\n  return readableAddChunk(this, state, chunk, '', true);\\n};\\n\\nReadable.prototype.isPaused = function() {\\n  return this._readableState.flowing === false;\\n};\\n\\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\\n  var er = chunkInvalid(state, chunk);\\n  if (er) {\\n    stream.emit('error', er);\\n  } else if (chunk === null) {\\n    state.reading = false;\\n    onEofChunk(stream, state);\\n  } else if (state.objectMode || chunk && chunk.length > 0) {\\n    if (state.ended && !addToFront) {\\n      var e = new Error('stream.push() after EOF');\\n      stream.emit('error', e);\\n    } else if (state.endEmitted && addToFront) {\\n      var e = new Error('stream.unshift() after end event');\\n      stream.emit('error', e);\\n    } else {\\n      if (state.decoder && !addToFront && !encoding)\\n        chunk = state.decoder.write(chunk);\\n\\n      if (!addToFront)\\n        state.reading = false;\\n\\n      // if we want the data now, just emit it.\\n      if (state.flowing && state.length === 0 && !state.sync) {\\n        stream.emit('data', chunk);\\n        stream.read(0);\\n      } else {\\n        // update the buffer info.\\n        state.length += state.objectMode ? 1 : chunk.length;\\n        if (addToFront)\\n          state.buffer.unshift(chunk);\\n        else\\n          state.buffer.push(chunk);\\n\\n        if (state.needReadable)\\n          emitReadable(stream);\\n      }\\n\\n      maybeReadMore(stream, state);\\n    }\\n  } else if (!addToFront) {\\n    state.reading = false;\\n  }\\n\\n  return needMoreData(state);\\n}\\n\\n\\n// if it's past the high water mark, we can push in some more.\\n// Also, if we have no data yet, we can stand some\\n// more bytes.  This is to work around cases where hwm=0,\\n// such as the repl.  Also, if the push() triggered a\\n// readable event, and the user called read(largeNumber) such that\\n// needReadable was set, then we ought to push more, so that another\\n// 'readable' event will be triggered.\\nfunction needMoreData(state) {\\n  return !state.ended &&\\n         (state.needReadable ||\\n          state.length < state.highWaterMark ||\\n          state.length === 0);\\n}\\n\\n// backwards compatibility.\\nReadable.prototype.setEncoding = function(enc) {\\n  if (!StringDecoder)\\n    StringDecoder = require('string_decoder').StringDecoder;\\n  this._readableState.decoder = new StringDecoder(enc);\\n  this._readableState.encoding = enc;\\n  return this;\\n};\\n\\n// Don't raise the hwm > 8MB\\nvar MAX_HWM = 0x800000;\\nfunction computeNewHighWaterMark(n) {\\n  if (n >= MAX_HWM) {\\n    n = MAX_HWM;\\n  } else {\\n    // Get the next highest power of 2\\n    n--;\\n    n |= n >>> 1;\\n    n |= n >>> 2;\\n    n |= n >>> 4;\\n    n |= n >>> 8;\\n    n |= n >>> 16;\\n    n++;\\n  }\\n  return n;\\n}\\n\\nfunction howMuchToRead(n, state) {\\n  if (state.length === 0 && state.ended)\\n    return 0;\\n\\n  if (state.objectMode)\\n    return n === 0 ? 0 : 1;\\n\\n  if (n === null || isNaN(n)) {\\n    // only flow one buffer at a time\\n    if (state.flowing && state.buffer.length)\\n      return state.buffer[0].length;\\n    else\\n      return state.length;\\n  }\\n\\n  if (n <= 0)\\n    return 0;\\n\\n  // If we're asking for more than the target buffer level,\\n  // then raise the water mark.  Bump up to the next highest\\n  // power of 2, to prevent increasing it excessively in tiny\\n  // amounts.\\n  if (n > state.highWaterMark)\\n    state.highWaterMark = computeNewHighWaterMark(n);\\n\\n  // don't have that much.  return null, unless we've ended.\\n  if (n > state.length) {\\n    if (!state.ended) {\\n      state.needReadable = true;\\n      return 0;\\n    } else {\\n      return state.length;\\n    }\\n  }\\n\\n  return n;\\n}\\n\\n// you can override either this method, or the async _read(n) below.\\nReadable.prototype.read = function(n) {\\n  debug('read', n);\\n  var state = this._readableState;\\n  var nOrig = n;\\n\\n  if (typeof n !== 'number' || n > 0)\\n    state.emittedReadable = false;\\n\\n  // if we're doing read(0) to trigger a readable event, but we\\n  // already have a bunch of data in the buffer, then just trigger\\n  // the 'readable' event and move on.\\n  if (n === 0 &&\\n      state.needReadable &&\\n      (state.length >= state.highWaterMark || state.ended)) {\\n    debug('read: emitReadable', state.length, state.ended);\\n    if (state.length === 0 && state.ended)\\n      endReadable(this);\\n    else\\n      emitReadable(this);\\n    return null;\\n  }\\n\\n  n = howMuchToRead(n, state);\\n\\n  // if we've ended, and we're now clear, then finish it up.\\n  if (n === 0 && state.ended) {\\n    if (state.length === 0)\\n      endReadable(this);\\n    return null;\\n  }\\n\\n  // All the actual chunk generation logic needs to be\\n  // *below* the call to _read.  The reason is that in certain\\n  // synthetic stream cases, such as passthrough streams, _read\\n  // may be a completely synchronous operation which may change\\n  // the state of the read buffer, providing enough data when\\n  // before there was *not* enough.\\n  //\\n  // So, the steps are:\\n  // 1. Figure out what the state of things will be after we do\\n  // a read from the buffer.\\n  //\\n  // 2. If that resulting state will trigger a _read, then call _read.\\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\\n  // deeply ugly to write APIs this way, but that still doesn't mean\\n  // that the Readable class should behave improperly, as streams are\\n  // designed to be sync/async agnostic.\\n  // Take note if the _read call is sync or async (ie, if the read call\\n  // has returned yet), so that we know whether or not it's safe to emit\\n  // 'readable' etc.\\n  //\\n  // 3. Actually pull the requested chunks out of the buffer and return.\\n\\n  // if we need a readable event, then we need to do some reading.\\n  var doRead = state.needReadable;\\n  debug('need readable', doRead);\\n\\n  // if we currently have less than the highWaterMark, then also read some\\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\\n    doRead = true;\\n    debug('length less than watermark', doRead);\\n  }\\n\\n  // however, if we've ended, then there's no point, and if we're already\\n  // reading, then it's unnecessary.\\n  if (state.ended || state.reading) {\\n    doRead = false;\\n    debug('reading or ended', doRead);\\n  }\\n\\n  if (doRead) {\\n    debug('do read');\\n    state.reading = true;\\n    state.sync = true;\\n    // if the length is currently zero, then we *need* a readable event.\\n    if (state.length === 0)\\n      state.needReadable = true;\\n    // call internal read method\\n    this._read(state.highWaterMark);\\n    state.sync = false;\\n  }\\n\\n  // If _read pushed data synchronously, then `reading` will be false,\\n  // and we need to re-evaluate how much data we can return to the user.\\n  if (doRead && !state.reading)\\n    n = howMuchToRead(nOrig, state);\\n\\n  var ret;\\n  if (n > 0)\\n    ret = fromList(n, state);\\n  else\\n    ret = null;\\n\\n  if (ret === null) {\\n    state.needReadable = true;\\n    n = 0;\\n  }\\n\\n  state.length -= n;\\n\\n  // If we have nothing in the buffer, then we want to know\\n  // as soon as we *do* get something into the buffer.\\n  if (state.length === 0 && !state.ended)\\n    state.needReadable = true;\\n\\n  // If we tried to read() past the EOF, then emit end on the next tick.\\n  if (nOrig !== n && state.ended && state.length === 0)\\n    endReadable(this);\\n\\n  if (ret !== null)\\n    this.emit('data', ret);\\n\\n  return ret;\\n};\\n\\nfunction chunkInvalid(state, chunk) {\\n  var er = null;\\n  if (!(Buffer.isBuffer(chunk)) &&\\n      typeof chunk !== 'string' &&\\n      chunk !== null &&\\n      chunk !== undefined &&\\n      !state.objectMode) {\\n    er = new TypeError('Invalid non-string/buffer chunk');\\n  }\\n  return er;\\n}\\n\\n\\nfunction onEofChunk(stream, state) {\\n  if (state.ended) return;\\n  if (state.decoder) {\\n    var chunk = state.decoder.end();\\n    if (chunk && chunk.length) {\\n      state.buffer.push(chunk);\\n      state.length += state.objectMode ? 1 : chunk.length;\\n    }\\n  }\\n  state.ended = true;\\n\\n  // emit 'readable' now to make sure it gets picked up.\\n  emitReadable(stream);\\n}\\n\\n// Don't emit readable right away in sync mode, because this can trigger\\n// another read() call => stack overflow.  This way, it might trigger\\n// a nextTick recursion warning, but that's not so bad.\\nfunction emitReadable(stream) {\\n  var state = stream._readableState;\\n  state.needReadable = false;\\n  if (!state.emittedReadable) {\\n    debug('emitReadable', state.flowing);\\n    state.emittedReadable = true;\\n    if (state.sync)\\n      process.nextTick(emitReadable_, stream);\\n    else\\n      emitReadable_(stream);\\n  }\\n}\\n\\nfunction emitReadable_(stream) {\\n  debug('emit readable');\\n  stream.emit('readable');\\n  flow(stream);\\n}\\n\\n\\n// at this point, the user has presumably seen the 'readable' event,\\n// and called read() to consume some data.  that may have triggered\\n// in turn another _read(n) call, in which case reading = true if\\n// it's in progress.\\n// However, if we're not ended, or reading, and the length < hwm,\\n// then go ahead and try to read some more preemptively.\\nfunction maybeReadMore(stream, state) {\\n  if (!state.readingMore) {\\n    state.readingMore = true;\\n    process.nextTick(maybeReadMore_, stream, state);\\n  }\\n}\\n\\nfunction maybeReadMore_(stream, state) {\\n  var len = state.length;\\n  while (!state.reading && !state.flowing && !state.ended &&\\n         state.length < state.highWaterMark) {\\n    debug('maybeReadMore read 0');\\n    stream.read(0);\\n    if (len === state.length)\\n      // didn't get any data, stop spinning.\\n      break;\\n    else\\n      len = state.length;\\n  }\\n  state.readingMore = false;\\n}\\n\\n// abstract method.  to be overridden in specific implementation classes.\\n// call cb(er, data) where data is <= n in length.\\n// for virtual (non-string, non-buffer) streams, \\\"length\\\" is somewhat\\n// arbitrary, and perhaps not very meaningful.\\nReadable.prototype._read = function(n) {\\n  this.emit('error', new Error('not implemented'));\\n};\\n\\nReadable.prototype.pipe = function(dest, pipeOpts) {\\n  var src = this;\\n  var state = this._readableState;\\n\\n  switch (state.pipesCount) {\\n    case 0:\\n      state.pipes = dest;\\n      break;\\n    case 1:\\n      state.pipes = [state.pipes, dest];\\n      break;\\n    default:\\n      state.pipes.push(dest);\\n      break;\\n  }\\n  state.pipesCount += 1;\\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\\n\\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\\n              dest !== process.stdout &&\\n              dest !== process.stderr;\\n\\n  var endFn = doEnd ? onend : cleanup;\\n  if (state.endEmitted)\\n    process.nextTick(endFn);\\n  else\\n    src.once('end', endFn);\\n\\n  dest.on('unpipe', onunpipe);\\n  function onunpipe(readable) {\\n    debug('onunpipe');\\n    if (readable === src) {\\n      cleanup();\\n    }\\n  }\\n\\n  function onend() {\\n    debug('onend');\\n    dest.end();\\n  }\\n\\n  // when the dest drains, it reduces the awaitDrain counter\\n  // on the source.  This would be more elegant with a .once()\\n  // handler in flow(), but adding and removing repeatedly is\\n  // too slow.\\n  var ondrain = pipeOnDrain(src);\\n  dest.on('drain', ondrain);\\n\\n  var cleanedUp = false;\\n  function cleanup() {\\n    debug('cleanup');\\n    // cleanup event handlers once the pipe is broken\\n    dest.removeListener('close', onclose);\\n    dest.removeListener('finish', onfinish);\\n    dest.removeListener('drain', ondrain);\\n    dest.removeListener('error', onerror);\\n    dest.removeListener('unpipe', onunpipe);\\n    src.removeListener('end', onend);\\n    src.removeListener('end', cleanup);\\n    src.removeListener('data', ondata);\\n\\n    cleanedUp = true;\\n\\n    // if the reader is waiting for a drain event from this\\n    // specific writer, then it would cause it to never start\\n    // flowing again.\\n    // So, if this is awaiting a drain, then we just call it now.\\n    // If we don't know, then assume that we are waiting for one.\\n    if (state.awaitDrain &&\\n        (!dest._writableState || dest._writableState.needDrain))\\n      ondrain();\\n  }\\n\\n  src.on('data', ondata);\\n  function ondata(chunk) {\\n    debug('ondata');\\n    var ret = dest.write(chunk);\\n    if (false === ret) {\\n      // If the user unpiped during `dest.write()`, it is possible\\n      // to get stuck in a permanently paused state if that write\\n      // also returned false.\\n      if (state.pipesCount === 1 &&\\n          state.pipes[0] === dest &&\\n          src.listenerCount('data') === 1 &&\\n          !cleanedUp) {\\n        debug('false write response, pause', src._readableState.awaitDrain);\\n        src._readableState.awaitDrain++;\\n      }\\n      src.pause();\\n    }\\n  }\\n\\n  // if the dest has an error, then stop piping into it.\\n  // however, don't suppress the throwing behavior for this.\\n  function onerror(er) {\\n    debug('onerror', er);\\n    unpipe();\\n    dest.removeListener('error', onerror);\\n    if (EE.listenerCount(dest, 'error') === 0)\\n      dest.emit('error', er);\\n  }\\n  // This is a brutally ugly hack to make sure that our error handler\\n  // is attached before any userland ones.  NEVER DO THIS.\\n  if (!dest._events || !dest._events.error)\\n    dest.on('error', onerror);\\n  else if (Array.isArray(dest._events.error))\\n    dest._events.error.unshift(onerror);\\n  else\\n    dest._events.error = [onerror, dest._events.error];\\n\\n\\n  // Both close and finish should trigger unpipe, but only once.\\n  function onclose() {\\n    dest.removeListener('finish', onfinish);\\n    unpipe();\\n  }\\n  dest.once('close', onclose);\\n  function onfinish() {\\n    debug('onfinish');\\n    dest.removeListener('close', onclose);\\n    unpipe();\\n  }\\n  dest.once('finish', onfinish);\\n\\n  function unpipe() {\\n    debug('unpipe');\\n    src.unpipe(dest);\\n  }\\n\\n  // tell the dest that it's being piped to\\n  dest.emit('pipe', src);\\n\\n  // start the flow if it hasn't been started already.\\n  if (!state.flowing) {\\n    debug('pipe resume');\\n    src.resume();\\n  }\\n\\n  return dest;\\n};\\n\\nfunction pipeOnDrain(src) {\\n  return function() {\\n    var state = src._readableState;\\n    debug('pipeOnDrain', state.awaitDrain);\\n    if (state.awaitDrain)\\n      state.awaitDrain--;\\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\\n      state.flowing = true;\\n      flow(src);\\n    }\\n  };\\n}\\n\\n\\nReadable.prototype.unpipe = function(dest) {\\n  var state = this._readableState;\\n\\n  // if we're not piping anywhere, then do nothing.\\n  if (state.pipesCount === 0)\\n    return this;\\n\\n  // just one destination.  most common case.\\n  if (state.pipesCount === 1) {\\n    // passed in one, but it's not the right one.\\n    if (dest && dest !== state.pipes)\\n      return this;\\n\\n    if (!dest)\\n      dest = state.pipes;\\n\\n    // got a match.\\n    state.pipes = null;\\n    state.pipesCount = 0;\\n    state.flowing = false;\\n    if (dest)\\n      dest.emit('unpipe', this);\\n    return this;\\n  }\\n\\n  // slow case. multiple pipe destinations.\\n\\n  if (!dest) {\\n    // remove all.\\n    var dests = state.pipes;\\n    var len = state.pipesCount;\\n    state.pipes = null;\\n    state.pipesCount = 0;\\n    state.flowing = false;\\n\\n    for (var i = 0; i < len; i++)\\n      dests[i].emit('unpipe', this);\\n    return this;\\n  }\\n\\n  // try to find the right one.\\n  var i = state.pipes.indexOf(dest);\\n  if (i === -1)\\n    return this;\\n\\n  state.pipes.splice(i, 1);\\n  state.pipesCount -= 1;\\n  if (state.pipesCount === 1)\\n    state.pipes = state.pipes[0];\\n\\n  dest.emit('unpipe', this);\\n\\n  return this;\\n};\\n\\n// set up data events if they are asked for\\n// Ensure readable listeners eventually get something\\nReadable.prototype.on = function(ev, fn) {\\n  var res = Stream.prototype.on.call(this, ev, fn);\\n\\n  // If listening to data, and it has not explicitly been paused,\\n  // then call resume to start the flow of data on the next tick.\\n  if (ev === 'data' && false !== this._readableState.flowing) {\\n    this.resume();\\n  }\\n\\n  if (ev === 'readable' && this.readable) {\\n    var state = this._readableState;\\n    if (!state.readableListening) {\\n      state.readableListening = true;\\n      state.emittedReadable = false;\\n      state.needReadable = true;\\n      if (!state.reading) {\\n        process.nextTick(nReadingNextTick, this);\\n      } else if (state.length) {\\n        emitReadable(this, state);\\n      }\\n    }\\n  }\\n\\n  return res;\\n};\\nReadable.prototype.addListener = Readable.prototype.on;\\n\\nfunction nReadingNextTick(self) {\\n  debug('readable nexttick read 0');\\n  self.read(0);\\n}\\n\\n// pause() and resume() are remnants of the legacy readable stream API\\n// If the user uses them, then switch into old mode.\\nReadable.prototype.resume = function() {\\n  var state = this._readableState;\\n  if (!state.flowing) {\\n    debug('resume');\\n    state.flowing = true;\\n    resume(this, state);\\n  }\\n  return this;\\n};\\n\\nfunction resume(stream, state) {\\n  if (!state.resumeScheduled) {\\n    state.resumeScheduled = true;\\n    process.nextTick(resume_, stream, state);\\n  }\\n}\\n\\nfunction resume_(stream, state) {\\n  if (!state.reading) {\\n    debug('resume read 0');\\n    stream.read(0);\\n  }\\n\\n  state.resumeScheduled = false;\\n  stream.emit('resume');\\n  flow(stream);\\n  if (state.flowing && !state.reading)\\n    stream.read(0);\\n}\\n\\nReadable.prototype.pause = function() {\\n  debug('call pause flowing=%j', this._readableState.flowing);\\n  if (false !== this._readableState.flowing) {\\n    debug('pause');\\n    this._readableState.flowing = false;\\n    this.emit('pause');\\n  }\\n  return this;\\n};\\n\\nfunction flow(stream) {\\n  var state = stream._readableState;\\n  debug('flow', state.flowing);\\n  if (state.flowing) {\\n    do {\\n      var chunk = stream.read();\\n    } while (null !== chunk && state.flowing);\\n  }\\n}\\n\\n// wrap an old-style stream as the async data source.\\n// This is *not* part of the readable stream interface.\\n// It is an ugly unfortunate mess of history.\\nReadable.prototype.wrap = function(stream) {\\n  var state = this._readableState;\\n  var paused = false;\\n\\n  var self = this;\\n  stream.on('end', function() {\\n    debug('wrapped end');\\n    if (state.decoder && !state.ended) {\\n      var chunk = state.decoder.end();\\n      if (chunk && chunk.length)\\n        self.push(chunk);\\n    }\\n\\n    self.push(null);\\n  });\\n\\n  stream.on('data', function(chunk) {\\n    debug('wrapped data');\\n    if (state.decoder)\\n      chunk = state.decoder.write(chunk);\\n\\n    // don't skip over falsy values in objectMode\\n    if (state.objectMode && (chunk === null || chunk === undefined))\\n      return;\\n    else if (!state.objectMode && (!chunk || !chunk.length))\\n      return;\\n\\n    var ret = self.push(chunk);\\n    if (!ret) {\\n      paused = true;\\n      stream.pause();\\n    }\\n  });\\n\\n  // proxy all the other methods.\\n  // important when wrapping filters and duplexes.\\n  for (var i in stream) {\\n    if (this[i] === undefined && typeof stream[i] === 'function') {\\n      this[i] = function(method) { return function() {\\n        return stream[method].apply(stream, arguments);\\n      }; }(i);\\n    }\\n  }\\n\\n  // proxy certain important events.\\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\\n  events.forEach(function(ev) {\\n    stream.on(ev, self.emit.bind(self, ev));\\n  });\\n\\n  // when we try to consume some more bytes, simply unpause the\\n  // underlying stream.\\n  self._read = function(n) {\\n    debug('wrapped _read', n);\\n    if (paused) {\\n      paused = false;\\n      stream.resume();\\n    }\\n  };\\n\\n  return self;\\n};\\n\\n\\n// exposed for testing purposes only.\\nReadable._fromList = fromList;\\n\\n// Pluck off n bytes from an array of buffers.\\n// Length is the combined lengths of all the buffers in the list.\\nfunction fromList(n, state) {\\n  var list = state.buffer;\\n  var length = state.length;\\n  var stringMode = !!state.decoder;\\n  var objectMode = !!state.objectMode;\\n  var ret;\\n\\n  // nothing in the list, definitely empty.\\n  if (list.length === 0)\\n    return null;\\n\\n  if (length === 0)\\n    ret = null;\\n  else if (objectMode)\\n    ret = list.shift();\\n  else if (!n || n >= length) {\\n    // read it all, truncate the array.\\n    if (stringMode)\\n      ret = list.join('');\\n    else if (list.length === 1)\\n      ret = list[0];\\n    else\\n      ret = Buffer.concat(list, length);\\n    list.length = 0;\\n  } else {\\n    // read just some of it.\\n    if (n < list[0].length) {\\n      // just take a part of the first list item.\\n      // slice is the same for buffers and strings.\\n      var buf = list[0];\\n      ret = buf.slice(0, n);\\n      list[0] = buf.slice(n);\\n    } else if (n === list[0].length) {\\n      // first list is a perfect match\\n      ret = list.shift();\\n    } else {\\n      // complex case.\\n      // we have enough to cover it, but it spans past the first buffer.\\n      if (stringMode)\\n        ret = '';\\n      else\\n        ret = new Buffer(n);\\n\\n      var c = 0;\\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\\n        var buf = list[0];\\n        var cpy = Math.min(n - c, buf.length);\\n\\n        if (stringMode)\\n          ret += buf.slice(0, cpy);\\n        else\\n          buf.copy(ret, c, 0, cpy);\\n\\n        if (cpy < buf.length)\\n          list[0] = buf.slice(cpy);\\n        else\\n          list.shift();\\n\\n        c += cpy;\\n      }\\n    }\\n  }\\n\\n  return ret;\\n}\\n\\nfunction endReadable(stream) {\\n  var state = stream._readableState;\\n\\n  // If we get here before consuming all the bytes, then that is a\\n  // bug in node.  Should never happen.\\n  if (state.length > 0)\\n    throw new Error('\\\"endReadable()\\\" called on non-empty stream');\\n\\n  if (!state.endEmitted) {\\n    state.ended = true;\\n    process.nextTick(endReadableNT, state, stream);\\n  }\\n}\\n\\nfunction endReadableNT(state, stream) {\\n  // Check that we didn't get one last unshift.\\n  if (!state.endEmitted && state.length === 0) {\\n    state.endEmitted = true;\\n    stream.readable = false;\\n    stream.emit('end');\\n  }\\n}\\n\",\"_stream_writable\":\"// A bit simpler than readable streams.\\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\\n// the drain event emission and buffering.\\n\\n'use strict';\\n\\nmodule.exports = Writable;\\nWritable.WritableState = WritableState;\\n\\nvar util = require('util');\\nvar internalUtil = require('internal/util');\\nvar Stream = require('stream');\\nvar Buffer = require('buffer').Buffer;\\n\\nutil.inherits(Writable, Stream);\\n\\nfunction nop() {}\\n\\nfunction WriteReq(chunk, encoding, cb) {\\n  this.chunk = chunk;\\n  this.encoding = encoding;\\n  this.callback = cb;\\n  this.next = null;\\n}\\n\\nfunction WritableState(options, stream) {\\n  options = options || {};\\n\\n  // object stream flag to indicate whether or not this stream\\n  // contains buffers or objects.\\n  this.objectMode = !!options.objectMode;\\n\\n  if (stream instanceof Stream.Duplex)\\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\\n\\n  // the point at which write() starts returning false\\n  // Note: 0 is a valid value, means that we always return false if\\n  // the entire buffer is not flushed immediately on write()\\n  var hwm = options.highWaterMark;\\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\\n\\n  // cast to ints.\\n  this.highWaterMark = ~~this.highWaterMark;\\n\\n  this.needDrain = false;\\n  // at the start of calling end()\\n  this.ending = false;\\n  // when end() has been called, and returned\\n  this.ended = false;\\n  // when 'finish' is emitted\\n  this.finished = false;\\n\\n  // should we decode strings into buffers before passing to _write?\\n  // this is here so that some node-core streams can optimize string\\n  // handling at a lower level.\\n  var noDecode = options.decodeStrings === false;\\n  this.decodeStrings = !noDecode;\\n\\n  // Crypto is kind of old and crusty.  Historically, its default string\\n  // encoding is 'binary' so we have to make this configurable.\\n  // Everything else in the universe uses 'utf8', though.\\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\\n\\n  // not an actual buffer we keep track of, but a measurement\\n  // of how much we're waiting to get pushed to some underlying\\n  // socket or file.\\n  this.length = 0;\\n\\n  // a flag to see when we're in the middle of a write.\\n  this.writing = false;\\n\\n  // when true all writes will be buffered until .uncork() call\\n  this.corked = 0;\\n\\n  // a flag to be able to tell if the onwrite cb is called immediately,\\n  // or on a later tick.  We set this to true at first, because any\\n  // actions that shouldn't happen until \\\"later\\\" should generally also\\n  // not happen before the first write call.\\n  this.sync = true;\\n\\n  // a flag to know if we're processing previously buffered items, which\\n  // may call the _write() callback in the same tick, so that we don't\\n  // end up in an overlapped onwrite situation.\\n  this.bufferProcessing = false;\\n\\n  // the callback that's passed to _write(chunk,cb)\\n  this.onwrite = function(er) {\\n    onwrite(stream, er);\\n  };\\n\\n  // the callback that the user supplies to write(chunk,encoding,cb)\\n  this.writecb = null;\\n\\n  // the amount that is being written when _write is called.\\n  this.writelen = 0;\\n\\n  this.bufferedRequest = null;\\n  this.lastBufferedRequest = null;\\n\\n  // number of pending user-supplied write callbacks\\n  // this must be 0 before 'finish' can be emitted\\n  this.pendingcb = 0;\\n\\n  // emit prefinish if the only thing we're waiting for is _write cbs\\n  // This is relevant for synchronous Transform streams\\n  this.prefinished = false;\\n\\n  // True if the error was already emitted and should not be thrown again\\n  this.errorEmitted = false;\\n}\\n\\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\\n  var current = this.bufferedRequest;\\n  var out = [];\\n  while (current) {\\n    out.push(current);\\n    current = current.next;\\n  }\\n  return out;\\n};\\n\\nObject.defineProperty(WritableState.prototype, 'buffer', {\\n  get: internalUtil.deprecate(function() {\\n    return this.getBuffer();\\n  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +\\n     'instead.')\\n});\\n\\nfunction Writable(options) {\\n  // Writable ctor is applied to Duplexes, though they're not\\n  // instanceof Writable, they're instanceof Readable.\\n  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))\\n    return new Writable(options);\\n\\n  this._writableState = new WritableState(options, this);\\n\\n  // legacy.\\n  this.writable = true;\\n\\n  if (options) {\\n    if (typeof options.write === 'function')\\n      this._write = options.write;\\n\\n    if (typeof options.writev === 'function')\\n      this._writev = options.writev;\\n  }\\n\\n  Stream.call(this);\\n}\\n\\n// Otherwise people can pipe Writable streams, which is just wrong.\\nWritable.prototype.pipe = function() {\\n  this.emit('error', new Error('Cannot pipe, not readable'));\\n};\\n\\n\\nfunction writeAfterEnd(stream, cb) {\\n  var er = new Error('write after end');\\n  // TODO: defer error events consistently everywhere, not just the cb\\n  stream.emit('error', er);\\n  process.nextTick(cb, er);\\n}\\n\\n// If we get something that is not a buffer, string, null, or undefined,\\n// and we're not in objectMode, then that's an error.\\n// Otherwise stream chunks are all considered to be of length=1, and the\\n// watermarks determine how many objects to keep in the buffer, rather than\\n// how many bytes or characters.\\nfunction validChunk(stream, state, chunk, cb) {\\n  var valid = true;\\n\\n  if (!(Buffer.isBuffer(chunk)) &&\\n      typeof chunk !== 'string' &&\\n      chunk !== null &&\\n      chunk !== undefined &&\\n      !state.objectMode) {\\n    var er = new TypeError('Invalid non-string/buffer chunk');\\n    stream.emit('error', er);\\n    process.nextTick(cb, er);\\n    valid = false;\\n  }\\n  return valid;\\n}\\n\\nWritable.prototype.write = function(chunk, encoding, cb) {\\n  var state = this._writableState;\\n  var ret = false;\\n\\n  if (typeof encoding === 'function') {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n\\n  if (chunk instanceof Buffer)\\n    encoding = 'buffer';\\n  else if (!encoding)\\n    encoding = state.defaultEncoding;\\n\\n  if (typeof cb !== 'function')\\n    cb = nop;\\n\\n  if (state.ended)\\n    writeAfterEnd(this, cb);\\n  else if (validChunk(this, state, chunk, cb)) {\\n    state.pendingcb++;\\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\\n  }\\n\\n  return ret;\\n};\\n\\nWritable.prototype.cork = function() {\\n  var state = this._writableState;\\n\\n  state.corked++;\\n};\\n\\nWritable.prototype.uncork = function() {\\n  var state = this._writableState;\\n\\n  if (state.corked) {\\n    state.corked--;\\n\\n    if (!state.writing &&\\n        !state.corked &&\\n        !state.finished &&\\n        !state.bufferProcessing &&\\n        state.bufferedRequest)\\n      clearBuffer(this, state);\\n  }\\n};\\n\\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\\n  // node::ParseEncoding() requires lower case.\\n  if (typeof encoding === 'string')\\n    encoding = encoding.toLowerCase();\\n  if (!Buffer.isEncoding(encoding))\\n    throw new TypeError('Unknown encoding: ' + encoding);\\n  this._writableState.defaultEncoding = encoding;\\n};\\n\\nfunction decodeChunk(state, chunk, encoding) {\\n  if (!state.objectMode &&\\n      state.decodeStrings !== false &&\\n      typeof chunk === 'string') {\\n    chunk = Buffer(chunk, encoding);\\n  }\\n  return chunk;\\n}\\n\\n// if we're already writing something, then just put this\\n// in the queue, and wait our turn.  Otherwise, call _write\\n// If we return false, then we need a drain event, so set that flag.\\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\\n  chunk = decodeChunk(state, chunk, encoding);\\n\\n  if (chunk instanceof Buffer)\\n    encoding = 'buffer';\\n  var len = state.objectMode ? 1 : chunk.length;\\n\\n  state.length += len;\\n\\n  var ret = state.length < state.highWaterMark;\\n  // we must ensure that previous needDrain will not be reset to false.\\n  if (!ret)\\n    state.needDrain = true;\\n\\n  if (state.writing || state.corked) {\\n    var last = state.lastBufferedRequest;\\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\\n    if (last) {\\n      last.next = state.lastBufferedRequest;\\n    } else {\\n      state.bufferedRequest = state.lastBufferedRequest;\\n    }\\n  } else {\\n    doWrite(stream, state, false, len, chunk, encoding, cb);\\n  }\\n\\n  return ret;\\n}\\n\\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\\n  state.writelen = len;\\n  state.writecb = cb;\\n  state.writing = true;\\n  state.sync = true;\\n  if (writev)\\n    stream._writev(chunk, state.onwrite);\\n  else\\n    stream._write(chunk, encoding, state.onwrite);\\n  state.sync = false;\\n}\\n\\nfunction onwriteError(stream, state, sync, er, cb) {\\n  --state.pendingcb;\\n  if (sync)\\n    process.nextTick(cb, er);\\n  else\\n    cb(er);\\n\\n  stream._writableState.errorEmitted = true;\\n  stream.emit('error', er);\\n}\\n\\nfunction onwriteStateUpdate(state) {\\n  state.writing = false;\\n  state.writecb = null;\\n  state.length -= state.writelen;\\n  state.writelen = 0;\\n}\\n\\nfunction onwrite(stream, er) {\\n  var state = stream._writableState;\\n  var sync = state.sync;\\n  var cb = state.writecb;\\n\\n  onwriteStateUpdate(state);\\n\\n  if (er)\\n    onwriteError(stream, state, sync, er, cb);\\n  else {\\n    // Check if we're actually ready to finish, but don't emit yet\\n    var finished = needFinish(state);\\n\\n    if (!finished &&\\n        !state.corked &&\\n        !state.bufferProcessing &&\\n        state.bufferedRequest) {\\n      clearBuffer(stream, state);\\n    }\\n\\n    if (sync) {\\n      process.nextTick(afterWrite, stream, state, finished, cb);\\n    } else {\\n      afterWrite(stream, state, finished, cb);\\n    }\\n  }\\n}\\n\\nfunction afterWrite(stream, state, finished, cb) {\\n  if (!finished)\\n    onwriteDrain(stream, state);\\n  state.pendingcb--;\\n  cb();\\n  finishMaybe(stream, state);\\n}\\n\\n// Must force callback to be called on nextTick, so that we don't\\n// emit 'drain' before the write() consumer gets the 'false' return\\n// value, and has a chance to attach a 'drain' listener.\\nfunction onwriteDrain(stream, state) {\\n  if (state.length === 0 && state.needDrain) {\\n    state.needDrain = false;\\n    stream.emit('drain');\\n  }\\n}\\n\\n\\n// if there's something in the buffer waiting, then process it\\nfunction clearBuffer(stream, state) {\\n  state.bufferProcessing = true;\\n  var entry = state.bufferedRequest;\\n\\n  if (stream._writev && entry && entry.next) {\\n    // Fast case, write everything using _writev()\\n    var buffer = [];\\n    var cbs = [];\\n    while (entry) {\\n      cbs.push(entry.callback);\\n      buffer.push(entry);\\n      entry = entry.next;\\n    }\\n\\n    // count the one we are adding, as well.\\n    // TODO(isaacs) clean this up\\n    state.pendingcb++;\\n    state.lastBufferedRequest = null;\\n    doWrite(stream, state, true, state.length, buffer, '', function(err) {\\n      for (var i = 0; i < cbs.length; i++) {\\n        state.pendingcb--;\\n        cbs[i](err);\\n      }\\n    });\\n\\n    // Clear buffer\\n  } else {\\n    // Slow case, write chunks one-by-one\\n    while (entry) {\\n      var chunk = entry.chunk;\\n      var encoding = entry.encoding;\\n      var cb = entry.callback;\\n      var len = state.objectMode ? 1 : chunk.length;\\n\\n      doWrite(stream, state, false, len, chunk, encoding, cb);\\n      entry = entry.next;\\n      // if we didn't call the onwrite immediately, then\\n      // it means that we need to wait until it does.\\n      // also, that means that the chunk and cb are currently\\n      // being processed, so move the buffer counter past them.\\n      if (state.writing) {\\n        break;\\n      }\\n    }\\n\\n    if (entry === null)\\n      state.lastBufferedRequest = null;\\n  }\\n  state.bufferedRequest = entry;\\n  state.bufferProcessing = false;\\n}\\n\\nWritable.prototype._write = function(chunk, encoding, cb) {\\n  cb(new Error('not implemented'));\\n};\\n\\nWritable.prototype._writev = null;\\n\\nWritable.prototype.end = function(chunk, encoding, cb) {\\n  var state = this._writableState;\\n\\n  if (typeof chunk === 'function') {\\n    cb = chunk;\\n    chunk = null;\\n    encoding = null;\\n  } else if (typeof encoding === 'function') {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n\\n  if (chunk !== null && chunk !== undefined)\\n    this.write(chunk, encoding);\\n\\n  // .end() fully uncorks\\n  if (state.corked) {\\n    state.corked = 1;\\n    this.uncork();\\n  }\\n\\n  // ignore unnecessary end() calls.\\n  if (!state.ending && !state.finished)\\n    endWritable(this, state, cb);\\n};\\n\\n\\nfunction needFinish(state) {\\n  return (state.ending &&\\n          state.length === 0 &&\\n          state.bufferedRequest === null &&\\n          !state.finished &&\\n          !state.writing);\\n}\\n\\nfunction prefinish(stream, state) {\\n  if (!state.prefinished) {\\n    state.prefinished = true;\\n    stream.emit('prefinish');\\n  }\\n}\\n\\nfunction finishMaybe(stream, state) {\\n  var need = needFinish(state);\\n  if (need) {\\n    if (state.pendingcb === 0) {\\n      prefinish(stream, state);\\n      state.finished = true;\\n      stream.emit('finish');\\n    } else {\\n      prefinish(stream, state);\\n    }\\n  }\\n  return need;\\n}\\n\\nfunction endWritable(stream, state, cb) {\\n  state.ending = true;\\n  finishMaybe(stream, state);\\n  if (cb) {\\n    if (state.finished)\\n      process.nextTick(cb);\\n    else\\n      stream.once('finish', cb);\\n  }\\n  state.ended = true;\\n}\\n\",\"_stream_duplex\":\"// a duplex stream is just a stream that is both readable and writable.\\n// Since JS doesn't have multiple prototypal inheritance, this class\\n// prototypally inherits from Readable, and then parasitically from\\n// Writable.\\n\\n'use strict';\\n\\nmodule.exports = Duplex;\\n\\nvar util = require('util');\\nvar Readable = require('_stream_readable');\\nvar Writable = require('_stream_writable');\\n\\nutil.inherits(Duplex, Readable);\\n\\nvar keys = Object.keys(Writable.prototype);\\nfor (var v = 0; v < keys.length; v++) {\\n  var method = keys[v];\\n  if (!Duplex.prototype[method])\\n    Duplex.prototype[method] = Writable.prototype[method];\\n}\\n\\nfunction Duplex(options) {\\n  if (!(this instanceof Duplex))\\n    return new Duplex(options);\\n\\n  Readable.call(this, options);\\n  Writable.call(this, options);\\n\\n  if (options && options.readable === false)\\n    this.readable = false;\\n\\n  if (options && options.writable === false)\\n    this.writable = false;\\n\\n  this.allowHalfOpen = true;\\n  if (options && options.allowHalfOpen === false)\\n    this.allowHalfOpen = false;\\n\\n  this.once('end', onend);\\n}\\n\\n// the no-half-open enforcer\\nfunction onend() {\\n  // if we allow half-open state, or if the writable side ended,\\n  // then we're ok.\\n  if (this.allowHalfOpen || this._writableState.ended)\\n    return;\\n\\n  // no more data can be written.\\n  // But allow more writes to happen in this tick.\\n  process.nextTick(onEndNT, this);\\n}\\n\\nfunction onEndNT(self) {\\n  self.end();\\n}\\n\",\"_stream_transform\":\"// a transform stream is a readable/writable stream where you do\\n// something with the data.  Sometimes it's called a \\\"filter\\\",\\n// but that's not a great name for it, since that implies a thing where\\n// some bits pass through, and others are simply ignored.  (That would\\n// be a valid example of a transform, of course.)\\n//\\n// While the output is causally related to the input, it's not a\\n// necessarily symmetric or synchronous transformation.  For example,\\n// a zlib stream might take multiple plain-text writes(), and then\\n// emit a single compressed chunk some time in the future.\\n//\\n// Here's how this works:\\n//\\n// The Transform stream has all the aspects of the readable and writable\\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\\n// internally, and returns false if there's a lot of pending writes\\n// buffered up.  When you call read(), that calls _read(n) until\\n// there's enough pending readable data buffered up.\\n//\\n// In a transform stream, the written data is placed in a buffer.  When\\n// _read(n) is called, it transforms the queued up data, calling the\\n// buffered _write cb's as it consumes chunks.  If consuming a single\\n// written chunk would result in multiple output chunks, then the first\\n// outputted bit calls the readcb, and subsequent chunks just go into\\n// the read buffer, and will cause it to emit 'readable' if necessary.\\n//\\n// This way, back-pressure is actually determined by the reading side,\\n// since _read has to be called to start processing a new chunk.  However,\\n// a pathological inflate type of transform can cause excessive buffering\\n// here.  For example, imagine a stream where every byte of input is\\n// interpreted as an integer from 0-255, and then results in that many\\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\\n// 1kb of data being output.  In this case, you could write a very small\\n// amount of input, and end up with a very large amount of output.  In\\n// such a pathological inflating mechanism, there'd be no way to tell\\n// the system to stop doing the transform.  A single 4MB write could\\n// cause the system to run out of memory.\\n//\\n// However, even in such a pathological case, only a single written chunk\\n// would be consumed, and then the rest would wait (un-transformed) until\\n// the results of the previous transformed chunk were consumed.\\n\\n'use strict';\\n\\nmodule.exports = Transform;\\n\\nvar Duplex = require('_stream_duplex');\\nvar util = require('util');\\nutil.inherits(Transform, Duplex);\\n\\n\\nfunction TransformState(stream) {\\n  this.afterTransform = function(er, data) {\\n    return afterTransform(stream, er, data);\\n  };\\n\\n  this.needTransform = false;\\n  this.transforming = false;\\n  this.writecb = null;\\n  this.writechunk = null;\\n}\\n\\nfunction afterTransform(stream, er, data) {\\n  var ts = stream._transformState;\\n  ts.transforming = false;\\n\\n  var cb = ts.writecb;\\n\\n  if (!cb)\\n    return stream.emit('error', new Error('no writecb in Transform class'));\\n\\n  ts.writechunk = null;\\n  ts.writecb = null;\\n\\n  if (data !== null && data !== undefined)\\n    stream.push(data);\\n\\n  if (cb)\\n    cb(er);\\n\\n  var rs = stream._readableState;\\n  rs.reading = false;\\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\\n    stream._read(rs.highWaterMark);\\n  }\\n}\\n\\n\\nfunction Transform(options) {\\n  if (!(this instanceof Transform))\\n    return new Transform(options);\\n\\n  Duplex.call(this, options);\\n\\n  this._transformState = new TransformState(this);\\n\\n  // when the writable side finishes, then flush out anything remaining.\\n  var stream = this;\\n\\n  // start out asking for a readable event once data is transformed.\\n  this._readableState.needReadable = true;\\n\\n  // we have implemented the _read method, and done the other things\\n  // that Readable wants before the first _read call, so unset the\\n  // sync guard flag.\\n  this._readableState.sync = false;\\n\\n  if (options) {\\n    if (typeof options.transform === 'function')\\n      this._transform = options.transform;\\n\\n    if (typeof options.flush === 'function')\\n      this._flush = options.flush;\\n  }\\n\\n  this.once('prefinish', function() {\\n    if (typeof this._flush === 'function')\\n      this._flush(function(er) {\\n        done(stream, er);\\n      });\\n    else\\n      done(stream);\\n  });\\n}\\n\\nTransform.prototype.push = function(chunk, encoding) {\\n  this._transformState.needTransform = false;\\n  return Duplex.prototype.push.call(this, chunk, encoding);\\n};\\n\\n// This is the part where you do stuff!\\n// override this function in implementation classes.\\n// 'chunk' is an input chunk.\\n//\\n// Call `push(newChunk)` to pass along transformed output\\n// to the readable side.  You may call 'push' zero or more times.\\n//\\n// Call `cb(err)` when you are done with this chunk.  If you pass\\n// an error, then that'll put the hurt on the whole operation.  If you\\n// never call cb(), then you'll never get another chunk.\\nTransform.prototype._transform = function(chunk, encoding, cb) {\\n  throw new Error('Not implemented');\\n};\\n\\nTransform.prototype._write = function(chunk, encoding, cb) {\\n  var ts = this._transformState;\\n  ts.writecb = cb;\\n  ts.writechunk = chunk;\\n  ts.writeencoding = encoding;\\n  if (!ts.transforming) {\\n    var rs = this._readableState;\\n    if (ts.needTransform ||\\n        rs.needReadable ||\\n        rs.length < rs.highWaterMark)\\n      this._read(rs.highWaterMark);\\n  }\\n};\\n\\n// Doesn't matter what the args are here.\\n// _transform does all the work.\\n// That we got here means that the readable side wants more data.\\nTransform.prototype._read = function(n) {\\n  var ts = this._transformState;\\n\\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\\n    ts.transforming = true;\\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\\n  } else {\\n    // mark that we need a transform, so that any data that comes in\\n    // will get processed, now that we've asked for it.\\n    ts.needTransform = true;\\n  }\\n};\\n\\n\\nfunction done(stream, er) {\\n  if (er)\\n    return stream.emit('error', er);\\n\\n  // if there's nothing in the write buffer, then that means\\n  // that nothing more will ever be provided\\n  var ws = stream._writableState;\\n  var ts = stream._transformState;\\n\\n  if (ws.length)\\n    throw new Error('Calling transform done when ws.length != 0');\\n\\n  if (ts.transforming)\\n    throw new Error('Calling transform done when still transforming');\\n\\n  return stream.push(null);\\n}\\n\",\"_stream_passthrough\":\"// a passthrough stream.\\n// basically just the most minimal sort of Transform stream.\\n// Every written chunk gets output as-is.\\n\\n'use strict';\\n\\nmodule.exports = PassThrough;\\n\\nvar Transform = require('_stream_transform');\\nvar util = require('util');\\nutil.inherits(PassThrough, Transform);\\n\\nfunction PassThrough(options) {\\n  if (!(this instanceof PassThrough))\\n    return new PassThrough(options);\\n\\n  Transform.call(this, options);\\n}\\n\\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\\n  cb(null, chunk);\\n};\\n\",\"http\":\"'use strict';\\n\\nvar util = require('util');\\nvar internalUtil = require('internal/util');\\nvar EventEmitter = require('events');\\n\\n\\nexports.IncomingMessage = require('_http_incoming').IncomingMessage;\\n\\n\\nvar common = require('_http_common');\\nexports.METHODS = common.methods.slice().sort();\\n\\n\\nexports.OutgoingMessage = require('_http_outgoing').OutgoingMessage;\\n\\n\\nvar server = require('_http_server');\\nexports.ServerResponse = server.ServerResponse;\\nexports.STATUS_CODES = server.STATUS_CODES;\\n\\n\\nvar agent = require('_http_agent');\\nvar Agent = exports.Agent = agent.Agent;\\nexports.globalAgent = agent.globalAgent;\\n\\nvar client = require('_http_client');\\nvar ClientRequest = exports.ClientRequest = client.ClientRequest;\\n\\nexports.request = function(options, cb) {\\n  return new ClientRequest(options, cb);\\n};\\n\\nexports.get = function(options, cb) {\\n  var req = exports.request(options, cb);\\n  req.end();\\n  return req;\\n};\\n\\nexports._connectionListener = server._connectionListener;\\nvar Server = exports.Server = server.Server;\\n\\nexports.createServer = function(requestListener) {\\n  return new Server(requestListener);\\n};\\n\\n\\n// Legacy Interface\\n\\nfunction Client(port, host) {\\n  if (!(this instanceof Client)) return new Client(port, host);\\n  EventEmitter.call(this);\\n\\n  host = host || 'localhost';\\n  port = port || 80;\\n  this.host = host;\\n  this.port = port;\\n  this.agent = new Agent({ host: host, port: port, maxSockets: 1 });\\n}\\nutil.inherits(Client, EventEmitter);\\nClient.prototype.request = function(method, path, headers) {\\n  var self = this;\\n  var options = {};\\n  options.host = self.host;\\n  options.port = self.port;\\n  if (method[0] === '/') {\\n    headers = path;\\n    path = method;\\n    method = 'GET';\\n  }\\n  options.method = method;\\n  options.path = path;\\n  options.headers = headers;\\n  options.agent = self.agent;\\n  var c = new ClientRequest(options);\\n  c.on('error', function(e) {\\n    self.emit('error', e);\\n  });\\n  // The old Client interface emitted 'end' on socket end.\\n  // This doesn't map to how we want things to operate in the future\\n  // but it will get removed when we remove this legacy interface.\\n  c.on('socket', function(s) {\\n    s.on('end', function() {\\n      if (self._decoder) {\\n        var ret = self._decoder.end();\\n        if (ret)\\n          self.emit('data', ret);\\n      }\\n      self.emit('end');\\n    });\\n  });\\n  return c;\\n};\\n\\nexports.Client = internalUtil.deprecate(Client, 'http.Client is deprecated.');\\n\\nexports.createClient = internalUtil.deprecate(function(port, host) {\\n  return new Client(port, host);\\n}, 'http.createClient is deprecated. Use http.request instead.');\\n\",\"_http_agent\":\"'use strict';\\n\\nvar net = require('net');\\nvar util = require('util');\\nvar EventEmitter = require('events');\\nvar debug = util.debuglog('http');\\n\\n// New Agent code.\\n\\n// The largest departure from the previous implementation is that\\n// an Agent instance holds connections for a variable number of host:ports.\\n// Surprisingly, this is still API compatible as far as third parties are\\n// concerned. The only code that really notices the difference is the\\n// request object.\\n\\n// Another departure is that all code related to HTTP parsing is in\\n// ClientRequest.onSocket(). The Agent is now *strictly*\\n// concerned with managing a connection pool.\\n\\nfunction Agent(options) {\\n  if (!(this instanceof Agent))\\n    return new Agent(options);\\n\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n\\n  self.defaultPort = 80;\\n  self.protocol = 'http:';\\n\\n  self.options = util._extend({}, options);\\n\\n  // don't confuse net and make it think that we're connecting to a pipe\\n  self.options.path = null;\\n  self.requests = {};\\n  self.sockets = {};\\n  self.freeSockets = {};\\n  self.keepAliveMsecs = self.options.keepAliveMsecs || 1000;\\n  self.keepAlive = self.options.keepAlive || false;\\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;\\n  self.maxFreeSockets = self.options.maxFreeSockets || 256;\\n\\n  self.on('free', function(socket, options) {\\n    var name = self.getName(options);\\n    debug('agent.on(free)', name);\\n\\n    if (!socket.destroyed &&\\n        self.requests[name] && self.requests[name].length) {\\n      self.requests[name].shift().onSocket(socket);\\n      if (self.requests[name].length === 0) {\\n        // don't leak\\n        delete self.requests[name];\\n      }\\n    } else {\\n      // If there are no pending requests, then put it in\\n      // the freeSockets pool, but only if we're allowed to do so.\\n      var req = socket._httpMessage;\\n      if (req &&\\n          req.shouldKeepAlive &&\\n          !socket.destroyed &&\\n          self.options.keepAlive) {\\n        var freeSockets = self.freeSockets[name];\\n        var freeLen = freeSockets ? freeSockets.length : 0;\\n        var count = freeLen;\\n        if (self.sockets[name])\\n          count += self.sockets[name].length;\\n\\n        if (count > self.maxSockets || freeLen >= self.maxFreeSockets) {\\n          self.removeSocket(socket, options);\\n          socket.destroy();\\n        } else {\\n          freeSockets = freeSockets || [];\\n          self.freeSockets[name] = freeSockets;\\n          socket.setKeepAlive(true, self.keepAliveMsecs);\\n          socket.unref();\\n          socket._httpMessage = null;\\n          self.removeSocket(socket, options);\\n          freeSockets.push(socket);\\n        }\\n      } else {\\n        self.removeSocket(socket, options);\\n        socket.destroy();\\n      }\\n    }\\n  });\\n}\\n\\nutil.inherits(Agent, EventEmitter);\\nexports.Agent = Agent;\\n\\nAgent.defaultMaxSockets = Infinity;\\n\\nAgent.prototype.createConnection = net.createConnection;\\n\\n// Get the key for a given set of request options\\nAgent.prototype.getName = function(options) {\\n  var name = options.host || 'localhost';\\n\\n  name += ':';\\n  if (options.port)\\n    name += options.port;\\n\\n  name += ':';\\n  if (options.localAddress)\\n    name += options.localAddress;\\n\\n  return name;\\n};\\n\\nAgent.prototype.addRequest = function(req, options) {\\n  // Legacy API: addRequest(req, host, port, path)\\n  if (typeof options === 'string') {\\n    options = {\\n      host: options,\\n      port: arguments[2],\\n      path: arguments[3]\\n    };\\n  }\\n\\n  var name = this.getName(options);\\n  if (!this.sockets[name]) {\\n    this.sockets[name] = [];\\n  }\\n\\n  var freeLen = this.freeSockets[name] ? this.freeSockets[name].length : 0;\\n  var sockLen = freeLen + this.sockets[name].length;\\n\\n  if (freeLen) {\\n    // we have a free socket, so use that.\\n    var socket = this.freeSockets[name].shift();\\n    debug('have free socket');\\n\\n    // don't leak\\n    if (!this.freeSockets[name].length)\\n      delete this.freeSockets[name];\\n\\n    socket.ref();\\n    req.onSocket(socket);\\n    this.sockets[name].push(socket);\\n  } else if (sockLen < this.maxSockets) {\\n    debug('call onSocket', sockLen, freeLen);\\n    // If we are under maxSockets create a new one.\\n    req.onSocket(this.createSocket(req, options));\\n  } else {\\n    debug('wait for socket');\\n    // We are over limit so we'll add it to the queue.\\n    if (!this.requests[name]) {\\n      this.requests[name] = [];\\n    }\\n    this.requests[name].push(req);\\n  }\\n};\\n\\nAgent.prototype.createSocket = function(req, options) {\\n  var self = this;\\n  options = util._extend({}, options);\\n  options = util._extend(options, self.options);\\n\\n  if (!options.servername) {\\n    options.servername = options.host;\\n    if (req) {\\n      var hostHeader = req.getHeader('host');\\n      if (hostHeader) {\\n        options.servername = hostHeader.replace(/:.*$/, '');\\n      }\\n    }\\n  }\\n\\n  var name = self.getName(options);\\n  options._agentKey = name;\\n\\n  debug('createConnection', name, options);\\n  options.encoding = null;\\n  var s = self.createConnection(options);\\n  if (!self.sockets[name]) {\\n    self.sockets[name] = [];\\n  }\\n  this.sockets[name].push(s);\\n  debug('sockets', name, this.sockets[name].length);\\n\\n  function onFree() {\\n    self.emit('free', s, options);\\n  }\\n  s.on('free', onFree);\\n\\n  function onClose(err) {\\n    debug('CLIENT socket onClose');\\n    // This is the only place where sockets get removed from the Agent.\\n    // If you want to remove a socket from the pool, just close it.\\n    // All socket errors end in a close event anyway.\\n    self.removeSocket(s, options);\\n  }\\n  s.on('close', onClose);\\n\\n  function onRemove() {\\n    // We need this function for cases like HTTP 'upgrade'\\n    // (defined by WebSockets) where we need to remove a socket from the\\n    // pool because it'll be locked up indefinitely\\n    debug('CLIENT socket onRemove');\\n    self.removeSocket(s, options);\\n    s.removeListener('close', onClose);\\n    s.removeListener('free', onFree);\\n    s.removeListener('agentRemove', onRemove);\\n  }\\n  s.on('agentRemove', onRemove);\\n  return s;\\n};\\n\\nAgent.prototype.removeSocket = function(s, options) {\\n  var name = this.getName(options);\\n  debug('removeSocket', name, 'destroyed:', s.destroyed);\\n  var sets = [this.sockets];\\n\\n  // If the socket was destroyed, remove it from the free buffers too.\\n  if (s.destroyed)\\n    sets.push(this.freeSockets);\\n\\n  for (var sk = 0; sk < sets.length; sk++) {\\n    var sockets = sets[sk];\\n\\n    if (sockets[name]) {\\n      var index = sockets[name].indexOf(s);\\n      if (index !== -1) {\\n        sockets[name].splice(index, 1);\\n        // Don't leak\\n        if (sockets[name].length === 0)\\n          delete sockets[name];\\n      }\\n    }\\n  }\\n\\n  if (this.requests[name] && this.requests[name].length) {\\n    debug('removeSocket, have a request, make a socket');\\n    var req = this.requests[name][0];\\n    // If we have pending requests and a socket gets closed make a new one\\n    this.createSocket(req, options).emit('free');\\n  }\\n};\\n\\nAgent.prototype.destroy = function() {\\n  var sets = [this.freeSockets, this.sockets];\\n  for (var s = 0; s < sets.length; s++) {\\n    var set = sets[s];\\n    var keys = Object.keys(set);\\n    for (var v = 0; v < keys.length; v++) {\\n      var setName = set[keys[v]];\\n      for (var n = 0; n < setName.length; n++) {\\n        setName[n].destroy();\\n      }\\n    }\\n  }\\n};\\n\\nexports.globalAgent = new Agent();\\n\",\"_http_client\":\"'use strict';\\n\\nvar util = require('util');\\nvar net = require('net');\\nvar url = require('url');\\nvar EventEmitter = require('events');\\nvar HTTPParser = process.binding('http_parser').HTTPParser;\\nvar assert = require('assert').ok;\\nvar common = require('_http_common');\\nvar httpSocketSetup = common.httpSocketSetup;\\nvar parsers = common.parsers;\\nvar freeParser = common.freeParser;\\nvar debug = common.debug;\\nvar OutgoingMessage = require('_http_outgoing').OutgoingMessage;\\nvar Agent = require('_http_agent');\\nvar Buffer = require('buffer').Buffer;\\n\\n\\nfunction ClientRequest(options, cb) {\\n  var self = this;\\n  OutgoingMessage.call(self);\\n\\n  if (typeof options === 'string') {\\n    options = url.parse(options);\\n    if (!options.hostname) {\\n      throw new Error('Unable to determine the domain name');\\n    }\\n  } else {\\n    options = util._extend({}, options);\\n  }\\n\\n  var agent = options.agent;\\n  var defaultAgent = options._defaultAgent || Agent.globalAgent;\\n  if (agent === false) {\\n    agent = new defaultAgent.constructor();\\n  } else if ((agent === null || agent === undefined) &&\\n             !options.createConnection) {\\n    agent = defaultAgent;\\n  }\\n  self.agent = agent;\\n\\n  var protocol = options.protocol || defaultAgent.protocol;\\n  var expectedProtocol = defaultAgent.protocol;\\n  if (self.agent && self.agent.protocol)\\n    expectedProtocol = self.agent.protocol;\\n\\n  if (options.path && / /.test(options.path)) {\\n    // The actual regex is more like /[^A-Za-z0-9\\\\-._~!$&'()*+,;=/:@]/\\n    // with an additional rule for ignoring percentage-escaped characters\\n    // but that's a) hard to capture in a regular expression that performs\\n    // well, and b) possibly too restrictive for real-world usage. That's\\n    // why it only scans for spaces because those are guaranteed to create\\n    // an invalid request.\\n    throw new TypeError('Request path contains unescaped characters');\\n  } else if (protocol !== expectedProtocol) {\\n    throw new Error('Protocol \\\"' + protocol + '\\\" not supported. ' +\\n                    'Expected \\\"' + expectedProtocol + '\\\"');\\n  }\\n\\n  var defaultPort = options.defaultPort ||\\n                      self.agent && self.agent.defaultPort;\\n\\n  var port = options.port = options.port || defaultPort || 80;\\n  var host = options.host = options.hostname || options.host || 'localhost';\\n\\n  if (options.setHost === undefined) {\\n    var setHost = true;\\n  }\\n\\n  self.socketPath = options.socketPath;\\n\\n  var method = self.method = (options.method || 'GET').toUpperCase();\\n  if (!common._checkIsHttpToken(method)) {\\n    throw new TypeError('Method must be a valid HTTP token');\\n  }\\n  self.path = options.path || '/';\\n  if (cb) {\\n    self.once('response', cb);\\n  }\\n\\n  if (!Array.isArray(options.headers)) {\\n    if (options.headers) {\\n      var keys = Object.keys(options.headers);\\n      for (var i = 0, l = keys.length; i < l; i++) {\\n        var key = keys[i];\\n        self.setHeader(key, options.headers[key]);\\n      }\\n    }\\n    if (host && !this.getHeader('host') && setHost) {\\n      var hostHeader = host;\\n      if (port && +port !== defaultPort) {\\n        hostHeader += ':' + port;\\n      }\\n      this.setHeader('Host', hostHeader);\\n    }\\n  }\\n\\n  if (options.auth && !this.getHeader('Authorization')) {\\n    //basic auth\\n    this.setHeader('Authorization', 'Basic ' +\\n                   new Buffer(options.auth).toString('base64'));\\n  }\\n\\n  if (method === 'GET' ||\\n      method === 'HEAD' ||\\n      method === 'DELETE' ||\\n      method === 'OPTIONS' ||\\n      method === 'CONNECT') {\\n    self.useChunkedEncodingByDefault = false;\\n  } else {\\n    self.useChunkedEncodingByDefault = true;\\n  }\\n\\n  if (Array.isArray(options.headers)) {\\n    self._storeHeader(self.method + ' ' + self.path + ' HTTP/1.1\\\\r\\\\n',\\n                      options.headers);\\n  } else if (self.getHeader('expect')) {\\n    self._storeHeader(self.method + ' ' + self.path + ' HTTP/1.1\\\\r\\\\n',\\n                      self._renderHeaders());\\n  }\\n\\n  if (self.socketPath) {\\n    self._last = true;\\n    self.shouldKeepAlive = false;\\n    var conn = self.agent.createConnection({ path: self.socketPath });\\n    self.onSocket(conn);\\n  } else if (self.agent) {\\n    // If there is an agent we should default to Connection:keep-alive,\\n    // but only if the Agent will actually reuse the connection!\\n    // If it's not a keepAlive agent, and the maxSockets==Infinity, then\\n    // there's never a case where this socket will actually be reused\\n    if (!self.agent.keepAlive && !Number.isFinite(self.agent.maxSockets)) {\\n      self._last = true;\\n      self.shouldKeepAlive = false;\\n    } else {\\n      self._last = false;\\n      self.shouldKeepAlive = true;\\n    }\\n    self.agent.addRequest(self, options);\\n  } else {\\n    // No agent, default to Connection:close.\\n    self._last = true;\\n    self.shouldKeepAlive = false;\\n    if (options.createConnection) {\\n      var conn = options.createConnection(options);\\n    } else {\\n      debug('CLIENT use net.createConnection', options);\\n      var conn = net.createConnection(options);\\n    }\\n    self.onSocket(conn);\\n  }\\n\\n  self._deferToConnect(null, null, function() {\\n    self._flush();\\n    self = null;\\n  });\\n}\\n\\nutil.inherits(ClientRequest, OutgoingMessage);\\n\\nexports.ClientRequest = ClientRequest;\\n\\nClientRequest.prototype.aborted = undefined;\\n\\nClientRequest.prototype._finish = function() {\\n  DTRACE_HTTP_CLIENT_REQUEST(this, this.connection);\\n  LTTNG_HTTP_CLIENT_REQUEST(this, this.connection);\\n  COUNTER_HTTP_CLIENT_REQUEST();\\n  OutgoingMessage.prototype._finish.call(this);\\n};\\n\\nClientRequest.prototype._implicitHeader = function() {\\n  this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\\\r\\\\n',\\n                    this._renderHeaders());\\n};\\n\\nClientRequest.prototype.abort = function() {\\n  if (this.aborted === undefined) {\\n    process.nextTick(emitAbortNT, this);\\n  }\\n  // Mark as aborting so we can avoid sending queued request data\\n  // This is used as a truthy flag elsewhere. The use of Date.now is for\\n  // debugging purposes only.\\n  this.aborted = Date.now();\\n\\n  // If we're aborting, we don't care about any more response data.\\n  if (this.res)\\n    this.res._dump();\\n  else\\n    this.once('response', function(res) {\\n      res._dump();\\n    });\\n\\n  // In the event that we don't have a socket, we will pop out of\\n  // the request queue through handling in onSocket.\\n  if (this.socket) {\\n    // in-progress\\n    this.socket.destroy();\\n  }\\n};\\n\\n\\nfunction emitAbortNT(self) {\\n  self.emit('abort');\\n}\\n\\n\\nfunction createHangUpError() {\\n  var error = new Error('socket hang up');\\n  error.code = 'ECONNRESET';\\n  return error;\\n}\\n\\n\\nfunction socketCloseListener() {\\n  var socket = this;\\n  var req = socket._httpMessage;\\n  debug('HTTP socket close');\\n\\n  // Pull through final chunk, if anything is buffered.\\n  // the ondata function will handle it properly, and this\\n  // is a no-op if no final chunk remains.\\n  socket.read();\\n\\n  // NOTE: It's important to get parser here, because it could be freed by\\n  // the `socketOnData`.\\n  var parser = socket.parser;\\n  req.emit('close');\\n  if (req.res && req.res.readable) {\\n    // Socket closed before we emitted 'end' below.\\n    req.res.emit('aborted');\\n    var res = req.res;\\n    res.on('end', function() {\\n      res.emit('close');\\n    });\\n    res.push(null);\\n  } else if (!req.res && !req.socket._hadError) {\\n    // This socket error fired before we started to\\n    // receive a response. The error needs to\\n    // fire on the request.\\n    req.emit('error', createHangUpError());\\n    req.socket._hadError = true;\\n  }\\n\\n  // Too bad.  That output wasn't getting written.\\n  // This is pretty terrible that it doesn't raise an error.\\n  // Fixed better in v0.10\\n  if (req.output)\\n    req.output.length = 0;\\n  if (req.outputEncodings)\\n    req.outputEncodings.length = 0;\\n\\n  if (parser) {\\n    parser.finish();\\n    freeParser(parser, req, socket);\\n  }\\n}\\n\\nfunction socketErrorListener(err) {\\n  var socket = this;\\n  var req = socket._httpMessage;\\n  debug('SOCKET ERROR:', err.message, err.stack);\\n\\n  if (req) {\\n    req.emit('error', err);\\n    // For Safety. Some additional errors might fire later on\\n    // and we need to make sure we don't double-fire the error event.\\n    req.socket._hadError = true;\\n  }\\n\\n  // Handle any pending data\\n  socket.read();\\n\\n  var parser = socket.parser;\\n  if (parser) {\\n    parser.finish();\\n    freeParser(parser, req, socket);\\n  }\\n\\n  // Ensure that no further data will come out of the socket\\n  socket.removeListener('data', socketOnData);\\n  socket.removeListener('end', socketOnEnd);\\n  socket.destroy();\\n}\\n\\nfunction socketOnEnd() {\\n  var socket = this;\\n  var req = this._httpMessage;\\n  var parser = this.parser;\\n\\n  if (!req.res && !req.socket._hadError) {\\n    // If we don't have a response then we know that the socket\\n    // ended prematurely and we need to emit an error on the request.\\n    req.emit('error', createHangUpError());\\n    req.socket._hadError = true;\\n  }\\n  if (parser) {\\n    parser.finish();\\n    freeParser(parser, req, socket);\\n  }\\n  socket.destroy();\\n}\\n\\nfunction socketOnData(d) {\\n  var socket = this;\\n  var req = this._httpMessage;\\n  var parser = this.parser;\\n\\n  assert(parser && parser.socket === socket);\\n\\n  var ret = parser.execute(d);\\n  if (ret instanceof Error) {\\n    debug('parse error');\\n    freeParser(parser, req, socket);\\n    socket.destroy();\\n    req.emit('error', ret);\\n    req.socket._hadError = true;\\n  } else if (parser.incoming && parser.incoming.upgrade) {\\n    // Upgrade or CONNECT\\n    var bytesParsed = ret;\\n    var res = parser.incoming;\\n    req.res = res;\\n\\n    socket.removeListener('data', socketOnData);\\n    socket.removeListener('end', socketOnEnd);\\n    parser.finish();\\n\\n    var bodyHead = d.slice(bytesParsed, d.length);\\n\\n    var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\\n    if (req.listenerCount(eventName) > 0) {\\n      req.upgradeOrConnect = true;\\n\\n      // detach the socket\\n      socket.emit('agentRemove');\\n      socket.removeListener('close', socketCloseListener);\\n      socket.removeListener('error', socketErrorListener);\\n\\n      // TODO(isaacs): Need a way to reset a stream to fresh state\\n      // IE, not flowing, and not explicitly paused.\\n      socket._readableState.flowing = null;\\n\\n      req.emit(eventName, res, socket, bodyHead);\\n      req.emit('close');\\n    } else {\\n      // Got Upgrade header or CONNECT method, but have no handler.\\n      socket.destroy();\\n    }\\n    freeParser(parser, req, socket);\\n  } else if (parser.incoming && parser.incoming.complete &&\\n             // When the status code is 100 (Continue), the server will\\n             // send a final response after this client sends a request\\n             // body. So, we must not free the parser.\\n             parser.incoming.statusCode !== 100) {\\n    socket.removeListener('data', socketOnData);\\n    socket.removeListener('end', socketOnEnd);\\n    freeParser(parser, req, socket);\\n  }\\n}\\n\\n\\n// client\\nfunction parserOnIncomingClient(res, shouldKeepAlive) {\\n  var socket = this.socket;\\n  var req = socket._httpMessage;\\n\\n\\n  // propagate \\\"domain\\\" setting...\\n  if (req.domain && !res.domain) {\\n    debug('setting \\\"res.domain\\\"');\\n    res.domain = req.domain;\\n  }\\n\\n  debug('AGENT incoming response!');\\n\\n  if (req.res) {\\n    // We already have a response object, this means the server\\n    // sent a double response.\\n    socket.destroy();\\n    return;\\n  }\\n  req.res = res;\\n\\n  // Responses to CONNECT request is handled as Upgrade.\\n  if (req.method === 'CONNECT') {\\n    res.upgrade = true;\\n    return true; // skip body\\n  }\\n\\n  // Responses to HEAD requests are crazy.\\n  // HEAD responses aren't allowed to have an entity-body\\n  // but *can* have a content-length which actually corresponds\\n  // to the content-length of the entity-body had the request\\n  // been a GET.\\n  var isHeadResponse = req.method === 'HEAD';\\n  debug('AGENT isHeadResponse', isHeadResponse);\\n\\n  if (res.statusCode === 100) {\\n    // restart the parser, as this is a continue message.\\n    delete req.res; // Clear res so that we don't hit double-responses.\\n    req.emit('continue');\\n    return true;\\n  }\\n\\n  if (req.shouldKeepAlive && !shouldKeepAlive && !req.upgradeOrConnect) {\\n    // Server MUST respond with Connection:keep-alive for us to enable it.\\n    // If we've been upgraded (via WebSockets) we also shouldn't try to\\n    // keep the connection open.\\n    req.shouldKeepAlive = false;\\n  }\\n\\n\\n  DTRACE_HTTP_CLIENT_RESPONSE(socket, req);\\n  LTTNG_HTTP_CLIENT_RESPONSE(socket, req);\\n  COUNTER_HTTP_CLIENT_RESPONSE();\\n  req.res = res;\\n  res.req = req;\\n\\n  // add our listener first, so that we guarantee socket cleanup\\n  res.on('end', responseOnEnd);\\n  var handled = req.emit('response', res);\\n\\n  // If the user did not listen for the 'response' event, then they\\n  // can't possibly read the data, so we ._dump() it into the void\\n  // so that the socket doesn't hang there in a paused state.\\n  if (!handled)\\n    res._dump();\\n\\n  return isHeadResponse;\\n}\\n\\n// client\\nfunction responseOnEnd() {\\n  var res = this;\\n  var req = res.req;\\n  var socket = req.socket;\\n\\n  if (!req.shouldKeepAlive) {\\n    if (socket.writable) {\\n      debug('AGENT socket.destroySoon()');\\n      socket.destroySoon();\\n    }\\n    assert(!socket.writable);\\n  } else {\\n    debug('AGENT socket keep-alive');\\n    if (req.timeoutCb) {\\n      socket.setTimeout(0, req.timeoutCb);\\n      req.timeoutCb = null;\\n    }\\n    socket.removeListener('close', socketCloseListener);\\n    socket.removeListener('error', socketErrorListener);\\n    // Mark this socket as available, AFTER user-added end\\n    // handlers have a chance to run.\\n    process.nextTick(emitFreeNT, socket);\\n  }\\n}\\n\\nfunction emitFreeNT(socket) {\\n  socket.emit('free');\\n}\\n\\nfunction tickOnSocket(req, socket) {\\n  var parser = parsers.alloc();\\n  req.socket = socket;\\n  req.connection = socket;\\n  parser.reinitialize(HTTPParser.RESPONSE);\\n  parser.socket = socket;\\n  parser.incoming = null;\\n  parser.outgoing = req;\\n  req.parser = parser;\\n\\n  socket.parser = parser;\\n  socket._httpMessage = req;\\n\\n  // Setup \\\"drain\\\" propagation.\\n  httpSocketSetup(socket);\\n\\n  // Propagate headers limit from request object to parser\\n  if (typeof req.maxHeadersCount === 'number') {\\n    parser.maxHeaderPairs = req.maxHeadersCount << 1;\\n  } else {\\n    // Set default value because parser may be reused from FreeList\\n    parser.maxHeaderPairs = 2000;\\n  }\\n\\n  parser.onIncoming = parserOnIncomingClient;\\n  socket.on('error', socketErrorListener);\\n  socket.on('data', socketOnData);\\n  socket.on('end', socketOnEnd);\\n  socket.on('close', socketCloseListener);\\n  req.emit('socket', socket);\\n}\\n\\nClientRequest.prototype.onSocket = function(socket) {\\n  process.nextTick(onSocketNT, this, socket);\\n};\\n\\nfunction onSocketNT(req, socket) {\\n  if (req.aborted) {\\n    // If we were aborted while waiting for a socket, skip the whole thing.\\n    socket.emit('free');\\n  } else {\\n    tickOnSocket(req, socket);\\n  }\\n}\\n\\nClientRequest.prototype._deferToConnect = function(method, arguments_, cb) {\\n  // This function is for calls that need to happen once the socket is\\n  // connected and writable. It's an important promisy thing for all the socket\\n  // calls that happen either now (when a socket is assigned) or\\n  // in the future (when a socket gets assigned out of the pool and is\\n  // eventually writable).\\n  var self = this;\\n\\n  function callSocketMethod() {\\n    if (method)\\n      self.socket[method].apply(self.socket, arguments_);\\n\\n    if (typeof cb === 'function')\\n      cb();\\n  }\\n\\n  var onSocket = function() {\\n    if (self.socket.writable) {\\n      callSocketMethod();\\n    } else {\\n      self.socket.once('connect', callSocketMethod);\\n    }\\n  };\\n\\n  if (!self.socket) {\\n    self.once('socket', onSocket);\\n  } else {\\n    onSocket();\\n  }\\n};\\n\\nClientRequest.prototype.setTimeout = function(msecs, callback) {\\n  if (callback) this.once('timeout', callback);\\n\\n  var self = this;\\n  function emitTimeout() {\\n    self.emit('timeout');\\n  }\\n\\n  if (this.socket && this.socket.writable) {\\n    if (this.timeoutCb)\\n      this.socket.setTimeout(0, this.timeoutCb);\\n    this.timeoutCb = emitTimeout;\\n    this.socket.setTimeout(msecs, emitTimeout);\\n    return this;\\n  }\\n\\n  // Set timeoutCb so that it'll get cleaned up on request end\\n  this.timeoutCb = emitTimeout;\\n  if (this.socket) {\\n    var sock = this.socket;\\n    this.socket.once('connect', function() {\\n      sock.setTimeout(msecs, emitTimeout);\\n    });\\n    return this;\\n  }\\n\\n  this.once('socket', function(sock) {\\n    sock.setTimeout(msecs, emitTimeout);\\n  });\\n\\n  return this;\\n};\\n\\nClientRequest.prototype.setNoDelay = function() {\\n  this._deferToConnect('setNoDelay', arguments);\\n};\\nClientRequest.prototype.setSocketKeepAlive = function() {\\n  this._deferToConnect('setKeepAlive', arguments);\\n};\\n\\nClientRequest.prototype.clearTimeout = function(cb) {\\n  this.setTimeout(0, cb);\\n};\\n\",\"_http_common\":\"'use strict';\\n\\nvar FreeList = require('internal/freelist').FreeList;\\nvar HTTPParser = process.binding('http_parser').HTTPParser;\\n\\nvar incoming = require('_http_incoming');\\nvar IncomingMessage = incoming.IncomingMessage;\\nvar readStart = incoming.readStart;\\nvar readStop = incoming.readStop;\\n\\nvar debug = require('util').debuglog('http');\\nexports.debug = debug;\\n\\nexports.CRLF = '\\\\r\\\\n';\\nexports.chunkExpression = /chunk/i;\\nexports.continueExpression = /100-continue/i;\\nexports.methods = HTTPParser.methods;\\n\\nvar kOnHeaders = HTTPParser.kOnHeaders | 0;\\nvar kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;\\nvar kOnBody = HTTPParser.kOnBody | 0;\\nvar kOnMessageComplete = HTTPParser.kOnMessageComplete | 0;\\n\\n// Only called in the slow case where slow means\\n// that the request headers were either fragmented\\n// across multiple TCP packets or too large to be\\n// processed in a single run. This method is also\\n// called to process trailing HTTP headers.\\nfunction parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n}\\n\\n// `headers` and `url` are set only if .onHeaders() has not been called for\\n// this request.\\n// `url` is not set for response parsers but that's not applicable here since\\n// all our parsers are request parsers.\\nfunction parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  var parser = this;\\n\\n  if (!headers) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (!url) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  parser.incoming = new IncomingMessage(parser.socket);\\n  parser.incoming.httpVersionMajor = versionMajor;\\n  parser.incoming.httpVersionMinor = versionMinor;\\n  parser.incoming.httpVersion = versionMajor + '.' + versionMinor;\\n  parser.incoming.url = url;\\n\\n  var n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = Math.min(n, parser.maxHeaderPairs);\\n\\n  parser.incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    parser.incoming.method = HTTPParser.methods[method];\\n  } else {\\n    // client only\\n    parser.incoming.statusCode = statusCode;\\n    parser.incoming.statusMessage = statusMessage;\\n  }\\n\\n  // The client made non-upgrade request, and server is just advertising\\n  // supported protocols.\\n  //\\n  // See RFC7230 Section 6.7\\n  //\\n  // NOTE: RegExp below matches `upgrade` in `Connection: abc, upgrade, def`\\n  // header.\\n  if (upgrade &&\\n      parser.outgoing !== null &&\\n      (parser.outgoing._headers.upgrade === undefined ||\\n       !/(^|\\\\W)upgrade(\\\\W|$)/i.test(parser.outgoing._headers.connection))) {\\n    upgrade = false;\\n  }\\n\\n  parser.incoming.upgrade = upgrade;\\n\\n  var skipBody = false; // response to HEAD or CONNECT\\n\\n  if (!upgrade) {\\n    // For upgraded connections and CONNECT method request, we'll emit this\\n    // after parser.execute so that we can capture the first part of the new\\n    // protocol.\\n    skipBody = parser.onIncoming(parser.incoming, shouldKeepAlive);\\n  }\\n\\n  return skipBody;\\n}\\n\\n// XXX This is a mess.\\n// TODO: http.Parser should be a Writable emits request/response events.\\nfunction parserOnBody(b, start, len) {\\n  var parser = this;\\n  var stream = parser.incoming;\\n\\n  // if the stream has already been removed, then drop it.\\n  if (!stream)\\n    return;\\n\\n  var socket = stream.socket;\\n\\n  // pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    var slice = b.slice(start, start + len);\\n    var ret = stream.push(slice);\\n    if (!ret)\\n      readStop(socket);\\n  }\\n}\\n\\nfunction parserOnMessageComplete() {\\n  var parser = this;\\n  var stream = parser.incoming;\\n\\n  if (stream) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    var headers = parser._headers;\\n    if (headers) {\\n      parser.incoming._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // force to read the next incoming message\\n  readStart(parser.socket);\\n}\\n\\n\\nvar parsers = new FreeList('parsers', 1000, function() {\\n  var parser = new HTTPParser(HTTPParser.REQUEST);\\n\\n  parser._headers = [];\\n  parser._url = '';\\n  parser._consumed = false;\\n\\n  parser.socket = null;\\n  parser.incoming = null;\\n  parser.outgoing = null;\\n\\n  // Only called in the slow case where slow means\\n  // that the request headers were either fragmented\\n  // across multiple TCP packets or too large to be\\n  // processed in a single run. This method is also\\n  // called to process trailing HTTP headers.\\n  parser[kOnHeaders] = parserOnHeaders;\\n  parser[kOnHeadersComplete] = parserOnHeadersComplete;\\n  parser[kOnBody] = parserOnBody;\\n  parser[kOnMessageComplete] = parserOnMessageComplete;\\n\\n  return parser;\\n});\\nexports.parsers = parsers;\\n\\n\\n// Free the parser and also break any links that it\\n// might have to any other things.\\n// TODO: All parser data should be attached to a\\n// single object, so that it can be easily cleaned\\n// up by doing `parser.data = {}`, which should\\n// be done in FreeList.free.  `parsers.free(parser)`\\n// should be all that is needed.\\nfunction freeParser(parser, req, socket) {\\n  if (parser) {\\n    parser._headers = [];\\n    parser.onIncoming = null;\\n    if (parser._consumed)\\n      parser.unconsume();\\n    parser._consumed = false;\\n    if (parser.socket)\\n      parser.socket.parser = null;\\n    parser.socket = null;\\n    parser.incoming = null;\\n    parser.outgoing = null;\\n    if (parsers.free(parser) === false)\\n      parser.close();\\n    parser = null;\\n  }\\n  if (req) {\\n    req.parser = null;\\n  }\\n  if (socket) {\\n    socket.parser = null;\\n  }\\n}\\nexports.freeParser = freeParser;\\n\\n\\nfunction ondrain() {\\n  if (this._httpMessage) this._httpMessage.emit('drain');\\n}\\n\\n\\nfunction httpSocketSetup(socket) {\\n  socket.removeListener('drain', ondrain);\\n  socket.on('drain', ondrain);\\n}\\nexports.httpSocketSetup = httpSocketSetup;\\n\\n/**\\n * Verifies that the given val is a valid HTTP token\\n * per the rules defined in RFC 7230\\n **/\\nvar token = /^[a-zA-Z0-9_!#$%&'*+.^`|~\\\\-]+$/;\\nfunction checkIsHttpToken(val) {\\n  return typeof val === 'string' && token.test(val);\\n}\\nexports._checkIsHttpToken = checkIsHttpToken;\\n\",\"_http_incoming\":\"'use strict';\\n\\nvar util = require('util');\\nvar Stream = require('stream');\\n\\nfunction readStart(socket) {\\n  if (socket && !socket._paused && socket.readable)\\n    socket.resume();\\n}\\nexports.readStart = readStart;\\n\\nfunction readStop(socket) {\\n  if (socket)\\n    socket.pause();\\n}\\nexports.readStop = readStop;\\n\\n\\n/* Abstract base class for ServerRequest and ClientResponse. */\\nfunction IncomingMessage(socket) {\\n  Stream.Readable.call(this);\\n\\n  // XXX This implementation is kind of all over the place\\n  // When the parser emits body chunks, they go in this list.\\n  // _read() pulls them out, and when it finds EOF, it ends.\\n\\n  this.socket = socket;\\n  this.connection = socket;\\n\\n  this.httpVersionMajor = null;\\n  this.httpVersionMinor = null;\\n  this.httpVersion = null;\\n  this.complete = false;\\n  this.headers = {};\\n  this.rawHeaders = [];\\n  this.trailers = {};\\n  this.rawTrailers = [];\\n\\n  this.readable = true;\\n\\n  this.upgrade = null;\\n\\n  // request (server) only\\n  this.url = '';\\n  this.method = null;\\n\\n  // response (client) only\\n  this.statusCode = null;\\n  this.statusMessage = null;\\n  this.client = socket;\\n\\n  // flag for backwards compatibility grossness.\\n  this._consuming = false;\\n\\n  // flag for when we decide that this message cannot possibly be\\n  // read by the user, so there's no point continuing to handle it.\\n  this._dumped = false;\\n}\\nutil.inherits(IncomingMessage, Stream.Readable);\\n\\n\\nexports.IncomingMessage = IncomingMessage;\\n\\n\\nIncomingMessage.prototype.setTimeout = function(msecs, callback) {\\n  if (callback)\\n    this.on('timeout', callback);\\n  this.socket.setTimeout(msecs);\\n  return this;\\n};\\n\\n\\nIncomingMessage.prototype.read = function(n) {\\n  this._consuming = true;\\n  this.read = Stream.Readable.prototype.read;\\n  return this.read(n);\\n};\\n\\n\\nIncomingMessage.prototype._read = function(n) {\\n  // We actually do almost nothing here, because the parserOnBody\\n  // function fills up our internal buffer directly.  However, we\\n  // do need to unpause the underlying socket so that it flows.\\n  if (this.socket.readable)\\n    readStart(this.socket);\\n};\\n\\n\\n// It's possible that the socket will be destroyed, and removed from\\n// any messages, before ever calling this.  In that case, just skip\\n// it, since something else is destroying this connection anyway.\\nIncomingMessage.prototype.destroy = function(error) {\\n  if (this.socket)\\n    this.socket.destroy(error);\\n};\\n\\n\\nIncomingMessage.prototype._addHeaderLines = function(headers, n) {\\n  if (headers && headers.length) {\\n    var raw, dest;\\n    if (this.complete) {\\n      raw = this.rawTrailers;\\n      dest = this.trailers;\\n    } else {\\n      raw = this.rawHeaders;\\n      dest = this.headers;\\n    }\\n\\n    for (var i = 0; i < n; i += 2) {\\n      var k = headers[i];\\n      var v = headers[i + 1];\\n      raw.push(k);\\n      raw.push(v);\\n      this._addHeaderLine(k, v, dest);\\n    }\\n  }\\n};\\n\\n\\n// Add the given (field, value) pair to the message\\n//\\n// Per RFC2616, section 4.2 it is acceptable to join multiple instances of the\\n// same header with a ', ' if the header in question supports specification of\\n// multiple values this way. If not, we declare the first instance the winner\\n// and drop the second. Extended header fields (those beginning with 'x-') are\\n// always joined.\\nIncomingMessage.prototype._addHeaderLine = function(field, value, dest) {\\n  field = field.toLowerCase();\\n  switch (field) {\\n    // Array headers:\\n    case 'set-cookie':\\n      if (dest[field] !== undefined) {\\n        dest[field].push(value);\\n      } else {\\n        dest[field] = [value];\\n      }\\n      break;\\n\\n    /* eslint-disable max-len */\\n    // list is taken from:\\n    // https://mxr.mozilla.org/mozilla/source/netwerk/protocol/http/src/nsHttpHeaderArray.cpp\\n    /* eslint-enable max-len */\\n    case 'content-type':\\n    case 'content-length':\\n    case 'user-agent':\\n    case 'referer':\\n    case 'host':\\n    case 'authorization':\\n    case 'proxy-authorization':\\n    case 'if-modified-since':\\n    case 'if-unmodified-since':\\n    case 'from':\\n    case 'location':\\n    case 'max-forwards':\\n    case 'retry-after':\\n    case 'etag':\\n    case 'last-modified':\\n    case 'server':\\n    case 'age':\\n    case 'expires':\\n      // drop duplicates\\n      if (dest[field] === undefined)\\n        dest[field] = value;\\n      break;\\n\\n    default:\\n      // make comma-separated list\\n      if (dest[field] !== undefined) {\\n        dest[field] += ', ' + value;\\n      } else {\\n        dest[field] = value;\\n      }\\n  }\\n};\\n\\n\\n// Call this instead of resume() if we want to just\\n// dump all the data to /dev/null\\nIncomingMessage.prototype._dump = function() {\\n  if (!this._dumped) {\\n    this._dumped = true;\\n    this.resume();\\n  }\\n};\\n\",\"_http_outgoing\":\"'use strict';\\n\\nvar assert = require('assert').ok;\\nvar Stream = require('stream');\\nvar timers = require('timers');\\nvar util = require('util');\\nvar internalUtil = require('internal/util');\\nvar Buffer = require('buffer').Buffer;\\nvar common = require('_http_common');\\n\\nvar CRLF = common.CRLF;\\nvar chunkExpression = common.chunkExpression;\\nvar debug = common.debug;\\n\\nvar connectionExpression = /^Connection$/i;\\nvar transferEncodingExpression = /^Transfer-Encoding$/i;\\nvar closeExpression = /close/i;\\nvar contentLengthExpression = /^Content-Length$/i;\\nvar dateExpression = /^Date$/i;\\nvar expectExpression = /^Expect$/i;\\nvar trailerExpression = /^Trailer$/i;\\n\\nvar automaticHeaders = {\\n  connection: true,\\n  'content-length': true,\\n  'transfer-encoding': true,\\n  date: true\\n};\\n\\n\\nvar dateCache;\\nfunction utcDate() {\\n  if (!dateCache) {\\n    var d = new Date();\\n    dateCache = d.toUTCString();\\n    timers.enroll(utcDate, 1000 - d.getMilliseconds());\\n    timers._unrefActive(utcDate);\\n  }\\n  return dateCache;\\n}\\nutcDate._onTimeout = function() {\\n  dateCache = undefined;\\n};\\n\\n\\nfunction OutgoingMessage() {\\n  Stream.call(this);\\n\\n  // Queue that holds all currently pending data, until the response will be\\n  // assigned to the socket (until it will its turn in the HTTP pipeline).\\n  this.output = [];\\n  this.outputEncodings = [];\\n  this.outputCallbacks = [];\\n\\n  // `outputSize` is an approximate measure of how much data is queued on this\\n  // response. `_onPendingData` will be invoked to update similar global\\n  // per-connection counter. That counter will be used to pause/unpause the\\n  // TCP socket and HTTP Parser and thus handle the backpressure.\\n  this.outputSize = 0;\\n\\n  this.writable = true;\\n\\n  this._last = false;\\n  this.chunkedEncoding = false;\\n  this.shouldKeepAlive = true;\\n  this.useChunkedEncodingByDefault = true;\\n  this.sendDate = false;\\n  this._removedHeader = {};\\n\\n  this._contentLength = null;\\n  this._hasBody = true;\\n  this._trailer = '';\\n\\n  this.finished = false;\\n  this._headerSent = false;\\n\\n  this.socket = null;\\n  this.connection = null;\\n  this._header = null;\\n  this._headers = null;\\n  this._headerNames = {};\\n\\n  this._onPendingData = null;\\n}\\nutil.inherits(OutgoingMessage, Stream);\\n\\n\\nexports.OutgoingMessage = OutgoingMessage;\\n\\n\\nOutgoingMessage.prototype.setTimeout = function(msecs, callback) {\\n\\n  if (callback) {\\n    this.on('timeout', callback);\\n  }\\n\\n  if (!this.socket) {\\n    this.once('socket', function(socket) {\\n      socket.setTimeout(msecs);\\n    });\\n  } else {\\n    this.socket.setTimeout(msecs);\\n  }\\n  return this;\\n};\\n\\n\\n// It's possible that the socket will be destroyed, and removed from\\n// any messages, before ever calling this.  In that case, just skip\\n// it, since something else is destroying this connection anyway.\\nOutgoingMessage.prototype.destroy = function(error) {\\n  if (this.socket)\\n    this.socket.destroy(error);\\n  else\\n    this.once('socket', function(socket) {\\n      socket.destroy(error);\\n    });\\n};\\n\\n\\n// This abstract either writing directly to the socket or buffering it.\\nOutgoingMessage.prototype._send = function(data, encoding, callback) {\\n  // This is a shameful hack to get the headers and first body chunk onto\\n  // the same packet. Future versions of Node are going to take care of\\n  // this at a lower level and in a more general way.\\n  if (!this._headerSent) {\\n    if (typeof data === 'string' &&\\n        encoding !== 'hex' &&\\n        encoding !== 'base64') {\\n      data = this._header + data;\\n    } else {\\n      this.output.unshift(this._header);\\n      this.outputEncodings.unshift('binary');\\n      this.outputCallbacks.unshift(null);\\n      this.outputSize += this._header.length;\\n      if (typeof this._onPendingData === 'function')\\n        this._onPendingData(this._header.length);\\n    }\\n    this._headerSent = true;\\n  }\\n  return this._writeRaw(data, encoding, callback);\\n};\\n\\n\\nOutgoingMessage.prototype._writeRaw = function(data, encoding, callback) {\\n  if (typeof encoding === 'function') {\\n    callback = encoding;\\n    encoding = null;\\n  }\\n\\n  var connection = this.connection;\\n  if (connection &&\\n      connection._httpMessage === this &&\\n      connection.writable &&\\n      !connection.destroyed) {\\n    // There might be pending data in the this.output buffer.\\n    var outputLength = this.output.length;\\n    if (outputLength > 0) {\\n      this._flushOutput(connection);\\n    } else if (data.length === 0) {\\n      if (typeof callback === 'function')\\n        process.nextTick(callback);\\n      return true;\\n    }\\n\\n    // Directly write to socket.\\n    return connection.write(data, encoding, callback);\\n  } else if (connection && connection.destroyed) {\\n    // The socket was destroyed.  If we're still trying to write to it,\\n    // then we haven't gotten the 'close' event yet.\\n    return false;\\n  } else {\\n    // buffer, as long as we're not destroyed.\\n    return this._buffer(data, encoding, callback);\\n  }\\n};\\n\\n\\nOutgoingMessage.prototype._buffer = function(data, encoding, callback) {\\n  this.output.push(data);\\n  this.outputEncodings.push(encoding);\\n  this.outputCallbacks.push(callback);\\n  this.outputSize += data.length;\\n  if (typeof this._onPendingData === 'function')\\n    this._onPendingData(data.length);\\n  return false;\\n};\\n\\n\\nOutgoingMessage.prototype._storeHeader = function(firstLine, headers) {\\n  // firstLine in the case of request is: 'GET /index.html HTTP/1.1\\\\r\\\\n'\\n  // in the case of response it is: 'HTTP/1.1 200 OK\\\\r\\\\n'\\n  var state = {\\n    sentConnectionHeader: false,\\n    sentContentLengthHeader: false,\\n    sentTransferEncodingHeader: false,\\n    sentDateHeader: false,\\n    sentExpect: false,\\n    sentTrailer: false,\\n    messageHeader: firstLine\\n  };\\n\\n  if (headers) {\\n    var keys = Object.keys(headers);\\n    var isArray = Array.isArray(headers);\\n    var field, value;\\n\\n    for (var i = 0, l = keys.length; i < l; i++) {\\n      var key = keys[i];\\n      if (isArray) {\\n        field = headers[key][0];\\n        value = headers[key][1];\\n      } else {\\n        field = key;\\n        value = headers[key];\\n      }\\n\\n      if (Array.isArray(value)) {\\n        for (var j = 0; j < value.length; j++) {\\n          storeHeader(this, state, field, value[j]);\\n        }\\n      } else {\\n        storeHeader(this, state, field, value);\\n      }\\n    }\\n  }\\n\\n  // Date header\\n  if (this.sendDate === true && state.sentDateHeader === false) {\\n    state.messageHeader += 'Date: ' + utcDate() + CRLF;\\n  }\\n\\n  // Force the connection to close when the response is a 204 No Content or\\n  // a 304 Not Modified and the user has set a \\\"Transfer-Encoding: chunked\\\"\\n  // header.\\n  //\\n  // RFC 2616 mandates that 204 and 304 responses MUST NOT have a body but\\n  // node.js used to send out a zero chunk anyway to accommodate clients\\n  // that don't have special handling for those responses.\\n  //\\n  // It was pointed out that this might confuse reverse proxies to the point\\n  // of creating security liabilities, so suppress the zero chunk and force\\n  // the connection to close.\\n  var statusCode = this.statusCode;\\n  if ((statusCode === 204 || statusCode === 304) &&\\n      this.chunkedEncoding === true) {\\n    debug(statusCode + ' response should not use chunked encoding,' +\\n          ' closing connection.');\\n    this.chunkedEncoding = false;\\n    this.shouldKeepAlive = false;\\n  }\\n\\n  // keep-alive logic\\n  if (this._removedHeader.connection) {\\n    this._last = true;\\n    this.shouldKeepAlive = false;\\n  } else if (state.sentConnectionHeader === false) {\\n    var shouldSendKeepAlive = this.shouldKeepAlive &&\\n        (state.sentContentLengthHeader ||\\n         this.useChunkedEncodingByDefault ||\\n         this.agent);\\n    if (shouldSendKeepAlive) {\\n      state.messageHeader += 'Connection: keep-alive\\\\r\\\\n';\\n    } else {\\n      this._last = true;\\n      state.messageHeader += 'Connection: close\\\\r\\\\n';\\n    }\\n  }\\n\\n  if (state.sentContentLengthHeader === false &&\\n      state.sentTransferEncodingHeader === false) {\\n    if (!this._hasBody) {\\n      // Make sure we don't end the 0\\\\r\\\\n\\\\r\\\\n at the end of the message.\\n      this.chunkedEncoding = false;\\n    } else if (!this.useChunkedEncodingByDefault) {\\n      this._last = true;\\n    } else {\\n      if (!state.sentTrailer &&\\n          !this._removedHeader['content-length'] &&\\n          typeof this._contentLength === 'number') {\\n        state.messageHeader += 'Content-Length: ' + this._contentLength +\\n                               '\\\\r\\\\n';\\n      } else if (!this._removedHeader['transfer-encoding']) {\\n        state.messageHeader += 'Transfer-Encoding: chunked\\\\r\\\\n';\\n        this.chunkedEncoding = true;\\n      } else {\\n        // We should only be able to get here if both Content-Length and\\n        // Transfer-Encoding are removed by the user.\\n        // See: test/parallel/test-http-remove-header-stays-removed.js\\n        debug('Both Content-Length and Transfer-Encoding are removed');\\n      }\\n    }\\n  }\\n\\n  this._header = state.messageHeader + CRLF;\\n  this._headerSent = false;\\n\\n  // wait until the first body chunk, or close(), is sent to flush,\\n  // UNLESS we're sending Expect: 100-continue.\\n  if (state.sentExpect) this._send('');\\n};\\n\\nfunction storeHeader(self, state, field, value) {\\n  if (!common._checkIsHttpToken(field)) {\\n    throw new TypeError(\\n      'Header name must be a valid HTTP Token [\\\"' + field + '\\\"]');\\n  }\\n  value = escapeHeaderValue(value);\\n  state.messageHeader += field + ': ' + value + CRLF;\\n\\n  if (connectionExpression.test(field)) {\\n    state.sentConnectionHeader = true;\\n    if (closeExpression.test(value)) {\\n      self._last = true;\\n    } else {\\n      self.shouldKeepAlive = true;\\n    }\\n\\n  } else if (transferEncodingExpression.test(field)) {\\n    state.sentTransferEncodingHeader = true;\\n    if (chunkExpression.test(value)) self.chunkedEncoding = true;\\n\\n  } else if (contentLengthExpression.test(field)) {\\n    state.sentContentLengthHeader = true;\\n  } else if (dateExpression.test(field)) {\\n    state.sentDateHeader = true;\\n  } else if (expectExpression.test(field)) {\\n    state.sentExpect = true;\\n  } else if (trailerExpression.test(field)) {\\n    state.sentTrailer = true;\\n  }\\n}\\n\\n\\nOutgoingMessage.prototype.setHeader = function(name, value) {\\n  if (!common._checkIsHttpToken(name))\\n    throw new TypeError(\\n      'Header name must be a valid HTTP Token [\\\"' + name + '\\\"]');\\n  if (typeof name !== 'string')\\n    throw new TypeError('\\\"name\\\" should be a string in setHeader(name, value)');\\n  if (value === undefined)\\n    throw new Error('\\\"value\\\" required in setHeader(\\\"' + name + '\\\", value)');\\n  if (this._header)\\n    throw new Error('Can\\\\'t set headers after they are sent');\\n\\n  if (this._headers === null)\\n    this._headers = {};\\n\\n  var key = name.toLowerCase();\\n  this._headers[key] = value;\\n  this._headerNames[key] = name;\\n\\n  if (automaticHeaders[key])\\n    this._removedHeader[key] = false;\\n};\\n\\n\\nOutgoingMessage.prototype.getHeader = function(name) {\\n  if (arguments.length < 1) {\\n    throw new Error('\\\"name\\\" argument is required for getHeader(name)');\\n  }\\n\\n  if (!this._headers) return;\\n\\n  var key = name.toLowerCase();\\n  return this._headers[key];\\n};\\n\\n\\nOutgoingMessage.prototype.removeHeader = function(name) {\\n  if (arguments.length < 1) {\\n    throw new Error('\\\"name\\\" argument is required for removeHeader(name)');\\n  }\\n\\n  if (this._header) {\\n    throw new Error('Can\\\\'t remove headers after they are sent');\\n  }\\n\\n  var key = name.toLowerCase();\\n\\n  if (key === 'date')\\n    this.sendDate = false;\\n  else if (automaticHeaders[key])\\n    this._removedHeader[key] = true;\\n\\n  if (this._headers) {\\n    delete this._headers[key];\\n    delete this._headerNames[key];\\n  }\\n};\\n\\n\\nOutgoingMessage.prototype._renderHeaders = function() {\\n  if (this._header) {\\n    throw new Error('Can\\\\'t render headers after they are sent to the client');\\n  }\\n\\n  var headersMap = this._headers;\\n  if (!headersMap) return {};\\n\\n  var headers = {};\\n  var keys = Object.keys(headersMap);\\n  var headerNames = this._headerNames;\\n\\n  for (var i = 0, l = keys.length; i < l; i++) {\\n    var key = keys[i];\\n    headers[headerNames[key]] = headersMap[key];\\n  }\\n  return headers;\\n};\\n\\n\\nObject.defineProperty(OutgoingMessage.prototype, 'headersSent', {\\n  configurable: true,\\n  enumerable: true,\\n  get: function() { return !!this._header; }\\n});\\n\\n\\nOutgoingMessage.prototype.write = function(chunk, encoding, callback) {\\n  if (this.finished) {\\n    var err = new Error('write after end');\\n    process.nextTick(writeAfterEndNT, this, err, callback);\\n\\n    return true;\\n  }\\n\\n  if (!this._header) {\\n    this._implicitHeader();\\n  }\\n\\n  if (!this._hasBody) {\\n    debug('This type of response MUST NOT have a body. ' +\\n          'Ignoring write() calls.');\\n    return true;\\n  }\\n\\n  if (typeof chunk !== 'string' && !(chunk instanceof Buffer)) {\\n    throw new TypeError('First argument must be a string or Buffer');\\n  }\\n\\n\\n  // If we get an empty string or buffer, then just do nothing, and\\n  // signal the user to keep writing.\\n  if (chunk.length === 0) return true;\\n\\n  var len, ret;\\n  if (this.chunkedEncoding) {\\n    if (typeof chunk === 'string' &&\\n        encoding !== 'hex' &&\\n        encoding !== 'base64' &&\\n        encoding !== 'binary') {\\n      len = Buffer.byteLength(chunk, encoding);\\n      chunk = len.toString(16) + CRLF + chunk + CRLF;\\n      ret = this._send(chunk, encoding, callback);\\n    } else {\\n      // buffer, or a non-toString-friendly encoding\\n      if (typeof chunk === 'string')\\n        len = Buffer.byteLength(chunk, encoding);\\n      else\\n        len = chunk.length;\\n\\n      if (this.connection && !this.connection.corked) {\\n        this.connection.cork();\\n        process.nextTick(connectionCorkNT, this.connection);\\n      }\\n      this._send(len.toString(16), 'binary', null);\\n      this._send(crlf_buf, null, null);\\n      this._send(chunk, encoding, null);\\n      ret = this._send(crlf_buf, null, callback);\\n    }\\n  } else {\\n    ret = this._send(chunk, encoding, callback);\\n  }\\n\\n  debug('write ret = ' + ret);\\n  return ret;\\n};\\n\\n\\nfunction writeAfterEndNT(self, err, callback) {\\n  self.emit('error', err);\\n  if (callback) callback(err);\\n}\\n\\n\\nfunction connectionCorkNT(conn) {\\n  if (conn)\\n    conn.uncork();\\n}\\n\\n\\nfunction escapeHeaderValue(value) {\\n  // Protect against response splitting. The regex test is there to\\n  // minimize the performance impact in the common case.\\n  return /[\\\\r\\\\n]/.test(value) ? value.replace(/[\\\\r\\\\n]+[ \\\\t]*/g, '') : value;\\n}\\n\\n\\nOutgoingMessage.prototype.addTrailers = function(headers) {\\n  this._trailer = '';\\n  var keys = Object.keys(headers);\\n  var isArray = Array.isArray(headers);\\n  var field, value;\\n  for (var i = 0, l = keys.length; i < l; i++) {\\n    var key = keys[i];\\n    if (isArray) {\\n      field = headers[key][0];\\n      value = headers[key][1];\\n    } else {\\n      field = key;\\n      value = headers[key];\\n    }\\n    if (!common._checkIsHttpToken(field)) {\\n      throw new TypeError(\\n        'Trailer name must be a valid HTTP Token [\\\"' + field + '\\\"]');\\n    }\\n    this._trailer += field + ': ' + escapeHeaderValue(value) + CRLF;\\n  }\\n};\\n\\n\\nvar crlf_buf = new Buffer('\\\\r\\\\n');\\n\\n\\nOutgoingMessage.prototype.end = function(data, encoding, callback) {\\n  if (typeof data === 'function') {\\n    callback = data;\\n    data = null;\\n  } else if (typeof encoding === 'function') {\\n    callback = encoding;\\n    encoding = null;\\n  }\\n\\n  if (data && typeof data !== 'string' && !(data instanceof Buffer)) {\\n    throw new TypeError('First argument must be a string or Buffer');\\n  }\\n\\n  if (this.finished) {\\n    return false;\\n  }\\n\\n  var self = this;\\n  function finish() {\\n    self.emit('finish');\\n  }\\n\\n  if (typeof callback === 'function')\\n    this.once('finish', callback);\\n\\n  if (!this._header) {\\n    if (data) {\\n      if (typeof data === 'string')\\n        this._contentLength = Buffer.byteLength(data, encoding);\\n      else\\n        this._contentLength = data.length;\\n    } else {\\n      this._contentLength = 0;\\n    }\\n    this._implicitHeader();\\n  }\\n\\n  if (data && !this._hasBody) {\\n    debug('This type of response MUST NOT have a body. ' +\\n          'Ignoring data passed to end().');\\n    data = null;\\n  }\\n\\n  if (this.connection && data)\\n    this.connection.cork();\\n\\n  var ret;\\n  if (data) {\\n    // Normal body write.\\n    this.write(data, encoding);\\n  }\\n\\n  if (this._hasBody && this.chunkedEncoding) {\\n    ret = this._send('0\\\\r\\\\n' + this._trailer + '\\\\r\\\\n', 'binary', finish);\\n  } else {\\n    // Force a flush, HACK.\\n    ret = this._send('', 'binary', finish);\\n  }\\n\\n  if (this.connection && data)\\n    this.connection.uncork();\\n\\n  this.finished = true;\\n\\n  // There is the first message on the outgoing queue, and we've sent\\n  // everything to the socket.\\n  debug('outgoing message end.');\\n  if (this.output.length === 0 &&\\n      this.connection &&\\n      this.connection._httpMessage === this) {\\n    this._finish();\\n  }\\n\\n  return ret;\\n};\\n\\n\\nOutgoingMessage.prototype._finish = function() {\\n  assert(this.connection);\\n  this.emit('prefinish');\\n};\\n\\n\\n// This logic is probably a bit confusing. Let me explain a bit:\\n//\\n// In both HTTP servers and clients it is possible to queue up several\\n// outgoing messages. This is easiest to imagine in the case of a client.\\n// Take the following situation:\\n//\\n//    req1 = client.request('GET', '/');\\n//    req2 = client.request('POST', '/');\\n//\\n// When the user does\\n//\\n//   req2.write('hello world\\\\n');\\n//\\n// it's possible that the first request has not been completely flushed to\\n// the socket yet. Thus the outgoing messages need to be prepared to queue\\n// up data internally before sending it on further to the socket's queue.\\n//\\n// This function, outgoingFlush(), is called by both the Server and Client\\n// to attempt to flush any pending messages out to the socket.\\nOutgoingMessage.prototype._flush = function() {\\n  var socket = this.socket;\\n  var ret;\\n\\n  if (socket && socket.writable) {\\n    // There might be remaining data in this.output; write it out\\n    ret = this._flushOutput(socket);\\n\\n    if (this.finished) {\\n      // This is a queue to the server or client to bring in the next this.\\n      this._finish();\\n    } else if (ret) {\\n      // This is necessary to prevent https from breaking\\n      this.emit('drain');\\n    }\\n  }\\n};\\n\\nOutgoingMessage.prototype._flushOutput = function _flushOutput(socket) {\\n  var ret;\\n  var outputLength = this.output.length;\\n  if (outputLength <= 0)\\n    return ret;\\n\\n  var output = this.output;\\n  var outputEncodings = this.outputEncodings;\\n  var outputCallbacks = this.outputCallbacks;\\n  socket.cork();\\n  for (var i = 0; i < outputLength; i++) {\\n    ret = socket.write(output[i], outputEncodings[i],\\n                       outputCallbacks[i]);\\n  }\\n  socket.uncork();\\n\\n  this.output = [];\\n  this.outputEncodings = [];\\n  this.outputCallbacks = [];\\n  if (typeof this._onPendingData === 'function')\\n    this._onPendingData(-this.outputSize);\\n  this.outputSize = 0;\\n\\n  return ret;\\n};\\n\\n\\nOutgoingMessage.prototype.flushHeaders = function() {\\n  if (!this._header) {\\n    this._implicitHeader();\\n  }\\n\\n  // Force-flush the headers.\\n  this._send('');\\n};\\n\\nOutgoingMessage.prototype.flush = internalUtil.deprecate(function() {\\n  this.flushHeaders();\\n}, 'OutgoingMessage.flush is deprecated. Use flushHeaders instead.');\\n\",\"_http_server\":\"'use strict';\\n\\nvar util = require('util');\\nvar net = require('net');\\nvar EventEmitter = require('events');\\nvar HTTPParser = process.binding('http_parser').HTTPParser;\\nvar assert = require('assert').ok;\\nvar common = require('_http_common');\\nvar parsers = common.parsers;\\nvar freeParser = common.freeParser;\\nvar debug = common.debug;\\nvar CRLF = common.CRLF;\\nvar continueExpression = common.continueExpression;\\nvar chunkExpression = common.chunkExpression;\\nvar httpSocketSetup = common.httpSocketSetup;\\nvar OutgoingMessage = require('_http_outgoing').OutgoingMessage;\\n\\nvar STATUS_CODES = exports.STATUS_CODES = {\\n  100 : 'Continue',\\n  101 : 'Switching Protocols',\\n  102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918\\n  200 : 'OK',\\n  201 : 'Created',\\n  202 : 'Accepted',\\n  203 : 'Non-Authoritative Information',\\n  204 : 'No Content',\\n  205 : 'Reset Content',\\n  206 : 'Partial Content',\\n  207 : 'Multi-Status',               // RFC 4918\\n  208 : 'Already Reported',\\n  226 : 'IM Used',\\n  300 : 'Multiple Choices',\\n  301 : 'Moved Permanently',\\n  302 : 'Found',\\n  303 : 'See Other',\\n  304 : 'Not Modified',\\n  305 : 'Use Proxy',\\n  307 : 'Temporary Redirect',\\n  308 : 'Permanent Redirect',         // RFC 7238\\n  400 : 'Bad Request',\\n  401 : 'Unauthorized',\\n  402 : 'Payment Required',\\n  403 : 'Forbidden',\\n  404 : 'Not Found',\\n  405 : 'Method Not Allowed',\\n  406 : 'Not Acceptable',\\n  407 : 'Proxy Authentication Required',\\n  408 : 'Request Timeout',\\n  409 : 'Conflict',\\n  410 : 'Gone',\\n  411 : 'Length Required',\\n  412 : 'Precondition Failed',\\n  413 : 'Payload Too Large',\\n  414 : 'URI Too Long',\\n  415 : 'Unsupported Media Type',\\n  416 : 'Range Not Satisfiable',\\n  417 : 'Expectation Failed',\\n  418 : 'I\\\\'m a teapot',              // RFC 2324\\n  421 : 'Misdirected Request',\\n  422 : 'Unprocessable Entity',       // RFC 4918\\n  423 : 'Locked',                     // RFC 4918\\n  424 : 'Failed Dependency',          // RFC 4918\\n  425 : 'Unordered Collection',       // RFC 4918\\n  426 : 'Upgrade Required',           // RFC 2817\\n  428 : 'Precondition Required',      // RFC 6585\\n  429 : 'Too Many Requests',          // RFC 6585\\n  431 : 'Request Header Fields Too Large',// RFC 6585\\n  500 : 'Internal Server Error',\\n  501 : 'Not Implemented',\\n  502 : 'Bad Gateway',\\n  503 : 'Service Unavailable',\\n  504 : 'Gateway Timeout',\\n  505 : 'HTTP Version Not Supported',\\n  506 : 'Variant Also Negotiates',    // RFC 2295\\n  507 : 'Insufficient Storage',       // RFC 4918\\n  508 : 'Loop Detected',\\n  509 : 'Bandwidth Limit Exceeded',\\n  510 : 'Not Extended',               // RFC 2774\\n  511 : 'Network Authentication Required' // RFC 6585\\n};\\n\\nvar kOnExecute = HTTPParser.kOnExecute | 0;\\n\\n\\nfunction ServerResponse(req) {\\n  OutgoingMessage.call(this);\\n\\n  if (req.method === 'HEAD') this._hasBody = false;\\n\\n  this.sendDate = true;\\n\\n  if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {\\n    this.useChunkedEncodingByDefault = chunkExpression.test(req.headers.te);\\n    this.shouldKeepAlive = false;\\n  }\\n}\\nutil.inherits(ServerResponse, OutgoingMessage);\\n\\nServerResponse.prototype._finish = function() {\\n  DTRACE_HTTP_SERVER_RESPONSE(this.connection);\\n  LTTNG_HTTP_SERVER_RESPONSE(this.connection);\\n  COUNTER_HTTP_SERVER_RESPONSE();\\n  OutgoingMessage.prototype._finish.call(this);\\n};\\n\\n\\nexports.ServerResponse = ServerResponse;\\n\\nServerResponse.prototype.statusCode = 200;\\nServerResponse.prototype.statusMessage = undefined;\\n\\nfunction onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n}\\n\\nServerResponse.prototype.assignSocket = function(socket) {\\n  assert(!socket._httpMessage);\\n  socket._httpMessage = this;\\n  socket.on('close', onServerResponseClose);\\n  this.socket = socket;\\n  this.connection = socket;\\n  this.emit('socket', socket);\\n  this._flush();\\n};\\n\\nServerResponse.prototype.detachSocket = function(socket) {\\n  assert(socket._httpMessage === this);\\n  socket.removeListener('close', onServerResponseClose);\\n  socket._httpMessage = null;\\n  this.socket = this.connection = null;\\n};\\n\\nServerResponse.prototype.writeContinue = function(cb) {\\n  this._writeRaw('HTTP/1.1 100 Continue' + CRLF + CRLF, 'ascii', cb);\\n  this._sent100 = true;\\n};\\n\\nServerResponse.prototype._implicitHeader = function() {\\n  this.writeHead(this.statusCode);\\n};\\n\\nServerResponse.prototype.writeHead = function(statusCode, reason, obj) {\\n  var headers;\\n\\n  if (typeof reason === 'string') {\\n    // writeHead(statusCode, reasonPhrase[, headers])\\n    this.statusMessage = reason;\\n  } else {\\n    // writeHead(statusCode[, headers])\\n    this.statusMessage =\\n        this.statusMessage || STATUS_CODES[statusCode] || 'unknown';\\n    obj = reason;\\n  }\\n  this.statusCode = statusCode;\\n\\n  if (this._headers) {\\n    // Slow-case: when progressive API and header fields are passed.\\n    if (obj) {\\n      var keys = Object.keys(obj);\\n      for (var i = 0; i < keys.length; i++) {\\n        var k = keys[i];\\n        if (k) this.setHeader(k, obj[k]);\\n      }\\n    }\\n    // only progressive api is used\\n    headers = this._renderHeaders();\\n  } else {\\n    // only writeHead() called\\n    headers = obj;\\n  }\\n\\n  var statusLine = 'HTTP/1.1 ' + statusCode.toString() + ' ' +\\n                   this.statusMessage + CRLF;\\n\\n  if (statusCode === 204 || statusCode === 304 ||\\n      (100 <= statusCode && statusCode <= 199)) {\\n    // RFC 2616, 10.2.5:\\n    // The 204 response MUST NOT include a message-body, and thus is always\\n    // terminated by the first empty line after the header fields.\\n    // RFC 2616, 10.3.5:\\n    // The 304 response MUST NOT contain a message-body, and thus is always\\n    // terminated by the first empty line after the header fields.\\n    // RFC 2616, 10.1 Informational 1xx:\\n    // This class of status code indicates a provisional response,\\n    // consisting only of the Status-Line and optional headers, and is\\n    // terminated by an empty line.\\n    this._hasBody = false;\\n  }\\n\\n  // don't keep alive connections where the client expects 100 Continue\\n  // but we sent a final status; they may put extra bytes on the wire.\\n  if (this._expect_continue && !this._sent100) {\\n    this.shouldKeepAlive = false;\\n  }\\n\\n  this._storeHeader(statusLine, headers);\\n};\\n\\nServerResponse.prototype.writeHeader = function() {\\n  this.writeHead.apply(this, arguments);\\n};\\n\\n\\nfunction Server(requestListener) {\\n  if (!(this instanceof Server)) return new Server(requestListener);\\n  net.Server.call(this, { allowHalfOpen: true });\\n\\n  if (requestListener) {\\n    this.addListener('request', requestListener);\\n  }\\n\\n  /* eslint-disable max-len */\\n  // Similar option to this. Too lazy to write my own docs.\\n  // http://www.squid-cache.org/Doc/config/half_closed_clients/\\n  // http://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\\n  /* eslint-enable max-len */\\n  this.httpAllowHalfOpen = false;\\n\\n  this.addListener('connection', connectionListener);\\n\\n  this.addListener('clientError', function(err, conn) {\\n    conn.destroy(err);\\n  });\\n\\n  this.timeout = 2 * 60 * 1000;\\n\\n  this._pendingResponseData = 0;\\n}\\nutil.inherits(Server, net.Server);\\n\\n\\nServer.prototype.setTimeout = function(msecs, callback) {\\n  this.timeout = msecs;\\n  if (callback)\\n    this.on('timeout', callback);\\n  return this;\\n};\\n\\n\\nexports.Server = Server;\\n\\n\\nfunction connectionListener(socket) {\\n  var self = this;\\n  var outgoing = [];\\n  var incoming = [];\\n  var outgoingData = 0;\\n\\n  function updateOutgoingData(delta) {\\n    // `outgoingData` is an approximate amount of bytes queued through all\\n    // inactive responses. If more data than the high watermark is queued - we\\n    // need to pause TCP socket/HTTP parser, and wait until the data will be\\n    // sent to the client.\\n    outgoingData += delta;\\n    if (socket._paused && outgoingData < socket._writableState.highWaterMark)\\n      return socketOnDrain();\\n  }\\n\\n  function abortIncoming() {\\n    while (incoming.length) {\\n      var req = incoming.shift();\\n      req.emit('aborted');\\n      req.emit('close');\\n    }\\n    // abort socket._httpMessage ?\\n  }\\n\\n  function serverSocketCloseListener() {\\n    debug('server socket close');\\n    // mark this parser as reusable\\n    if (this.parser) {\\n      freeParser(this.parser, null, this);\\n    }\\n\\n    abortIncoming();\\n  }\\n\\n  debug('SERVER new http connection');\\n\\n  httpSocketSetup(socket);\\n\\n  // If the user has added a listener to the server,\\n  // request, or response, then it's their responsibility.\\n  // otherwise, destroy on timeout by default\\n  if (self.timeout)\\n    socket.setTimeout(self.timeout);\\n  socket.on('timeout', function() {\\n    var req = socket.parser && socket.parser.incoming;\\n    var reqTimeout = req && !req.complete && req.emit('timeout', socket);\\n    var res = socket._httpMessage;\\n    var resTimeout = res && res.emit('timeout', socket);\\n    var serverTimeout = self.emit('timeout', socket);\\n\\n    if (!reqTimeout && !resTimeout && !serverTimeout)\\n      socket.destroy();\\n  });\\n\\n  var parser = parsers.alloc();\\n  parser.reinitialize(HTTPParser.REQUEST);\\n  parser.socket = socket;\\n  socket.parser = parser;\\n  parser.incoming = null;\\n\\n  // Propagate headers limit from server instance to parser\\n  if (typeof this.maxHeadersCount === 'number') {\\n    parser.maxHeaderPairs = this.maxHeadersCount << 1;\\n  } else {\\n    // Set default value because parser may be reused from FreeList\\n    parser.maxHeaderPairs = 2000;\\n  }\\n\\n  socket.addListener('error', socketOnError);\\n  socket.addListener('close', serverSocketCloseListener);\\n  parser.onIncoming = parserOnIncoming;\\n  socket.on('end', socketOnEnd);\\n  socket.on('data', socketOnData);\\n\\n  // We are consuming socket, so it won't get any actual data\\n  socket.on('resume', onSocketResume);\\n  socket.on('pause', onSocketPause);\\n\\n  socket.on('drain', socketOnDrain);\\n\\n  // Override on to unconsume on `data`, `readable` listeners\\n  socket.on = socketOnWrap;\\n\\n  var external = socket._handle._externalStream;\\n  if (external) {\\n    parser._consumed = true;\\n    parser.consume(external);\\n  }\\n  external = null;\\n  parser[kOnExecute] = onParserExecute;\\n\\n  // TODO(isaacs): Move all these functions out of here\\n  function socketOnError(e) {\\n    self.emit('clientError', e, this);\\n  }\\n\\n  function socketOnData(d) {\\n    assert(!socket._paused);\\n    debug('SERVER socketOnData %d', d.length);\\n    var ret = parser.execute(d);\\n\\n    onParserExecuteCommon(ret, d);\\n  }\\n\\n  function onParserExecute(ret, d) {\\n    debug('SERVER socketOnParserExecute %d', ret);\\n    onParserExecuteCommon(ret, undefined);\\n  }\\n\\n  function onParserExecuteCommon(ret, d) {\\n    if (ret instanceof Error) {\\n      debug('parse error');\\n      socket.destroy(ret);\\n    } else if (parser.incoming && parser.incoming.upgrade) {\\n      // Upgrade or CONNECT\\n      var bytesParsed = ret;\\n      var req = parser.incoming;\\n      debug('SERVER upgrade or connect', req.method);\\n\\n      if (!d)\\n        d = parser.getCurrentBuffer();\\n\\n      socket.removeListener('data', socketOnData);\\n      socket.removeListener('end', socketOnEnd);\\n      socket.removeListener('close', serverSocketCloseListener);\\n      unconsume(parser, socket);\\n      parser.finish();\\n      freeParser(parser, req, null);\\n      parser = null;\\n\\n      var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\\n      if (EventEmitter.listenerCount(self, eventName) > 0) {\\n        debug('SERVER have listener for %s', eventName);\\n        var bodyHead = d.slice(bytesParsed, d.length);\\n\\n        // TODO(isaacs): Need a way to reset a stream to fresh state\\n        // IE, not flowing, and not explicitly paused.\\n        socket._readableState.flowing = null;\\n        self.emit(eventName, req, socket, bodyHead);\\n      } else {\\n        // Got upgrade header or CONNECT method, but have no handler.\\n        socket.destroy();\\n      }\\n    }\\n\\n    if (socket._paused && socket.parser) {\\n      // onIncoming paused the socket, we should pause the parser as well\\n      debug('pause parser');\\n      socket.parser.pause();\\n    }\\n  }\\n\\n  function socketOnEnd() {\\n    var socket = this;\\n    var ret = parser.finish();\\n\\n    if (ret instanceof Error) {\\n      debug('parse error');\\n      socket.destroy(ret);\\n      return;\\n    }\\n\\n    if (!self.httpAllowHalfOpen) {\\n      abortIncoming();\\n      if (socket.writable) socket.end();\\n    } else if (outgoing.length) {\\n      outgoing[outgoing.length - 1]._last = true;\\n    } else if (socket._httpMessage) {\\n      socket._httpMessage._last = true;\\n    } else {\\n      if (socket.writable) socket.end();\\n    }\\n  }\\n\\n\\n  // The following callback is issued after the headers have been read on a\\n  // new message. In this callback we setup the response object and pass it\\n  // to the user.\\n\\n  socket._paused = false;\\n  function socketOnDrain() {\\n    var needPause = outgoingData > socket._writableState.highWaterMark;\\n\\n    // If we previously paused, then start reading again.\\n    if (socket._paused && !needPause) {\\n      socket._paused = false;\\n      if (socket.parser)\\n        socket.parser.resume();\\n      socket.resume();\\n    }\\n  }\\n\\n  function parserOnIncoming(req, shouldKeepAlive) {\\n    incoming.push(req);\\n\\n    // If the writable end isn't consuming, then stop reading\\n    // so that we don't become overwhelmed by a flood of\\n    // pipelined requests that may never be resolved.\\n    if (!socket._paused) {\\n      var needPause = socket._writableState.needDrain ||\\n          outgoingData >= socket._writableState.highWaterMark;\\n      if (needPause) {\\n        socket._paused = true;\\n        // We also need to pause the parser, but don't do that until after\\n        // the call to execute, because we may still be processing the last\\n        // chunk.\\n        socket.pause();\\n      }\\n    }\\n\\n    var res = new ServerResponse(req);\\n    res._onPendingData = updateOutgoingData;\\n\\n    res.shouldKeepAlive = shouldKeepAlive;\\n    DTRACE_HTTP_SERVER_REQUEST(req, socket);\\n    LTTNG_HTTP_SERVER_REQUEST(req, socket);\\n    COUNTER_HTTP_SERVER_REQUEST();\\n\\n    if (socket._httpMessage) {\\n      // There are already pending outgoing res, append.\\n      outgoing.push(res);\\n    } else {\\n      res.assignSocket(socket);\\n    }\\n\\n    // When we're finished writing the response, check if this is the last\\n    // respose, if so destroy the socket.\\n    res.on('finish', resOnFinish);\\n    function resOnFinish() {\\n      // Usually the first incoming element should be our request.  it may\\n      // be that in the case abortIncoming() was called that the incoming\\n      // array will be empty.\\n      assert(incoming.length === 0 || incoming[0] === req);\\n\\n      incoming.shift();\\n\\n      // if the user never called req.read(), and didn't pipe() or\\n      // .resume() or .on('data'), then we call req._dump() so that the\\n      // bytes will be pulled off the wire.\\n      if (!req._consuming && !req._readableState.resumeScheduled)\\n        req._dump();\\n\\n      res.detachSocket(socket);\\n\\n      if (res._last) {\\n        socket.destroySoon();\\n      } else {\\n        // start sending the next message\\n        var m = outgoing.shift();\\n        if (m) {\\n          m.assignSocket(socket);\\n        }\\n      }\\n    }\\n\\n    if (req.headers.expect !== undefined &&\\n        (req.httpVersionMajor == 1 && req.httpVersionMinor == 1) &&\\n        continueExpression.test(req.headers['expect'])) {\\n      res._expect_continue = true;\\n      if (EventEmitter.listenerCount(self, 'checkContinue') > 0) {\\n        self.emit('checkContinue', req, res);\\n      } else {\\n        res.writeContinue();\\n        self.emit('request', req, res);\\n      }\\n    } else {\\n      self.emit('request', req, res);\\n    }\\n    return false; // Not a HEAD response. (Not even a response!)\\n  }\\n}\\nexports._connectionListener = connectionListener;\\n\\nfunction onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n}\\n\\nfunction onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\\n\\nfunction unconsume(parser, socket) {\\n  if (socket._handle) {\\n    if (parser._consumed)\\n      parser.unconsume(socket._handle._externalStream);\\n    parser._consumed = false;\\n    socket.removeListener('pause', onSocketPause);\\n    socket.removeListener('resume', onSocketResume);\\n  }\\n}\\n\\nfunction socketOnWrap(ev, fn) {\\n  var res = net.Socket.prototype.on.call(this, ev, fn);\\n  if (!this.parser) {\\n    this.on = net.Socket.prototype.on;\\n    return res;\\n  }\\n\\n  if (ev === 'data' || ev === 'readable')\\n    unconsume(this.parser, this);\\n\\n  return res;\\n}\\n\",\"internal/freelist\":\"'use strict';\\n\\n// This is a free list to avoid creating so many of the same object.\\nexports.FreeList = function(name, max, constructor) {\\n  this.name = name;\\n  this.constructor = constructor;\\n  this.max = max;\\n  this.list = [];\\n};\\n\\n\\nexports.FreeList.prototype.alloc = function() {\\n  return this.list.length ? this.list.shift() :\\n                            this.constructor.apply(this, arguments);\\n};\\n\\n\\nexports.FreeList.prototype.free = function(obj) {\\n  if (this.list.length < this.max) {\\n    this.list.push(obj);\\n    return true;\\n  }\\n  return false;\\n};\\n\",\"timer_wrap\":\"var uv = require('uv');\\n\\nvar kOnTimeout = 'ontimeout';\\n\\nfunction Timer() {\\n\\tvar handle = uv.new_timer();\\n\\n\\tObject.defineProperty(this, \\\"_handle\\\", {\\n\\t\\tenumerable: false,\\n\\t\\twritable: true\\n\\t});\\n\\n\\tthis._handle = handle;\\n\\treturn this;\\n}\\n\\nTimer.kOnTimeout = kOnTimeout;\\n\\nTimer.prototype.start  = function (timeout, repeat) {\\n\\tvar handle = this._handle;\\n\\tuv.timer_start(handle, timeout, repeat || -1, OnTimeout.bind(this));\\n};\\n\\nTimer.prototype.stop  = function (timeout, repeat) {\\n\\tvar handle = this._handle;\\n\\tuv.timer_stop(handle);\\n};\\n\\nTimer.prototype.close = function(cb){\\n\\tuv.handle_close(this._handle, cb);\\n};\\n\\nTimer.prototype.unref = function(){\\n\\tuv.unref(this._handle);\\n};\\n\\nTimer.prototype.ref = function(){\\n\\tuv.ref(this._handle);\\n};\\n\\nTimer.now = function () {\\n\\tvar now = uv.update_time();\\n\\tif (uv.now){\\n\\t\\treturn uv.now();\\n\\t}\\n\\treturn now;\\n};\\n\\nfunction OnTimeout (handle) {\\n\\tvar wrap = this;\\n\\tprocess.MakeCallback(wrap, kOnTimeout);\\n}\\n\\nmodule.exports = {\\n\\tTimer : Timer,\\n\\tkOnTimeout : Timer.kOnTimeout\\n};\\n\",\"buffer_wrap\":\"var binding = process.binding('buffer');\\nvar _bufferPrototype;\\n\\nfunction _enc (enc){\\n\\treturn binding.encodings[enc] || 3;\\n}\\n\\nexports.setupBufferJS = function(proto, obj){\\n\\t_bufferPrototype = proto;\\n\\n\\tproto.hexSlice     = binding.hexSlice;\\n\\tproto.asciiSlice   = binding.asciiSlice;\\n\\tproto.base64Slice  = binding.base64Slice;\\n\\tproto.binarySlice  = binding.asciiSlice;\\n\\tproto.utf8Slice    = binding.utf8Slice;\\n\\tproto.ucs2Slice    = binding.ucs2Slice;\\n\\n\\t// proto.utf8Slice    = function(s,e){\\n\\t// \\treturn NODE_BUFFER.prototype.toString.call(this, 'utf8', s, e);\\n\\t// };\\n\\n\\tproto.hexWrite = binding.hexWrite;\\n\\tproto.utf8Write = binding.utf8Write;\\n\\tproto.asciiWrite = binding.asciiWrite;\\n\\tproto.binaryWrite = binding.binaryWrite;\\n\\tproto.base64Write = binding.base64Write;\\n\\tproto.ucs2Write   = binding.ucs2Write;\\n\\n\\tproto.foreach = binding.foreach;\\n\\tproto.copy = NODE_BUFFER.prototype.copy;\\n\\n\\tobj.flags = new Uint8Array(1);\\n};\\n\\nexports.createFromString = function(string, encoding){\\n\\tvar enc = _enc(encoding);\\n\\tvar buf = binding.createFromString(string, enc);\\n\\t// buf = new Int32Array(buf, 0, buf.byteLength);\\n\\tObject.setPrototypeOf(buf, _bufferPrototype);\\n\\treturn buf;\\n};\\n\\nexports.createFromArrayBuffer = function(ab){\\n\\tif(!(ab instanceof ArrayBuffer)) throw(\\\"argument is not an ArrayBuffer\\\");\\n\\tvar buf = new Uint8Array(ab, 0, ab.byteLength);\\n\\tObject.setPrototypeOf(buf, _bufferPrototype);\\n\\treturn buf;\\n};\\n\\nexports.fill    = binding.fill;\\nexports.compare = binding.compare;\\n\\nexports.byteLengthUtf8 = binding.byteLengthUtf8;\\nexports.create = binding.create;\\nexports.kMaxLength = binding.kMaxLength;\\n\",\"tcp_wrap\":\"var sock    = process.binding('socket');\\nvar uv      = require('uv');\\nvar errno   = require('errno');\\n\\nexports.TCP = TCP;\\nexports.TCPConnectWrap = TCPConnectWrap;\\n\\nvar MakeCallback = process.MakeCallback;\\n\\nfunction TCPConnectWrap (){}\\n\\nfunction TCP (){\\n\\tthis.writeQueueSize = 0;\\n\\tthis._handle = new uv.TCP();\\n}\\n\\n\\nTCP.prototype.bind6 = TCP.prototype.bind = function(ip, port){\\n\\tvar addr = uv.ip_address(ip, port);\\n\\tif (!addr){\\n\\t\\treturn process.errno;\\n\\t}\\n\\n\\tthis.bindPort = port;\\n\\tthis.bindAddress = ip;\\n\\tvar err = this._handle.bind(addr, 0);\\n\\treturn err;\\n};\\n\\n\\nTCP.prototype.close = function(cb){\\n\\tvar tcp = this;\\n\\tprocess.nextTick(function(){\\n\\t\\ttcp._handle.close(cb);\\n\\t});\\n};\\n\\n\\nTCP.prototype.listen = function(backlog){\\n\\tvar tcp = this;\\n\\t//pass onConnection callback\\n\\treturn this._handle.listen(backlog, function(status){\\n\\t\\tif (!status){\\n\\t\\t\\tclient = new TCP();\\n\\t\\t\\tthis.accept(client._handle);\\n\\t\\t}\\n\\t\\tMakeCallback(tcp, \\\"onconnection\\\", status, client);\\n\\t});\\n};\\n\\n\\nTCP.prototype.readStart = function(){\\n\\tvar tcp = this;\\n\\tthis._handle.read_start(function(err, buf){\\n\\t\\tvar len;\\n\\t\\tif (err){\\n\\t\\t\\tlen = err > 0 ? -err : err;\\n\\t\\t}\\n\\n\\t\\telse if (buf){\\n\\t\\t\\tlen = buf.length;\\n\\t\\t}\\n\\n\\t\\t// nread == 0\\n\\t\\telse { return; }\\n\\t\\tMakeCallback(tcp, \\\"onread\\\", len, buf);\\n\\t});\\n};\\n\\n\\nTCP.prototype.readStop = function(){\\n\\treturn this._handle.read_stop();\\n};\\n\\n\\nTCP.prototype.open = function(fd){\\n\\treturn this._handle.open(fd);\\n};\\n\\n\\nTCP.prototype.setSimultaneousAccepts = function(enable) {\\n\\treturn this._handle.simultaneous_accepts(enable);\\n};\\n\\n\\nTCP.prototype.shutdown = function(req){\\n\\tvar tcp = this;\\n\\tthis._handle.shutdown(function(status){\\n\\t\\tMakeCallback(req, \\\"oncomplete\\\", status, tcp, req);\\n\\t});\\n};\\n\\n\\nTCP.prototype.writeBinaryString = function(req, data){\\n\\tdata = Buffer(data, \\\"binary\\\");\\n\\treturn this.writeUtf8String(req, data.toString(\\\"binary\\\"));\\n};\\n\\n\\nTCP.prototype.writeAsciiString =\\nTCP.prototype.writeBuffer =\\nTCP.prototype.writeUtf8String = function(req, data){\\n\\tvar tcp = this;\\n\\tthis._handle.write(data, function(status){\\n\\t\\ttcp.writeQueueSize = tcp._handle.write_queue_size;\\n\\t\\treq.bytes = this.bytes;\\n\\t\\tMakeCallback(req, \\\"oncomplete\\\", status, tcp, req, 0);\\n\\t});\\n\\n\\treturn 0;\\n};\\n\\n\\nTCP.prototype.connect = function(req_wrap_obj, ip_address, port){\\n\\tvar tcp = this;\\n\\tvar addr = uv.ip_address(ip_address, port);\\n\\tif (addr === null){\\n\\t\\treturn errno.translate(process.errno);\\n\\t}\\n\\n\\tvar err = this._handle.connect(addr, function AfterConnect (status){\\n\\t\\tMakeCallback(req_wrap_obj, \\\"oncomplete\\\", errno.translate(status), tcp, req_wrap_obj, true, true);\\n\\t});\\n\\treturn errno.translate(err);\\n};\\n\\n\\n// TODO: use syscall!!\\n// FIXME: handle errors\\nTCP.prototype.getsockname = function(out){\\n\\tvar addr = sock.getsockname(this._handle.fd);\\n\\tvar info = sock.addr_info(addr);\\n\\tout.address = this.bindAddress || info[0];\\n\\tout.port    = this.bindPort    || info[1];\\n\\tswitch (sock.isIP(out.address)){\\n\\t\\tcase 4 : out.family = 'IPv4'; break;\\n\\t\\tcase 6 : out.family = 'IPv6'; break;\\n\\t\\tdefault : throw new Error('unknown family type');\\n\\t}\\n};\\n\\n\\nTCP.prototype.getpeername = function(out){\\n\\tvar peerinfo = this._handle.getpeername();\\n\\tout.address = peerinfo.ip;\\n\\tout.port = peerinfo.port;\\n\\treturn 0;\\n};\\n\\n\\nTCP.prototype.setKeepAlive = function(){\\n\\t// throw new Error('setKeepAlive');\\n};\\n\\n\\nTCP.prototype.unref = function(){\\n\\tthis._handle.unref();\\n\\treturn 0;\\n};\\n\\n\\nTCP.prototype.ref = function(fd){\\n\\tthis._handle.ref();\\n\\treturn 0;\\n};\\n\",\"stream_wrap\":\"exports.WriteWrap = function(){};\\nexports.ShutdownWrap = function(){};\\n\\n\",\"pipe_wrap\":\"var uv           = require('uv');\\nvar MakeCallback = process.MakeCallback;\\nvar syscall      = require('syscall');\\nvar tcpWrap      = process.binding('tcp_wrap').TCP;\\nvar errno        = require('errno');\\n\\n\\nfunction Pipe(ipc){\\n\\tthis._handle = new uv.Pipe(ipc);\\n}\\n\\n\\nPipe.prototype.close = function(cb){\\n\\tvar pipe = this;\\n\\tpipe._handle.close(cb);\\n};\\n\\n\\nPipe.prototype.readStop = function(){\\n\\tthrow new Error('read stop');\\n\\treturn this._handle.read_stop();\\n};\\n\\n\\nPipe.prototype.writeBuffer =\\nPipe.prototype.writeUtf8String = function(req, data, send_handle){\\n\\tvar stream = this;\\n\\n\\tif (send_handle){\\n\\t\\tsend_handle = send_handle._handle;\\n\\t}\\n\\n\\tthis._handle.write(data, function(status){\\n\\t\\tstream.writeQueueSize = stream._handle.write_queue_size;\\n\\t\\treq.bytes = this.bytes;\\n\\t\\tMakeCallback(req, \\\"oncomplete\\\", status, stream, req, 0);\\n\\t}, send_handle);\\n\\treturn 0;\\n};\\n\\n\\nPipe.prototype.open = function(fd){\\n\\treturn this._handle.open(fd);\\n};\\n\\n\\nPipe.prototype.unref = function(fd){\\n\\tthis._handle.unref();\\n\\treturn 0;\\n};\\n\\n\\nPipe.prototype.ref = function(fd){\\n\\tthis._handle.ref();\\n\\treturn 0;\\n};\\n\\n\\nPipe.prototype.readStart = function(){\\n\\tvar pipe = this;\\n\\n\\tpipe._handle.read_start(function(err, buf){\\n\\t\\tvar handle = pipe._handle;\\n\\n\\t\\t// get pending type\\n\\t\\tvar type   = 'UNKNOWN_HANDLE';\\n\\t\\tif (handle.type === 'NAMED_PIPE' && handle.ipc &&\\n\\t\\t\\tuv.pipe_pending_count(handle) > 0){\\n\\t\\t\\ttype = uv.pipe_handle_type(handle);\\n\\t\\t}\\n\\n\\t\\tvar nread = 0;\\n\\t\\tif (err){\\n\\t\\t\\tnread = err > 0 ? -err : err;\\n\\t\\t}\\n\\n\\t\\telse if (buf){\\n\\t\\t\\tnread = Buffer.byteLength(buf);\\n\\t\\t}\\n\\n\\t\\telse { nread = 0; }\\n\\n\\t\\tif (nread === 0) return;\\n\\n\\t\\tvar pending_object;\\n\\t\\tif (type !== 'UNKNOWN_HANDLE'){\\n\\t\\t\\tpending_object = new tcpWrap();\\n\\t\\t\\tvar ret = this.accept(pending_object._handle);\\n\\t\\t\\tif (ret){\\n\\t\\t\\t\\tthrow new Error(\\\"pending object error\\\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tMakeCallback(pipe, 'onread', nread, Buffer(buf).toString(), pending_object);\\n\\t});\\n};\\n\\nexports.Pipe = Pipe;\\n\",\"fs_wrap\":\"var posix    = process.binding('posix');\\nvar syscall  = require('syscall');\\nvar util     = require('util');\\n\\nvar isWin    = process.platform == 'win32';\\nvar errnoException = require('util')._errnoException;\\n\\nfunction _throw (errno, syscall, path){\\n\\tvar error = errnoException(errno, syscall);\\n\\tif (path) error.path = path.replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\/, '');\\n\\treturn error;\\n}\\n\\nexports.FSReqWrap = function(){};\\n\\nvar statFunction; /* global */\\nexports.FSInitialize = function(fn){\\n\\tstatFunction = fn;\\n};\\n\\n\\nexports.open = function(file, flags, mode, req){\\n\\tvar err = null;\\n\\tvar fd = posix.open(file, flags, mode);\\n\\tif (fd === null){\\n\\t\\terr = _throw(process.errno, 'open', file);\\n\\t} else {\\n\\t\\tvar closefd = isWin ? syscall.GetFdHandle(fd) : fd;\\n\\t\\tif (!syscall.cloexec(closefd, 1)){\\n\\t\\t    err = _throw(process.errno, 'open', file);\\n\\t\\t}\\n\\t}\\n\\n\\tif (req){\\n\\t\\tprocess.nextTick(function(){\\n\\t\\t\\treq.oncomplete(err, fd);\\n\\t\\t});\\n\\t\\treturn;\\n\\t}\\n\\n\\tif (err) throw(err);\\n\\treturn fd;\\n};\\n\\n\\nexports.read = function(fd, buffer, offset, length, position, req){\\n\\toffset = offset || 0;\\n\\tlength = length || buffer.byteLength;\\n\\n\\tvar err;\\n\\tvar nread = posix.read(fd, [buffer, offset], length, position);\\n\\tif (nread === null){\\n\\t\\terr = _throw(process.errno, 'read');\\n\\t}\\n\\n\\tif (req){\\n\\t\\tprocess.nextTick(function(){\\n\\t\\t\\treq.oncomplete(err, nread);\\n\\t\\t});\\n\\t\\treturn;\\n\\t}\\n\\n\\tif (err) throw err;\\n\\treturn nread;\\n};\\n\\n\\nexports.writeBuffers = function(fd, chunks, pos, req){\\n\\tif (req){\\n\\t\\tcb = {};\\n\\t\\tcb.oncomplete = function(err, n){\\n\\t\\t\\tif (err){\\n\\t\\t\\t\\treq.oncomplete(err);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar chunk = chunks.shift();\\n\\t\\t\\tif (!chunk){\\n\\t\\t\\t\\treq.oncomplete(err, n);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\texports.writeBuffer(fd, chunk, 0, chunk.byteLength, pos, cb);\\n\\t\\t};\\n\\n\\t\\tcb.oncomplete(null);\\n\\t\\treturn;\\n\\t}\\n\\n\\tchunks.forEach(function(chunk){\\n\\t\\texports.writeBuffer(fd, chunk, 0, chunk.byteLength, pos);\\n\\t});\\n};\\n\\n\\nexports.writeBuffer = exports.writeString = function(fd, data, offset, length, position, req){\\n\\tvar err;\\n\\tvar buffer;\\n\\n\\tif (util.isBuffer(data)){\\n\\t\\tbuffer = data;\\n\\t\\tif (!util.isNumber(position)){\\n\\t\\t\\tposition = 0;\\n\\t\\t}\\n\\t} else {\\n\\t\\tvar args = [].slice.call(arguments);\\n\\t\\tposition = args[2];\\n\\t\\tif (!util.isNumber(position)){\\n\\t\\t\\tposition = 0;\\n\\t\\t}\\n\\n\\t\\tvar encoding = args[3];\\n\\t\\treq = args[4];\\n\\n\\t\\tif (!util.isString(encoding)){\\n\\t\\t\\tencoding = 'utf8';\\n\\t\\t\\treq = encoding;\\n\\t\\t}\\n\\n\\t\\tbuffer = Buffer(data, encoding);\\n\\t\\tlength = buffer.byteLength;\\n\\t\\toffset = 0;\\n\\t}\\n\\n\\tvar nwritten = posix.writeBuffer(fd, [buffer, offset], length, position);\\n\\tif (nwritten === null){\\n\\t\\terr = _throw(process.errno, 'write');\\n\\t}\\n\\n\\tif (req){\\n\\t\\tprocess.nextTick(function(){\\n\\t\\t\\treq.oncomplete(err, nwritten);\\n\\t\\t});\\n\\t\\treturn;\\n\\t}\\n\\n\\tif (err) throw(err);\\n\\treturn nwritten;\\n};\\n\\n\\nfunction _normalizePath (args){\\n\\tif (typeof args[0] === 'string'){\\n\\targs[0] = args[0].replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\/, '');\\n\\t}\\n\\treturn args;\\n}\\n\\n\\nfunction _normalizeLinkArgs (args) {\\n\\t//src => args[0]\\n\\tif (!util.isString(args[0])){\\n\\t\\tthrow new Error('src path must be a string');\\n\\t}\\n\\n\\t//dest => args[1]\\n\\tif (!util.isString(args[1])){\\n\\t\\tthrow new Error('dest path must be a string');\\n\\t}\\n\\n\\targs[0] = _normalizePath(args[0]);\\n\\targs[1] = _normalizePath(args[1]);\\n\\n\\treturn args;\\n}\\n\\n\\nfunction _checkAccessArgs (args){\\n\\t if (!util.isString(args[0])){\\n\\t\\tthrow new Error(\\\"path must be a string\\\");\\n\\t}\\n\\treturn args;\\n}\\n\\n\\n[\\n\\t['close', 2],\\n\\t['ftruncate', 3],\\n\\t['rmdir', 3],\\n\\t['mkdir', 3],\\n\\t['fchmod', 3],\\n\\t['chmod', 3],\\n\\t['unlink', 2],\\n\\t['symlink', 4],\\n\\t['readdir', 2],\\n\\t['fsync', 2],\\n\\t['link', 3, _normalizeLinkArgs],\\n\\t['access', 3, _checkAccessArgs]\\n].forEach(function(obj){\\n\\tvar fn         = obj[0];\\n\\tvar argsLength = obj[1];\\n\\tvar _normalize = obj[2] || _normalizePath;\\n\\n\\texports[fn] = function(){\\n\\t\\tvar args = [].slice.call(arguments);\\n\\t\\tvar req;\\n\\t\\tvar err = null;\\n\\n\\t\\tif (args.length === argsLength){\\n\\t\\t\\treq = args.pop();\\n\\t\\t}\\n\\n\\t\\t//normalize and or check arguments\\n\\t\\targs = _normalize(args);\\n\\n\\t\\tvar ret = posix[fn].apply(null, args);\\n\\n\\t\\tif (ret === null){\\n\\t\\t\\terr = _throw(process.errno, fn, args[0]);\\n\\t\\t}\\n\\n\\t\\tif (req){\\n\\t\\t\\tprocess.nextTick(function(){\\n\\t\\t\\t\\treq.oncomplete(err, ret);\\n\\t\\t\\t});\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (err) throw err;\\n\\t\\treturn ret;\\n\\t};\\n});\\n\\nexports.fdatasync = exports.fsync;\\n\\n\\n//stat functions\\n['lstat', 'fstat', 'stat'].forEach(function(fn){\\n\\texports[fn] = function(file, req){\\n\\t\\tvar err = null;\\n\\t\\tvar stat;\\n\\n\\t\\tif (typeof file === 'string'){\\n\\t\\t\\tfile = file.replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\/, '');\\n\\t\\t}\\n\\n\\t\\tvar s = posix[fn](file);\\n\\t\\tif (s === null){\\n\\t\\t\\terr = _throw(process.errno, fn, file);\\n\\t\\t}\\n\\n\\t\\tif (s && !err){\\n\\t\\t\\tstat = new statFunction(s.dev,\\n\\t\\t\\t\\ts.mode,\\n\\t\\t\\t\\ts.nlink,\\n\\t\\t\\t\\ts.uid,\\n\\t\\t\\t\\ts.gid,\\n\\t\\t\\t\\ts.rdev,\\n\\t\\t\\t\\ts.blksize,\\n\\t\\t\\t\\ts.ino,\\n\\t\\t\\t\\ts.size,\\n\\t\\t\\t\\ts.blocks,\\n\\t\\t\\t\\ts.atime * 1000, //to millisecond\\n\\t\\t\\t\\ts.mtime * 1000, //to millisecond\\n\\t\\t\\t\\ts.ctime * 1000, //to millisecond\\n\\t\\t\\t\\ts.birthtim_msec\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tif (req){\\n\\t\\t\\tprocess.nextTick(function(){\\n\\t\\t\\t\\treq.oncomplete(err, stat);\\n\\t\\t\\t});\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (err) throw err;\\n\\t\\treturn stat;\\n\\t};\\n});\\n\",\"fs_event_wrap\":\"//empty file\\nmodule.exports = {};\\n\",\"cares_wrap\":\"var sock  = process.binding('socket');\\nvar C       = require('C');\\nvar syscall = require('syscall');\\nvar assert  = require('assert');\\nvar errno = require('errno');\\n\\nexports.QueryReqWrap = function(){};\\nexports.GetAddrInfoReqWrap = function(){};\\n\\n\\nexports.getaddrinfo = function(req, hostname, family, flags){\\n\\n\\tassert(typeof hostname === 'string');\\n\\tswitch (family) {\\n\\t\\tcase 0: family = syscall.AF_UNSPEC; break;\\n\\t\\tcase 4: family = syscall.AF_INET;   break;\\n\\t\\tcase 6: family = syscall.AF_INET6;  break;\\n\\t\\tdefault: throw new Error (\\\"bad address family\\\");\\n\\t}\\n\\n\\tvar hints = new C.Struct.addrinfo();\\n\\thints.ai_family   = family;\\n\\thints.ai_socktype = syscall.SOCK_STREAM;\\n\\thints.ai_flags    = flags;\\n\\n\\tvar result = C.void();\\n\\n\\t// TODO in thread\\n\\tvar status = syscall.getaddrinfo(hostname, null /* service */, hints, result);\\n\\n\\tvar addrs = [];\\n\\tif (status === 0){ //success\\n\\t\\tvar freePTR = result.ptr;\\n\\t\\tvar info;\\n\\n\\t\\t// Iterate over the IPv4\\n\\t\\tresult = freePTR;\\n\\t\\tinfo   = new C.Struct.addrinfo(result);\\n\\t\\twhile (result !== null){\\n\\t\\t\\tvar info = new C.Struct.addrinfo(result);\\n\\t\\t\\tresult = info.ai_next;\\n\\t\\t\\tif (info.ai_family === syscall.AF_INET){\\n\\t\\t\\t\\tvar addr = new C.Struct.sockaddr(info.ai_addr);\\n\\t\\t\\t\\tvar ipv4 = sock.ntop(addr.pointer);\\n\\t\\t\\t\\taddrs.push(ipv4);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Iterate over the IPv6\\n\\t\\tresult = freePTR;\\n\\t\\tinfo   = new C.Struct.addrinfo(result);\\n\\t\\twhile (result !== null){\\n\\t\\t\\tvar info = new C.Struct.addrinfo(result);\\n\\t\\t\\tresult = info.ai_next;\\n\\t\\t\\tif (info.ai_family === syscall.AF_INET6){\\n\\t\\t\\t\\tvar addr = new C.Struct.sockaddr6(info.ai_addr);\\n\\t\\t\\t\\tvar ipv6  = sock.ntop(addr.pointer);\\n\\t\\t\\t\\taddrs.push(ipv6);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsyscall.freeaddrinfo(freePTR);\\n\\t}\\n\\n\\tif (status){\\n\\t\\tvar errname = errno.errname(status);\\n\\t\\tswitch (errname){\\n\\t\\t\\tcase 'WSAHOST_NOT_FOUND' : status = 'ENOTFOUND'; break;\\n\\t\\t\\tcase 'ENOENT' : status = 'ENOTFOUND'; break;\\n\\t\\t\\tdefault : status = 'errno(' + status + ')';\\n\\t\\t}\\n\\t}\\n\\tprocess.MakeCallback(req, 'oncomplete', status, addrs);\\n};\\n\\n\\nexports.queryA = function(req, hostname){\\n\\treturn exports.getaddrinfo(req, hostname, 4, 0);\\n};\\n\\nexports.queryAaaa = function(req, hostname){\\n\\treturn exports.getaddrinfo(req, hostname, 6, 0);\\n};\\n\\nexports.isIP = function(ip){\\n\\treturn sock.isIP(ip);\\n};\\n\",\"tty_wrap\":\"var uv  = require('uv');\\n\\nfunction TTY (fd, readable){\\n\\tthis._handle = new uv.TTY(fd, readable);\\n\\tthis.readStart(function(){});\\n};\\n\\nTTY.prototype.writeAsciiString =\\nTTY.prototype.writeBuffer =\\nTTY.prototype.writeUtf8String = function(req, data){\\n\\tthis._handle.write(data);\\n};\\n\\nTTY.prototype.getWindowSize = function(arr){\\n\\tvar winsize = this._handle.get_winsize();\\n\\tif (!winsize){\\n\\t\\treturn process.errno;\\n\\t}\\n\\n\\tarr[0] = winsize.width;\\n\\tarr[1] = winsize.height;\\n\\treturn 0;\\n};\\n\\nTTY.prototype.readStart = function(){\\n\\tvar tcp = this;\\n\\tthis._handle.read_start(function(err, buf){\\n\\t\\tvar len;\\n\\t\\tif (err){\\n\\t\\t\\tlen = err > 0 ? -err : err;\\n\\t\\t} else if (buf){\\n\\t\\t\\tlen = buf.length;\\n\\t\\t} else { len = 0; }\\n\\n\\t\\ttcp.onread(len, buf);\\n\\t});\\n};\\n\\nTTY.prototype.readStop = function(){\\n\\treturn this._handle.read_stop();\\n};\\n\\nTTY.prototype.setRawMode = function(mode){\\n\\tthis._handle.set_mode(mode ? 1 : 0);\\n};\\n\\nTTY.prototype.close = function(cb){\\n\\tthis._handle.close();\\n\\tsetTimeout(cb, 1);\\n};\\n\\nexports.TTY = TTY;\\n\\nexports.guessHandleType = function(h){\\n\\treturn uv.guess_handle(h);\\n};\\n\\nexports.isTTY = function(h){\\n\\treturn uv.guess_handle(h) === 'TTY';\\n};\\n\",\"spawn_sync\":\"var process_wrap = process.binding('process_wrap').Process;\\nvar binding = process.binding('loop');\\nvar loop = require('loop').main;\\nvar child_process = require('child_process');\\n\\n\\nexports.spawn = function(a,b,c){\\n\\t// save main event loop as we\\n\\t// are going to use it again\\n\\tvar main_loop = loop._handle;\\n\\tvar nextTick  = process.nextTick;\\n\\n\\tprocess.nextTick = function(){\\n\\t\\tvar args = [].slice.call(arguments);\\n\\t\\tvar callback = args.shift();\\n\\t\\tcallback.apply(null, args);\\n\\t};\\n\\n\\t// create new event loop handle\\n\\t// change main loop handle to this new\\n\\t// loop handle, run then, reset back the original\\n\\t// loop handle\\n\\tloop._handle = binding.init();\\n\\n\\tvar result = {\\n\\t\\tstatus : 0,\\n\\t\\toutput : []\\n\\t};\\n\\n\\tvar stdout = [];\\n\\tvar stderr = [];\\n\\tvar status;\\n\\n\\ttry {\\n\\t\\tvar child = child_process.spawn.apply(null, arguments);\\n\\t} catch (e){\\n\\t\\te.syscall = e.syscall.replace('spawn', 'spawnSync');\\n\\t\\tresult.error = e;\\n\\t\\tloop._handle = main_loop;\\n\\t\\tprocess.nextTick = nextTick;\\n\\t\\treturn result;\\n\\t}\\n\\n\\tchild.on('exit', function(code){\\n\\t\\tresult.status = code;\\n\\t});\\n\\n\\t// child.on('error', function(e){\\n\\t// \\tresult.error = e;\\n\\t// });\\n\\n\\tchild.stdout.on('data', function(data){\\n\\t\\tstdout.push(data);\\n\\t});\\n\\n\\tchild.stderr.on('data', function(data){\\n\\t\\tstderr.push(data);\\n\\t});\\n\\n\\tloop.run(0);\\n\\n\\tif (stdout.length > 0){\\n\\t\\tresult.output[1] = Buffer.concat(stdout);\\n\\t}\\n\\n\\tif (stderr.length > 0){\\n\\t\\tresult.output[2] = Buffer.concat(stderr);\\n\\t}\\n\\n\\t// reset back to main loop\\n\\tloop._handle = main_loop;\\n\\tprocess.nextTick = nextTick;\\n\\n\\treturn result;\\n};\\n\",\"process_wrap\":\"var uv           = require('uv');\\nvar MakeCallback = process.MakeCallback;\\nvar cons         = require('constants');\\n\\nfunction Process (){}\\n\\n// convert signal number to string\\n// return null if not found\\nfunction signum_to_string(signum){\\n\\tif (signum === 0) return null;\\n\\tfor (var key in cons){\\n\\t\\tif (cons[key] === signum){\\n\\t\\t\\treturn key;\\n\\t\\t}\\n\\t}\\n\\treturn null;\\n}\\n\\n\\nfunction ParseStdioOptions(stdios, options){\\n\\n\\tvar stdioLength = stdios.length\\n\\tvar stdio_container = uv.stdio_container(stdioLength);\\n\\n\\t// options.stdio_count = stdioLength;\\n\\n\\tfor (var i = 0; i < stdioLength; i++){\\n\\t\\tvar stdio = stdios[i];\\n\\t\\tvar type  = stdio.type;\\n\\n\\t\\t//ignor\\n\\t\\tif (type === 'ignore'){\\n\\t\\t\\tstdio_container[i].flags = uv.IGNORE;\\n\\t\\t}\\n\\n\\t\\t//pipe\\n\\t\\telse if (type === 'pipe'){\\n\\t\\t\\tstdio_container[i].flags = uv.CREATE_PIPE | uv.STREAM_READABLE | uv.STREAM_WRITABLE;\\n\\t\\t\\tstdio_container[i].stream = stdio.handle._handle;\\n\\t\\t}\\n\\n\\t\\t//inherit\\n\\t\\telse if (type === 'fd' || type === 'inherit') {\\n\\t\\t\\tstdio_container[i].flags  = uv.INHERIT_FD;\\n\\t\\t\\tstdio_container[i].fd     = stdio.fd;\\n\\t\\t}\\n\\n\\t\\telse {\\n\\t\\t\\tthrow new Error('unknown type!');\\n\\t\\t}\\n\\t}\\n\\n\\treturn stdio_container;\\n}\\n\\n\\nProcess.prototype.spawn = function(js_options){\\n\\tvar process = this;\\n\\n\\tvar options   = {};\\n\\toptions.flags = 0;\\n\\toptions.file  = js_options.file;\\n\\toptions.cwd   = js_options.cwd || null;\\n\\toptions.args  = js_options.args || [];\\n\\n\\tif (!options.file){\\n\\t\\tthrow new Error(\\\"Bad argument\\\");\\n\\t}\\n\\n\\toptions.stdio_count = js_options.stdio.length;\\n\\toptions.stdio = ParseStdioOptions(js_options.stdio);\\n\\n\\n\\t//env pairs\\n\\tvar env = js_options.envPairs;\\n\\tif (!env){\\n\\t\\tthrow new Error(\\\"TODO set current env block\\\");\\n\\t}\\n\\n\\toptions.env = env;\\n\\n\\tif ( js_options.windowsVerbatimArguments ){\\n\\t\\toptions.flags |= uv.PROCESS_WINDOWS_VERBATIM_ARGUMENTS;\\n\\t}\\n\\n\\t// detach process\\n\\tif ( js_options.detached ) {\\n\\t\\toptions.flags |= uv.PROCESS_DETACHED;\\n\\t}\\n\\n\\t// options.uid\\n\\tif ( js_options.uid ) {\\n\\t\\toptions.flags |= uv.PROCESS_SETUID;\\n\\t\\toptions.uid    = js_options.uid;\\n\\t}\\n\\n\\t// options.uid\\n\\tif ( js_options.gid ) {\\n\\t\\toptions.flags |= uv.PROCESS_SETGID;\\n\\t\\toptions.gid = js_options.gid;\\n\\t}\\n\\n\\t// on exit call back\\n\\toptions.exit_cb = function(status, term_signal){\\n\\t\\tvar sig = signum_to_string(term_signal);\\n\\t\\tprocess.onexit(status, sig);\\n\\t};\\n\\n\\tthis._handle = uv.spawn(options);\\n\\tif (this._handle.errno){\\n\\t\\treturn -this._handle.errno;\\n\\t}\\n\\n\\tthis.pid = this._handle.pid;\\n\\treturn 0;\\n};\\n\\n\\nProcess.prototype.unref = function(){\\n\\treturn this._handle.unref();\\n};\\n\\n\\nProcess.prototype.kill = function(signum){\\n\\treturn this._handle.kill(signum);\\n};\\n\\n\\nProcess.prototype.close = function(cb){\\n\\treturn this._handle.close(cb);\\n};\\n\\nexports.Process = Process;\\n\",\"uv_wrap\":\"var errno = require('errno');\\n// reset uv_eof to negative value\\nerrno.UV_EOF = -errno.UV_EOF;\\nmodule.exports = errno;\\n\",\"setup/stdio\":\"exports.createWritableStdioStream = function(fd){\\n\\tvar stream;\\n\\tvar tty_wrap = process.binding('tty_wrap');\\n\\n\\t// Note stream._type is used for test-module-load-list.js\\n\\n\\tswitch (tty_wrap.guessHandleType(fd)) {\\n\\t  case 'TTY':\\n\\t\\tvar tty = require('tty');\\n\\t\\tstream = new tty.WriteStream(fd);\\n\\t\\tstream._type = 'tty';\\n\\t\\tbreak;\\n\\n\\t  case 'FILE':\\n\\t\\tvar fs = require('fs');\\n\\t\\tstream = new fs.SyncWriteStream(fd, { autoClose: false });\\n\\t\\tstream._type = 'fs';\\n\\t\\tbreak;\\n\\n\\t\\tcase 'PIPE':\\n\\t\\tcase 'TCP':\\n\\t\\tvar net = require('net');\\n\\t\\tstream = new net.Socket({\\n\\t\\t  fd: fd,\\n\\t\\t  readable: false,\\n\\t\\t  writable: true\\n\\t\\t});\\n\\t\\tstream._type = 'pipe';\\n\\t\\tbreak;\\n\\n\\t  default:\\n\\t\\t// Probably an error on in uv_guess_handle()\\n\\t\\tthrow new Error('Implement me. Unknown stream file type!');\\n\\t}\\n\\n\\t// For supporting legacy API we put the FD here.\\n\\tstream.fd = fd;\\n\\n\\tstream._isStdio = true;\\n\\n\\treturn stream;\\n};\\n\\nexports.createReadableStdioStream = function(fd){\\n\\tvar tty_wrap = process.binding('tty_wrap');\\n\\n\\tswitch (tty_wrap.guessHandleType(fd)) {\\n\\tcase 'TTY':\\n\\t\\tvar tty = require('tty');\\n\\t\\tstdin = new tty.ReadStream(fd, {\\n\\t\\t\\thighWaterMark: 0,\\n\\t\\t\\treadable: true,\\n\\t\\t\\twritable: false\\n\\t\\t});\\n\\t\\tbreak;\\n\\n\\tcase 'FILE':\\n\\t\\tvar fs = require('fs');\\n\\t\\tstdin = new fs.ReadStream(null, { fd: fd, autoClose: false });\\n\\t\\tbreak;\\n\\n\\tcase 'PIPE':\\n\\tcase 'TCP':\\n\\t\\tvar net = require('net');\\n\\t\\t// It could be that process has been started with an IPC channel\\n\\t\\t// sitting on fd=0, in such case the pipe for this fd is already\\n\\t\\t// present and creating a new one will lead to the assertion failure\\n\\t\\t// in libuv.\\n\\t\\tif (process._channel && process._channel.fd === fd) {\\n\\t\\t\\tstdin = new net.Socket({\\n\\t\\t\\t\\thandle: process._channel,\\n\\t\\t\\t\\treadable: true,\\n\\t\\t\\t\\twritable: false\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tstdin = new net.Socket({\\n\\t\\t\\t\\tfd: fd,\\n\\t\\t\\t\\treadable: true,\\n\\t\\t\\t\\twritable: false\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\t// Make sure the stdin can't be `.end()`-ed\\n\\t\\tstdin._writableState.ended = true;\\n\\t\\tbreak;\\n\\n\\tdefault:\\n\\t  // Probably an error on in uv_guess_handle()\\n\\t  throw new Error('Implement me. Unknown stdin file type!');\\n\\t}\\n\\n\\t// For supporting legacy API we put the FD here.\\n\\tstdin.fd = fd;\\n\\n\\t// stdin starts out life in a paused state, but node doesn't\\n\\t// know yet.  Explicitly to readStop() it to put it in the\\n\\t// not-reading state.\\n\\tif (stdin._handle && stdin._handle.readStop) {\\n\\t\\tstdin._handle.reading = false;\\n\\t\\tstdin._readableState.reading = false;\\n\\t\\tstdin._handle.readStop();\\n\\t}\\n\\n\\t// if the user calls stdin.pause(), then we need to stop reading\\n\\t// immediately, so that the process can close down.\\n\\tstdin.on('pause', function() {\\n\\t\\tif (!stdin._handle)\\n\\t\\t\\treturn;\\n\\t\\tstdin._readableState.reading = false;\\n\\t\\tstdin._handle.reading = false;\\n\\t\\tstdin._handle.readStop();\\n\\t});\\n\\n\\treturn stdin;\\n};\\n\"}"
