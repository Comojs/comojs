"{\"fileMap\":{\"main\":\"js/main.js\",\"loop\":\"js/loop.js\",\"C\":\"js/C.js\",\"syscall\":\"js/syscall/index.js\",\"syscall/linux\":\"js/syscall/linux.js\",\"syscall/windows\":\"js/syscall/windows.js\",\"module\":\"js/module.js\",\"http_parser\":\"js/http-parser.js\",\"socket\":\"js/socket.js\",\"errno\":\"js/errno.js\",\"os\":\"js/os.js\",\"uv\":\"js/uv/index.js\",\"uv/stream\":\"js/uv/stream.js\",\"uv/tcp\":\"js/uv/tcp.js\",\"uv/pipe\":\"js/uv/pipe.js\",\"uv/process\":\"js/uv/process.js\",\"uv/process/windows\":\"js/uv/process/windows.js\",\"uv/process/unix\":\"js/uv/process/unix.js\",\"uv/tty\":\"js/uv/tty.js\",\"uv/tty/windows\":\"js/uv/tty/windows.js\",\"uv/tty/ansi\":\"js/uv/tty/ansi.js\",\"uv/tty/linux\":\"js/uv/tty/linux.js\",\"internal/util\":\"js/node/internal/util.js\",\"internal/linkedlist\":\"js/node/internal/linkedlist.js\",\"buffer\":\"js/node/buffer.js\",\"util\":\"js/node/util.js\",\"path\":\"js/node/path.js\",\"fs\":\"js/node/fs.js\",\"url\":\"js/node/url.js\",\"readline\":\"js/node/readline.js\",\"querystring\":\"js/node/querystring.js\",\"assert\":\"js/node/assert.js\",\"console\":\"js/node/console.js\",\"constants\":\"js/node/constants.js\",\"events\":\"js/node/events.js\",\"timers\":\"js/node/timers.js\",\"net\":\"js/node/net.js\",\"dns\":\"js/node/dns.js\",\"cluster\":\"js/node/cluster.js\",\"string_decoder\":\"js/node/string_decoder.js\",\"tty\":\"js/node/tty.js\",\"internal/child_process\":\"js/node/internal/child_process.js\",\"internal/socket_list\":\"js/node/internal/socket_list.js\",\"child_process\":\"js/node/child_process.js\",\"stream\":\"js/node/stream.js\",\"_stream_readable\":\"js/node/stream/_stream_readable.js\",\"_stream_writable\":\"js/node/stream/_stream_writable.js\",\"_stream_duplex\":\"js/node/stream/_stream_duplex.js\",\"_stream_transform\":\"js/node/stream/_stream_transform.js\",\"_stream_passthrough\":\"js/node/stream/_stream_passthrough.js\",\"http\":\"js/node/http.js\",\"_http_agent\":\"js/node/http/_http_agent.js\",\"_http_client\":\"js/node/http/_http_client.js\",\"_http_common\":\"js/node/http/_http_common.js\",\"_http_incoming\":\"js/node/http/_http_incoming.js\",\"_http_outgoing\":\"js/node/http/_http_outgoing.js\",\"_http_server\":\"js/node/http/_http_server.js\",\"internal/freelist\":\"js/node/internal/freelist.js\",\"timer_wrap\":\"js/node_wrap/timer_wrap.js\",\"buffer_wrap\":\"js/node_wrap/buffer_wrap.js\",\"tcp_wrap\":\"js/node_wrap/tcp_wrap.js\",\"stream_wrap\":\"js/node_wrap/stream_wrap.js\",\"pipe_wrap\":\"js/node_wrap/pipe_wrap.js\",\"fs_wrap\":\"js/node_wrap/fs_wrap.js\",\"fs_event_wrap\":\"js/node_wrap/fs_event_wrap.js\",\"cares_wrap\":\"js/node_wrap/cares_wrap.js\",\"tty_wrap\":\"js/node_wrap/tty_wrap.js\",\"spawn_sync\":\"js/node_wrap/spawn_sync.js\",\"process_wrap\":\"js/node_wrap/process_wrap.js\",\"uv_wrap\":\"js/node_wrap/uv.js\",\"setup/stdio\":\"js/node/setup/stdio.js\"},\"loop\":\"var loop = process.binding('loop');\\r\\nvar util = require('util');\\r\\nexports.POLLOUT = loop.POLLOUT;\\r\\nexports.POLLIN  = loop.POLLIN;\\r\\nexports.POLLERR = loop.POLLERR;\\r\\nexports.POLLHUP = loop.POLLHUP;\\r\\n\\r\\nconst TIMER = 0;\\r\\nconst IO    = 1;\\r\\n\\r\\nexports.main = new Loop();\\r\\n\\r\\nexports.init = function(){\\r\\n\\treturn new Loop();\\r\\n};\\r\\n\\r\\nfunction Handle (loopHandle, cb){\\r\\n\\tif (cb) this.cb = cb;\\r\\n\\tthis._handle = loop.handle_init(loopHandle, cb);\\r\\n}\\r\\n\\r\\nHandle.prototype.ref = function(){\\r\\n\\tloop.handle_ref(this._handle);\\r\\n};\\r\\n\\r\\nHandle.prototype.unref = function(){\\r\\n\\tloop.handle_unref(this._handle);\\r\\n};\\r\\n\\r\\nHandle.prototype.io_start = function(fd, events, cb){\\r\\n\\tif (cb) this.cb = cb;\\r\\n\\tloop.io_start(this._handle, fd, events, cb);\\r\\n};\\r\\n\\r\\nHandle.prototype.io_stop = function(events){\\r\\n\\tloop.io_stop(this._handle, events);\\r\\n};\\r\\n\\r\\nHandle.prototype.io_active = function(events){\\r\\n\\treturn loop.io_active(this._handle, events);\\r\\n};\\r\\n\\r\\nHandle.prototype.timer_start = function(timeout, repeat, cb){\\r\\n\\tif (cb) this.cb = cb;\\r\\n\\tloop.timer_start(this._handle, timeout, repeat, cb);\\r\\n};\\r\\n\\r\\nHandle.prototype.timer_stop = function(timeout, repeat, cb){\\r\\n\\tloop.timer_stop(this._handle);\\r\\n};\\r\\n\\r\\nHandle.prototype.timer_again = function(timeout, repeat, cb){\\r\\n\\tloop.timer_again(this._handle);\\r\\n};\\r\\n\\r\\n\\r\\nHandle.prototype.close = function(events){\\r\\n\\tloop.handle_close(this._handle, events);\\r\\n};\\r\\n\\r\\nfunction Loop (){\\r\\n\\tthis._handle = loop.init();\\r\\n\\tfor (var key in loop){\\r\\n\\t\\tif (key === 'run' || key === 'update_time') continue;\\r\\n\\t\\tthis[key] = loop[key];\\r\\n\\t}\\r\\n}\\r\\n\\r\\nLoop.prototype.update_time = function(type){\\r\\n\\treturn loop.update_time(this._handle);\\r\\n};\\r\\n\\r\\nLoop.prototype.run = function(type){\\r\\n\\treturn loop.run(this._handle, type);\\r\\n};\\r\\n\\r\\n// inititae new handle\\r\\nLoop.prototype.handle = function(cb){\\r\\n\\treturn new Handle(this._handle, cb);\\r\\n};\\r\\n\\r\\n// initiate io handle\\r\\nLoop.prototype.io = function(cb){\\r\\n\\treturn new IOHandle(this._handle, cb);\\r\\n};\\r\\n\\r\\n/* IO HANDLE */\\r\\nfunction IOHandle (loopHandle, cb){\\r\\n\\tif (cb) this.cb = cb;\\r\\n\\tthis._handle = loop.handle_init(loopHandle, cb);\\r\\n}\\r\\n\\r\\nIOHandle.prototype.close = function(events){\\r\\n\\tloop.handle_close(this._handle, events);\\r\\n};\\r\\n\\r\\nIOHandle.prototype.start = function(fd, events, cb){\\r\\n\\tif (cb) this.cb = cb;\\r\\n\\tloop.io_start(this._handle, fd, events, cb);\\r\\n};\\r\\n\\r\\nIOHandle.prototype.active = function(events){\\r\\n\\treturn loop.io_active(this._handle, events);\\r\\n};\\r\\n\\r\\nIOHandle.prototype.stop = function(events){\\r\\n\\tloop.io_stop(this._handle, events);\\r\\n};\\r\\n\\r\\nIOHandle.prototype.handle_stop = function(){\\r\\n\\tloop.handle_stop(this._handle);\\r\\n};\\r\\n\\r\\nIOHandle.prototype.ref = function(){\\r\\n\\tloop.handle_ref(this._handle);\\r\\n};\\r\\n\\r\\nIOHandle.prototype.unref = function(){\\r\\n\\tloop.handle_unref(this._handle);\\r\\n};\\r\\n\\r\\nexports.setTimeout = setTimeout;\\r\\nexports.setInterval = setInterval;\\r\\nexports.clearInterval = clearInterval;\\r\\nexports.clearTimeout = clearTimeout;\\r\\n\",\"C\":\"'use strict';\\r\\n\\r\\nvar C = process.binding('C');\\r\\n\\r\\nC.LE = (function() {\\r\\n\\tvar buffer = new ArrayBuffer(2);\\r\\n\\tnew DataView(buffer).setInt16(0, 256, true /* littleEndian */);\\r\\n\\t// Int16Array uses the platform's endianness.\\r\\n\\treturn new Int16Array(buffer)[0] === 256;\\r\\n})();\\r\\n\\r\\nvar _typesMap = {\\r\\n\\tuint : {\\r\\n\\t\\tfn   : C.uint,\\r\\n\\t\\tsize : C.sizeOf.int\\r\\n\\t},\\r\\n\\tuint8 : {\\r\\n\\t\\tfn   : C.uint8,\\r\\n\\t\\tsize : C.sizeOf.int8\\r\\n\\t},\\r\\n\\tuint16 : {\\r\\n\\t\\tfn   : C.uint16,\\r\\n\\t\\tsize : C.sizeOf.int16\\r\\n\\t},\\r\\n\\tuint32 : {\\r\\n\\t\\tfn   : C.uint32,\\r\\n\\t\\tsize : C.sizeOf.int32\\r\\n\\t},\\r\\n\\tuint64 : {\\r\\n\\t\\tfn   : C.uint64,\\r\\n\\t\\tsize : C.sizeOf.uint64\\r\\n\\t},\\r\\n\\tint : {\\r\\n\\t\\tfn   : C.int,\\r\\n\\t\\tsize : C.sizeOf.int\\r\\n\\t},\\r\\n\\tint8 : {\\r\\n\\t\\tfn   : C.int8,\\r\\n\\t\\tsize : C.sizeOf.int8\\r\\n\\t},\\r\\n\\tint16 : {\\r\\n\\t\\tfn   : C.int16,\\r\\n\\t\\tsize : C.sizeOf.int16\\r\\n\\t},\\r\\n\\tint32 : {\\r\\n\\t\\tfn   : C.int32,\\r\\n\\t\\tsize : C.sizeOf.int32\\r\\n\\t},\\r\\n\\tint64 : {\\r\\n\\t\\tfn   : C.int64,\\r\\n\\t\\tsize : C.sizeOf.int64\\r\\n\\t},\\r\\n\\tpointer : {\\r\\n\\t\\tfn   : C.pointer,\\r\\n\\t\\tsize : C.sizeOf.uintptr\\r\\n\\t},\\r\\n\\t'*' : {\\r\\n\\t\\tfn   : C.pointer,\\r\\n\\t\\tsize : C.sizeOf.uintptr\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nfunction fieldError(field){\\r\\n\\tthrow new Error('field ' + field + ' not found');\\r\\n}\\r\\n\\r\\n\\r\\nfunction create_struct_fields(fields){\\r\\n\\r\\n\\tvar obj = {};\\r\\n\\tvar buffers = {};\\r\\n\\tvar structSize = 0;\\r\\n\\r\\n\\tfor (var key in fields){\\r\\n\\t\\tvar type = fields[key];\\r\\n\\t\\tvar size   = type.size;\\r\\n\\t\\tvar offset = type.offset;\\r\\n\\t\\tvar set    = type.fn;\\r\\n\\r\\n\\t\\t// localize field offset & size\\r\\n\\t\\t(function(set, off, size){\\r\\n\\t\\t\\tObject.defineProperty(obj, key, {\\r\\n\\t\\t\\t\\tget : function(){\\r\\n\\t\\t\\t\\t\\treturn set(this, off, size);\\r\\n\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\tset : function(v){\\r\\n\\t\\t\\t\\t\\treturn set(this, off, size, v);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\r\\n\\t\\t\\tObject.defineProperty(buffers, key, {\\r\\n\\t\\t\\t\\tget : function(){\\r\\n\\t\\t\\t\\t\\treturn new DataView(this.buffer, off, size);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\r\\n\\t\\t})(set, offset, size);\\r\\n\\t\\tstructSize += size;\\r\\n\\t}\\r\\n\\r\\n\\tObject.defineProperty(obj, 'inspect', {\\r\\n\\t\\tvalue : function(){\\r\\n\\t\\t\\tvar b = new DataView(this);\\r\\n\\t\\t\\tb.Length = b.length;\\r\\n\\t\\t\\tb.fields = fields;\\r\\n\\t\\t\\treturn b;\\r\\n\\t\\t}\\r\\n\\t});\\r\\n\\r\\n\\tObject.defineProperty(obj, 'buffer', {\\r\\n\\t\\tget : function(){\\r\\n\\t\\t\\tbuffers.buffer = this;\\r\\n\\t\\t\\treturn buffers;\\r\\n\\t\\t}\\r\\n\\t});\\r\\n\\r\\n\\tObject.defineProperty(obj, 'pointer', {\\r\\n\\t\\tget : function(){\\r\\n\\t\\t\\treturn C.to_pointer(this);\\r\\n\\t\\t}\\r\\n\\t});\\r\\n\\r\\n\\tobj.size = structSize;\\r\\n\\treturn obj;\\r\\n}\\r\\n\\r\\n\\r\\nfunction _throwFieldError (type){\\r\\n\\tthrow new Error('unknown field type ' + type);\\r\\n};\\r\\n\\r\\n\\r\\nfunction normalize_fields(fields){\\r\\n\\tvar offset = 0;\\r\\n\\tObject.keys(fields).forEach(function(name) {\\r\\n\\t\\tvar type = fields[name];\\r\\n\\r\\n\\t\\t// number field value [buffer]\\r\\n\\t\\tif (typeof type === 'number'){\\r\\n\\t\\t\\tfields[name] = {\\r\\n\\t\\t\\t\\tfn     : C.buffer,\\r\\n\\t\\t\\t\\tsize   : type,\\r\\n\\t\\t\\t\\toffset : offset\\r\\n\\t\\t\\t};\\r\\n\\t\\t\\toffset += fields[name].size;\\r\\n\\t\\t}\\r\\n\\t\\t// string field type [uint32, int32, int, ...]\\r\\n\\t\\telse if (typeof type === 'string'){\\r\\n\\t\\t\\tvar clone = _typesMap[type];\\r\\n\\t\\t\\tif (!clone) _throwFieldError(type);\\r\\n\\t\\t\\tfields[name] = {\\r\\n\\t\\t\\t\\tfn     : clone.fn,\\r\\n\\t\\t\\t\\tsize   : clone.size,\\r\\n\\t\\t\\t\\toffset : offset\\r\\n\\t\\t\\t};\\r\\n\\t\\t\\toffset += fields[name].size;\\r\\n\\t\\t}\\r\\n\\t\\t// function field value, passed as another struct\\r\\n\\t\\telse if (typeof type === 'function' && type.byteLength){\\r\\n\\t\\t\\tvar struct = new type();\\r\\n\\t\\t\\tfields[name] = {\\r\\n\\t\\t\\t\\tfn : function(buf, offset, size, v){\\r\\n\\t\\t\\t\\t\\tvar buf = new DataView(buf, offset, size);\\r\\n\\t\\t\\t\\t\\tObject.setPrototypeOf(buf, struct);\\r\\n\\t\\t\\t\\t\\treturn buf;\\r\\n\\t\\t\\t\\t},\\r\\n\\t\\t\\t\\tsize   : type.byteLength,\\r\\n\\t\\t\\t\\toffset : offset\\r\\n\\t\\t\\t};\\r\\n\\t\\t\\toffset += fields[name].size;\\r\\n\\t\\t}\\r\\n\\t\\t// object, most likely passed by C struct\\r\\n\\t\\telse {\\r\\n\\t\\t\\tfields[name] = (function(){\\r\\n\\t\\t\\t\\tvar obj = fields[name];\\r\\n\\t\\t\\t\\tobj.fn  = _typesMap[obj.type] ? _typesMap[obj.type].fn : _throwFieldError(obj.type);\\r\\n\\t\\t\\t\\tdelete obj.type;\\r\\n\\t\\t\\t\\treturn obj;\\r\\n\\t\\t\\t})();\\r\\n\\t\\t}\\r\\n\\t});\\r\\n\\treturn fields;\\r\\n}\\r\\n\\r\\n\\r\\nfunction Union (obj){\\r\\n\\tvar self = this;\\r\\n\\tobj = normalize_fields(obj);\\r\\n\\tvar size = 0;\\r\\n\\tObject.keys(obj).forEach(function(name) {\\r\\n\\t\\t// get largest member size\\r\\n\\t\\tif (obj[name].size > size){\\r\\n\\t\\t\\tsize = obj[name].size;\\r\\n\\t\\t}\\r\\n\\t\\t// force offset at 0\\r\\n\\t\\tobj[name].offset = 0;\\r\\n\\t});\\r\\n\\tthis.size = size;\\r\\n\\r\\n\\tvar fields = create_struct_fields(obj);\\r\\n\\r\\n\\tthis.fn = function(buf, offset, size, val){\\r\\n\\t\\tbuf = buf || new ArrayBuffer(self.size);\\r\\n\\t\\tbuf = new DataView(buf, offset || 0, size || self.size);\\r\\n\\t\\tObject.setPrototypeOf(buf, fields);\\r\\n\\t\\tObject.preventExtensions(buf);\\r\\n\\t\\treturn buf;\\r\\n\\t};\\r\\n\\tthis.fn.byteLength = size;\\r\\n\\treturn this.fn;\\r\\n}\\r\\n\\r\\n\\r\\nC.union = function(obj){\\r\\n\\treturn new Union(obj);\\r\\n};\\r\\n\\r\\n\\r\\nC.Struct.create = function(obj){\\r\\n\\t// if obj passed struct length use it\\r\\n\\tvar length = obj.length; delete obj.length;\\r\\n\\tobj        = normalize_fields(obj);\\r\\n\\tvar fields = create_struct_fields(obj);\\r\\n\\tlength     = length || fields.size;\\r\\n\\tvar structure = function(v){\\r\\n\\t\\tvar buf = new ArrayBuffer(length);\\r\\n\\t\\tif (v) C.buffer(buf, v);\\r\\n\\t\\tObject.setPrototypeOf(buf, fields);\\r\\n\\t\\tObject.preventExtensions(buf);\\r\\n\\t\\treturn buf;\\r\\n\\t};\\r\\n\\r\\n\\tstructure.byteLength = length;\\r\\n\\treturn structure;\\r\\n};\\r\\n\\r\\n\\r\\nvar voidValues = {};\\r\\nObject.defineProperty(voidValues, 'ptr', {\\r\\n\\tget : function(){\\r\\n\\t\\treturn C.pointer(this);\\r\\n\\t}\\r\\n});\\r\\n\\r\\nObject.defineProperty(voidValues, 'int', {\\r\\n\\tget : function(){\\r\\n\\t\\treturn C.int(this, 0);\\r\\n\\t},\\r\\n\\tset : function(v){\\r\\n\\t\\tC.int(this, 0, 0, v);\\r\\n\\t}\\r\\n});\\r\\n\\r\\nObject.defineProperty(voidValues, 'int32', {\\r\\n\\tget : function(){\\r\\n\\t\\treturn C.int32(this, 0);\\r\\n\\t},\\r\\n\\tset : function(v){\\r\\n\\t\\tC.int32(this, 0, 0, v);\\r\\n\\t}\\r\\n});\\r\\n\\r\\nObject.defineProperty(voidValues, 'uint32', {\\r\\n\\tget : function(){\\r\\n\\t\\treturn C.uint32(this, 0);\\r\\n\\t},\\r\\n\\tset : function(v){\\r\\n\\t\\tC.uint32(this, 0, 0, v);\\r\\n\\t}\\r\\n});\\r\\n\\r\\nC.void = function(n){\\r\\n\\tvar buf = new ArrayBuffer(n || C.sizeOf.intptr);\\r\\n\\tObject.setPrototypeOf(buf, voidValues);\\r\\n\\treturn buf;\\r\\n}\\r\\n\\r\\nObject.keys(C.Struct).forEach(function(name) {\\r\\n\\tif (name === 'create') return;\\r\\n\\tC.Struct[name] = C.Struct.create(C.Struct[name]());\\r\\n});\\r\\n\\r\\nmodule.exports = C;\\r\\n\",\"syscall\":\"var binding = process.binding('syscall');\\r\\nvar errno   = require('errno');\\r\\nvar C       = require('C');\\r\\nvar sock    = require('socket');\\r\\nvar syscall = exports;\\r\\n\\r\\n{\\t// shared constants\\r\\n\\tsyscall.AF_UNSPEC   = sock.AF_UNSPEC;\\r\\n\\tsyscall.SOCK_STREAM = sock.SOCK_STREAM;\\r\\n\\tsyscall.IPPROTO_IP  = sock.IPPROTO_IP;\\r\\n\\tsyscall.AF_INET     = sock.AF_INET;\\r\\n\\tsyscall.AF_INET6    = sock.AF_INET6;\\r\\n}\\r\\n\\r\\nvar _LoadedLib = {};\\r\\nvar littleEndian = (function() {\\r\\n\\tvar buffer = new ArrayBuffer(2);\\r\\n\\tnew DataView(buffer).setInt16(0, 256, true /* littleEndian */);\\r\\n\\treturn new Int16Array(buffer)[0] === 256; // Int16Array uses the platform's endianness.\\r\\n})();\\r\\n\\r\\nvar rr     = new Buffer(8);\\r\\nvar retVal = new DataView(rr, 0);\\r\\n\\r\\n// syscall.LoadLibrary Constructor\\r\\n// see expoprts.LoadLibrary\\r\\nfunction NewLoadLibrary (h){\\r\\n\\tthis._handle = h;\\r\\n\\tthis.procs = {};\\r\\n\\r\\n\\t// return a function (name) from proc address\\r\\n\\t// if errval passed, the return value will check against\\r\\n\\t// this errval and if matched the function will return null\\r\\n\\t// and set process.errno to the last error\\r\\n\\tthis.GetProcAddress = function(name, errval){\\r\\n\\t\\tvar fn = binding.GetProcAddress(h, name);\\r\\n\\t\\tif (fn === null){\\r\\n\\t\\t\\tthrow new Error(\\\"unknown proc name \\\" + name);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//return cached function\\r\\n\\t\\tvar proc = this.procs[name];\\r\\n\\t\\tif (proc) return proc;\\r\\n\\r\\n\\t\\tthis.procs[name] = function (){\\r\\n\\t\\t\\tvar args = [].slice.call(arguments);\\r\\n\\t\\t\\targs.unshift(retVal);\\r\\n\\t\\t\\targs.unshift(fn);\\r\\n\\t\\t\\tbinding.syscall.apply(null, args);\\r\\n\\t\\t\\tvar r = retVal.getInt32(0, littleEndian);\\r\\n\\t\\t\\tif (typeof errval !== 'undefined'){\\r\\n\\t\\t\\t\\tif (r === errval){\\r\\n\\t\\t\\t\\t\\tprocess.errno = syscall.GetLastError() || errno.EINVAL;\\r\\n\\t\\t\\t\\t\\treturn null;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn r;\\r\\n\\t\\t};\\r\\n\\t\\treturn this.procs[name];\\r\\n\\t};\\r\\n}\\r\\n\\r\\n\\r\\n// load WINAPI Library\\r\\n// var lib = syscall.LoadLibrary('kernel32');\\r\\n// var ReadFile = lib.GetProcAddress('ReadFile');\\r\\n// ReadFile( ..args.. );\\r\\n//===========================================================\\r\\n  syscall.LoadLibrary = function (lib){\\r\\n//===========================================================\\r\\n\\tif (_LoadedLib[lib]) {\\r\\n\\t\\treturn _LoadedLib[lib];\\r\\n\\t}\\r\\n\\r\\n\\tvar handle = binding.LoadLibrary(lib);\\r\\n\\tif (handle === null){\\r\\n\\t\\tthrow new Error(\\\"unknown library name \\\" + lib);\\r\\n\\t}\\r\\n\\r\\n\\t_LoadedLib[lib] = new NewLoadLibrary(handle);\\r\\n\\treturn _LoadedLib[lib];\\r\\n};\\r\\n\\r\\n\\r\\nvar platform = process.platform;\\r\\nif (platform === 'win32'){\\r\\n\\trequire('syscall/windows')(module);\\r\\n} else {\\r\\n\\trequire('syscall/linux')(module);\\r\\n}\\r\\n\\r\\n//===========================================================\\r\\n  syscall.LookupIP = function(name) {\\r\\n//===========================================================\\r\\n\\tvar hints = new C.Struct.addrinfo();\\r\\n\\r\\n\\t//set hints\\r\\n\\thints.ai_family   = syscall.AF_UNSPEC;\\r\\n\\thints.ai_socktype = syscall.SOCK_STREAM;\\r\\n\\thints.ai_protocol = syscall.IPPROTO_IP;\\r\\n\\r\\n\\tvar result = C.void();\\r\\n\\t// name = UTF16PtrFromString(name);\\r\\n\\r\\n\\tvar e = syscall.getaddrinfo(name, null, hints, result);\\r\\n\\tif (e !== 0){\\r\\n\\t\\tthrow new Error(e);\\r\\n\\t}\\r\\n\\r\\n\\t// get pointer address stored in result buffer\\r\\n\\tvar freePTR = result.ptr;\\r\\n\\tresult = freePTR;\\r\\n\\tvar addrs = [];\\r\\n\\r\\n\\tvar info = new C.Struct.addrinfo(result);\\r\\n\\twhile (result !== null){\\r\\n\\t\\tvar info = new C.Struct.addrinfo(result);\\r\\n\\t\\tresult = info.ai_next;\\r\\n\\t\\tswitch (info.ai_family){\\r\\n\\t\\t\\tcase syscall.AF_INET : {\\r\\n\\t\\t\\t\\tvar addr = new C.Struct.sockaddr(info.ai_addr);\\r\\n\\t\\t\\t\\taddrs.push(sock.ntop(addr.pointer));\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tcase syscall.AF_INET6 : {\\r\\n\\t\\t\\t\\tvar addr = new C.Struct.sockaddr6(info.ai_addr);\\r\\n\\t\\t\\t\\taddrs.push(sock.ntop(addr.pointer));\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tdefault : throw new Error('unknown family type');\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tsyscall.freeaddrinfo(freePTR);\\r\\n\\treturn addrs;\\r\\n};\\r\\n\",\"syscall/linux\":\"module.exports = (function(platform){\\r\\n\\tvar sys     = process.binding('syscall');\\r\\n\\tvar C       = require('C');\\r\\n\\tvar assert  = require('assert');\\r\\n\\tvar errno   = require('errno');\\r\\n\\r\\n\\texports = platform.exports;\\r\\n\\texports.SYS = sys;\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t  var Timespec                                   // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.Timespec\\r\\n\\t= C.Struct.create({\\r\\n\\t\\tSec  : 'int32',\\r\\n\\t\\tNsec : 'int32'\\r\\n\\t});\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t  var Stat_t                                     // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.Stat_t\\r\\n\\t= C.Struct.create({\\r\\n\\t\\tDev       : 'uint64',\\r\\n\\t\\tX__pad1   : 'uint16',\\r\\n\\t\\tPad_cgo_0 : 2, //2 bytes buffer padding\\r\\n\\t\\tX__st_ino : 'uint32',\\r\\n\\t\\tMode      : 'uint32',\\r\\n\\t\\tNlink     : 'uint32',\\r\\n\\t\\tUid       : 'uint32',\\r\\n\\t\\tGid       : 'uint32',\\r\\n\\t\\tRdev      : 'uint64',\\r\\n\\t\\tX__pad2   : 'uint16',\\r\\n\\t\\tPad_cgo_1 : 2, //2 bytes buffer padding\\r\\n\\t\\tSize      : 'int64',\\r\\n\\t\\tBlksize   : 'int32',\\r\\n\\t\\tBlocks    : 'int64',\\r\\n\\t\\tAtim      : exports.Timespec, //Timespec\\r\\n\\t\\tMtim      : exports.Timespec, //Timespec\\r\\n\\t\\tCtim      : exports.Timespec, //Timespec\\r\\n\\t\\tIno       : 'uint64'\\r\\n\\t});\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t  var WinSize                                    // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.WinSize\\r\\n\\t= C.Struct.create({\\r\\n\\t\\tws_row    : 'uint16',\\r\\n\\t\\tws_col    : 'uint16',\\r\\n\\t\\tws_xpixel : 'uint16',\\r\\n\\t\\tws_ypixel : 'uint16'\\r\\n\\t});\\r\\n\\r\\n\\tvar libc = exports.LoadLibrary(null);\\r\\n\\r\\n\\tvar kill  = libc.GetProcAddress('kill', -1, 2);\\r\\n\\tvar fcntl = libc.GetProcAddress('fcntl', -1);\\r\\n\\tvar fork = libc.GetProcAddress('fork', -1, 0);\\r\\n\\tvar dup2 = libc.GetProcAddress('dup2', -1, 2);\\r\\n\\tvar chdir = libc.GetProcAddress('chdir', -1, 1);\\r\\n\\tvar setgroups = libc.GetProcAddress('setgroups', -1, 2);\\r\\n\\tvar execlp = libc.GetProcAddress('execlp', -1, 3);\\r\\n\\tvar wait = libc.GetProcAddress('wait', -1, 1);\\r\\n\\tvar waitpid = libc.GetProcAddress('waitpid', -1, 3);\\r\\n    var setenv  = libc.GetProcAddress('setenv', -1, 3);\\r\\n    var putenv  = libc.GetProcAddress('putenv', -1, 1);\\r\\n    var recvmsg  = libc.GetProcAddress('recvmsg', -1, 3);\\r\\n    var setsid  = libc.GetProcAddress('setsid', -1, 0);\\r\\n    var open  = libc.GetProcAddress('open', -1, 3);\\r\\n    var getuid = libc.GetProcAddress('getuid', -1, 0);\\r\\n    var setuid = libc.GetProcAddress('setuid', -1, 1);\\r\\n    var isatty = libc.GetProcAddress('isatty', -1, 1);\\r\\n    var getaddrinfo   = libc.GetProcAddress('getaddrinfo');\\r\\n    var freeaddrinfo   = libc.GetProcAddress('freeaddrinfo');\\r\\n    var ioctl   = libc.GetProcAddress('ioctl', -1);\\r\\n\\r\\n\\tvar pipe2;\\r\\n\\ttry {\\r\\n\\t\\tpipe2 = libc.GetProcAddress('pipe2', -1, 2);\\r\\n\\t} catch (e){}\\r\\n\\r\\n\\tvar pipe = libc.GetProcAddress('pipe', -1, 1);\\r\\n\\r\\n\\t// direct exported functions\\r\\n\\t//===========================================================\\r\\n\\t  exports.GetLastError = sys.GetLastError;\\r\\n\\t  exports.kill  = sys.kill;\\r\\n\\t  exports.fcntl = fcntl;\\r\\n\\t  exports.fork  = fork;\\r\\n\\t  exports.dup2  = dup2;\\r\\n\\t  exports.chdir  = chdir;\\r\\n\\t  exports.setgroups  = setgroups;\\r\\n\\t  exports.execlp = execlp;\\r\\n\\t  exports.waitpid = waitpid;\\r\\n\\t  exports.putenv = putenv;\\r\\n\\t  exports.recvmsg = recvmsg;\\r\\n\\t  exports.setsid = setsid;\\r\\n\\t  exports.setuid = setuid;\\r\\n\\t  exports.getuid = getuid;\\r\\n\\t  exports.getaddrinfo = getaddrinfo;\\r\\n\\t  exports.freeaddrinfo = freeaddrinfo;\\r\\n\\t  exports.isatty = isatty;\\r\\n\\t  exports.ioctl = ioctl;\\r\\n\\t//===========================================================\\r\\n\\r\\n\\t// cloexec\\r\\n\\t//===========================================================\\r\\n\\t  exports.cloexec = function(fd, set){\\r\\n\\t//===========================================================\\r\\n\\t\\tvar flags = 0;\\r\\n\\t\\tvar ret = fcntl(fd, sys.F_GETFD);\\r\\n\\t\\tif (ret === null) return null;\\r\\n\\r\\n\\t\\t// if cloexec flag already set do nothing\\r\\n\\t\\tif (!!(ret & sys.FD_CLOEXEC) == !!set) {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (set) {\\r\\n\\t\\t\\tflags = ret | sys.FD_CLOEXEC;\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tflags = ret & ~sys.FD_CLOEXEC;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tret = fcntl(fd, sys.F_SETFD, flags);\\r\\n\\t\\tif (ret === null) return null;\\r\\n\\t\\treturn 1;\\r\\n\\t};\\r\\n\\r\\n\\t// return a pair of pipes, null on error\\r\\n\\t//===========================================================\\r\\n\\t  var pairs = new C.Struct.create({ f : 'int', s : 'int' })();\\r\\n\\t  exports.pipe = function(){\\r\\n\\t//===========================================================\\r\\n\\t\\tif (pipe(pairs) === null) return null;\\r\\n\\t\\treturn [pairs.f, pairs.s];\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tif (pipe2){\\r\\n\\t\\t// exports pipe2 function if supported\\r\\n\\t\\t//===========================================================\\r\\n\\t\\t  exports.pipe2 = function(flags){\\r\\n\\t\\t//===========================================================\\r\\n\\t\\t\\tif (pipe2(pairs, flags || 0) === null) return null;\\r\\n\\t\\t\\treturn [pairs.f, pairs.s];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// process check status\\r\\n\\t//===========================================================\\r\\n\\t  exports.WTERMSIG    = function(s) { return (s & 0x7f) }\\r\\n\\t  exports.WEXITSTATUS = function(s) { return ((s) & 0xff00) >> 8 }\\r\\n\\t  exports.WIFEXITED   = function(s)  { return !exports.WTERMSIG(s) }\\r\\n\\t  exports.WIFSIGNALED = function(s) { return (( s & 0xffff) -1) < 0xff }\\r\\n\\t//===========================================================\\r\\n\\r\\n\\r\\n\\t// set environment variable\\r\\n\\t//===========================================================\\r\\n\\t  exports.Setenv = function(name, val){\\r\\n\\t//===========================================================\\r\\n\\t\\treturn setenv(name, val, 1);\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\texports.Open = function(file, access, perm){\\r\\n\\t\\treturn open(file, access, perm || 0);\\r\\n\\t}\\r\\n});\\r\\n\",\"syscall/windows\":\"module.exports = (function(platform){\\r\\n\\tvar binding = process.binding('syscall');\\r\\n\\tvar assert  = require('assert');\\r\\n\\tvar errno   = require('errno');\\r\\n\\tvar C       = require('C');\\r\\n\\t// var utf16   = require('../go/unicode/utf16');\\r\\n\\r\\n\\tvar syscall = exports = platform.exports;\\r\\n\\r\\n\\t{\\t// Invented values to support what package os expects.\\r\\n\\t\\tvar O_RDONLY   = exports.O_RDONLY   = 0x00000;\\r\\n\\t\\tvar O_WRONLY   = exports.O_WRONLY   = 0x00001;\\r\\n\\t\\tvar O_RDWR     = exports.O_RDWR     = 0x00002;\\r\\n\\t\\tvar O_CREAT    = exports.O_CREAT    = 0x00040;\\r\\n\\t\\tvar O_EXCL     = exports.O_EXCL     = 0x00080;\\r\\n\\t\\tvar O_NOCTTY   = exports.O_NOCTTY   = 0x00100;\\r\\n\\t\\tvar O_TRUNC    = exports.O_TRUNC    = 0x00200;\\r\\n\\t\\tvar O_NONBLOCK = exports.O_NONBLOCK = 0x00800;\\r\\n\\t\\tvar O_APPEND   = exports.O_APPEND   = 0x00400;\\r\\n\\t\\tvar O_SYNC     = exports.O_SYNC     = 0x01000;\\r\\n\\t\\tvar O_ASYNC    = exports.O_ASYNC    = 0x02000;\\r\\n\\t\\tvar O_CLOEXEC  = exports.O_CLOEXEC  = 0x80000;\\r\\n\\t}\\r\\n\\r\\n\\t{\\r\\n\\t\\tGENERIC_READ    = 0x80000000\\r\\n\\t\\tGENERIC_WRITE   = 0x40000000\\r\\n\\t\\tGENERIC_EXECUTE = 0x20000000\\r\\n\\t\\tGENERIC_ALL     = 0x10000000\\r\\n\\r\\n\\t\\tFILE_LIST_DIRECTORY   = 0x00000001\\r\\n\\t\\tFILE_APPEND_DATA      = 0x00000004\\r\\n\\t\\tFILE_WRITE_ATTRIBUTES = 0x00000100\\r\\n\\r\\n\\t\\tFILE_SHARE_READ              = 0x00000001\\r\\n\\t\\tFILE_SHARE_WRITE             = 0x00000002\\r\\n\\t\\tFILE_SHARE_DELETE            = 0x00000004\\r\\n\\t\\tFILE_ATTRIBUTE_READONLY      = 0x00000001\\r\\n\\t\\tFILE_ATTRIBUTE_HIDDEN        = 0x00000002\\r\\n\\t\\tFILE_ATTRIBUTE_SYSTEM        = 0x00000004\\r\\n\\t\\tFILE_ATTRIBUTE_DIRECTORY     = 0x00000010\\r\\n\\t\\tFILE_ATTRIBUTE_ARCHIVE       = 0x00000020\\r\\n\\t\\tFILE_ATTRIBUTE_NORMAL        = 0x00000080\\r\\n\\t\\tFILE_ATTRIBUTE_REPARSE_POINT = 0x00000400\\r\\n\\r\\n\\t\\tINVALID_FILE_ATTRIBUTES = 0xffffffff\\r\\n\\r\\n\\t\\tCREATE_NEW        = 1\\r\\n\\t\\tCREATE_ALWAYS     = 2\\r\\n\\t\\tOPEN_EXISTING     = 3\\r\\n\\t\\tOPEN_ALWAYS       = 4\\r\\n\\t\\tTRUNCATE_EXISTING = 5\\r\\n\\r\\n\\t\\tFILE_FLAG_OPEN_REPARSE_POINT = 0x00200000\\r\\n\\t\\tFILE_FLAG_BACKUP_SEMANTICS   = 0x02000000\\r\\n\\t\\tFILE_FLAG_OVERLAPPED         = 0x40000000\\r\\n\\r\\n\\t\\texports.HANDLE_FLAG_INHERIT    = 0x00000001\\r\\n\\t\\texports.STARTF_USESTDHANDLES   = 0x00000100\\r\\n\\t\\texports.STARTF_USESHOWWINDOW   = 0x00000001\\r\\n\\t\\texports.DUPLICATE_CLOSE_SOURCE = 0x00000001\\r\\n\\t\\texports.DUPLICATE_SAME_ACCESS  = 0x00000002\\r\\n\\r\\n\\t\\tSTD_INPUT_HANDLE  = -10\\r\\n\\t\\tSTD_OUTPUT_HANDLE = -11\\r\\n\\t\\tSTD_ERROR_HANDLE  = -12\\r\\n\\r\\n\\t\\tFILE_BEGIN   = 0\\r\\n\\t\\tFILE_CURRENT = 1\\r\\n\\t\\tFILE_END     = 2\\r\\n\\r\\n\\t\\tLANG_ENGLISH       = 0x09\\r\\n\\t\\tSUBLANG_ENGLISH_US = 0x01\\r\\n\\r\\n\\t\\tFORMAT_MESSAGE_ALLOCATE_BUFFER = 256\\r\\n\\t\\tFORMAT_MESSAGE_IGNORE_INSERTS  = 512\\r\\n\\t\\tFORMAT_MESSAGE_FROM_STRING     = 1024\\r\\n\\t\\tFORMAT_MESSAGE_FROM_HMODULE    = 2048\\r\\n\\t\\tFORMAT_MESSAGE_FROM_SYSTEM     = 4096\\r\\n\\t\\tFORMAT_MESSAGE_ARGUMENT_ARRAY  = 8192\\r\\n\\t\\tFORMAT_MESSAGE_MAX_WIDTH_MASK  = 255\\r\\n\\r\\n\\t\\tMAX_PATH      = 260\\r\\n\\t\\tMAX_LONG_PATH = 32768\\r\\n\\r\\n\\t\\tMAX_COMPUTERNAME_LENGTH = 15\\r\\n\\r\\n\\t\\tTIME_ZONE_ID_UNKNOWN  = 0\\r\\n\\t\\tTIME_ZONE_ID_STANDARD = 1\\r\\n\\r\\n\\t\\tTIME_ZONE_ID_DAYLIGHT = 2\\r\\n\\t\\tIGNORE                = 0\\r\\n\\t\\tINFINITE              = 0xffffffff\\r\\n\\r\\n\\t\\tWAIT_TIMEOUT   = 258\\r\\n\\t\\tWAIT_ABANDONED = 0x00000080\\r\\n\\t\\tWAIT_OBJECT_0  = 0x00000000\\r\\n\\t\\tWAIT_FAILED    = 0xFFFFFFFF\\r\\n\\r\\n\\t\\tCREATE_NEW_PROCESS_GROUP   = 0x00000200\\r\\n\\t\\tCREATE_UNICODE_ENVIRONMENT = 0x00000400\\r\\n\\r\\n\\t\\texports.PROCESS_TERMINATE         = 1\\r\\n\\t\\texports.PROCESS_QUERY_INFORMATION = 0x00000400\\r\\n\\t\\texports.SYNCHRONIZE               = 0x00100000\\r\\n\\r\\n\\t\\tPAGE_READONLY          = 0x02\\r\\n\\t\\tPAGE_READWRITE         = 0x04\\r\\n\\t\\tPAGE_WRITECOPY         = 0x08\\r\\n\\t\\tPAGE_EXECUTE_READ      = 0x20\\r\\n\\t\\tPAGE_EXECUTE_READWRITE = 0x40\\r\\n\\t\\tPAGE_EXECUTE_WRITECOPY = 0x80\\r\\n\\r\\n\\t\\tFILE_MAP_COPY    = 0x01\\r\\n\\t\\tFILE_MAP_WRITE   = 0x02\\r\\n\\t\\tFILE_MAP_READ    = 0x04\\r\\n\\t\\tFILE_MAP_EXECUTE = 0x20\\r\\n\\r\\n\\t\\tCTRL_C_EVENT     = 0\\r\\n\\t\\tCTRL_BREAK_EVENT = 1\\r\\n\\t}\\r\\n\\r\\n\\t{\\t//File types\\r\\n\\t\\texports.FILE_TYPE_CHAR    = 0x0002\\r\\n\\t\\texports.FILE_TYPE_DISK    = 0x0001\\r\\n\\t\\texports.FILE_TYPE_PIPE    = 0x0003\\r\\n\\t\\texports.FILE_TYPE_REMOTE  = 0x8000\\r\\n\\t\\texports.FILE_TYPE_UNKNOWN = 0x0000\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t{\\t// ShowWindow constants\\r\\n\\t\\t// winuser.h\\r\\n\\t\\texports.SW_HIDE            = 0\\r\\n\\t\\tSW_NORMAL          = 1\\r\\n\\t\\tSW_SHOWNORMAL      = 1\\r\\n\\t\\texports.SW_SHOWMINIMIZED   = 2\\r\\n\\t\\tSW_SHOWMAXIMIZED   = 3\\r\\n\\t\\tSW_MAXIMIZE        = 3\\r\\n\\t\\tSW_SHOWNOACTIVATE  = 4\\r\\n\\t\\tSW_SHOW            = 5\\r\\n\\t\\tSW_MINIMIZE        = 6\\r\\n\\t\\tSW_SHOWMINNOACTIVE = 7\\r\\n\\t\\tSW_SHOWNA          = 8\\r\\n\\t\\tSW_RESTORE         = 9\\r\\n\\t\\texports.SW_SHOWDEFAULT     = 10\\r\\n\\t\\tSW_FORCEMINIMIZE   = 11\\r\\n\\t}\\r\\n\\r\\n\\tvar WORD   = 'uint16';\\r\\n\\tvar DWORD  = 'uint32';\\r\\n\\tvar HANDLE = 'uint32';\\r\\n\\tvar ULONG  = 'uint32';\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar Overlapped                               // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.Overlapped\\r\\n\\t= C.Struct.create({\\r\\n\\t\\tInternal     : ULONG,\\r\\n\\t\\tInternalHigh : ULONG,\\r\\n\\t\\tOffset       : 'uint32',\\r\\n\\t\\tOffsetHigh   : 'uint32',\\r\\n\\t\\tHEvent       : HANDLE\\r\\n\\t});\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar Filetime                                 // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.Filetime\\r\\n\\t= C.Struct.create({\\r\\n\\t\\tLowDateTime  : DWORD,\\r\\n\\t\\tHighDateTime : DWORD\\r\\n\\t});\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar ByHandleFileInformation                  // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.ByHandleFileInformation\\r\\n\\t= C.Struct.create({\\r\\n\\t\\tFileAttributes      : DWORD,\\r\\n\\t\\tCreationTime        : exports.Filetime,\\r\\n\\t\\tLastAccessTime      : exports.Filetime,\\r\\n\\t\\tLastWriteTime       : exports.Filetime,\\r\\n\\t\\tVolumeSerialNumber  : DWORD,\\r\\n\\t\\tFileSizeHigh        : DWORD,\\r\\n\\t\\tFileSizeLow         : DWORD,\\r\\n\\t\\tNumberOfLinks       : DWORD,\\r\\n\\t\\tFileIndexHigh       : DWORD,\\r\\n\\t\\tFileIndexLow        : DWORD\\r\\n\\t});\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar Win32FileAttributeData                   // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.Win32FileAttributeData\\r\\n\\t= C.Struct.create({\\r\\n\\t\\tFileAttributes : 'uint32',\\r\\n\\t\\tCreationTime   : exports.Filetime,\\r\\n\\t\\tLastAccessTime : exports.Filetime,\\r\\n\\t\\tLastWriteTime  : exports.Filetime,\\r\\n\\t\\tFileSizeHigh   : 'uint32',\\r\\n\\t\\tFileSizeLow    : 'uint32'\\r\\n\\t});\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar SystemTime                               // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.SystemTime\\r\\n\\t= C.Struct.create({\\r\\n\\t\\tYear         : WORD,\\r\\n\\t\\tMonth        : WORD,\\r\\n\\t\\tDayOfWeek    : WORD,\\r\\n\\t\\tDay          : WORD,\\r\\n\\t\\tHour         : WORD,\\r\\n\\t\\tMinute       : WORD,\\r\\n\\t\\tSecond       : WORD,\\r\\n\\t\\tMilliseconds : WORD\\r\\n\\t});\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar SecurityAttributes                       // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.SecurityAttributes\\r\\n\\t= C.Struct.create ({\\r\\n\\t\\tLength             : 'uint32',\\r\\n\\t\\tSecurityDescriptor : 'uint32',\\r\\n\\t\\tInheritHandle      : 'uint32'\\r\\n\\t});\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar StartupInfo                              // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.StartupInfo\\r\\n\\t= C.Struct.create({\\r\\n\\t\\tCb            : 'uint32',\\r\\n\\t\\tReserved1     : '*',\\r\\n\\t\\tDesktop       : '*',\\r\\n\\t\\tTitle         : '*',\\r\\n\\t\\tX             : 'uint32',\\r\\n\\t\\tY             : 'uint32',\\r\\n\\t\\tXSize         : 'uint32',\\r\\n\\t\\tYSize         : 'uint32',\\r\\n\\t\\tXCountChars   : 'uint32',\\r\\n\\t\\tYCountChars   : 'uint32',\\r\\n\\t\\tFillAttribute : 'uint32',\\r\\n\\t\\tFlags         : 'uint32',\\r\\n\\t\\tShowWindow    : 'uint16',\\r\\n\\t\\tReserved2     : 'uint16',\\r\\n\\t\\tReserved3     : '*',\\r\\n\\t\\tStdInput      : HANDLE,\\r\\n\\t\\tStdOutput     : HANDLE,\\r\\n\\t\\tStdError      : HANDLE\\r\\n\\t});\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar ProcessInformation                       // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.ProcessInformation\\r\\n\\t= C.Struct.create({\\r\\n\\t\\tProcess   : HANDLE,\\r\\n\\t\\tThread    : HANDLE,\\r\\n\\t\\tProcessId : 'uint32',\\r\\n\\t\\tThreadId  : 'uint32'\\r\\n\\t});\\r\\n\\r\\n\\t//kernel32 library\\r\\n\\tvar kernel       = exports.LoadLibrary('kernel32');\\r\\n\\tvar ws2          = exports.LoadLibrary('Ws2_32');\\r\\n\\texports.WSADuplicateSocket = ws2.GetProcAddress('WSADuplicateSocketW', -1, 3);\\r\\n\\texports.WSASocket = ws2.GetProcAddress('WSASocketW');\\r\\n\\texports.WSAGetLastError = ws2.GetProcAddress('WSAGetLastError');\\r\\n\\r\\n\\texports.getaddrinfo   = ws2.GetProcAddress('getaddrinfo', null, 4);\\r\\n\\texports.freeaddrinfo  = ws2.GetProcAddress('freeaddrinfo');\\r\\n\\r\\n\\tGetLastError     = kernel.GetProcAddress('GetLastError');\\r\\n\\r\\n\\t// functions with failure value of -1.\\r\\n\\tvar GetStdHandle = kernel.GetProcAddress('GetStdHandle', -1);\\r\\n\\tvar CreateFile   = kernel.GetProcAddress('CreateFileW', -1);\\r\\n\\r\\n\\tvar ReadFile      = kernel.GetProcAddress('ReadFile', 0);\\r\\n\\tvar WriteFile     = kernel.GetProcAddress('WriteFile', 0);\\r\\n\\tvar GetTempPath   = kernel.GetProcAddress('GetTempPathW');\\r\\n\\tvar WriteConsole  = kernel.GetProcAddress('WriteConsoleW');\\r\\n\\tvar GetFileType   = kernel.GetProcAddress('GetFileType', 0, 1);\\r\\n\\r\\n\\tvar SetHandleInformation = kernel.GetProcAddress('SetHandleInformation', 0);\\r\\n\\tvar GetFileInformationByHandle = kernel.GetProcAddress('GetFileInformationByHandle', 0);\\r\\n\\tvar DuplicateHandle = kernel.GetProcAddress('DuplicateHandle', 0);\\r\\n\\tvar GetCurrentProcess = kernel.GetProcAddress('GetCurrentProcess');\\r\\n\\tvar GetCurrentProcessId = kernel.GetProcAddress('GetCurrentProcessId');\\r\\n\\tvar FileTimeToSystemTime = kernel.GetProcAddress('FileTimeToSystemTime', 0, 2);\\r\\n\\tvar OpenProcess    = kernel.GetProcAddress('OpenProcess', 0);\\r\\n\\tvar TerminateProcess   = kernel.GetProcAddress('TerminateProcess', 0, 2);\\r\\n\\tvar CreateProcess    = kernel.GetProcAddress('CreateProcessW', 0);\\r\\n\\tvar CloseHandle    = kernel.GetProcAddress('CloseHandle', 0);\\r\\n\\tvar GetExitCodeProcess = kernel.GetProcAddress('GetExitCodeProcess', 0);\\r\\n\\tvar GetCurrentDirectory =  kernel.GetProcAddress('GetCurrentDirectoryW', 0);\\r\\n\\tvar GetEnvironmentVariable =  kernel.GetProcAddress('GetEnvironmentVariableW', 0);\\r\\n\\tvar CreatePipe = kernel.GetProcAddress('CreatePipe', 0);\\r\\n\\tvar GetConsoleMode = kernel.GetProcAddress('GetConsoleMode', 0, 2);\\r\\n\\r\\n\\t// exported raw syscall functions\\r\\n\\t//===========================================================\\r\\n\\t  exports.GetLastError = GetLastError;\\r\\n\\t  exports.CloseOnExec = CloseOnExec;\\r\\n\\t  exports.DuplicateHandle = DuplicateHandle;\\r\\n\\t  exports.GetCurrentProcess = GetCurrentProcess;\\r\\n\\t  exports.GetCurrentProcessId = GetCurrentProcessId;\\r\\n\\r\\n\\t  exports.OpenProcess     = OpenProcess;\\r\\n\\t  exports.TerminateProcess  = TerminateProcess;\\r\\n\\t  exports.CreateProcess     = CreateProcess;\\r\\n\\t  exports.CloseHandle = CloseHandle;\\r\\n\\t  exports.GetExitCodeProcess = GetExitCodeProcess;\\r\\n\\r\\n\\t  exports.GetFdHandle = binding.GetFdHandle;\\r\\n\\t  exports.GetHandleFd = binding.GetHandleFd;\\r\\n\\r\\n\\t  exports.UTF16PtrFromString = UTF16PtrFromString;\\r\\n\\r\\n\\t  exports.WriteFile = WriteFile;\\r\\n\\t  exports.GetFileInformationByHandle = GetFileInformationByHandle;\\r\\n\\t  exports.FileTimeToSystemTime  = FileTimeToSystemTime;\\r\\n\\t  exports.GetFileType = GetFileType;\\r\\n\\t//===========================================================\\r\\n\\r\\n\\r\\n\\t// STDIO handles\\r\\n\\t//===========================================================\\r\\n\\t  exports.Stdin  = getStdHandle(STD_INPUT_HANDLE);\\r\\n\\t  exports.Stdout = getStdHandle(STD_OUTPUT_HANDLE);\\r\\n\\t  exports.Stderr = getStdHandle(STD_ERROR_HANDLE);\\r\\n\\t//===========================================================\\r\\n\\r\\n\\r\\n\\tfunction _kill(handle, signum){\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\texports.kill = function(pid, signum) {\\r\\n\\r\\n\\t\\tvar process_handle = OpenProcess(\\r\\n\\t\\t\\tPROCESS_TERMINATE | PROCESS_QUERY_INFORMATION,\\r\\n\\t\\t\\t0, pid\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\tif (process_handle === null) {\\r\\n\\t\\t\\terr = process.errno;\\r\\n\\t\\t\\tif (err == errno.ERROR_INVALID_PARAMETER) {\\r\\n\\t\\t\\t\\treturn errno.ESRCH;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn uv_translate_sys_error(err);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\terr = _kill(process_handle, signum);\\r\\n\\t\\tCloseHandle(process_handle);\\r\\n\\t\\treturn err;  /* err is already translated. */\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tfunction CloseOnExec(fd) {\\r\\n\\t\\treturn SetHandleInformation(fd, exports.HANDLE_FLAG_INHERIT, 0);\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tfunction getStdHandle(h){\\r\\n\\t\\tvar r = GetStdHandle(h);\\r\\n\\t\\tif (r === null) return null;\\r\\n\\t\\tCloseOnExec(r);\\r\\n\\t\\treturn r;\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tfunction UTF16PtrFromString (s){\\r\\n\\t\\ts = s + '\\\\0'; //nul terminated string\\r\\n\\t\\treturn new Buffer(s, 'ucs2');\\r\\n\\t\\t// return utf16.Encode(rune(s + \\\"\\\\x00\\\"));\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t// SetFilePointer return value is not as other win32 functions\\r\\n\\t// on failure it returns INVALID_SET_FILE_POINTER  0xffffffff\\r\\n\\t// we could define this error as GetProcAddress 2nd argument\\r\\n\\t// but for clarification we created a whole function\\r\\n\\tvar _SetFilePointer  = kernel.GetProcAddress('SetFilePointer');\\r\\n\\tfunction SetFilePointer(handle, lowoffset, highoffsetptr, whence) {\\r\\n\\t\\tvar newlowoffset = _SetFilePointer(handle, lowoffset, highoffsetptr, whence);\\r\\n\\t\\tif (newlowoffset === 0xffffffff) {\\r\\n\\t\\t\\tprocess.errno = GetLastError() || errno.EINVAL;\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\t\\treturn newlowoffset;\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t// returns a utf16 buffer to the current working directory\\r\\n\\t//===========================================================\\r\\n\\t  exports.GetCurrentDirectory = function() {\\r\\n\\t//===========================================================\\r\\n\\r\\n\\t\\t// first need get the current directory length\\r\\n\\t\\tvar buf_length = GetCurrentDirectory(0, null);\\r\\n\\t\\tif (!buf_length) return null;\\r\\n\\r\\n\\t\\tvar buf = new Buffer(buf_length * 2);\\r\\n\\r\\n\\t\\tvar ret = GetCurrentDirectory(buf.byteLength, buf);\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\tthrow new Error(process.errno);\\r\\n\\t\\t}\\r\\n\\t\\treturn buf;\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// returns string value of environment variable (v)\\r\\n\\t//===========================================================\\r\\n\\t  exports.Getenv = function(v) {\\r\\n\\t//===========================================================\\r\\n\\t\\tvar vUTF16 = UTF16PtrFromString(v);\\r\\n\\r\\n\\t\\tvar n = 200;\\r\\n\\r\\n\\t\\t// we first try with small buffer\\r\\n\\t\\t// if the return value exceeds our initial\\r\\n\\t\\t// buffer length we go through the loop\\r\\n\\t\\t// again and allocate a new buffer with the\\r\\n\\t\\t// exact length of charcters returned\\r\\n\\t\\twhile (1){\\r\\n\\t\\t\\tvar buf = new Buffer(n);\\r\\n\\t\\t\\tvar len = buf.byteLength;\\r\\n\\r\\n\\t\\t\\tn = GetEnvironmentVariable(vUTF16, buf, len);\\r\\n\\t\\t\\tif (n === null){\\r\\n\\t\\t\\t\\tif (process.errno === errno.ERROR_ENVVAR_NOT_FOUND){\\r\\n\\t\\t\\t\\t\\treturn \\\"\\\";\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthrow new Error(process.errno);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (n <= len){\\r\\n\\t\\t\\t\\treturn buf.toString('ucs2').slice(0, n);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tn *= 2;\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// enable disable file handle inheritance\\r\\n\\t// in new created child processes\\r\\n\\t//===========================================================\\r\\n\\t  exports.cloexec = function(fd, close){\\r\\n\\t//===========================================================\\r\\n\\t\\tvar n = close ? 0 : 1;\\r\\n\\t\\treturn SetHandleInformation(fd, exports.HANDLE_FLAG_INHERIT, n);\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// open file with mode and permission\\r\\n\\t// on success returns file handle opened\\r\\n\\t// on error returns null and set process.errno\\r\\n\\t// with the last syscall error\\r\\n\\t//===========================================================\\r\\n\\t  exports.Open = function(path, mode, perm) {\\r\\n\\t//===========================================================\\r\\n\\t\\tassert(typeof path === 'string', \\\"path must be a string\\\");\\r\\n\\r\\n\\t\\tif (path.length === 0) {\\r\\n\\t\\t\\tprocess.errno = ERROR_FILE_NOT_FOUND;\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar pathp = UTF16PtrFromString(path);\\r\\n\\t\\tif (pathp == null) { //return null as this already set errno\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar access = 0;\\r\\n\\t\\tswitch (mode & (O_RDONLY | O_WRONLY | O_RDWR)) {\\r\\n\\t\\t\\tcase O_RDONLY:\\r\\n\\t\\t\\t\\taccess = GENERIC_READ; break;\\r\\n\\t\\t\\tcase O_WRONLY:\\r\\n\\t\\t\\t\\taccess = GENERIC_WRITE; break;\\r\\n\\t\\t\\tcase O_RDWR:\\r\\n\\t\\t\\t\\taccess = GENERIC_READ | GENERIC_WRITE; break;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( (mode & O_CREAT) != 0 ) {\\r\\n\\t\\t\\taccess |= GENERIC_WRITE;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( (mode & O_APPEND) != 0 ) {\\r\\n\\t\\t\\taccess &= ~GENERIC_WRITE;\\r\\n\\t\\t\\taccess |= FILE_APPEND_DATA;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar sharemode = FILE_SHARE_READ | FILE_SHARE_WRITE;\\r\\n\\t\\tvar sa = SecurityAttributes();\\r\\n\\r\\n\\t\\t//if no O_CLOEXEC flag make this handle inheritable\\r\\n\\t\\tif ( (mode & O_CLOEXEC) == 0 ) {\\r\\n\\t\\t\\t// sa = makeInheritSa();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar createmode = 0;\\r\\n\\r\\n\\t\\t{\\t/*  file creation mode */\\r\\n\\t\\t\\tif ((mode & (O_CREAT | O_EXCL)) === (O_CREAT | O_EXCL)) {\\r\\n\\t\\t\\t\\tcreatemode = CREATE_NEW;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\telse if ((mode & (O_CREAT|O_TRUNC)) == (O_CREAT | O_TRUNC)){\\r\\n\\t\\t\\t\\tcreatemode = CREATE_ALWAYS;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\telse if ( (mode & O_CREAT) == O_CREAT ) {\\r\\n\\t\\t\\t\\tcreatemode = OPEN_ALWAYS;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\telse if ((mode & O_TRUNC) == O_TRUNC){\\r\\n\\t\\t\\t\\tcreatemode = TRUNCATE_EXISTING;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\tcreatemode = OPEN_EXISTING;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar h = CreateFile(pathp, access, sharemode, sa, createmode, FILE_ATTRIBUTE_NORMAL, 0);\\r\\n\\t\\treturn h;\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// Read file (fd) into buffer (b)\\r\\n\\t// on success returns number of read bytes\\r\\n\\t// on error returns null and set process.errno\\r\\n\\t// to the last syscall error\\r\\n\\t//===========================================================\\r\\n\\t  var rDone = new C.void( C.sizeOf.uint32 );\\r\\n\\t  exports.Read = function(fd, b) {\\r\\n\\t//===========================================================\\r\\n\\t\\tvar e = ReadFile(fd, b, b.byteLength, rDone, null);\\r\\n\\t\\tif (e === null) return e;\\r\\n\\t\\treturn rDone.uint32;\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// Write data from buffer (b) into file fd\\r\\n\\t// return null on failure and number of written data\\r\\n\\t// on success\\r\\n\\t//===========================================================\\r\\n\\t  var wDone = new C.void( C.sizeOf.uint32 );\\r\\n\\t  exports.Write = function(fd, b) {\\r\\n\\t//===========================================================\\r\\n\\t\\tvar e = WriteFile(fd, b, b.byteLength, wDone, null);\\r\\n\\t\\tif (e === null) return null;\\r\\n\\t\\treturn wDone.uint32;\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t  exports.Seek = function(fd, offset, whence) {\\r\\n\\t//===========================================================\\r\\n\\t\\tvar w = 0;\\r\\n\\t\\tswitch (whence) {\\r\\n\\t\\t\\tcase 0:\\r\\n\\t\\t\\t\\tw = FILE_BEGIN; break;\\r\\n\\t\\t\\tcase 1:\\r\\n\\t\\t\\t\\tw = FILE_CURRENT; break;\\r\\n\\t\\t\\tcase 2:\\r\\n\\t\\t\\t\\tw = FILE_END; break;\\r\\n\\t\\t\\tdeafult: throw new Error('unknown file seek whence');\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar hi = new C.void( C.sizeOf.uint32 );\\r\\n\\t\\thi.uint32 = offset.RShift(32); // offset >> 32\\r\\n\\r\\n\\t\\tvar lo = offset;\\r\\n\\t\\t// use GetFileType to check pipe, pipe can't do seek\\r\\n\\t\\tvar ft = GetFileType(fd);\\r\\n\\t\\tif (ft == FILE_TYPE_PIPE) {\\r\\n\\t\\t\\tprocess.errno = errno.EPIPE;\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar rlo = SetFilePointer(fd, lo, hi, w);\\r\\n\\t\\tif (rlo === null) return null;\\r\\n\\r\\n\\t\\t//(hi << 32) + rlo\\r\\n\\t\\treturn ( hi.uint32.LShift(32) ) + rlo;\\r\\n\\t};\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t  var consoleMode = new C.void( C.sizeOf.uint32 );\\r\\n\\t  exports.GetConsoleMode = function(handle){\\r\\n\\t//===========================================================\\r\\n\\t\\tif (GetConsoleMode(handle, consoleMode) === null){\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\t\\treturn consoleMode.uint32;\\r\\n\\t};\\r\\n});\\r\\n\",\"module\":\"'use strict';\\r\\n\\r\\nconst NativeModule = process.NativeModule;\\r\\nconst util = require('util');\\r\\nconst internalModule = {};\\r\\n\\r\\ninternalModule.stripBOM = function(content) {\\r\\n\\tif (content.charCodeAt(0) === 0xFEFF) {\\r\\n\\t\\tcontent = content.slice(1);\\r\\n\\t}\\r\\n\\treturn content;\\r\\n};\\r\\n\\r\\ninternalModule.makeRequireFunction = function() {\\r\\n\\tconst Module = this.constructor;\\r\\n\\tconst self = this;\\r\\n\\r\\n\\tfunction require(path) {\\r\\n\\t\\treturn self.require(path);\\r\\n\\t}\\r\\n\\r\\n\\trequire.resolve = function(request) {\\r\\n\\t\\treturn Module._resolveFilename(request, self);\\r\\n\\t};\\r\\n\\r\\n\\trequire.main = process.mainModule;\\r\\n\\r\\n\\t// Enable support to add extra extension types.\\r\\n\\trequire.extensions = Module._extensions;\\r\\n\\r\\n\\trequire.cache = Module._cache;\\r\\n\\r\\n\\treturn require;\\r\\n};\\r\\n\\r\\nconst runInThisContext = function(script, options){\\r\\n\\treturn process.eval(script, options.filename, options.lineOffset);\\r\\n};\\r\\n\\r\\nconst internalUtil = require('internal/util');\\r\\nconst assert = require('assert').ok;\\r\\nconst fs = require('fs');\\r\\nconst path = require('path');\\r\\npath._makeLong = function(p){ return p };\\r\\n\\r\\nconst internalModuleReadFile = function(file){\\r\\n\\tif (process.isFile(file)){\\r\\n\\t\\tvar content = process.readFile(file);\\r\\n\\t\\treturn internalModule.stripBOM(content);\\r\\n\\t}\\r\\n\\treturn;\\r\\n};\\r\\n\\r\\nconst internalModuleStat = function(file){\\r\\n\\treturn process.stat(file);\\r\\n};\\r\\n\\r\\nconst splitRe = process.platform === 'win32' ? /[\\\\/\\\\\\\\]/ : /\\\\//;\\r\\nconst isIndexRe = /^index\\\\.\\\\w+?$/;\\r\\nconst shebangRe = /^\\\\#\\\\!.*/;\\r\\n\\r\\n// If obj.hasOwnProperty has been overridden, then calling\\r\\n// obj.hasOwnProperty(prop) will break.\\r\\n// See: https://github.com/joyent/node/issues/1707\\r\\nfunction hasOwnProperty(obj, prop) {\\r\\n\\treturn Object.prototype.hasOwnProperty.call(obj, prop);\\r\\n}\\r\\n\\r\\n\\r\\nfunction Module(id, parent) {\\r\\n\\tthis.id = id;\\r\\n\\tthis.exports = {};\\r\\n\\tthis.parent = parent;\\r\\n\\tif (parent && parent.children) {\\r\\n\\t\\tparent.children.push(this);\\r\\n\\t}\\r\\n\\r\\n\\tthis.filename = null;\\r\\n\\tthis.loaded = false;\\r\\n\\tthis.children = [];\\r\\n}\\r\\nmodule.exports = Module;\\r\\n\\r\\nModule._cache = {};\\r\\nModule._pathCache = {};\\r\\nModule._extensions = {};\\r\\nvar modulePaths = [];\\r\\nModule.globalPaths = [];\\r\\n\\r\\nModule.wrapper = NativeModule.wrapper;\\r\\nModule.wrap = NativeModule.wrap;\\r\\nModule._debug = util.debuglog('module');\\r\\n\\r\\n// We use this alias for the preprocessor that filters it out\\r\\nconst debug = Module._debug;\\r\\n\\r\\n\\r\\n// given a module name, and a list of paths to test, returns the first\\r\\n// matching file in the following precedence.\\r\\n//\\r\\n// require(\\\"a.<ext>\\\")\\r\\n//   -> a.<ext>\\r\\n//\\r\\n// require(\\\"a\\\")\\r\\n//   -> a\\r\\n//   -> a.<ext>\\r\\n//   -> a/index.<ext>\\r\\n\\r\\n// check if the directory is a package.json dir\\r\\nconst packageMainCache = {};\\r\\n\\r\\nfunction readPackage(requestPath) {\\r\\n\\tif (hasOwnProperty(packageMainCache, requestPath)) {\\r\\n\\t\\treturn packageMainCache[requestPath];\\r\\n\\t}\\r\\n\\r\\n\\tvar jsonPath = path.resolve(requestPath, 'package.json');\\r\\n\\tvar json = internalModuleReadFile(path._makeLong(jsonPath));\\r\\n\\r\\n\\tif (json === undefined) {\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\r\\n\\ttry {\\r\\n\\t\\tvar pkg = packageMainCache[requestPath] = JSON.parse(json).main;\\r\\n\\t} catch (e) {\\r\\n\\t\\te.path = jsonPath;\\r\\n\\t\\te.message = 'Error parsing ' + jsonPath + ': ' + e.message;\\r\\n\\t\\tthrow e;\\r\\n\\t}\\r\\n\\treturn pkg;\\r\\n}\\r\\n\\r\\nfunction tryPackage(requestPath, exts) {\\r\\n\\tvar pkg = readPackage(requestPath);\\r\\n\\r\\n\\tif (!pkg) return false;\\r\\n\\r\\n\\tvar filename = path.resolve(requestPath, pkg);\\r\\n\\treturn tryFile(filename) || tryExtensions(filename, exts) ||\\r\\n\\t\\t\\t\\t tryExtensions(path.resolve(filename, 'index'), exts);\\r\\n}\\r\\n\\r\\n// In order to minimize unnecessary lstat() calls,\\r\\n// this cache is a list of known-real paths.\\r\\n// Set to an empty object to reset.\\r\\nModule._realpathCache = {};\\r\\n\\r\\n// check if the file exists and is not a directory\\r\\nfunction tryFile(requestPath) {\\r\\n\\tconst rc = internalModuleStat(path._makeLong(requestPath));\\r\\n\\treturn rc === 0 && toRealPath(requestPath);\\r\\n}\\r\\n\\r\\nfunction toRealPath(requestPath) {\\r\\n\\treturn fs.realpathSync(requestPath, Module._realpathCache);\\r\\n}\\r\\n\\r\\n// given a path check a the file exists with any of the set extensions\\r\\nfunction tryExtensions(p, exts) {\\r\\n\\tfor (var i = 0, EL = exts.length; i < EL; i++) {\\r\\n\\t\\tvar filename = tryFile(p + exts[i]);\\r\\n\\r\\n\\t\\tif (filename) {\\r\\n\\t\\t\\treturn filename;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn false;\\r\\n}\\r\\n\\r\\nvar warned = false;\\r\\nModule._findPath = function(request, paths) {\\r\\n\\tvar exts = Object.keys(Module._extensions);\\r\\n\\r\\n\\tif (path.isAbsolute(request)) {\\r\\n\\t\\tpaths = [''];\\r\\n\\t}\\r\\n\\r\\n\\tvar trailingSlash = (request.slice(-1) === '/');\\r\\n\\r\\n\\tvar cacheKey = JSON.stringify({request: request, paths: paths});\\r\\n\\tif (Module._pathCache[cacheKey]) {\\r\\n\\t\\treturn Module._pathCache[cacheKey];\\r\\n\\t}\\r\\n\\r\\n\\t// For each path\\r\\n\\tfor (var i = 0, PL = paths.length; i < PL; i++) {\\r\\n\\t\\t// Don't search further if path doesn't exist\\r\\n\\t\\tif (paths[i] && internalModuleStat(path._makeLong(paths[i])) < 1) continue;\\r\\n\\t\\tvar basePath = path.resolve(paths[i], request);\\r\\n\\t\\tvar filename;\\r\\n\\r\\n\\t\\tif (!trailingSlash) {\\r\\n\\t\\t\\tconst rc = internalModuleStat(path._makeLong(basePath));\\r\\n\\t\\t\\tif (rc === 0) {  // File.\\r\\n\\t\\t\\t\\tfilename = toRealPath(basePath);\\r\\n\\t\\t\\t} else if (rc === 1) {  // Directory.\\r\\n\\t\\t\\t\\tfilename = tryPackage(basePath, exts);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (!filename) {\\r\\n\\t\\t\\t\\t// try it with each of the extensions\\r\\n\\t\\t\\t\\tfilename = tryExtensions(basePath, exts);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!filename) {\\r\\n\\t\\t\\tfilename = tryPackage(basePath, exts);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!filename) {\\r\\n\\t\\t\\t// try it with each of the extensions at \\\"index\\\"\\r\\n\\t\\t\\tfilename = tryExtensions(path.resolve(basePath, 'index'), exts);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (filename) {\\r\\n\\t\\t\\t// Warn once if '.' resolved outside the module dir\\r\\n\\t\\t\\tif (request === '.' && i > 0) {\\r\\n\\t\\t\\t\\twarned = internalUtil.printDeprecationMessage(\\r\\n\\t\\t\\t\\t\\t'warning: require(\\\\'.\\\\') resolved outside the package ' +\\r\\n\\t\\t\\t\\t\\t'directory. This functionality is deprecated and will be removed ' +\\r\\n\\t\\t\\t\\t\\t'soon.', warned);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tModule._pathCache[cacheKey] = filename;\\r\\n\\t\\t\\treturn filename;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn false;\\r\\n};\\r\\n\\r\\n// 'from' is the __dirname of the module.\\r\\nModule._nodeModulePaths = function(from) {\\r\\n\\t// guarantee that 'from' is absolute.\\r\\n\\tfrom = path.resolve(from);\\r\\n\\r\\n\\t// note: this approach *only* works when the path is guaranteed\\r\\n\\t// to be absolute.  Doing a fully-edge-case-correct path.split\\r\\n\\t// that works on both Windows and Posix is non-trivial.\\r\\n\\tvar paths = [];\\r\\n\\tvar parts = from.split(splitRe);\\r\\n\\r\\n\\tfor (var tip = parts.length - 1; tip >= 0; tip--) {\\r\\n\\t\\t// don't search in .../node_modules/node_modules\\r\\n\\t\\tif (parts[tip] === 'node_modules') continue;\\r\\n\\t\\tvar dir = parts.slice(0, tip + 1).concat('node_modules').join(path.sep);\\r\\n\\t\\tpaths.push(dir);\\r\\n\\t}\\r\\n\\r\\n\\treturn paths;\\r\\n};\\r\\n\\r\\n\\r\\nModule._resolveLookupPaths = function(request, parent) {\\r\\n\\tif (NativeModule.nonInternalExists(request)) {\\r\\n\\t\\treturn [request, []];\\r\\n\\t}\\r\\n\\r\\n\\tvar start = request.substring(0, 2);\\r\\n\\tif (start !== './' && start !== '..') {\\r\\n\\t\\tvar paths = modulePaths;\\r\\n\\t\\tif (parent) {\\r\\n\\t\\t\\tif (!parent.paths) parent.paths = [];\\r\\n\\t\\t\\tpaths = parent.paths.concat(paths);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Maintain backwards compat with certain broken uses of require('.')\\r\\n\\t\\t// by putting the module's directory in front of the lookup paths.\\r\\n\\t\\tif (request === '.') {\\r\\n\\t\\t\\tif (parent && parent.filename) {\\r\\n\\t\\t\\t\\tpaths.splice(0, 0, path.dirname(parent.filename));\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tpaths.splice(0, 0, path.resolve(request));\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn [request, paths];\\r\\n\\t}\\r\\n\\r\\n\\t// with --eval, parent.id is not set and parent.filename is null\\r\\n\\tif (!parent || !parent.id || !parent.filename) {\\r\\n\\t\\t// make require('./path/to/foo') work - normally the path is taken\\r\\n\\t\\t// from realpath(__filename) but with eval there is no filename\\r\\n\\t\\tvar mainPaths = ['.'].concat(modulePaths);\\r\\n\\t\\tmainPaths = Module._nodeModulePaths('.').concat(mainPaths);\\r\\n\\t\\treturn [request, mainPaths];\\r\\n\\t}\\r\\n\\r\\n\\t// Is the parent an index module?\\r\\n\\t// We can assume the parent has a valid extension,\\r\\n\\t// as it already has been accepted as a module.\\r\\n\\tvar isIndex = isIndexRe.test(path.basename(parent.filename));\\r\\n\\tvar parentIdPath = isIndex ? parent.id : path.dirname(parent.id);\\r\\n\\tvar id = path.resolve(parentIdPath, request);\\r\\n\\r\\n\\t// make sure require('./path') and require('path') get distinct ids, even\\r\\n\\t// when called from the toplevel js file\\r\\n\\tif (parentIdPath === '.' && id.indexOf('/') === -1) {\\r\\n\\t\\tid = './' + id;\\r\\n\\t}\\r\\n\\r\\n\\tdebug('RELATIVE: requested: %s set ID to: %s from %s', request, id,\\r\\n\\t\\t\\t\\tparent.id);\\r\\n\\r\\n\\treturn [id, [path.dirname(parent.filename)]];\\r\\n};\\r\\n\\r\\n\\r\\n// Check the cache for the requested file.\\r\\n// 1. If a module already exists in the cache: return its exports object.\\r\\n// 2. If the module is native: call `NativeModule.require()` with the\\r\\n//    filename and return the result.\\r\\n// 3. Otherwise, create a new module for the file and save it to the cache.\\r\\n//    Then have it load  the file contents before returning its exports\\r\\n//    object.\\r\\nModule._load = function(request, parent, isMain) {\\r\\n\\tif (parent) {\\r\\n\\t\\tdebug('Module._load REQUEST %s parent: %s', request, parent.id);\\r\\n\\t}\\r\\n\\r\\n\\tvar filename = Module._resolveFilename(request, parent);\\r\\n\\r\\n\\tvar cachedModule = Module._cache[filename];\\r\\n\\tif (cachedModule) {\\r\\n\\t\\treturn cachedModule.exports;\\r\\n\\t}\\r\\n\\r\\n\\tif (NativeModule.nonInternalExists(filename)) {\\r\\n\\t\\tdebug('load native module %s', request);\\r\\n\\t\\treturn NativeModule.require(filename);\\r\\n\\t}\\r\\n\\r\\n\\tvar module = new Module(filename, parent);\\r\\n\\r\\n\\tif (isMain) {\\r\\n\\t\\tprocess.mainModule = module;\\r\\n\\t\\tmodule.id = '.';\\r\\n\\t}\\r\\n\\r\\n\\tModule._cache[filename] = module;\\r\\n\\r\\n\\tvar hadException = true;\\r\\n\\r\\n\\ttry {\\r\\n\\t\\tmodule.load(filename);\\r\\n\\t\\thadException = false;\\r\\n\\t} finally {\\r\\n\\t\\tif (hadException) {\\r\\n\\t\\t\\tdelete Module._cache[filename];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\treturn module.exports;\\r\\n};\\r\\n\\r\\nModule._resolveFilename = function(request, parent) {\\r\\n\\tif (NativeModule.nonInternalExists(request)) {\\r\\n\\t\\treturn request;\\r\\n\\t}\\r\\n\\r\\n\\tvar resolvedModule = Module._resolveLookupPaths(request, parent);\\r\\n\\tvar id = resolvedModule[0];\\r\\n\\tvar paths = resolvedModule[1];\\r\\n\\r\\n\\t// look up the filename first, since that's the cache key.\\r\\n\\tdebug('looking for %j in %j', id, paths);\\r\\n\\r\\n\\tvar filename = Module._findPath(request, paths);\\r\\n\\tif (!filename) {\\r\\n\\t\\tvar err = new Error(\\\"Cannot find module '\\\" + request + \\\"'\\\");\\r\\n\\t\\terr.code = 'MODULE_NOT_FOUND';\\r\\n\\t\\tthrow err;\\r\\n\\t}\\r\\n\\treturn filename;\\r\\n};\\r\\n\\r\\n\\r\\n// Given a file name, pass it to the proper extension handler.\\r\\nModule.prototype.load = function(filename) {\\r\\n\\tdebug('load %j for module %j', filename, this.id);\\r\\n\\r\\n\\tassert(!this.loaded);\\r\\n\\tthis.filename = filename;\\r\\n\\tthis.paths = Module._nodeModulePaths(path.dirname(filename));\\r\\n\\r\\n\\tvar extension = path.extname(filename) || '.js';\\r\\n\\tif (!Module._extensions[extension]) extension = '.js';\\r\\n\\tModule._extensions[extension](this, filename);\\r\\n\\tthis.loaded = true;\\r\\n};\\r\\n\\r\\n\\r\\n// Loads a module at the given file path. Returns that module's\\r\\n// `exports` property.\\r\\nModule.prototype.require = function(path) {\\r\\n\\tassert(path, 'missing path');\\r\\n\\tassert(typeof path === 'string', 'path must be a string');\\r\\n\\treturn Module._load(path, this);\\r\\n};\\r\\n\\r\\n\\r\\n// Resolved path to process.argv[1] will be lazily placed here\\r\\n// (needed for setting breakpoint when called with --debug-brk)\\r\\nvar resolvedArgv;\\r\\n\\r\\n\\r\\n// Run the file contents in the correct scope or sandbox. Expose\\r\\n// the correct helper variables (require, module, exports) to\\r\\n// the file.\\r\\n// Returns exception, if any.\\r\\nModule.prototype._compile = function(content, filename) {\\r\\n\\t// remove shebang\\r\\n\\tcontent = content.replace(shebangRe, '');\\r\\n\\r\\n\\t// create wrapper function\\r\\n\\tvar wrapper = Module.wrap(content);\\r\\n\\r\\n\\tvar compiledWrapper = runInThisContext(wrapper,\\r\\n\\t\\t{ filename: filename, lineOffset: 0 });\\r\\n\\tif (global.v8debug) {\\r\\n\\t\\tif (!resolvedArgv) {\\r\\n\\t\\t\\t// we enter the repl if we're not given a filename argument.\\r\\n\\t\\t\\tif (process.argv[1]) {\\r\\n\\t\\t\\t\\tresolvedArgv = Module._resolveFilename(process.argv[1], null);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tresolvedArgv = 'repl';\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Set breakpoint on module start\\r\\n\\t\\tif (filename === resolvedArgv) {\\r\\n\\t\\t\\t// Installing this dummy debug event listener tells V8 to start\\r\\n\\t\\t\\t// the debugger.  Without it, the setBreakPoint() fails with an\\r\\n\\t\\t\\t// 'illegal access' error.\\r\\n\\t\\t\\tglobal.v8debug.Debug.setListener(function() {});\\r\\n\\t\\t\\tglobal.v8debug.Debug.setBreakPoint(compiledWrapper, 0, 0);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tconst dirname = path.dirname(filename);\\r\\n\\tconst require = internalModule.makeRequireFunction.call(this);\\r\\n\\tconst args = [this.exports, require, this, filename, dirname];\\r\\n\\treturn compiledWrapper.apply(this.exports, args);\\r\\n};\\r\\n\\r\\n\\r\\n// Native extension for .js\\r\\nModule._extensions['.js'] = function(module, filename) {\\r\\n\\tvar content = fs.readFileSync(filename, 'utf8');\\r\\n\\tmodule._compile(internalModule.stripBOM(content), filename);\\r\\n};\\r\\n\\r\\n\\r\\n// Native extension for .json\\r\\nModule._extensions['.json'] = function(module, filename) {\\r\\n\\tvar content = fs.readFileSync(filename, 'utf8');\\r\\n\\ttry {\\r\\n\\t\\tmodule.exports = JSON.parse(internalModule.stripBOM(content));\\r\\n\\t} catch (err) {\\r\\n\\t\\terr.message = filename + ': ' + err.message;\\r\\n\\t\\tthrow err;\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\n//Native extension for .node\\r\\nModule._extensions['.como'] =\\r\\nModule._extensions['.node'] = function(module, filename) {\\r\\n\\treturn process.dlopen(module, path._makeLong(filename));\\r\\n};\\r\\n\\r\\n\\r\\n// bootstrap main module.\\r\\nModule.runMain = function() {\\r\\n\\t// Load the main module--the command line argument.\\r\\n\\tModule._load(process.argv[1], null, true);\\r\\n\\t// Handle any nextTicks added in the first tick of the program\\r\\n\\tprocess._tickCallback();\\r\\n};\\r\\n\\r\\nModule._initPaths = function() {\\r\\n\\tconst isWindows = process.platform === 'win32';\\r\\n\\r\\n\\tif (isWindows) {\\r\\n\\t\\tvar homeDir = process.env.USERPROFILE;\\r\\n\\t} else {\\r\\n\\t\\tvar homeDir = process.env.HOME;\\r\\n\\t}\\r\\n\\r\\n\\tvar paths = [path.resolve(process.execPath, '..', '..', 'lib', 'node')];\\r\\n\\r\\n\\tif (homeDir) {\\r\\n\\t\\tpaths.unshift(path.resolve(homeDir, '.node_libraries'));\\r\\n\\t\\tpaths.unshift(path.resolve(homeDir, '.node_modules'));\\r\\n\\t}\\r\\n\\r\\n\\tvar nodePath = process.env['NODE_PATH'];\\r\\n\\tif (nodePath) {\\r\\n\\t\\tpaths = nodePath.split(path.delimiter).filter(function(path) {\\r\\n\\t\\t\\treturn !!path;\\r\\n\\t\\t}).concat(paths);\\r\\n\\t}\\r\\n\\r\\n\\tmodulePaths = paths;\\r\\n\\r\\n\\t// clone as a read-only copy, for introspection.\\r\\n\\tModule.globalPaths = modulePaths.slice(0);\\r\\n};\\r\\n\\r\\n// TODO(bnoordhuis) Unused, remove in the future.\\r\\nModule.requireRepl = internalUtil.deprecate(function() {\\r\\n\\treturn NativeModule.require('internal/repl');\\r\\n}, 'Module.requireRepl is deprecated.');\\r\\n\\r\\nModule._preloadModules = function(requests) {\\r\\n\\tif (!Array.isArray(requests))\\r\\n\\t\\treturn;\\r\\n\\r\\n\\t// Preloaded modules have a dummy parent module which is deemed to exist\\r\\n\\t// in the current working directory. This seeds the search path for\\r\\n\\t// preloaded modules.\\r\\n\\tvar parent = new Module('internal/preload', null);\\r\\n\\ttry {\\r\\n\\t\\tparent.paths = Module._nodeModulePaths(process.cwd());\\r\\n\\t}\\r\\n\\tcatch (e) {\\r\\n\\t\\tif (e.code !== 'ENOENT') {\\r\\n\\t\\t\\tthrow e;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\trequests.forEach(function(request) {\\r\\n\\t\\tparent.require(request);\\r\\n\\t});\\r\\n};\\r\\n\\r\\nModule._initPaths();\\r\\n\\r\\n// backwards compatibility\\r\\nModule.Module = Module;\\r\\n\",\"http_parser\":\"/**\\r\\n* @module http-parser\\r\\n* @author Mamod A. Mehyar\\r\\n* @license MIT\\r\\n******************************************************************************/\\r\\n\\\"use strict\\\";\\r\\n\\r\\nvar parser = process.binding('http-parser');\\r\\nvar assert = require('assert');\\r\\n\\r\\n\\r\\nvar headersNum = 0;\\r\\nvar lastHeaderfield = '';\\r\\nvar lastHeaderValue = '';\\r\\n\\r\\n/** @constructor\\r\\n  * @alias module:http-parser\\r\\n  * @param type {Constant} http parsing type [ <b>parser.REQUEST</b> |\\r\\n  * <b>parser.RESPONSE</b> | <b>parser.BOTH</b> ]\\r\\n  *\\r\\n  * @example\\r\\n  * var parser = require('http-parser');\\r\\n  * var p = new parser(parser.RESPONSE);\\r\\n  *\\r\\n  * var HTTPResponse = \\\"POST /example HTTP/1.1\\\\r\\\\n\\\"  +\\r\\n  *                    \\\"Host: example.com\\\\r\\\\n\\\"       +\\r\\n  *                    \\\"Content-Type: text/html\\\\r\\\\n\\\" +\\r\\n  *                    \\\"Content-Length: 2\\\\r\\\\n\\\\r\\\\n\\\"   +\\r\\n  *                    \\\"Hi\\\";\\r\\n  *\\r\\n  * var nread = p.parse(HTTPResponse);\\r\\n  * console.log(p.method);  // log method type\\r\\n  * console.log(p.path);    // log response path\\r\\n  * console.log(p.headers); // log response headers\\r\\n  * p.on_status = function(val){\\r\\n  *     console.log(val);\\r\\n  * };\\r\\n  *\\r\\n  * @returns {Object} an http parser object\\r\\n  *\\r\\n******************************************************************************/\\r\\nfunction HTTPParser (type){\\r\\n\\ttype = type || 0;\\r\\n\\tthis.headers = {};\\r\\n\\tthis._headers = [];\\r\\n\\tthis._headerFields = [];\\r\\n\\tthis._headerValues = [];\\r\\n\\r\\n\\tthis.body = '';\\r\\n\\tthis.url = '';\\r\\n\\tvar pointer = parser.init(type, this);\\r\\n\\tthis.pointer = pointer;\\r\\n\\tthis.type = type;\\r\\n\\tif (pointer === null) {\\r\\n\\t\\tthrow new Error(\\\"out of memory while creating new Http parser\\\");\\r\\n\\t}\\r\\n\\treturn this;\\r\\n}\\r\\n\\r\\nHTTPParser.prototype._reset = function(){\\r\\n\\theadersNum = 0;\\r\\n\\tlastHeaderfield = '';\\r\\n\\tlastHeaderValue = '';\\r\\n\\r\\n\\tthis.status_message = '';\\r\\n\\tthis._headers = [];\\r\\n\\tthis._headerFields = [];\\r\\n\\tthis._headerValues = [];\\r\\n\\r\\n\\tthis._headerFields.length = 0;\\r\\n\\tthis._headerValues.length = 0;\\r\\n\\tthis._headers.length = 0;\\r\\n\\r\\n\\tthis.headers = {};\\r\\n\\tthis.url = '';\\r\\n}\\r\\n\\r\\nHTTPParser.prototype._check_message = function(r){\\r\\n\\tif (!r){\\r\\n\\t\\tthis.got_exception = true;\\r\\n\\t\\treturn -1;\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n/** parse http strings, on error return an instance of Error object,\\r\\n  * other wise number of bytes parsed so far will be returned\\r\\n  *\\r\\n  * @function\\r\\n  * @param type {String} http string (either a response or request string)\\r\\n  *\\r\\n  * @returns {Number} number of parsed bytes\\r\\n  *\\r\\n******************************************************************************/\\r\\nHTTPParser.prototype.execute = HTTPParser.prototype.parse = function (str, len){\\r\\n\\tstr = String(str); //make sure it's a string\\r\\n\\tlen = len || str.length;\\r\\n\\tvar nparsed = parser.execute(this.pointer, str, len);\\r\\n\\tif (!this.upgrade() && nparsed !== len) {\\r\\n\\t\\tvar cb = this[HTTPParser.kOnExecute];\\r\\n\\t\\tvar err  = Error('Parse Error');\\r\\n\\t\\terr.bytesRead = nparsed;\\r\\n\\t\\tif (!cb) return err;\\r\\n\\t\\tcb.call(this, err);\\r\\n\\t\\treturn err;\\r\\n\\t}\\r\\n\\r\\n\\treturn nparsed;\\r\\n};\\r\\n\\r\\n/** Reinitialize parser type so you can use it on different http headers\\r\\n  * [response / request] without a need to reconstruct a new http-parser\\r\\n  * object\\r\\n  *\\r\\n  * @function\\r\\n  * @param type {Constant} http parsing type [ <b>parser.REQUEST</b> |\\r\\n  * <b>parser.RESPONSE</b> | <b>parser.BOTH</b> ]\\r\\n  *\\r\\n  * @example\\r\\n  * var p = new parser(parser.RESPONSE);\\r\\n  * //do some response header parsing ...\\r\\n  * p.reinitialize(parser.REQUEST);\\r\\n  * //do some request headers parsing ...\\r\\n  *\\r\\n******************************************************************************/\\r\\nHTTPParser.prototype.reinitialize = function (type){\\r\\n\\tassert(type == parser.HTTP_REQUEST ||\\r\\n\\t\\t   type == parser.HTTP_RESPONSE);\\r\\n\\r\\n\\tthis._reset();\\r\\n\\tthis.type = type;\\r\\n\\tparser.reinitialize(this.pointer, type);\\r\\n};\\r\\n\\r\\n\\r\\n/** Will be called every time the parser parses header field name\\r\\n  * and should be followed by on_header_value callback\\r\\n  *\\r\\n  * @ignore\\r\\n  * @function on_header_field\\r\\n  * @param value {String} header field name\\r\\n  *\\r\\n  * @returns {Number} [1|0] return 1 to continue parsing, 0 to stop the parser\\r\\n  *\\r\\n******************************************************************************/\\r\\nHTTPParser.prototype.on_header_field = function (value){\\r\\n\\tlastHeaderfield = lastHeaderfield + value;\\r\\n};\\r\\n\\r\\n/** Will be called every time the parser parses header field name\\r\\n  * and should be followed by on_header_value callback\\r\\n  *\\r\\n  * @ignore\\r\\n  * @function on_header_value\\r\\n  * @param value {String} header field name\\r\\n  *\\r\\n  * @returns {Number} [1|0] return 1 to continue parsing, 0 to stop the parser\\r\\n  *\\r\\n******************************************************************************/\\r\\n\\r\\nHTTPParser.prototype.on_header_value = function (value){\\r\\n\\tif (lastHeaderfield !== ''){\\r\\n\\t\\tthis._headers.push(lastHeaderfield);\\r\\n\\t\\theadersNum = this._headers.length;\\r\\n\\t\\tlastHeaderValue = lastHeaderfield;\\r\\n\\t\\tthis.headers[lastHeaderfield] = '';\\r\\n\\t\\tlastHeaderfield = '';\\r\\n\\t\\tthis._headers[headersNum] = '';\\r\\n\\t}\\r\\n\\tthis.headers[lastHeaderValue] += value;\\r\\n\\tthis._headers[headersNum] += value;\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.on_url = function (value){\\r\\n\\tthis.url = this.url + value;\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.on_status = function (msg){\\r\\n\\tthis.status_message = msg;\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.on_body = function (val){\\r\\n\\tthis.body += val;\\r\\n\\tvar cb = this[HTTPParser.kOnBody];\\r\\n\\tif (!cb) return 0;\\r\\n\\tvar r = cb.call(this, val, 0, val.length);\\r\\n\\treturn this._check_message(r);\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.on_message_begin = function (){\\r\\n\\tthis._reset();\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.on_headers_complete = function (){\\r\\n\\r\\n\\tvar message_info = {};\\r\\n\\tvar headers = this._headers;\\r\\n\\tvar cb = this[HTTPParser.kOnHeadersComplete];\\r\\n\\tif (!cb) return 0;\\r\\n\\r\\n\\tvar statusCode, statusMessage, url, method;\\r\\n\\tif (this.type === parser.HTTP_REQUEST) {\\r\\n\\t\\turl = this.url;\\r\\n\\t\\tmethod = this.method();\\r\\n\\t}\\r\\n\\r\\n\\t// STATUS\\r\\n\\tif (this.type === parser.HTTP_RESPONSE) {\\r\\n\\t\\tstatusCode = this.status_code();\\r\\n\\t\\tstatusMessage = this.status_message;\\r\\n\\t}\\r\\n\\r\\n\\t// VERSION\\r\\n\\tvar versionMajor = this.versionMajor();\\r\\n\\tvar versionMinor = this.versionMinor();\\r\\n\\tvar shouldKeepAlive = this.shouldKeepAlive();\\r\\n\\tvar upgrade = this.upgrade();\\r\\n\\r\\n\\r\\n\\tvar head_response = cb.call(this, versionMajor, versionMinor, headers, method,\\r\\n\\t                               url, statusCode, statusMessage, upgrade,\\r\\n\\t                               shouldKeepAlive);\\r\\n\\r\\n\\t//reset\\r\\n\\tthis._headers.length = 0;\\r\\n\\tthis.headers = [];\\r\\n\\tthis.headers.length = 0;\\r\\n\\tthis.url = '';\\r\\n\\tlastHeaderfield = '';\\r\\n\\theadersNum = 0;\\r\\n\\r\\n\\tif (head_response !== 0 && !head_response){\\r\\n\\t\\tthis.got_exception = true;\\r\\n\\t\\treturn -1;\\r\\n\\t}\\r\\n\\r\\n\\treturn head_response ? 1 : 0;\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.Flush = function (){\\r\\n\\tvar cb = this[HTTPParser.kOnHeaders];\\r\\n\\tif (!cb) return;\\r\\n\\tcb.call(this, this._headers, this.url);\\r\\n\\tthis.flushed = true;\\r\\n\\tthis.url = '';\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.on_message_complete = function (){\\r\\n\\tif (this._headers.length) this.Flush();\\r\\n\\tvar cb = this[HTTPParser.kOnMessageComplete];\\r\\n\\tif (!cb) return 0;\\r\\n\\tvar r = cb.call(this, 0);\\r\\n\\treturn this._check_message(r);\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.shouldKeepAlive = function (){\\r\\n\\treturn parser.http_should_keep_alive(this.pointer);\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.upgrade = function (){\\r\\n\\treturn parser.http_upgrade(this.pointer);\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.versionMinor = function (){\\r\\n\\treturn parser.http_minor(this.pointer);\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.versionMajor = function (){\\r\\n\\treturn parser.http_major(this.pointer);\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.method = function (){\\r\\n\\treturn parser.http_method(this.pointer);\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.status_code = function (){\\r\\n\\treturn parser.status_code(this.pointer);\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.finish = function (){\\r\\n\\tthis._reset();\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nHTTPParser.prototype.close = function (){\\r\\n\\tparser.destroy(this.pointer);\\r\\n};\\r\\n\\r\\n/** @constant REQUEST  */ HTTPParser.REQUEST  = parser.HTTP_REQUEST;\\r\\n/** @constant RESPONSE */ HTTPParser.RESPONSE = parser.HTTP_RESPONSE;\\r\\n/** @constant BOTH     */ HTTPParser.BOTH     = parser.HTTP_BOTH;\\r\\n\\r\\n//compatable with node\\r\\nHTTPParser.methods = parser.methods();\\r\\n\\r\\n\\r\\nHTTPParser.kOnHeaders = 0;\\r\\nHTTPParser.kOnHeadersComplete = 1;\\r\\nHTTPParser.kOnBody = 2;\\r\\nHTTPParser.kOnMessageComplete = 3;\\r\\nHTTPParser.kOnExecute = 4;\\r\\n\\r\\nHTTPParser.HTTPParser = HTTPParser;\\r\\n\\r\\nmodule.exports = HTTPParser;\\r\\n\",\"socket\":\"\\\"use strict\\\";\\r\\n\\r\\nvar socket = process.binding('socket');\\r\\n\\r\\nvar SOCK_STREAM = socket.SOCK_STREAM;\\r\\nvar AF_INET     = socket.AF_INET;\\r\\n\\r\\nsocket.ipAddress = socket.pton;\\r\\n\\r\\nObject.defineProperty(socket, 'hasIPv6', {\\r\\n\\tget : function (){\\r\\n\\t\\tif (typeof this.IPV6 !== 'undefined')\\r\\n\\t\\t\\treturn this.IPV6;\\r\\n\\r\\n\\t\\tvar s = this.socket(this.AF_INET6, this.SOCK_STREAM, 0);\\r\\n\\t\\tif (s === null){\\r\\n\\t\\t\\tthis.IPV6 = false;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tthis.IPV6 = true;\\r\\n\\t\\t\\tthis.close(s);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn this.IPV6;\\r\\n\\t}\\r\\n});\\r\\n\\r\\n\\r\\nsocket.winsocketpair = function(n){\\r\\n\\treturn socket.socketpair(n);\\r\\n\\r\\n\\tvar proto = socket.getprotobyname('tcp');\\r\\n\\t// for (1..5) {\\r\\n\\t// \\tcarp \\\"winsocketpair failed: $!, retrying\\\" unless $_ == 1;\\r\\n\\tvar port = 5000;\\r\\n\\twhile (1){\\r\\n\\t\\tvar listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto );\\r\\n\\t\\tvar server = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto );\\r\\n\\t\\tvar client = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto );\\r\\n\\r\\n\\t\\tsocket.nonblock(client, 0);\\r\\n\\r\\n\\t\\tvar addr = socket.pton4(socket.INADDR_LOOPBACK, port++);\\r\\n\\r\\n\\t\\tif (socket.bind( listener, addr ) === null){\\r\\n\\t\\t\\tif (process.errno === 10048 || process.errno === 98){\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthrow new Error(\\\"bind error \\\" + process.errno);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (socket.listen( listener, 1 ) === null){\\r\\n\\t\\t\\tthrow new Error(\\\"listen error \\\" + process.errno);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\taddr = socket.getsockname( listener );\\r\\n\\t\\tif (addr === null) throw new Error('get sock name ' + process.errno);\\r\\n\\r\\n\\t\\tvar ret = 0;\\r\\n\\t\\tdo {\\r\\n\\t\\t\\tret = socket.connect(client, addr);\\r\\n\\t\\t} while(ret === null & process.errno === 10035);\\r\\n\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\tthrow new Error(\\\"connect error \\\" + process.errno);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar peer = socket.accept( listener );\\r\\n\\t\\tif (peer === null){\\r\\n\\t\\t\\tthrow new Error('accept error ' + process.errno);\\r\\n\\t\\t\\t//continue\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tsocket.nonblock(client, 1);\\r\\n\\t\\treturn [peer, client];\\r\\n\\t}\\r\\n};\\r\\n\\r\\nmodule.exports = socket;\\r\\n\",\"errno\":\"var errno = process.binding('errno');\\r\\nvar _toString = errno.toString;\\r\\n\\r\\nerrno.toString = function(errno){\\r\\n\\tif (errno < 0) errno = -errno;\\r\\n\\treturn _toString(errno);\\r\\n};\\r\\n\\r\\n// windows specific errors\\r\\nerrno.ERROR_ENVVAR_NOT_FOUND        = 203;\\r\\nerrno.ERROR_INVALID_PARAMETER       = 87;\\r\\nerrno.ERROR_ACCESS_DENIED           = 5;\\r\\n\\r\\nvar ERROR_MAP = {};\\r\\nObject.keys(errno).forEach(function(key) {\\r\\n    var val = errno[key];\\r\\n    if (typeof val === 'function') return;\\r\\n    ERROR_MAP[val] = key;\\r\\n    var uv_key = 'UV_' + key;\\r\\n    errno[uv_key] = -val;\\r\\n});\\r\\n\\r\\nerrno.errname = function(err){\\r\\n    if (err < 0) err = -err;\\r\\n    return ERROR_MAP[err];\\r\\n};\\r\\n\\r\\nmodule.exports = errno;\\r\\n\",\"os\":\"var isWindows = process.platform === 'win32';\\r\\n\\r\\nexports.EOL = isWindows ? '\\\\r\\\\n' : '\\\\n';\\r\\n\\r\\nvar trailingSlashRe = isWindows ? /[^:]\\\\\\\\$/ : /.\\\\/$/;\\r\\n\\r\\nexports.tmpdir = function() {\\r\\n\\tvar path;\\r\\n\\tif (isWindows) {\\r\\n\\t\\tpath = process.env.TEMP ||\\r\\n\\t\\t  process.env.TMP ||\\r\\n\\t\\t  (process.env.SystemRoot || process.env.windir) + '\\\\\\\\temp';\\r\\n\\r\\n\\t} else {\\r\\n\\t\\tpath = process.env.TMPDIR ||\\r\\n\\t\\t  process.env.TMP ||\\r\\n\\t\\t  process.env.TEMP ||\\r\\n\\t\\t  '/tmp';\\r\\n\\t}\\r\\n\\r\\n\\tif (trailingSlashRe.test(path)) {\\r\\n\\t\\tpath = path.slice(0, -1);\\r\\n\\t}\\r\\n\\treturn path;\\r\\n};\\r\\n\",\"uv\":\"// delete global uv if available\\r\\n// this required when we are compiling with\\r\\n// dukluv which exports uv as global object\\r\\ndelete global.uv;\\r\\n\\r\\nvar sock     = require('socket');\\r\\nvar posix    = process.binding('posix');\\r\\nvar loop     = require('loop').main;\\r\\nvar errno    = require('errno');\\r\\nvar assert   = require('assert');\\r\\nvar syscall  = require('syscall');\\r\\nvar SYS      = syscall.SYS;\\r\\n\\r\\nvar C        = require('C');\\r\\nvar constant = require('constants');\\r\\n\\r\\nvar isWin   = process.platform === 'win32';\\r\\n\\r\\nexports.CLOSING              = 0x01;    /* uv_close() called but not finished. */\\r\\nexports.CLOSED               = 0x02;    /* close(2) finished. */\\r\\nexports.STREAM_READING       = 0x04;    /* uv_read_start() called. */\\r\\nexports.STREAM_SHUTTING      = 0x08;    /* uv_shutdown() called but not complete. */\\r\\nexports.STREAM_SHUT          = 0x10;    /* Write side closed. */\\r\\nexports.STREAM_READABLE      = 0x20;    /* The stream is readable */\\r\\nexports.STREAM_WRITABLE      = 0x40;    /* The stream is writable */\\r\\nexports.STREAM_BLOCKING      = 0x80;    /* Synchronous writes. */\\r\\nexports.STREAM_READ_PARTIAL  = 0x100;   /* read(2) read less than requested. */\\r\\nexports.STREAM_READ_EOF      = 0x200;   /* read(2) read EOF. */\\r\\nexports.TCP_NODELAY          = 0x400;   /* Disable Nagle. */\\r\\nexports.TCP_KEEPALIVE        = 0x800;   /* Turn on keep-alive. */\\r\\nexports.TCP_SINGLE_ACCEPT    = 0x1000;  /* Only accept() when idle. */\\r\\nexports.HANDLE_IPV6          = 0x10000; /* Handle is bound to a IPv6 socket. */\\r\\n\\r\\nexports.TCP_IPV6ONLY         = 1;\\r\\n\\r\\nexports.IGNORE               = 0x00;\\r\\nexports.CREATE_PIPE          = 0x01;\\r\\nexports.INHERIT_FD           = 0x02;\\r\\nexports.INHERIT_STREAM       = 0x04;\\r\\nexports.PROCESS_SETUID       = (1 << 0);\\r\\nexports.PROCESS_SETGID       = (1 << 1);\\r\\nexports.PROCESS_DETACHED     = (1 << 3);\\r\\nexports.PROCESS_WINDOWS_HIDE = (1 << 4);\\r\\nexports.PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2);\\r\\n\\r\\nexports.EOF = errno.EOF;\\r\\n\\r\\nexports.isWin = isWin;\\r\\n\\r\\nexports.new_timer = function(){\\r\\n\\treturn loop.handle_init(loop._handle);\\r\\n};\\r\\n\\r\\nexports.unref = function(handle){\\r\\n\\tloop.handle_unref(handle);\\r\\n};\\r\\n\\r\\nexports.ref = function(handle){\\r\\n\\tloop.handle_ref(handle);\\r\\n};\\r\\n\\r\\nexports.run = function(type){\\r\\n\\treturn loop.run(type);\\r\\n};\\r\\n\\r\\nexports.timer_start = function(handle, timeout, repeat, cb){\\r\\n\\treturn loop.timer_start(handle, timeout, repeat, cb);\\r\\n};\\r\\n\\r\\nexports.timer_stop = function(handle, timeout, repeat, cb){\\r\\n\\tloop.timer_stop(handle);\\r\\n};\\r\\n\\r\\nexports.handle_close = function(handle){\\r\\n\\treturn loop.handle_close(handle);\\r\\n};\\r\\n\\r\\nexports.update_time = function(handle){\\r\\n\\treturn loop.update_time();\\r\\n};\\r\\n\\r\\n\\r\\n// create a socket with (domain, type, protocol) options\\r\\n// the created socket will be set to nonblocking mode\\r\\n// and mark as un inheritable, cloexec = 1\\r\\n//===========================================================\\r\\n  exports.socket = function(domain, type, protocol) {\\r\\n//===========================================================\\r\\n\\tvar sockfd, err;\\r\\n\\r\\n\\tif (sock.SOCK_NONBLOCK && sock.SOCK_CLOEXEC) {\\r\\n\\t\\tsockfd = sock.socket(domain, type | sock.SOCK_NONBLOCK | sock.SOCK_CLOEXEC, protocol);\\r\\n\\t\\tif (sockfd !== null) return sockfd;\\r\\n\\r\\n\\t\\t// if EINVAL error returned this may indicate\\r\\n\\t\\t// that SOCK_NONBLOCK or SOCK_CLOEXEC are\\r\\n\\t\\t// not supported, we give it another shot\\r\\n\\t\\t// by doing a seperate call by creating a\\r\\n\\t\\t// socket then set it's blocking and cloexec flags\\r\\n\\t\\tif (process.errno !== errno.EINVAL) return;\\r\\n\\t}\\r\\n\\r\\n\\tsockfd = sock.socket(domain, type, protocol);\\r\\n\\tif (sockfd === null) return;\\r\\n\\r\\n\\tif (!sock.nonblock(sockfd, 1)){\\r\\n\\t\\tsock.close(sockfd);\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (!syscall.cloexec(sockfd, 1)){\\r\\n\\t\\tsock.close(sockfd);\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (sock.SO_NOSIGPIPE){\\r\\n\\t\\tsock.setsockopt(sockfd, sock.SOL_SOCKET, sock.SO_NOSIGPIPE, 1);\\r\\n\\t}\\r\\n\\r\\n\\treturn sockfd;\\r\\n};\\r\\n\\r\\n\\r\\n// return an ip4 packed addrerss\\r\\n//===========================================================\\r\\n  exports.ip4_addr = exports.ip4_address = function(ip, port){\\r\\n//===========================================================\\r\\n\\treturn sock.pton4(ip, port);\\r\\n};\\r\\n\\r\\n\\r\\n// return an ip4 packed addrerss\\r\\n//===========================================================\\r\\n  exports.ip6_addr = exports.ip6_address = function(ip, port){\\r\\n//===========================================================\\r\\n\\treturn sock.pton6(ip, port);\\r\\n};\\r\\n\\r\\n\\r\\n// either ip6 or ip4 address\\r\\n//===========================================================\\r\\n  exports.ip_address = exports.ip_addr = function(ip, port){\\r\\n//===========================================================\\r\\n\\treturn sock.pton(ip, port);\\r\\n};\\r\\n\\r\\n\\r\\n//===========================================================\\r\\n  exports.make_socketpair = function(fds, flags) {\\r\\n//===========================================================\\r\\n\\tvar pairs = sock.winsocketpair(1);\\r\\n\\r\\n\\tif (!pairs) return process.errno;\\r\\n\\tfds[0] = pairs[0];\\r\\n\\tfds[1] = pairs[1];\\r\\n\\r\\n\\tsyscall.cloexec(fds[0], 1);\\r\\n\\tsyscall.cloexec(fds[1], 1);\\r\\n\\r\\n\\tif (flags & 1) {\\r\\n\\t\\tsock.nonblock(fds[0], 1);\\r\\n\\t\\tsock.nonblock(fds[1], 1);\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n//===========================================================\\r\\n  exports.make_pipe = function(fds, flags) {\\r\\n//===========================================================\\r\\n\\tvar pairs;\\r\\n\\tif (syscall.pipe2){\\r\\n\\t\\tpairs = syscall.pipe2(SYS.O_CLOEXEC);\\r\\n\\t\\tif (!pairs) return process.errno;\\r\\n\\t\\tfds[0] = pairs[0];\\r\\n\\t\\tfds[1] = pairs[1];\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\tvar pairs = syscall.pipe();\\r\\n\\r\\n\\tif (!pairs) return process.errno;\\r\\n\\tfds[0] = pairs[0];\\r\\n\\tfds[1] = pairs[1];\\r\\n\\r\\n\\tsyscall.cloexec(fds[0], 1);\\r\\n\\tsyscall.cloexec(fds[1], 1);\\r\\n\\r\\n\\tif (flags & 1) {\\r\\n\\t\\tsock.nonblock(fds[0], 1);\\r\\n\\t\\tsock.nonblock(fds[1], 1);\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\n// make fd/file handle (h) inheritable accross new\\r\\n// created child processes\\r\\n//===========================================================\\r\\n  exports.make_inheritable = function(h){\\r\\n//===========================================================\\r\\n\\tif (!syscall.cloexec(h, 0)){\\r\\n\\t\\tthrow new Error(\\\"can't inherit handle\\\");\\r\\n\\t}\\r\\n\\r\\n\\treturn h;\\r\\n};\\r\\n\\r\\n// generates an array container for stdio options\\r\\n//===========================================================\\r\\n  exports.stdio_container = function(count){\\r\\n//===========================================================\\r\\n\\tvar stdio = [];\\r\\n\\tfor (var i = 0; i < count; i++){\\r\\n\\t\\tstdio[i] = {\\r\\n\\t\\t\\tflags  : exports.IGNORE,\\r\\n\\t\\t\\tstream : null,\\r\\n\\t\\t\\tfd     : null\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\treturn stdio;\\r\\n};\\r\\n\\r\\n// returns win32 os handle for the\\r\\n// passed file descriptor\\r\\n//===========================================================\\r\\n  exports.get_fd_handle = function(fd){\\r\\n//===========================================================\\r\\n\\tvar handle = syscall.GetFdHandle(fd);\\r\\n\\tif (handle === null){\\r\\n\\t\\tthrow new Error(\\\"can't get os handle for fd : \\\" + fd);\\r\\n\\t}\\r\\n\\r\\n\\treturn handle;\\r\\n};\\r\\n\\r\\n\\r\\n// win32 return exit code of the running process (h)\\r\\n// exit code 259 indicates that the process still running\\r\\n//===========================================================\\r\\n  var exitCode = new C.void( C.sizeOf.int32 );\\r\\n  exports.get_exit_code = function(h){\\r\\n//===========================================================\\r\\n\\tif (syscall.GetExitCodeProcess(h, exitCode) === null){\\r\\n\\t\\tthrow new Error(\\\"GetExitCodeProcess error \\\" + process.errno);\\r\\n\\t}\\r\\n\\treturn exitCode.int32;\\r\\n};\\r\\n\\r\\n\\r\\n// close fd/handle\\r\\n//===========================================================\\r\\n  var _close = isWin ? syscall.CloseHandle : posix.close;\\r\\n  exports.close = function(fd) {\\r\\n//===========================================================\\r\\n\\t/* Catch uninitialized io_watcher.fd bugs. */\\r\\n\\tassert(fd > -1, \\\"uv.close fd uninitialized\\\");\\r\\n\\r\\n\\t// FIXME: win test against stdio handles\\r\\n\\t/* Catch stdio close bugs. */\\r\\n\\tassert(fd > 2, \\\"uv.close stdio file\\\");\\r\\n\\r\\n\\tvar saved_errno = process.errno;\\r\\n\\tvar rc = _close(fd);\\r\\n\\r\\n\\tif (rc === null) {\\r\\n\\t\\trc = process.errno;\\r\\n\\t\\tif (rc == errno.EINTR) rc = errno.EINPROGRESS;  /* For platform/libc consistency. */\\r\\n\\t\\tprocess.errno = saved_errno;\\r\\n\\t}\\r\\n\\r\\n\\treturn rc;\\r\\n};\\r\\n\\r\\n\\r\\n//===========================================================\\r\\n  var _write = isWin ? sock.send : sock.write;\\r\\n  exports.write = function(fd, buf, len, flag){\\r\\n//===========================================================\\r\\n\\treturn _write(fd, buf, len);\\r\\n};\\r\\n\\r\\n\\r\\n//===========================================================\\r\\n  var _read  = isWin ? sock.recv : sock.read;\\r\\n  exports.read = function(fd, len){\\r\\n//===========================================================\\r\\n\\treturn _read(fd, len);\\r\\n};\\r\\n\\r\\n\\r\\n// return number of pending handles\\r\\n//===========================================================\\r\\n  exports.pipe_pending_count = function(handle) {\\r\\n//===========================================================\\r\\n\\tif (!handle.ipc) return 0;\\r\\n\\r\\n\\tif (handle.accepted_fd === -1){\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\tif ( handle.queued_fds.length === 0 ){\\r\\n\\t\\treturn 1;\\r\\n\\t}\\r\\n\\r\\n\\treturn handle.queued_fds.length;\\r\\n};\\r\\n\\r\\n\\r\\nvar STILL_ACTIVE = 259;\\r\\nvar Win32kill = exports.Win32kill = function(process_handle, signum){\\r\\n\\tvar status = new C.void( C.sizeOf.int32 );\\r\\n\\tswitch (signum) {\\r\\n\\t\\tcase constant.SIGTERM:\\r\\n\\t\\tcase constant.SIGKILL:\\r\\n\\t\\tcase constant.SIGINT: {\\r\\n\\t\\t\\t/* Unconditionally terminate the process. On Windows, killed processes */\\r\\n\\t\\t\\t/* normally return 1. */\\r\\n\\t\\t\\tvar err;\\r\\n\\r\\n\\t\\t\\tif (syscall.TerminateProcess(process_handle, 1)) return 0;\\r\\n\\r\\n\\t\\t\\t/* If the process already exited before TerminateProcess was called, */\\r\\n\\t\\t\\t/* TerminateProcess will fail with ERROR_ACCESS_DENIED. */\\r\\n\\t\\t\\terr = syscall.GetLastError();\\r\\n\\t\\t\\tif (err == errno.ERROR_ACCESS_DENIED &&\\r\\n\\t\\t\\t\\t\\tsyscall.GetExitCodeProcess(process_handle, status) &&\\r\\n\\t\\t\\t\\t\\tstatus.int32 !== STILL_ACTIVE) {\\r\\n\\t\\t\\t\\treturn errno.ESRCH;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn errno.translate(err);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase 0: {\\r\\n\\t\\t\\t/* Health check: is the process still alive? */\\r\\n\\r\\n\\t\\t\\tif (syscall.GetExitCodeProcess(process_handle, status) === null) {\\r\\n\\t\\t\\t\\treturn errno.translate(process.errno);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (status.int32 !== STILL_ACTIVE) {\\r\\n\\t\\t\\t\\treturn errno.ESRCH;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdefault: {\\r\\n\\t\\t\\t/* Unsupported signal. */\\r\\n\\t\\t\\treturn errno.ENOSYS;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nif (isWin){\\r\\n\\t// kill process (pid) with signal (signum)\\r\\n\\t//===========================================================\\r\\n\\t  exports.kill = function(pid, signum) {\\r\\n\\t//===========================================================\\r\\n\\t\\tvar process_handle = syscall.OpenProcess(\\r\\n\\t\\t\\tsyscall.PROCESS_TERMINATE | syscall.PROCESS_QUERY_INFORMATION,\\r\\n\\t\\t\\t0, pid\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\tif (process_handle === null) {\\r\\n\\t\\t\\terr = process.errno;\\r\\n\\t\\t\\tif (err == errno.ERROR_INVALID_PARAMETER) {\\r\\n\\t\\t\\t\\treturn errno.ESRCH;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn errno.translate(err);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\terr = Win32kill(process_handle, signum);\\r\\n\\t\\tsyscall.CloseHandle(process_handle);\\r\\n\\t\\treturn err;  /* err is already translated. */\\r\\n\\t};\\r\\n} else {\\r\\n\\t// kill process (pid) with signal (signum)\\r\\n\\t//===========================================================\\r\\n\\t  exports.kill = function(pid, signum) {\\r\\n\\t//===========================================================\\r\\n\\t\\tif (syscall.kill(pid, signum) === null){\\r\\n\\t\\t\\treturn process.errno;\\r\\n\\t\\t}\\r\\n\\t\\treturn 0;\\r\\n\\t};\\r\\n}\\r\\n\\r\\n// returns pipe handle type\\r\\n// TCP, NAMED_PIPE, UNKNOWN\\r\\n//===========================================================\\r\\n  exports.pipe_handle_type = function(handle){\\r\\n//===========================================================\\r\\n\\tif (!handle.ipc) {\\r\\n\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t}\\r\\n\\r\\n\\tif (handle.accepted_fd === -1) {\\r\\n\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t}\\r\\n\\r\\n\\telse {\\r\\n\\t\\tvar fd = handle.accepted_fd;\\r\\n\\t\\tvar sockaddr = sock.getsockname(fd);\\r\\n\\r\\n\\t\\tif (sockaddr === null) {\\r\\n\\t\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar type = sock.getsockopt(fd, sock.SOL_SOCKET, sock.SO_TYPE);\\r\\n\\t\\tif (type === null) {\\r\\n\\t\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar family = sock.family(sockaddr);\\r\\n\\t\\tif (family === null) {\\r\\n\\t\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (type === sock.SOCK_STREAM) {\\r\\n\\t\\t\\tif (family === sock.AF_UNIX) {\\r\\n\\t\\t\\t\\treturn 'NAMED_PIPE';\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse if (family === sock.AF_INET || family === sock.AF_INET6 ){\\r\\n\\t\\t\\t\\treturn 'TCP';\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (type === sock.SOCK_DGRAM &&\\r\\n\\t\\t\\t(family === sock.AF_INET || family === sock.AF_INET6)) {\\r\\n\\t\\t\\treturn 'UDP';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\n// windows recvmsg & sendmsg emulation\\r\\n// this should be moved to a seperate platform\\r\\n// file ** TODO\\r\\nvar protobuf = C.Struct.create({\\r\\n\\tstart  : 'uint16',\\r\\n\\ttarget : 'uint32',\\r\\n\\tpid    : 'uint32',\\r\\n\\thandle : 'uint32',\\r\\n\\tpad    :  1024 * 8,\\r\\n\\tend    : 'uint16'\\r\\n});\\r\\n\\r\\n\\r\\nif (isWin){\\r\\n\\t// win32 duplicate handle with same access flags\\r\\n\\t//===========================================================\\r\\n\\t  var pseudo_id = syscall.GetCurrentProcess();\\r\\n\\t  exports.duplicate_handle = function(h){\\r\\n\\t//===========================================================\\r\\n\\t\\tvar dupHandle = new C.void( C.sizeOf.int32 );\\r\\n\\r\\n\\t\\tvar ret = syscall.DuplicateHandle( pseudo_id, h, pseudo_id, dupHandle, 0, 1,\\r\\n\\t\\t\\tsyscall.DUPLICATE_SAME_ACCESS);\\r\\n\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\tthrow new Error(\\\"can't duplicate handle\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn dupHandle.int32;\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// win32 sendmsg\\r\\n\\t//===========================================================\\r\\n\\t  exports.sendmsg = function(fd, buf, len, fd_to_send, pid, flag){\\r\\n\\t//===========================================================\\r\\n\\t\\tvar dupHandle = new C.void( C.sizeOf.int32 );\\r\\n\\t\\tvar protoBuf  = new protobuf();\\r\\n\\t\\tvar ret = syscall.DuplicateHandle(\\r\\n\\t\\t\\t-1,\\r\\n\\t\\t\\tfd_to_send,\\r\\n\\t\\t\\t-1,\\r\\n\\t\\t\\tdupHandle, 0, 0,\\r\\n\\t\\t\\tsyscall.DUPLICATE_SAME_ACCESS);\\r\\n\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\tthrow new Error(\\\"can't duplicate\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tprotoBuf.target = pid;\\r\\n\\t\\tprotoBuf.pid = process.pid;\\r\\n\\t\\tprotoBuf.handle = dupHandle.int32;\\r\\n\\r\\n\\t\\t// special message\\r\\n\\t\\tprotoBuf.start = 123;\\r\\n\\t\\tprotoBuf.end   = 456;\\r\\n\\r\\n\\t\\t// first send both processid and duplicated handle\\r\\n\\t\\tif (_write(fd, protoBuf, protoBuf.size, flag) !== protoBuf.size){\\r\\n\\t\\t\\tthrow new Error(\\\"error sending handle\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn _write(fd, buf, len, flag);\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t  var PROCESS_DUP_HANDLE = 0x0040;\\r\\n\\t  exports.recvmsg = function(fd, len, fds){\\r\\n\\t//===========================================================\\r\\n\\t\\tvar dupHandle = new C.void( C.sizeOf.int32 );\\r\\n\\t\\tvar protoBuf  = new protobuf();\\r\\n\\t\\tvar n = sock.readIntoBuffer(fd, protoBuf, 0);\\r\\n\\t\\tif (n === null) return null;\\r\\n\\r\\n\\t\\t//this is not protocol buffer\\r\\n\\t\\tif (n !== protoBuf.size){\\r\\n\\t\\t\\treturn Buffer(protoBuf).slice(0, n).toString();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// maybe protocol buffer\\r\\n\\t\\tif (protoBuf.start === 123 && protoBuf.end === 456){\\r\\n\\t\\t\\t// print('gottt protocol buffer');\\r\\n\\t\\t\\t// get source process handle\\r\\n\\t\\t\\tvar source = syscall.OpenProcess(PROCESS_DUP_HANDLE, 0, protoBuf.pid);\\r\\n\\t\\t\\tif (source === null){\\r\\n\\t\\t\\t\\tthrow new Error(\\\"can't open process\\\");\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar ret = syscall.DuplicateHandle(\\r\\n\\t\\t\\t\\tsource,\\r\\n\\t\\t\\t\\tprotoBuf.handle,\\r\\n\\t\\t\\t\\t-1,\\r\\n\\t\\t\\t\\tdupHandle, 0, 0,\\r\\n\\t\\t\\t\\tsyscall.DUPLICATE_SAME_ACCESS | syscall.DUPLICATE_CLOSE_SOURCE\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\tif (ret === null){\\r\\n\\t\\t\\t\\tthrow new Error(\\\"can't duplicate\\\");\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfds.push(dupHandle.int32);\\r\\n\\t\\t}\\r\\n\\t\\telse { // it's just a normal data sent to socket\\r\\n\\t\\t\\treturn Buffer(protoBuf, 0, n).toString();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn _read(fd, len);\\r\\n\\t};\\r\\n} else {\\r\\n\\t// linux sendmsg\\r\\n\\t//===========================================================\\r\\n\\t  exports.sendmsg = function(fd, buf, len, fd_to_send, pid, flag){\\r\\n\\t//===========================================================\\r\\n\\t\\t//send fd\\r\\n\\t\\tif (sock.sendfd(fd, fd_to_send) === null){\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\t\\treturn _write(fd, buf, len, flag);\\r\\n\\t};\\r\\n\\r\\n\\t// linux recvmsg\\r\\n\\t//===========================================================\\r\\n\\t  exports.recvmsg = function(fd, len, fds){\\r\\n\\t//===========================================================\\r\\n\\t\\t//get fd\\r\\n\\t\\tvar pfd = new C.void( C.sizeOf.int );\\r\\n\\t\\tpfd.int = -1;\\r\\n\\r\\n\\t\\tvar buf = Buffer(len);\\r\\n\\t\\tvar ret = sock.recvfd(fd, buf, pfd);\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar nfd = pfd.int;\\r\\n\\t\\tif (nfd !== -1){\\r\\n\\t\\t\\texports.cloexec(nfd, 1);\\r\\n\\t\\t\\tfds.push(nfd);\\r\\n\\t\\t\\tif (ret === 1 && buf[0] === 0){\\r\\n\\t\\t\\t\\treturn exports.recvmsg(fd, len, fds);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn buf.slice(0, ret).toString();\\r\\n\\t};\\r\\n}\\r\\n\\r\\nexports.cloexec  = syscall.cloexec;\\r\\nexports.nonblock = sock.nonblock;\\r\\n\\r\\nexports.O_RDWR  = posix.O_RDWR;\\r\\nexports.open    = posix.open;\\r\\n\\r\\n\\r\\n//===========================================================\\r\\n  exports.TCP    = require('uv/tcp');\\r\\n  exports.Pipe   = require('uv/pipe');\\r\\n  exports.Stream = require('uv/stream');\\r\\n  exports.TTY    = require('uv/tty');\\r\\n//===========================================================\\r\\n\\r\\n//===========================================================\\r\\n  var uvProcess  = require('uv/process');\\r\\n  exports.spawn  = function(options){\\r\\n//===========================================================\\r\\n\\treturn new uvProcess(options);\\r\\n};\\r\\n\\r\\nif (isWin){\\r\\n\\texports.guess_handle = function(fd){\\r\\n\\t\\tvar handle = syscall.GetFdHandle(fd);\\r\\n\\t\\tvar type = syscall.GetFileType(handle);\\r\\n\\t\\tif (type === null){\\r\\n\\t\\t\\ttype = syscall.GetFileType(fd);\\r\\n\\t\\t\\tif (type === null){\\r\\n\\t\\t\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tswitch (type){\\r\\n\\t\\t\\tcase syscall.FILE_TYPE_CHAR : {\\r\\n\\t\\t\\t\\tif (syscall.GetConsoleMode(handle) !== null){\\r\\n\\t\\t\\t\\t\\treturn 'TTY';\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\treturn 'FILE'\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase syscall.FILE_TYPE_DISK : {\\r\\n\\t\\t\\t\\treturn 'FILE'\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase syscall.FILE_TYPE_PIPE : {\\r\\n\\t\\t\\t\\treturn 'TCP';\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t};\\r\\n} else {\\r\\n\\tvar fs = require('fs');\\r\\n\\texports.guess_handle = function(fd){\\r\\n\\t\\tif (fd < 0) return 'UNKNOWN_HANDLE';\\r\\n\\r\\n\\t\\t// tty\\r\\n\\t\\tif (syscall.isatty(fd)) return 'TTY';\\r\\n\\r\\n\\t\\tvar st = fs.fstatSync(fd);\\r\\n\\t\\tif (st.isFile()) return 'FILE';\\r\\n\\t\\tif (st.isFIFO()) return 'NAMED_PIPE';\\r\\n\\t\\tif (st.isSocket()) return 'TCP';\\r\\n\\r\\n\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t};\\r\\n}\\r\\n\",\"uv/stream\":\"var sock   = require('socket');\\r\\nvar loop   = require('loop').main;\\r\\nvar errno  = require('errno');\\r\\nvar uv     = require('uv');\\r\\nvar assert = require('assert');\\r\\n\\r\\nvar POLLERR   = loop.POLLERR;\\r\\nvar POLLIN    = loop.POLLIN;\\r\\nvar POLLOUT   = loop.POLLOUT;\\r\\n\\r\\nvar POLLREAD  = POLLIN | POLLERR;\\r\\nvar POLLWRITE = POLLOUT | POLLERR;\\r\\n\\r\\nvar _shutting_mask = ( uv.STREAM_SHUT | uv.STREAM_SHUTTING | uv.CLOSED | uv.CLOSING);\\r\\n\\r\\nvar MAXREAD   =  80 * 1024;\\r\\nvar SEND_FLAG = sock.MSG_NOSIGNAL ? sock.MSG_NOSIGNAL : 0;\\r\\n\\r\\nfunction _accept (self){\\r\\n\\tvar sockfd = self.fd;\\r\\n\\twhile (1) {\\r\\n\\t\\tvar peerfd = sock.accept(sockfd);\\r\\n\\t\\tif (peerfd === null){\\r\\n\\t\\t\\tif (process.errno === errno.EINTR){\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//TODO cloexec\\r\\n\\t\\tif (!sock.nonblock(peerfd, 1)){\\r\\n\\t\\t\\tthrow new Error(\\\"can't set nonblocking peerfd \\\" + peerfd);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn peerfd;\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nfunction Stream (type){\\r\\n\\tthis.type = type;\\r\\n\\tthis.accepted_fd = -1;\\r\\n\\tthis.fd  = -1;\\r\\n\\tthis.flags = 0;\\r\\n\\r\\n\\tthis.queued_fds      = [];\\r\\n\\tthis.pending_queue   = [];\\r\\n\\tthis.write_queue     = [];\\r\\n\\tthis.write_completed = [];\\r\\n\\r\\n\\tthis.write_queue_size = 0;\\r\\n\\r\\n\\tvar self = this;\\r\\n\\tthis.io_watcher = loop.io(function(h, events){\\r\\n\\t\\tself.stream_io(events);\\r\\n\\t});\\r\\n}\\r\\n\\r\\n\\r\\nStream.prototype.server_io = function(events){\\r\\n\\r\\n\\tassert(events === POLLIN);\\r\\n\\tassert(!(this.flags & uv.CLOSING));\\r\\n\\r\\n\\tprocess.errno = 0;\\r\\n\\twhile (this.fd !== -1){\\r\\n\\t\\tassert(this.accepted_fd === -1);\\r\\n\\t\\tvar ret = _accept(this);\\r\\n\\t\\tif (!ret){\\r\\n\\t\\t\\tvar err = process.errno;\\r\\n\\t\\t\\tif (err === errno.EAGAIN || err === errno.EWOULDBLOCK) {\\r\\n\\t\\t\\t\\treturn; //not an error\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (err === errno.ECONNABORTED){\\r\\n\\t\\t\\t\\tcontinue; //nothing to do\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (err === errno.EMFILE || err === errno.ENFILE) {\\r\\n\\t\\t\\t\\tthrow new Error(\\\"EMFILE Error\\\");\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.connection_cb(err);\\r\\n\\t\\t\\tcontinue;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.accepted_fd = ret;\\r\\n\\t\\tthis.connection_cb(0);\\r\\n\\t\\tif (this.accepted_fd != -1) {\\r\\n\\t\\t\\tthis.io_watcher.stop(POLLIN);\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nfunction __stream_recv_cmsg (stream, fds) {\\r\\n\\r\\n\\tfor (var i = 0; i < fds.length; i++){\\r\\n\\t\\tvar fd = fds[i];\\r\\n\\t\\tif (stream.accepted_fd !== -1){\\r\\n\\t\\t\\tstream.queued_fds.push(fd);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tuv.nonblock(fd, 1);\\r\\n\\t\\t\\tstream.accepted_fd = fd;\\r\\n\\t\\t\\tstream.flags |= uv.STREAM_READABLE | uv.STREAM_WRITABLE;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n    return 1;\\r\\n}\\r\\n\\r\\n\\r\\nfunction _read (stream){\\r\\n\\tvar buf;\\r\\n\\tvar err = 0;\\r\\n\\tvar is_ipc;\\r\\n\\r\\n\\tstream.flags &= ~uv.STREAM_READ_PARTIAL;\\r\\n\\r\\n\\t/* Prevent loop starvation when the data comes in as fast as (or faster than)\\r\\n\\t * we can read it. XXX Need to rearm fd if we switch to edge-triggered I/O.\\r\\n\\t*/\\r\\n\\r\\n\\tvar count = 24;\\r\\n\\r\\n\\tvar is_ipc = stream.type === \\\"NAMED_PIPE\\\" && stream.ipc;\\r\\n\\r\\n\\t/* XXX: Maybe instead of having UV_STREAM_READING we just test if\\r\\n\\t * tcp->read_cb is NULL or not?\\r\\n\\t*/\\r\\n\\r\\n\\tvar fds = [];\\r\\n\\tvar fd = stream.fd;\\r\\n\\twhile (stream.read_cb\\r\\n\\t\\t  && (stream.flags & uv.STREAM_READING)\\r\\n\\t\\t  && (count-- > 0)) {\\r\\n\\r\\n\\t\\tassert(fd >= 0);\\r\\n\\r\\n\\t\\tif (!is_ipc) {\\r\\n\\t\\t\\tbuf = uv.read(fd, MAXREAD);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tbuf = uv.recvmsg(fd, MAXREAD, fds);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar error = process.errno;\\r\\n\\t\\tif (buf === null) {\\r\\n\\t\\t\\t// EOF\\r\\n\\t\\t\\tif (error === errno.EOF){\\r\\n\\t\\t\\t\\tstream.stream_eof(\\\"\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t/* Error */\\r\\n\\t\\t\\telse if (error === errno.EAGAIN || error === errno.EWOULDBLOCK) {\\r\\n\\t\\t\\t\\t/* Wait for the next one. */\\r\\n\\t\\t\\t\\tif (stream.flags & uv.STREAM_READING) {\\r\\n\\t\\t\\t\\t\\tstream.io_watcher.start(stream.fd, POLLIN);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tstream.read_cb(0, \\\"\\\");\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t/* Error. User should call uv_close(). */\\r\\n\\t\\t\\t\\tstream.read_cb(error, \\\"\\\");\\r\\n\\t\\t\\t\\tif (stream.flags & uv.STREAM_READING) {\\r\\n\\t\\t\\t\\t\\tstream.flags &= ~uv.STREAM_READING;\\r\\n\\t\\t\\t\\t\\tstream.io_watcher.stop(POLLIN);\\r\\n\\t\\t\\t\\t\\tif (!stream.io_watcher.active(POLLOUT)){\\r\\n\\t\\t\\t\\t\\t\\tstream.io_watcher.handle_stop();\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t/* Successful read */\\r\\n\\t\\t\\tif (is_ipc) {\\r\\n\\t\\t\\t\\t__stream_recv_cmsg(stream, fds);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstream.read_cb(0, buf);\\r\\n\\r\\n\\t\\t\\t/* Return if we didn't fill the buffer, there is no more data to read. */\\r\\n\\t\\t\\tif (buf.length < MAXREAD) {\\r\\n\\t\\t\\t\\tstream.flags |= uv.STREAM_READ_PARTIAL;\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nfunction _write_req_finish (req) {\\r\\n\\tvar stream = req.handle;\\r\\n\\treq.call(req, req.error);\\r\\n\\t// stream.write_completed.push(req);\\r\\n\\t// stream.io_feed();\\r\\n}\\r\\n\\r\\n\\r\\nfunction _write(stream) {\\r\\n\\tvar req = stream.write_queue[0];\\r\\n\\tif (!req){ return }\\r\\n\\r\\n\\tvar buffer = req.buf;\\r\\n\\tvar length = req.len;\\r\\n\\tvar nbufs = 0;\\r\\n\\tvar n;\\r\\n\\r\\n\\t//TODO check if array\\r\\n\\tif (Array.isArray(buffer)){\\r\\n\\t\\t//this is an array of buffers to write\\r\\n\\t\\tnbufs = buffer.length;\\r\\n\\t}\\r\\n\\r\\n\\t// writev\\r\\n\\tif (nbufs > 0){\\r\\n\\t\\tthrow new Error(\\\"writev\\\");\\r\\n\\t}\\r\\n\\r\\n\\t// sendmsg\\r\\n\\telse if (req.send_handle) {\\r\\n\\t\\tvar fd_to_send = req.send_handle.fd;\\r\\n\\t\\tvar pid        = stream.ipc_pid;\\r\\n\\t\\tn = uv.sendmsg(stream.fd, buffer, length, fd_to_send, pid, SEND_FLAG);\\r\\n\\t}\\r\\n\\r\\n\\telse { // single write\\r\\n\\t\\tn = uv.write(stream.fd, buffer, length, SEND_FLAG);\\r\\n\\t}\\r\\n\\r\\n\\t// null indicates an error\\r\\n\\tif (n === null){\\r\\n\\t\\t// anything other than EWOULDBLOCK & EAGAIN\\r\\n\\t\\t// should be treated as an error\\r\\n\\t\\tvar error = process.errno;\\r\\n\\t\\tif ( error != errno.EAGAIN && error != errno.EWOULDBLOCK) {\\r\\n\\t\\t\\treq.error = -error;\\r\\n\\t\\t\\t_write_req_finish(req);\\r\\n\\t\\t\\tstream.io_watcher.stop(POLLOUT);\\r\\n\\t\\t\\tif (!stream.io_watcher.active(POLLIN)){\\r\\n\\t\\t\\t\\tstream.io_watcher.handle_stop();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\telse {\\r\\n\\t\\treq.bytes += n;\\r\\n\\t\\tstream.write_queue_size -= n;\\r\\n\\r\\n\\t\\tif (n === length){\\r\\n\\t\\t\\tstream.write_queue.shift();\\r\\n\\t\\t\\t_write_req_finish(req);\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\telse if (n > 0) {\\r\\n\\t\\t\\treq.buf = Buffer(buffer).slice(n, length).toString();\\r\\n\\t\\t\\treq.len = length - n;\\r\\n\\t\\t\\tstream.write_queue[0] = req;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nStream.prototype.stream_io = function(events){\\r\\n\\r\\n\\tif (events === POLLERR){\\r\\n\\t\\tthis.maybe_error = 1;\\r\\n\\t}\\r\\n\\r\\n\\tassert(!(this.flags & uv.CLOSING));\\r\\n\\r\\n\\tif (this.connect_req) {\\r\\n\\t\\tthis.stream_connect();\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tvar fd = this.fd;\\r\\n\\tif ( events & (POLLIN | POLLERR) ){\\r\\n\\t\\t_read(this);\\r\\n\\t}\\r\\n\\r\\n\\tif (this.fd === -1) return;  /* read_cb closed stream. */\\r\\n\\r\\n\\tvar flag = this.flags;\\r\\n\\tif ( (events & POLLERR) &&\\r\\n\\t  (flag & uv.STREAM_READING) &&\\r\\n\\t  (flag & uv.STREAM_READ_PARTIAL) &&\\r\\n\\t  !(flag & uv.STREAM_READ_EOF)) {\\r\\n\\r\\n\\t\\tthis.stream_eof(\\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\tif (this.fd === -1) return;  /* read_cb closed stream. */\\r\\n\\r\\n\\tif (events & (POLLOUT | POLLERR)) {\\r\\n\\t\\t_write(this);\\r\\n\\r\\n\\t\\t//uv_write_callbacks\\r\\n\\t\\twhile (1){\\r\\n\\t\\t\\tvar req = this.write_completed.shift();\\r\\n\\t\\t\\tif (!req) break;\\r\\n\\t\\t\\treq.call(req, req.error);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.write_completed = [];\\r\\n\\t\\tthis.write_completed.length = 0;\\r\\n\\r\\n\\t\\t//uv_drain\\r\\n\\t\\tif (!this.write_queue.length){\\r\\n\\t\\t\\tthis.write_queue.length = 0;\\r\\n\\t\\t\\tthis.io_watcher.stop(POLLOUT);\\r\\n\\t\\t\\tvar flag = this.flags;\\r\\n\\t\\t\\tif ((flag & uv.STREAM_SHUTTING) && !(flag & uv.CLOSING) && !(flag & uv.STREAM_SHUT)) {\\r\\n\\t\\t\\t\\tthis.flags &= ~uv.STREAM_SHUTTING;\\r\\n\\r\\n\\t\\t\\t\\tvar error = 0;\\r\\n\\t\\t\\t\\tif (!sock.shutdown(this.fd, sock.SHUT_WR)){\\r\\n\\t\\t\\t\\t\\terror = process.errno;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthis.flags |= uv.STREAM_SHUT;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (this.shutdown_cb){\\r\\n\\t\\t\\t\\t\\tthis.shutdown_cb(error);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.stream_eof = function(buf){\\r\\n\\tthis.flags |= uv.STREAM_READ_EOF;\\r\\n\\tthis.io_watcher.stop(POLLIN);\\r\\n\\tif (!this.io_watcher.active(POLLOUT)){\\r\\n\\t\\tthis.io_watcher.handle_stop();\\r\\n\\t}\\r\\n\\r\\n\\tthis.read_cb(errno.EOF, buf);\\r\\n\\tthis.flags &= ~uv.STREAM_READING;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.shutdown = function(cb){\\r\\n\\r\\n\\tif (this.flags & _shutting_mask){\\r\\n\\t\\treturn errno.ENOTCONN;\\r\\n\\t}\\r\\n\\r\\n\\tthis.shutdown_cb = cb;\\r\\n\\tthis.flags |= uv.STREAM_SHUTTING;\\r\\n\\r\\n\\tif (!this.io_watcher.active(POLLOUT)){\\r\\n\\t\\tthis.io_watcher.start(this.fd, POLLWRITE);\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.close = function(cb){\\r\\n\\tthis.flags |= uv.CLOSING;\\r\\n\\tthis.read_stop();\\r\\n\\tthis.io_watcher.close(cb);\\r\\n\\r\\n\\tif (this.fd !== -1){\\r\\n\\t\\tsock.close(this.fd);\\r\\n\\t\\tthis.fd = -1;\\r\\n\\t}\\r\\n\\r\\n\\tif (this.accepted_fd !== -1){\\r\\n\\t\\tsock.close(this.accepted_fd);\\r\\n\\t\\tthis.accepted_fd = -1;\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.read_stop = function(cb){\\r\\n\\tif (!(this.flags & uv.STREAM_READING)) return 0;\\r\\n\\r\\n\\tthis.flags &= ~uv.STREAM_READING;\\r\\n\\tthis.io_watcher.stop(POLLIN);\\r\\n\\tif (!this.io_watcher.active(POLLOUT)){\\r\\n\\t\\tthis.io_watcher.handle_stop();\\r\\n\\t}\\r\\n\\r\\n\\tthis.read_cb = null;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.stream_open = function(fd, flags){\\r\\n\\tif (!(this.fd === -1 || this.fd === fd)){\\r\\n\\t\\treturn errno.EBUSY;\\r\\n\\t}\\r\\n\\r\\n\\tthis.flags |= flags;\\r\\n\\r\\n\\tif (this.type === \\\"TCP\\\") {\\r\\n\\t\\t// if ((this.flags & uv.TCP_NODELAY) && uv__tcp_nodelay(fd, 1)){\\r\\n\\t\\t//     return process.errno;\\r\\n\\t\\t// }\\r\\n\\r\\n\\t\\t/* TODO Use delay the user passed in. */\\r\\n\\t\\t// if ((this.flags & uv.TCP_KEEPALIVE) && uv__tcp_keepalive(fd, 1, 60)) {\\r\\n\\t\\t//     return process.errno;\\r\\n\\t\\t// }\\r\\n\\t}\\r\\n\\r\\n\\tthis.fd = fd;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\n//override in uv/tcp.js\\r\\nStream.prototype.connect = function(ip, port, cb){\\r\\n\\treturn errno.EINVAL;\\r\\n};\\r\\n\\r\\n\\r\\n//override in tcp.js & uv/ipc.js\\r\\nStream.prototype.listen = function(backlog, cb){\\r\\n\\treturn errno.EINVAL;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.accept = function(client){\\r\\n\\tif (this.accepted_fd === -1) return errno.EINVAL;\\r\\n\\r\\n\\tvar ret = client.stream_open(this.accepted_fd, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n\\tif (ret){\\r\\n\\t\\tthrow new Error(\\\"stream open error\\\");\\r\\n\\t}\\r\\n\\r\\n\\tthis.accepted_fd = -1;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.read_start = function(cb){\\r\\n\\r\\n\\tif (this.flags & uv.CLOSING) return errno.EINVAL;\\r\\n\\r\\n\\tif (cb) this.read_cb = cb.bind(this);\\r\\n\\r\\n\\tthis.flags |= uv.STREAM_READING;\\r\\n\\r\\n\\t//TODO try to read immediately\\r\\n\\tassert(this.fd !== -1);\\r\\n\\tthis.io_watcher.start(this.fd, POLLREAD);\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.dowrite = function(){\\r\\n\\tvar self = this;\\r\\n\\tvar sockfd = self.fd;\\r\\n\\tassert(sockfd > 0);\\r\\n\\r\\n\\tvar req = this.write_queue[0];\\r\\n\\tif (!req){\\r\\n\\t\\tself.write_queue.length = 0;\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tvar buf    = req.buf;\\r\\n\\tvar length = req.len;\\r\\n\\r\\n\\r\\n\\tvar n = sock.send(sockfd, buf, length, SEND_FLAG);\\r\\n\\tif (n === null){\\r\\n\\t\\t//do nothing just yet\\r\\n\\t\\t//queue it for the event loop\\r\\n\\t} else {\\r\\n\\t\\tself.write_queue_size -= n;\\r\\n\\t\\tif (n === length){\\r\\n\\t\\t\\tself.write_queue.shift();\\r\\n\\t\\t\\treq.call(self, 0, n);\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t} else if (n > 0) {\\r\\n\\t\\t\\treq.buf = Buffer(buf).slice(n, length).toString();\\r\\n\\t\\t\\treq.len = length - n;\\r\\n\\t\\t\\tself.write_queue[0] = req;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (!self.io_watcher.active(POLLOUT)){\\r\\n\\t\\tself.io_watcher.start(sockfd, POLLWRITE);\\r\\n\\t}\\r\\n\\treturn n;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.write = function(buf, cb, send_handle){\\r\\n\\tvar self = this;\\r\\n\\tvar sockfd = self.fd;\\r\\n\\tassert(sockfd > 0);\\r\\n\\r\\n\\tif (Array.isArray(buf)){\\r\\n\\t\\tvar last = buf.pop();\\r\\n\\t\\tbuf.forEach(function(b){\\r\\n\\t\\t\\tself.write(b);\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\treturn self.write(last, cb);\\r\\n\\t}\\r\\n\\r\\n\\tvar empty_queue = self.write_queue_size === 0;\\r\\n\\tvar length = Buffer.byteLength(buf);\\r\\n\\tself.write_queue_size += length;\\r\\n\\r\\n\\tvar req    = cb || function (){};\\r\\n\\treq.buf    = buf;\\r\\n\\treq.send_handle = send_handle;\\r\\n\\treq.len    = length;\\r\\n\\treq.handle = self;\\r\\n\\treq.write_index = 0;\\r\\n\\treq.bytes = 0;\\r\\n\\treq.error = 0;\\r\\n\\r\\n\\tself.write_queue.push(req);\\r\\n\\r\\n\\tif (self.connect_req) {\\r\\n\\t\\t//still connecting\\r\\n\\t}\\r\\n\\telse if (empty_queue){\\r\\n\\t\\t_write(self);\\r\\n\\t}\\r\\n\\telse {\\r\\n\\t\\tself.io_watcher.start(sockfd, POLLWRITE);\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.stream_connect = function(){\\r\\n\\r\\n\\tassert(this.type == \\\"TCP\\\" || this.type == \\\"NAMED_PIPE\\\");\\r\\n\\r\\n\\tvar error = 0;\\r\\n\\tif (this.delayed_error) {\\r\\n\\t\\t/* To smooth over the differences between unixes errors that\\r\\n\\t\\t * were reported synchronously on the first connect can be delayed\\r\\n\\t\\t * until the next tick--which is now.\\r\\n\\t\\t */\\r\\n\\t\\terror = this.delayed_error;\\r\\n\\t\\tthis.delayed_error = 0;\\r\\n\\t} else {\\r\\n\\t\\t/* Normal situation: we need to get the socket error from the kernel. */\\r\\n\\t\\tassert(this.fd >= 0);\\r\\n\\t\\terror = sock.getsockopt(this.fd, sock.SOL_SOCKET, sock.SO_ERROR);\\r\\n\\t}\\r\\n\\r\\n\\tif (error === errno.EINPROGRESS) {\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tthis.connect_req = null;\\r\\n\\r\\n\\tif (error || this.write_queue.length === 0) {\\r\\n\\t\\tthis.io_watcher.stop(POLLOUT);\\r\\n\\t}\\r\\n\\r\\n\\tif (this.connect_req_cb) {\\r\\n\\t\\tvar cb = this.connect_req_cb;\\r\\n\\t\\t// this.connect_req_cb = null;\\r\\n\\t\\tcb(error);\\r\\n\\t}\\r\\n\\r\\n\\tif (this.fd === -1){\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (error) {\\r\\n\\t\\t// throw new Error(\\\"flush write & connect error \\\" + error);\\r\\n\\t\\t// uv__stream_flush_write_queue(stream, -ECANCELED);\\r\\n\\t\\t// uv__write_callbacks(stream);\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.io_feed = function(){\\r\\n\\tvar stream = this;\\r\\n\\tvar io = this.io_watcher;\\r\\n\\tsetTimeout(function(){\\r\\n\\t\\tstream.stream_io(POLLOUT);\\r\\n\\t}, 1);\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.ref = function(cb){\\r\\n\\tthis.io_watcher.ref();\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.unref = function(cb){\\r\\n\\tthis.io_watcher.unref();\\r\\n};\\r\\n\\r\\nmodule.exports = Stream;\\r\\n\",\"uv/tcp\":\"var util   = require(\\\"util\\\");\\r\\nvar stream = require('uv/stream');\\r\\nvar sock   = require('socket');\\r\\nvar errno  = require('errno');\\r\\nvar loop   = require('loop').main;\\r\\nvar uv     = require('uv');\\r\\nvar assert = require('assert');\\r\\n\\r\\nvar isWin  = process.platform === \\\"win32\\\";\\r\\n\\r\\nutil.inherits(TCP, stream);\\r\\nfunction TCP (){\\r\\n\\tstream.call(this, 'TCP');\\r\\n}\\r\\n\\r\\n\\r\\nTCP.prototype.open = function(s){\\r\\n\\tif (!sock.nonblock(s, 1)){\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\treturn this.stream_open(s, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.maybe_new_socket = function(domain, flags){\\r\\n\\tif (domain == sock.AF_UNSPEC || this.fd !== -1) {\\r\\n\\t\\tthis.flags |= flags;\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\tvar fd = uv.socket(domain, sock.SOCK_STREAM, 0);\\r\\n\\tif (!fd) return process.errno;\\r\\n\\r\\n\\tthis.stream_open(fd, flags);\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.simultaneous_accepts = function(enable){\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.bind = function(addr, flags) {\\r\\n\\r\\n\\tvar family = sock.family(addr);\\r\\n\\r\\n\\t/* Cannot set IPv6-only mode on non-IPv6 socket. */\\r\\n\\tif ((flags & uv.TCP_IPV6ONLY) && family !== uv.AF_INET6) {\\r\\n\\t\\treturn errno.EINVAL;\\r\\n\\t}\\r\\n\\r\\n\\tvar err = this.maybe_new_socket(family, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n\\r\\n\\tif (err) return err;\\r\\n\\r\\n\\tvar set = process.platform === 'win32' ? 0 : 1;\\r\\n\\tif (!sock.setsockopt(this.fd, sock.SOL_SOCKET, sock.SO_REUSEADDR, set)) {\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\tprocess.errno = 0;\\r\\n\\tif (!sock.bind(this.fd, addr) && process.errno !== errno.EADDRINUSE) {\\r\\n\\t\\tif (process.errno === errno.EAFNOSUPPORT) {\\r\\n\\t\\t\\t/* OSX, other BSDs and SunoS fail with EAFNOSUPPORT when binding a\\r\\n\\t\\t\\t* socket created with AF_INET to an AF_INET6 address or vice versa. */\\r\\n\\t\\t\\treturn errno.EINVAL;\\r\\n\\t\\t}\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\tthis.delayed_error = process.errno;\\r\\n\\r\\n\\tif (family === sock.AF_INET6) {\\r\\n\\t\\tthis.flags |= uv.HANDLE_IPV6;\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.listen = function(backlog, cb){\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tif (this.delayed_error) {\\r\\n\\t\\treturn this.delayed_error;\\r\\n\\t}\\r\\n\\r\\n\\tthis.maybe_new_socket(sock.AF_INET, uv.STREAM_READABLE);\\r\\n\\r\\n\\tif (!sock.listen(this.fd, backlog)){\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\tthis.connection_cb = cb.bind(this);\\r\\n\\r\\n\\t// close previous loop watcher and\\r\\n\\t// create new one to be handled with\\r\\n\\t// server_io function\\r\\n\\tself.io_watcher.close();\\r\\n\\tthis.io_watcher = loop.io(function(h, events){\\r\\n\\t\\tself.server_io(events);\\r\\n\\t});\\r\\n\\r\\n\\tthis.io_watcher.start(this.fd, loop.POLLIN);\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.connect = function(addr, cb){\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tif (this.connect_req){\\r\\n\\t\\treturn errno.EALREADY;\\r\\n\\t}\\r\\n\\r\\n\\tvar family = sock.family(addr);\\r\\n\\r\\n\\tvar err = this.maybe_new_socket(family, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n\\tif (err) return err;\\r\\n\\r\\n\\tthis.delayed_error = 0;\\r\\n\\tthis.connect_req    = 1;\\r\\n\\tif (cb) this.connect_req_cb = cb.bind(this);\\r\\n\\r\\n\\tself.io_watcher.start(self.fd, loop.POLLIN | loop.POLLOUT | loop.POLLERR);\\r\\n\\tsock.connect(this.fd, addr);\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\nTCP.prototype.getpeername = function(){\\r\\n\\tvar addr = sock.getpeername(this.fd);\\r\\n\\tif (addr === null) return process.errno;\\r\\n\\tvar peerinfo = sock.addr_info(addr);\\r\\n\\tif (peerinfo === null) return process.errno;\\r\\n\\treturn {\\r\\n\\t\\tip : peerinfo[0],\\r\\n\\t\\tport : peerinfo[1]\\r\\n\\t};\\r\\n};\\r\\n\\r\\n\\r\\nmodule.exports = TCP;\\r\\n\",\"uv/pipe\":\"var util   = require(\\\"util\\\");\\r\\nvar stream = require('uv/stream');\\r\\nvar sock   = require('socket');\\r\\nvar errno  = require('errno');\\r\\nvar loop   = require('loop');\\r\\nvar uv     = require('uv');\\r\\nvar assert = require('assert');\\r\\n\\r\\nvar isWin  = process.platform === 'win32';\\r\\n\\r\\nvar pipe_map = {};\\r\\n\\r\\nutil.inherits(Pipe, stream);\\r\\nfunction Pipe (ipc){\\r\\n\\tstream.call(this, 'NAMED_PIPE');\\r\\n\\tthis.shutdown_req = null;\\r\\n\\tthis.connect_req = null;\\r\\n\\tthis.pipe_fname = null;\\r\\n\\tthis.ipc = ipc;\\r\\n}\\r\\n\\r\\n\\r\\nPipe.prototype.open = function(fd){\\r\\n\\tif (!sock.nonblock(fd, 1)){\\r\\n\\t\\tthrow new Error(process.errno);\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\treturn this.stream_open(fd, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.listen = function(backlog, cb){\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tif (this.fd === -1) return errno.EINVAL;\\r\\n\\r\\n\\tif (!sock.listen(this.fd, backlog)){\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\t// we already have io_watcher active with\\r\\n\\t// stream_io, clean this up and activate again\\r\\n\\t// on server_io cb\\r\\n\\tthis.io_watcher.close();\\r\\n\\tthis.io_watcher = null;\\r\\n\\r\\n\\tthis.connection_cb = cb;\\r\\n\\tthis.io_watcher = loop.io(function(h, events){\\r\\n\\t\\tself.server_io(events);\\r\\n\\t});\\r\\n\\r\\n\\tthis.io_watcher.start(this.fd, loop.POLLIN);\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.bind = function(pipe_fname) {\\r\\n\\r\\n\\tvar sockfd;\\r\\n\\r\\n\\t/* Already bound? */\\r\\n\\tif (this.fd >= 0) {\\r\\n\\t\\treturn errno.EINVAL;\\r\\n\\t}\\r\\n\\r\\n\\t//we are emulatiing AF_UNIX\\r\\n\\tif (isWin){\\r\\n\\t\\tsockfd = uv.socket(sock.AF_INET, sock.SOCK_STREAM, 0);\\r\\n\\t} else {\\r\\n\\t\\tsockfd = uv.socket(sock.AF_UNIX, sock.SOCK_STREAM, 0);\\r\\n\\t}\\r\\n\\r\\n\\tif (!sockfd) return process.errno;\\r\\n\\r\\n\\tvar addr = sock.pton(\\\"127.0.0.1\\\", 8000);\\r\\n\\tif (addr === null){\\r\\n\\t\\tthrow new Error(\\\"addr error \\\" + process.errno);\\r\\n\\t}\\r\\n\\r\\n\\tpipe_map[pipe_fname] = addr;\\r\\n\\r\\n\\t// memset(&saddr, 0, sizeof saddr);\\r\\n\\t// strncpy(saddr.sun_path, pipe_fname, sizeof(saddr.sun_path) - 1);\\r\\n\\t// saddr.sun_path[sizeof(saddr.sun_path) - 1] = '\\\\0';\\r\\n\\t// saddr.sun_family = AF_UNIX;\\r\\n\\r\\n\\tif (!sock.bind(sockfd, addr)) {\\r\\n\\t\\tuv.close(sockfd);\\r\\n\\t\\t/* Convert ENOENT to EACCES for compatibility with Windows. */\\r\\n\\t\\tif (process.errno == errno.ENOENT) return errno.EACCES;\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\t/* Success. */\\r\\n\\tthis.pipe_fname = pipe_fname; /* Is a strdup'ed copy. */\\r\\n\\tthis.fd = sockfd;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.connect = function(name, cb) {\\r\\n\\r\\n\\tvar new_sock = (this.fd === -1);\\r\\n\\r\\n\\tif (new_sock) {\\r\\n\\t\\tif (isWin){\\r\\n\\t\\t\\tnewSock = uv.socket(sock.AF_INET, sock.SOCK_STREAM, 0);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tnewSock = uv.socket(sock.AF_UNIX, sock.SOCK_STREAM, 0);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!newSock) return this.connect_error();\\r\\n\\t\\tthis.fd = newSock;\\r\\n\\t}\\r\\n\\r\\n\\tvar addr = pipe_map[name];\\r\\n\\tvar err = 0;\\r\\n\\tvar r;\\r\\n\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tthis.connect_req   = 1;\\r\\n\\tif (cb) this.connect_req_cb = cb.bind(this);\\r\\n\\r\\n\\tif (new_sock) {\\r\\n\\t\\terr = this.stream_open(this.fd, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n\\t}\\r\\n\\r\\n\\tself.io_watcher.start(self.fd, loop.POLLIN | loop.POLLOUT | loop.POLLERR);\\r\\n\\tsock.connect(this.fd, addr);\\r\\n\\r\\n\\tthis.delayed_error = err;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\nmodule.exports = Pipe;\\r\\n\",\"uv/process\":\"var isWin = process.platform === 'win32';\\r\\nmodule.exports = isWin ? require('uv/process/windows') :\\r\\n                         require('uv/process/unix');\\r\\n\",\"uv/process/windows\":\"var assert   = require('assert');\\r\\nvar uv       = require('uv');\\r\\nvar errno    = require('errno');\\r\\nvar syscall  = require('syscall');\\r\\nvar timers   = require('timers');\\r\\n\\r\\nvar DETACHED_PROCESS           = 0x00000008;\\r\\nvar CREATE_NEW_PROCESS_GROUP   = 0x00000200;\\r\\nvar CREATE_UNICODE_ENVIRONMENT = 0x00000400;\\r\\nvar CREATE_NO_WINDOW           = 0x08000000;\\r\\n\\r\\nvar READ_PIPE  = 0;\\r\\nvar WRITE_PIPE = 1;\\r\\n\\r\\n// TODO child_watcher ref\\r\\n\\r\\nfunction Process (options) {\\r\\n\\r\\n\\tthis.exit_signal = 0;\\r\\n\\r\\n\\toptions = options || {};\\r\\n\\tassert(options.file, \\\"options.file required\\\");\\r\\n\\r\\n\\tassert(!(options.flags & ~(\\r\\n\\t\\tuv.PROCESS_DETACHED |\\r\\n\\t\\tuv.PROCESS_SETGID |\\r\\n\\t\\tuv.PROCESS_SETUID |\\r\\n\\t\\tuv.PROCESS_WINDOWS_HIDE |\\r\\n\\t\\tuv.PROCESS_WINDOWS_VERBATIM_ARGUMENTS\\r\\n\\t)));\\r\\n\\r\\n\\tvar stdio_count = options.stdio_count;\\r\\n\\tif (stdio_count < 3) stdio_count = 3;\\r\\n\\r\\n\\tvar err = errno.ENOMEM;\\r\\n\\r\\n\\tvar pipes = [];\\r\\n\\r\\n\\tfor (var i = 0; i < stdio_count; i++) {\\r\\n\\t\\tpipes[i]    = [];\\r\\n\\t\\tpipes[i][0] = -1;\\r\\n\\t\\tpipes[i][1] = -1;\\r\\n\\t}\\r\\n\\r\\n\\tfor (var i = 0; i < options.stdio_count; i++) {\\r\\n\\t\\terr = this.init_stdio(options.stdio[i], pipes[i], i);\\r\\n\\t\\tif (err) throw new Error(\\\"STDIO initiate error \\\" + err);\\r\\n\\t}\\r\\n\\r\\n\\tthis.status = 0;\\r\\n\\tthis.pid = 0;\\r\\n\\tthis.exit_cb = options.exit_cb;\\r\\n\\r\\n\\t// on error returns null and set process.errno\\r\\n\\t// on success returns an object hold process\\r\\n\\t// handle and process id\\r\\n\\tvar ret = this.child_init(options, stdio_count, pipes);\\r\\n\\tthis.pipes = pipes;\\r\\n\\r\\n\\tif (ret === null) {\\r\\n\\t\\terr = process.errno;\\r\\n\\t\\tthis.errno = errno.translate(process.errno);\\r\\n\\t} else {\\r\\n\\t\\tthis.process_handle = ret.process || -1;\\r\\n\\t\\tthis.pid = ret.process_id || 0;\\r\\n\\t}\\r\\n\\r\\n\\tfor (var i = 0; i < options.stdio_count; i++) {\\r\\n\\t\\t// set process id for all stream pipes\\r\\n\\t\\t// we need to use this with msgrecv function\\r\\n\\t\\tvar stream = options.stdio[i].stream;\\r\\n\\t\\tif (stream){\\r\\n\\t\\t\\tif (stream.type === 'NAMED_PIPE' || stream.type){\\r\\n\\t\\t\\t\\toptions.stdio[i].stream.ipc_pid = this.pid;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\terr = this.open_stream(options.stdio[i], pipes[i], i === 0);\\r\\n\\t\\tif (err === 0) continue;\\r\\n\\r\\n\\t\\twhile (i--) {\\r\\n\\t\\t\\tthis.close_stream(options.stdio[i]);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// Only activate this handle if exec() happened\\r\\n\\t// successfully, we are hacky here as we are using\\r\\n\\t// a timer loop to check for process status\\r\\n\\tif ( !err && this.pid ) {\\r\\n\\t\\tvar self = this;\\r\\n\\t\\tvar process_handle = this.process_handle;\\r\\n\\t\\tself.child_watcher = setInterval(function(){\\r\\n\\t\\t\\tvar exitcode = uv.get_exit_code(process_handle);\\r\\n\\r\\n\\t\\t\\t// 259 indicates that the\\r\\n\\t\\t\\t// process still running\\r\\n\\t\\t\\tif (exitcode === 259){\\r\\n\\t\\t\\t\\treturn; /* do nothing we need to check again */\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// stop child status watcher\\r\\n\\t\\t\\tclearInterval(this);\\r\\n\\t\\t\\tself.child_watcher = null;\\r\\n\\r\\n\\t\\t\\t// close process handle\\r\\n\\t\\t\\tassert(syscall.CloseHandle(self.process_handle) !== null);\\r\\n\\r\\n\\t\\t\\tif (self.exit_cb) self.exit_cb.call(self, exitcode, self.exit_signal);\\r\\n\\r\\n\\t\\t\\tfor (var fd = 0; fd < pipes.length; fd++) {\\r\\n\\t\\t\\t\\tif (pipes[fd][0] > -1){\\r\\n\\t\\t\\t\\t\\tuv.close(pipes[fd][0]);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}, 1);\\r\\n\\t} else {\\r\\n\\t\\tfor (var fd = 0; fd < pipes.length; fd++) {\\r\\n\\t\\t\\tif (pipes[fd][0] > -1){\\r\\n\\t\\t\\t\\tuv.close(pipes[fd][0]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (err) {\\r\\n\\t\\tthis.errno = errno.translate(err);\\r\\n\\t}\\r\\n\\treturn this;\\r\\n}\\r\\n\\r\\n\\r\\nProcess.prototype.unref = function(){\\r\\n\\tif (this.child_watcher){\\r\\n\\t\\tthis.child_watcher.unref();\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.open_stream = function (container, pipefds, writable) {\\r\\n\\r\\n\\tif (!(container.flags & uv.CREATE_PIPE) || pipefds[0] < 0) {\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\tvar flags = 0;\\r\\n\\r\\n\\tif (container.stream.type === 'NAMED_PIPE' && container.stream.ipc ) {\\r\\n\\t\\tflags = uv.STREAM_READABLE | uv.STREAM_WRITABLE;\\r\\n\\t}\\r\\n\\r\\n\\telse if (writable) {\\r\\n\\t\\tflags = uv.STREAM_WRITABLE;\\r\\n\\t}\\r\\n\\r\\n\\telse {\\r\\n\\t\\tflags = uv.STREAM_READABLE;\\r\\n\\t}\\r\\n\\r\\n\\treturn container.stream.stream_open(pipefds[1], flags);\\r\\n};\\r\\n\\r\\n\\r\\n// constructs a utf16 buffer of environment\\r\\n// variables block, windows require each env to be\\r\\n// seperated with 1 nul and ends with 2 nul charachters\\r\\nfunction make_env_block(env){\\r\\n\\tif (!env){\\r\\n\\t\\treturn null;\\r\\n\\t}\\r\\n\\r\\n\\tvar envBlock = process.env;\\r\\n\\r\\n\\t//extend\\r\\n\\tfor (var key in envBlock){\\r\\n\\t\\tenv.unshift(key + '=' + envBlock[key]);\\r\\n\\t}\\r\\n\\r\\n\\tvar len = env.length;\\r\\n\\r\\n\\tvar n = \\\"\\\";\\r\\n\\tfor (var i = 0; i < len; i++){\\r\\n\\t\\tn += env[i] + '\\\\0';\\r\\n\\t}\\r\\n\\tn += '\\\\0\\\\0';\\r\\n\\treturn new Buffer(n, 'ucs2');\\r\\n}\\r\\n\\r\\n\\r\\nfunction join_arguments (args, verbatim){\\r\\n\\tif (!verbatim){\\r\\n\\t\\tfor (var i = 0; i < args.length; i++){\\r\\n\\t\\t\\tvar arg = args[i];\\r\\n\\t\\t\\tif (/\\\\s/g.test(arg)){\\r\\n\\t\\t\\t\\targ.replace(/\\\"/g, '\\\\\\\"');\\r\\n\\t\\t\\t\\targ = '\\\"' + arg + '\\\"'\\r\\n\\t\\t\\t\\targs[i] = arg;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\targs = args.join(' ');\\r\\n\\treturn syscall.UTF16PtrFromString(args);\\r\\n}\\r\\n\\r\\n\\r\\nProcess.prototype.child_init = function(options, stdio_count, pipes) {\\r\\n\\r\\n\\tvar process_flags = CREATE_UNICODE_ENVIRONMENT;\\r\\n\\tif (options.flags & uv.PROCESS_DETACHED) {\\r\\n\\t\\tprocess_flags |= DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP;\\r\\n\\t}\\r\\n\\r\\n\\t//initiate stdio handles\\r\\n\\tvar stdioHandles = [-1, -1, -1];\\r\\n\\r\\n\\tfor (var fd = 0; fd < stdio_count; fd++) {\\r\\n\\t\\tvar use_handle   = pipes[fd][2];\\r\\n\\t\\tif (use_handle > -1) {\\r\\n\\t\\t\\tif (fd <= 2) {\\r\\n\\t\\t\\t\\tstdioHandles[fd] = use_handle;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t// store shared handles?\\r\\n\\t\\t\\t\\toptions.env = options.env || [];\\r\\n\\t\\t\\t\\toptions.env.push(\\\"COMO_FD_\\\"+fd+'='+use_handle);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// working directory\\r\\n\\tvar cwd = null\\r\\n\\tif (options.cwd) {\\r\\n\\t\\tcwd = syscall.UTF16PtrFromString(options.cwd);\\r\\n\\t} else {\\r\\n\\t\\tcwd = syscall.GetCurrentDirectory();\\r\\n\\t\\tif (!cwd) return null;\\r\\n\\t}\\r\\n\\r\\n\\t// var path = syscall.Getenv('PATH');\\r\\n\\r\\n\\t//custom env block\\r\\n\\tvar env = null;\\r\\n\\tif (options.env) {\\r\\n\\t\\tenv = make_env_block(options.env);\\r\\n\\t}\\r\\n\\r\\n\\t// CreateProcess syscall\\r\\n\\tvar info    = new syscall.ProcessInformation();\\r\\n\\tvar startup = new syscall.StartupInfo();\\r\\n\\r\\n\\tstartup.Cb = startup.size;\\r\\n\\tstartup.Flags = (syscall.STARTF_USESTDHANDLES | syscall.STARTF_USESHOWWINDOW);\\r\\n\\tstartup.StdInput  = stdioHandles[0];\\r\\n\\tstartup.StdOutput = stdioHandles[1];\\r\\n\\tstartup.StdError  = stdioHandles[2];\\r\\n\\r\\n\\tif (options.flags & uv.PROCESS_WINDOWS_HIDE) {\\r\\n\\t\\t/* Use SW_HIDE to avoid any potential process window. */\\r\\n\\t\\tstartup.ShowWindow = syscall.SW_HIDE;\\r\\n\\t} else {\\r\\n\\t\\tstartup.wShowWindow = syscall.SW_SHOWDEFAULT;\\r\\n\\t}\\r\\n\\r\\n\\tvar program = null;\\r\\n\\tvar arguments = join_arguments(options.args,\\r\\n\\t\\toptions.flags & uv.PROCESS_WINDOWS_VERBATIM_ARGUMENTS);\\r\\n\\r\\n\\t// syscall CreateProcess\\r\\n\\t// on failure returns null and set\\r\\n\\t// process.errno to last error\\r\\n\\tvar ret = syscall.CreateProcess(\\r\\n\\t\\tprogram,      // programs path\\r\\n\\t\\targuments,    // utf16 buffer of all args\\r\\n\\t\\tnull,\\r\\n\\t\\tnull,\\r\\n\\t\\t1,\\r\\n\\t\\tprocess_flags,\\r\\n\\t\\tenv,          // utf16 env block\\r\\n\\t\\tcwd,          // child working director\\r\\n\\t\\tstartup,      // startup info\\r\\n\\t\\tinfo          // new created process info\\r\\n\\t);\\r\\n\\r\\n\\t// duplicated handles passed to the child\\r\\n\\t// we can close them now\\r\\n\\tfor (var fd = 0; fd < pipes.length; fd++) {\\r\\n\\t\\tif (pipes[fd][2] !== -1){\\r\\n\\t\\t\\tuv.close(pipes[fd][2]);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (ret === null) return null;\\r\\n\\r\\n\\tassert(syscall.CloseHandle(info.Thread) !== null);\\r\\n\\r\\n\\treturn {\\r\\n\\t\\tprocess: info.Process,\\r\\n\\t\\tprocess_id : info.ProcessId\\r\\n\\t};\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.init_stdio = function (container, fds, i) {\\r\\n\\tvar STDIO_MASK = uv.IGNORE | uv.CREATE_PIPE | uv.INHERIT_FD | uv.INHERIT_STREAM;\\r\\n\\r\\n\\t// initiated fd to invalid handle\\r\\n\\t// ignore by default\\r\\n\\tif (i <= 2) fds[2] = -1;\\r\\n\\r\\n\\tif (!container) return 0;\\r\\n\\tswitch (container.flags & STDIO_MASK){\\r\\n\\t\\tcase uv.IGNORE : {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase uv.CREATE_PIPE : {\\r\\n\\t\\t\\tassert(container.stream.type === 'NAMED_PIPE');\\r\\n\\r\\n\\t\\t\\tif (uv.make_socketpair(fds, 0)) throw new Error(\\\"Error creating socketpair\\\");\\r\\n\\t\\t\\tvar fh = fds[0];\\r\\n\\t\\t\\tvar inherit_handle = -1;\\r\\n\\t\\t\\tif (i > 2) {\\r\\n\\t\\t\\t\\tinherit_handle = uv.make_inheritable(fh);\\r\\n\\t\\t\\t\\tinherit_handle = uv.duplicate_handle(inherit_handle);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tinherit_handle = uv.duplicate_handle(fh);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfds[2] = inherit_handle;\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase uv.INHERIT_FD :\\r\\n\\t\\tcase uv.INHERIT_STREAM : {\\r\\n\\t\\t\\tif (container.flags & uv.INHERIT_FD) {\\r\\n\\t\\t\\t\\tfd = container.fd;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tfd = container.stream.fd;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (typeof fd === 'undefined' || fd == -1){\\r\\n\\t\\t\\t\\treturn errno.EINVAL;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t//duplicate fd to handle\\r\\n\\t\\t\\tvar handle = uv.get_fd_handle(fd);\\r\\n\\t\\t\\tif (handle === null) return process.errno;\\r\\n\\t\\t\\tvar dupHandle = uv.duplicate_handle(handle);\\r\\n\\t\\t\\tfds[2] = dupHandle;\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdefault : {\\r\\n\\t\\t\\tthrow new Error(\\\"unknown stdio type\\\");\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.kill = function(signum){\\r\\n\\tvar process = this;\\r\\n\\tvar err;\\r\\n\\r\\n\\tif (process.process_handle == -1) {\\r\\n\\t\\treturn errno.EINVAL;\\r\\n\\t}\\r\\n\\r\\n\\terr = uv.Win32kill(process.process_handle, signum);\\r\\n\\tif (err) return err;  /* err is already translated. */\\r\\n\\tprocess.exit_signal = signum;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.close = function(cb){\\r\\n\\tvar self = this;\\r\\n\\r\\n\\t// clean opened pipes\\r\\n\\tvar pipes = this.pipes || [];\\r\\n\\tfor (var fd = 0; fd < pipes.length; fd++) {\\r\\n\\t\\tif (pipes[fd][0] > -1){\\r\\n\\t\\t\\tuv.close(pipes[fd][0]);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// only close if process handle is there\\r\\n\\tif (this.process_handle){\\r\\n\\t\\tuv.close(this.process_handle);\\r\\n\\t}\\r\\n\\r\\n\\t//clear child watcher interval\\r\\n\\tif (this.child_watcher){\\r\\n\\t\\tclearInterval(this.child_watcher);\\r\\n\\t}\\r\\n};\\r\\n\\r\\nmodule.exports = Process;\\r\\n\",\"uv/process/unix\":\"var assert   = require('assert');\\r\\nvar uv       = require('uv');\\r\\nvar errno    = require('errno');\\r\\nvar syscall  = require('syscall');\\r\\nvar SYS      = syscall.SYS;\\r\\nvar timers   = require('timers');\\r\\nvar C        = require('C');\\r\\n\\r\\nvar DETACHED_PROCESS           = 0x00000008;\\r\\nvar CREATE_NEW_PROCESS_GROUP   = 0x00000200;\\r\\nvar CREATE_UNICODE_ENVIRONMENT = 0x00000400;\\r\\nvar CREATE_NO_WINDOW           = 0x08000000;\\r\\n\\r\\nvar READ_PIPE  = 0;\\r\\nvar WRITE_PIPE = 1;\\r\\n\\r\\nfunction _exit(n){\\r\\n\\tprocess.reallyExit(n);\\r\\n}\\r\\n\\r\\nfunction init_stdio (container, fds) {\\r\\n\\tvar mask = uv.IGNORE | uv.CREATE_PIPE | uv.INHERIT_FD | uv.INHERIT_STREAM;\\r\\n\\tvar fd;\\r\\n\\r\\n\\tswitch( container.flags & mask ){\\r\\n\\t\\tcase uv.IGNORE : {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase uv.CREATE_PIPE : {\\r\\n\\t\\t\\tassert(container.stream.type === 'NAMED_PIPE');\\r\\n\\t\\t\\tif (uv.make_socketpair(fds, 0)) throw new Error(\\\"Error creating socketpair\\\");\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase uv.INHERIT_FD :\\r\\n\\t\\tcase uv.INHERIT_STREAM : {\\r\\n\\t\\t\\tif (container.flags & uv.INHERIT_FD) {\\r\\n\\t\\t\\t\\tfd = container.fd;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tfd = container.stream.fd;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (typeof fd === 'undefined' || fd == -1){\\r\\n\\t\\t\\t\\treturn errno.EINVAL;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfds[1] = fd;\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdefault : {\\r\\n\\t\\t\\tthrow new Error(\\\"unknown stdio type\\\");\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfunction write_int (fd, val){\\r\\n\\tval = \\\"\\\" + val; //stringify\\r\\n\\tvar n;\\r\\n\\tdo {\\r\\n\\t\\tn = uv.write(fd, val, val.length);\\r\\n\\t} while (n === null && process.errno === errno.EINVAL);\\r\\n\\r\\n\\tif (n === null && process.errno === errno.EPIPE){\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nvar jargs;\\r\\nfunction make_args_block (args){\\r\\n\\tfor (var i = 0; i < args.length; i++){\\r\\n\\t\\targs[i] = args[i] + '\\\\0';\\r\\n\\t}\\r\\n\\tjargs = Buffer(args.join(''));\\r\\n\\treturn jargs;\\r\\n}\\r\\n\\r\\nfunction child_init (options, stdio_count, pipes, error_fd){\\r\\n\\r\\n\\tvar fd, use_fd, close_fd;\\r\\n\\r\\n\\tif (options.flags & uv.PROCESS_DETACHED) {\\r\\n\\t\\tsyscall.setsid();\\r\\n\\t}\\r\\n\\r\\n\\t/* First duplicate low numbered fds, since it's not safe to duplicate them,\\r\\n\\t * they could get replaced. Example: swapping stdout and stderr; without\\r\\n\\t * this fd 2 (stderr) would be duplicated into fd 1, thus making both\\r\\n\\t * stdout and stderr go to the same fd, which was not the intention. */\\r\\n\\tfor (fd = 0; fd < stdio_count; fd++) {\\r\\n\\t\\tuse_fd = pipes[fd][1];\\r\\n\\t\\tif (use_fd < 0 || use_fd >= fd) continue;\\r\\n\\r\\n\\t\\tpipes[fd][1] = syscall.fcntl(use_fd, SYS.F_DUPFD, stdio_count);\\r\\n\\t\\tif (pipes[fd][1] === null) {\\r\\n\\t\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t\\t\\t_exit(127);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfor (fd = 0; fd < stdio_count; fd++) {\\r\\n\\r\\n\\t\\tclose_fd = pipes[fd][0];\\r\\n\\t\\tuse_fd   = pipes[fd][1];\\r\\n\\r\\n\\t\\tif (use_fd < 0) {\\r\\n\\t\\t\\tif (fd >= 3) {\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\t// redirect stdin, stdout and stderr to /dev/null even if\\r\\n\\t\\t\\t\\t// uv.IGNORE is set\\r\\n\\t\\t\\t\\tuse_fd = syscall.Open(\\\"/dev/null\\\", fd == 0 ? SYS.O_RDONLY : SYS.O_RDWR);\\r\\n\\t\\t\\t\\tclose_fd = use_fd;\\r\\n\\r\\n\\t\\t\\t\\tif (use_fd === null) {\\r\\n\\t\\t\\t\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t\\t\\t\\t\\t_exit(127);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (fd === use_fd) {\\r\\n\\t\\t\\tuv.cloexec(use_fd, 0);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tfd = syscall.dup2(use_fd, fd);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (fd === null) {\\r\\n\\t\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t\\t\\t_exit(127);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (fd <= 2) {\\r\\n\\t\\t\\tuv.nonblock(fd, 0);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (close_fd >= stdio_count) {\\r\\n\\t\\t\\tuv.close(close_fd);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfor (fd = 0; fd < stdio_count; fd++) {\\r\\n\\t\\tuse_fd = pipes[fd][1];\\r\\n\\t\\tif (use_fd >= stdio_count) {\\r\\n\\t\\t\\tuv.close(use_fd);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (options.cwd) {\\r\\n\\t\\tvar ret = syscall.chdir(options.cwd);\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t\\t\\t_exit(127);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (options.flags & (uv.PROCESS_SETUID | uv.PROCESS_SETGID)) {\\r\\n\\t\\t/* When dropping privileges from root, the `setgroups` call will\\r\\n\\t\\t * remove any extraneous groups. If we don't call this, then\\r\\n\\t\\t * even though our uid has dropped, we may still have groups\\r\\n\\t\\t * that enable us to do super-user things. This will fail if we\\r\\n\\t\\t * aren't root, so don't bother checking the return value, this\\r\\n\\t\\t * is just done as an optimistic privilege dropping function.\\r\\n\\t\\t */\\r\\n\\t\\tvar olderrno = process.errno;\\r\\n\\t\\tsyscall.setgroups(0, null);\\r\\n\\t\\tprocess.errno = olderrno;\\r\\n\\t}\\r\\n\\r\\n\\tif ((options.flags & uv.PROCESS_SETGID) && syscall.setgid(options.gid) === null) {\\r\\n\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t\\t_exit(127);\\r\\n\\t}\\r\\n\\r\\n\\tif ((options.flags & uv.PROCESS_SETUID) && syscall.setuid(options.uid) === null) {\\r\\n\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t\\t_exit(127);\\r\\n\\t}\\r\\n\\r\\n\\tif (options.env) {\\r\\n\\t\\tset_env_block(options.env);\\r\\n\\t}\\r\\n\\r\\n\\tvar args = options.args.slice(0);\\r\\n\\targs.unshift(options.file);\\r\\n\\r\\n\\t// make sure to convert everything to strings\\r\\n\\tfor (var i = 0; i < args.length; i++){\\r\\n\\t\\targs[i] = String(args[i]);\\r\\n\\t}\\r\\n\\targs.push(null);\\r\\n\\r\\n\\tif (syscall.execlp.apply(null, args) === null){\\r\\n\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t}\\r\\n\\r\\n\\t// write_int(error_fd, options.cwd);\\r\\n\\t// var n = write_int(error_fd, \\\"done\\\");\\r\\n\\t// // console.log(n);\\r\\n\\t// console.log(process.errno);\\r\\n\\t// console.log('done');\\r\\n}\\r\\n\\r\\n// TODO child_watcher ref\\r\\n\\r\\nfunction Process (options) {\\r\\n\\tvar self = this;\\r\\n\\tthis.exit_signal = 0;\\r\\n\\r\\n\\toptions = options || {};\\r\\n\\tassert(options.file, \\\"options.file required\\\");\\r\\n\\r\\n\\tassert(!(options.flags & ~(\\r\\n\\t\\tuv.PROCESS_DETACHED |\\r\\n\\t\\tuv.PROCESS_SETGID |\\r\\n\\t\\tuv.PROCESS_SETUID |\\r\\n\\t\\tuv.PROCESS_WINDOWS_HIDE |\\r\\n\\t\\tuv.PROCESS_WINDOWS_VERBATIM_ARGUMENTS\\r\\n\\t)));\\r\\n\\r\\n\\tvar stdio_count = options.stdio_count;\\r\\n\\tif (stdio_count < 3) stdio_count = 3;\\r\\n\\r\\n\\tvar err = errno.ENOMEM;\\r\\n\\r\\n\\tvar pipes = [];\\r\\n\\tvar signal_pipe = [ -1, -1 ];\\r\\n\\r\\n\\tfor (var i = 0; i < stdio_count; i++) {\\r\\n\\t\\tpipes[i]    = [];\\r\\n\\t\\tpipes[i][0] = -1;\\r\\n\\t\\tpipes[i][1] = -1;\\r\\n\\t}\\r\\n\\r\\n\\tfor (var i = 0; i < options.stdio_count; i++) {\\r\\n\\t\\terr = init_stdio(options.stdio[i], pipes[i], i);\\r\\n\\t\\tif (err) throw new Error(\\\"STDIO initiate error \\\" + err);\\r\\n\\t}\\r\\n\\r\\n\\t// initiate child parent signal pipes\\r\\n\\tif (uv.make_pipe(signal_pipe, 0)) throw new Error(\\\"Error creating signal pipe\\\");\\r\\n\\r\\n\\t/* Acquire write lock to prevent opening new fds in worker threads */\\r\\n\\t// uv_rwlock_wrlock(&loop->cloexec_lock);\\r\\n\\r\\n\\tvar pid = syscall.fork();\\r\\n\\tif (pid === null){\\r\\n\\t\\tthrow new Error(\\\"can't fork\\\");\\r\\n\\t}\\r\\n\\r\\n\\t// child process\\r\\n\\tif (pid === 0){\\r\\n\\t\\tchild_init(options, stdio_count, pipes, signal_pipe[1]);\\r\\n\\t\\tprocess.reallyExit(0);\\r\\n\\t}\\r\\n\\r\\n\\t/* Release lock in parent process */\\r\\n\\t// uv_rwlock_wrunlock(&loop->cloexec_lock);\\r\\n\\tuv.close(signal_pipe[1]);\\r\\n\\r\\n\\t// waitpid status\\r\\n\\tvar status = new C.void( C.sizeOf.int );\\r\\n\\tvar r;\\r\\n\\tvar spawn_error = 0;\\r\\n\\r\\n\\tdo {\\r\\n\\t\\tr = uv.read(signal_pipe[0], 1024);\\r\\n\\t} while (r === null && process.errno === errno.EINTR);\\r\\n\\r\\n\\tif (r === null && process.errno === errno.EOF){\\r\\n\\t\\t/* okay, EOF - do nothing */\\r\\n\\t}\\r\\n\\telse if (r) {\\r\\n\\t\\tdo {\\r\\n\\t\\t\\terr = syscall.waitpid(pid, status, 0);  //okay, read errorno\\r\\n\\t\\t} while (err === null && process.errno == errno.EINTR);\\r\\n\\t\\tassert(err == pid);\\r\\n\\t\\tspawn_error = Number(r);\\r\\n\\t}\\r\\n\\telse if (r === null && process.errno === errno.EPIPE) {\\r\\n\\t\\t// do\\r\\n\\t\\t// \\terr = waitpid(pid, &status, 0); /* okay, got EPIPE */\\r\\n\\t\\t// while (err == -1 && errno == EINTR);\\r\\n\\t\\t// assert(err == pid);\\r\\n\\t}\\r\\n\\telse {\\r\\n\\t\\tthrow new Error('spawn error ' + process.errno);\\r\\n\\t}\\r\\n\\r\\n\\tuv.close(signal_pipe[0]);\\r\\n\\r\\n\\tthis.pipes = pipes;\\r\\n\\tfor (var i = 0; i < options.stdio_count; i++) {\\r\\n\\t\\terr = this.open_stream(options.stdio[i], pipes[i], i === 0);\\r\\n\\t\\tif (err === 0) continue;\\r\\n\\r\\n\\t\\twhile (i--) {\\r\\n\\t\\t\\tthis.close_stream(options.stdio[i]);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tthis.pid = pid;\\r\\n\\tthis.exit_cb = options.exit_cb;\\r\\n\\r\\n\\tif (!spawn_error){\\r\\n\\t\\tthis.child_watcher = setInterval(function(){\\r\\n\\t\\t\\tvar t = syscall.waitpid(pid, status, SYS.WNOHANG);\\r\\n\\t\\t\\tif (t === pid){\\r\\n\\t\\t\\t\\tvar s = status.int;\\r\\n\\t\\t\\t\\tvar exitcode = 0;\\r\\n\\t\\t\\t\\tvar termsignal = 0;\\r\\n\\r\\n\\t\\t\\t\\tif (syscall.WIFEXITED(s)){\\r\\n\\t\\t\\t\\t\\texitcode = syscall.WEXITSTATUS(s);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\ttermsignal = syscall.WTERMSIG(s);\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (self.exit_signal){\\r\\n\\t\\t\\t\\t\\ttermsignal = self.exit_signal;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tclearInterval(this);\\r\\n\\t\\t\\t\\tself.child_watcher = null;\\r\\n\\r\\n\\t\\t\\t\\tif (self.exit_cb) self.exit_cb.call(self, exitcode, termsignal);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}, 1);\\r\\n\\t}\\r\\n\\r\\n\\tif (spawn_error) {\\r\\n\\t\\tthis.errno = errno.translate(spawn_error);\\r\\n\\t}\\r\\n\\treturn this;\\r\\n}\\r\\n\\r\\n\\r\\nProcess.prototype.unref = function(){\\r\\n\\tif (this.child_watcher){\\r\\n\\t\\tthis.child_watcher.unref();\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.open_stream = function (container, pipefds, writable) {\\r\\n\\tvar flags = 0;\\r\\n\\r\\n\\tif (!(container.flags & uv.CREATE_PIPE) || pipefds[0] < 0) {\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\tif (uv.close(pipefds[1]) === null){\\r\\n\\t\\tthrow new Error('closing pipe fd ' + pipefds[1]);\\r\\n\\t}\\r\\n\\r\\n\\tpipefds[1] = -1;\\r\\n\\tuv.nonblock(pipefds[0], 1);\\r\\n\\r\\n\\tif (container.stream.type === 'NAMED_PIPE' && container.stream.ipc ) {\\r\\n\\t\\tflags = uv.STREAM_READABLE | uv.STREAM_WRITABLE;\\r\\n\\t}\\r\\n\\r\\n\\telse if (writable) {\\r\\n\\t\\tflags = uv.STREAM_WRITABLE;\\r\\n\\t}\\r\\n\\r\\n\\telse {\\r\\n\\t\\tflags = uv.STREAM_READABLE;\\r\\n\\t}\\r\\n\\r\\n\\treturn container.stream.stream_open(pipefds[0], flags);\\r\\n};\\r\\n\\r\\n\\r\\n// constructs a utf16 buffer of environment\\r\\n// variables block, windows require each env to be\\r\\n// seperated with 1 nul and ends with 2 nul charachters\\r\\nfunction set_env_block(env){\\r\\n\\tif (!env){\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tvar envBlock = process.env;\\r\\n\\r\\n\\t//extend\\r\\n\\tfor (var key in envBlock){\\r\\n\\t\\tenv.unshift(key + '=' + envBlock[key]);\\r\\n\\t}\\r\\n\\r\\n\\tvar len = env.length;\\r\\n\\r\\n\\tvar n = \\\"\\\";\\r\\n\\tfor (var i = 0; i < len; i++){\\r\\n\\t\\tassert(syscall.putenv(env[i]) !== null);\\r\\n\\t}\\r\\n\\treturn;\\r\\n}\\r\\n\\r\\n\\r\\nProcess.prototype.kill = function(signum){\\r\\n\\tvar process = this;\\r\\n\\tvar err;\\r\\n\\r\\n\\tif (process.process_handle == -1) {\\r\\n\\t\\treturn errno.EINVAL;\\r\\n\\t}\\r\\n\\r\\n\\terr = uv.kill(process.pid, signum);\\r\\n\\tif (err) return err;  /* err is already translated. */\\r\\n\\tprocess.exit_signal = signum;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.close = function(cb){\\r\\n\\tvar self = this;\\r\\n\\t//clear child watcher interval\\r\\n\\tif (this.child_watcher){\\r\\n\\t\\tclearInterval(this.child_watcher);\\r\\n\\t}\\r\\n};\\r\\n\\r\\nmodule.exports = Process;\\r\\n\",\"uv/tty\":\"var util     = require(\\\"util\\\");\\r\\nvar stream   = require('uv/stream');\\r\\nvar uv       = require('uv');\\r\\n\\r\\nutil.inherits(TTY, stream);\\r\\nfunction TTY (){\\r\\n\\tif (uv.isWin) require('uv/tty/windows').apply(this, arguments);\\r\\n\\telse require('uv/tty/linux').apply(this, arguments);\\r\\n}\\r\\n\\r\\nmodule.exports = TTY;\\r\\n\",\"uv/tty/windows\":\"var uv      = require('uv');\\r\\nvar syscall = require('syscall');\\r\\nvar C       = require('C');\\r\\nvar ansi    = require('uv/tty/ansi');\\r\\n\\r\\nvar kernel  = syscall.LoadLibrary('kernel32');\\r\\nvar CreateEvent = kernel.GetProcAddress('CreateEventW', null, 4);\\r\\nvar WaitForSingleObject = kernel.GetProcAddress('WaitForSingleObject', undefined, 2);\\r\\nvar SetConsoleMode    = kernel.GetProcAddress('SetConsoleMode', 0, 2);\\r\\nvar ReadConsoleInput  = kernel.GetProcAddress('ReadConsoleInputW', 0, 4);\\r\\nvar WriteConsole      = kernel.GetProcAddress('WriteConsoleW', 0, 5);\\r\\nvar ReadConsole       = kernel.GetProcAddress('ReadConsoleW', 0, 5);\\r\\n\\r\\nvar WORD   = 'uint16';\\r\\nvar DWORD  = 'uint32';\\r\\nvar WCHAR  = 2;\\r\\nvar CHAR   = 1;\\r\\nvar UINT   = 'uint32';\\r\\nvar BOOL   = 'int';\\r\\n\\r\\n\\r\\nvar COORD = C.Struct.create({\\r\\n\\tX : 'int16',\\r\\n\\tY : 'int16'\\r\\n});\\r\\n\\r\\n\\r\\nvar FOCUS_EVENT_RECORD = C.Struct.create({\\r\\n\\tbSetFocus : BOOL\\r\\n});\\r\\n\\r\\n\\r\\nvar MOUSE_EVENT_RECORD =  C.Struct.create({\\r\\n\\tdwMousePosition   : COORD,\\r\\n\\tdwButtonState     : DWORD,\\r\\n\\tdwControlKeyState : DWORD,\\r\\n\\tdwEventFlags      : DWORD\\r\\n});\\r\\n\\r\\n\\r\\nvar WINDOW_BUFFER_SIZE_RECORD =  C.Struct.create({\\r\\n\\tdwSize : COORD\\r\\n});\\r\\n\\r\\n\\r\\nvar MENU_EVENT_RECORD = C.Struct.create({\\r\\n\\tdwCommandId : UINT\\r\\n});\\r\\n\\r\\n\\r\\nvar KEY_EVENT_RECORD = C.Struct.create({\\r\\n\\tbKeyDown : BOOL,\\r\\n\\twRepeatCount : WORD,\\r\\n\\twVirtualKeyCode : WORD,\\r\\n\\twVirtualScanCode : WORD,\\r\\n\\tuChar : C.union ({\\r\\n\\t\\tUnicodeChar : WCHAR,\\r\\n\\t\\tAsciiChar : CHAR\\r\\n\\t}),\\r\\n\\tdwControlKeyState : DWORD\\r\\n});\\r\\n\\r\\n\\r\\nvar INPUT_RECORD = C.Struct.create({\\r\\n\\tEventType : WORD,\\r\\n\\t__pad : 2, // FIXME : padding on x64!!\\r\\n\\tEvent : C.union ({\\r\\n\\t\\tKeyEvent : KEY_EVENT_RECORD,\\r\\n\\t\\tMouseEvent : MOUSE_EVENT_RECORD,\\r\\n\\t\\tWindowBufferSizeEvent : WINDOW_BUFFER_SIZE_RECORD,\\r\\n\\t\\tMenuEvent  : MENU_EVENT_RECORD,\\r\\n\\t\\tFocusEvent : FOCUS_EVENT_RECORD\\r\\n\\t})\\r\\n});\\r\\n\\r\\n\\r\\nvar rDone = new C.void( C.sizeOf.uint32 );\\r\\nvar irec  = new INPUT_RECORD();\\r\\n\\r\\nvar ENHANCED_KEY  = 256;\\r\\nvar KEY_LEFT      = 37;\\r\\nvar KEY_UP        = 38;\\r\\nvar KEY_DOWN      = 40;\\r\\nvar KEY_RIGHT     = 39;\\r\\nvar KEY_HOME      = 36;\\r\\nvar KEY_END       = 35;\\r\\nvar KEY_DEL       = 46;\\r\\n\\r\\nmodule.exports = function (fd, readable){\\r\\n\\tvar self = this;\\r\\n\\tthis.fd = fd;\\r\\n\\tthis.fdHandle = syscall.GetFdHandle(fd);\\r\\n\\r\\n\\tif (readable){\\r\\n\\t\\tthis.readable = true;\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nuv.TTY.prototype.read_start = function(cb){\\r\\n\\tvar self = this;\\r\\n\\tthis._doread = true;\\r\\n\\tthis.read_cb = cb;\\r\\n\\tif (!this.readable) return;\\r\\n\\tif (this.timer) clearInterval(this.timer);\\r\\n\\tself.timer = setInterval(function(){\\r\\n\\t\\twhile (self._doread){\\r\\n\\t\\t\\tvar t = WaitForSingleObject(self.fdHandle, 0);\\r\\n\\t\\t\\tif (t === 0){\\r\\n\\t\\t\\t\\tif (self.mode !== 1){\\r\\n\\t\\t\\t\\t\\tvar b = new Buffer(16 * 1024);\\r\\n\\t\\t\\t\\t\\tvar n = ReadConsole(self.fdHandle, b, 8 * 1024, rDone, null);\\r\\n\\t\\t\\t\\t\\tself.read_cb(0, b.toString('ucs2').slice(0, rDone.uint32));\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (ReadConsoleInput (self.fdHandle, irec, 1, rDone) === null) {\\r\\n\\t\\t\\t\\t\\tself.read_cb(process.errno);\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tvar ev = irec.Event.KeyEvent;\\r\\n\\t\\t\\t\\tvar b = '';\\r\\n\\t\\t\\t\\tif (irec.EventType === 1 && ev.bKeyDown){\\r\\n\\t\\t\\t\\t\\tif (ev.dwControlKeyState & ENHANCED_KEY) {\\r\\n\\t\\t\\t\\t\\t\\tb = '\\\\u001b';\\r\\n\\t\\t\\t\\t\\t\\tswitch(ev.wVirtualKeyCode) {\\r\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_DOWN  : b += '[B';  break;\\r\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_UP    : b += '[A';  break;\\r\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_RIGHT : b += '[C';  break;\\r\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_LEFT  : b += '[D';  break;\\r\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_HOME  : b += '[H';  break;\\r\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_END   : b += '[F';  break;\\r\\n\\t\\t\\t\\t\\t\\t\\tcase KEY_DEL   : b += '[3~'; break;\\r\\n\\t\\t\\t\\t\\t\\t\\t// default : throw new Error(\\\"unknown key type \\\" + ev.wVirtualKeyCode);\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tself.read_cb(0, Buffer(b));\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tif(\\tev.uChar.UnicodeChar[0] === 0) {\\r\\n\\t\\t\\t\\t\\t\\t\\t// console.log(ev.wVirtualKeyCode);\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\tb = ev.uChar.UnicodeChar;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tself.read_cb(0, Buffer(b).toString('ucs2'));\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}, 10);\\r\\n};\\r\\n\\r\\n\\r\\nuv.TTY.prototype.read_stop = function(cb){\\r\\n\\tthis._doread = false;\\r\\n\\tif (this.timer) clearInterval(this.timer);\\r\\n\\tthis.timer = false;\\r\\n};\\r\\n\\r\\n\\r\\nuv.TTY.prototype.write = function(data){\\r\\n\\tansi.write(this.fdHandle, data);\\r\\n};\\r\\n\\r\\n\\r\\nuv.TTY.prototype.close = function(cb){\\r\\n\\tthis._doread = false;\\r\\n\\tif (this.timer) clearInterval(this.timer);\\r\\n\\tthis.timer = false;\\r\\n};\\r\\n\\r\\n\\r\\nuv.TTY.prototype.get_winsize = function(){\\r\\n\\tvar info = new ansi.CONSOLE_SCREEN_BUFFER_INFO();\\r\\n\\tif (ansi.GetConsoleScreenBufferInfo(this.fdHandle, info) === null){\\r\\n\\t\\tthrow new Error(\\\"GetConsoleScreenBufferInfo \\\" + process.errno);\\r\\n\\t}\\r\\n\\tvar cols = info.srWindow.Right - info.srWindow.Left + 1;\\r\\n\\tvar rows = info.srWindow.Bottom - info.srWindow.Top + 1;\\r\\n\\treturn {\\r\\n\\t\\twidth  : cols,\\r\\n\\t\\theight : rows\\r\\n\\t};\\r\\n};\\r\\n\\r\\n\\r\\nuv.TTY.prototype.set_mode = function(mode){\\r\\n\\tif (this.mode === mode) return;\\r\\n\\tthis.mode = mode;\\r\\n\\tvar flags = 0;\\r\\n\\tif (mode){\\r\\n\\t\\tflags = 0x0008;\\r\\n\\t} else {\\r\\n\\t\\tflags = 0x0004 | 0x0002 | 0x0001;\\r\\n\\t}\\r\\n\\tSetConsoleMode(this.fdHandle, flags);\\r\\n};\\r\\n\",\"uv/tty/ansi\":\"var C       = require('C');\\r\\nvar syscall = require('syscall');\\r\\nvar kernel  = syscall.LoadLibrary('kernel32');\\r\\n\\r\\n\\r\\n{\\t// color codes\\r\\n\\tconst FOREGROUND_BLUE       = 0x0001; // text color contains blue.\\r\\n\\tconst FOREGROUND_GREEN      = 0x0002; // text color contains green.\\r\\n\\tconst FOREGROUND_RED        = 0x0004; // text color contains red.\\r\\n\\tconst FOREGROUND_INTENSITY  = 0x0008; // text color is intensified.\\r\\n\\tconst BACKGROUND_BLUE       = 0x0010; // background color contains blue.\\r\\n\\tconst BACKGROUND_GREEN      = 0x0020; // background color contains green.\\r\\n\\tconst BACKGROUND_RED        = 0x0040; // background color contains red.\\r\\n\\tconst BACKGROUND_INTENSITY  = 0x0080; // background color is intensified.\\r\\n\\r\\n\\t// masks\\r\\n\\tconst FOREGROUND_MASK       = (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);\\r\\n\\tconst BACKGROUND_MASK       = (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY);\\r\\n\\r\\n\\t// extended colors\\r\\n\\tconst FOREGROUND_WHITE\\t    = (FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN);\\r\\n\\tconst FOREGROUND_YELLOW     = (FOREGROUND_RED | FOREGROUND_GREEN);\\r\\n\\r\\n\\tconst FOREGROUND_CYAN\\t\\t= (FOREGROUND_BLUE | FOREGROUND_GREEN);\\r\\n\\tconst FOREGROUND_MAGENTA\\t= (FOREGROUND_RED | FOREGROUND_BLUE);\\r\\n\\r\\n\\tconst BACKGROUND_WHITE     = (BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_GREEN);\\r\\n\\tconst BACKGROUND_YELLOW\\t   = (BACKGROUND_RED | BACKGROUND_GREEN);\\r\\n\\tconst BACKGROUND_CYAN      = (BACKGROUND_BLUE | BACKGROUND_GREEN);\\r\\n\\tconst BACKGROUND_MAGENTA   = (BACKGROUND_RED | BACKGROUND_BLUE);\\r\\n\\r\\n\\tconst FOREGROUND_BLACK     = 0;\\r\\n\\tconst BACKGROUND_BLACK     = 0;\\r\\n}\\r\\n\\r\\n\\r\\nvar WORD = 'uint16';\\r\\n\\r\\nvar COORD = C.Struct.create({\\r\\n\\tX : 'int16',\\r\\n\\tY : 'int16'\\r\\n});\\r\\n\\r\\nvar SMALL_RECT = C.Struct.create({\\r\\n\\tLeft   : 'int16',\\r\\n\\tTop    : 'int16',\\r\\n\\tRight  : 'int16',\\r\\n\\tBottom : 'int16'\\r\\n});\\r\\n\\r\\nvar CONSOLE_SCREEN_BUFFER_INFO = C.Struct.create({\\r\\n\\tdwSize              : COORD,\\r\\n\\tdwCursorPosition    : COORD,\\r\\n\\twAttributes         : WORD,\\r\\n\\tsrWindow            : SMALL_RECT,\\r\\n\\tdwMaximumWindowSize : COORD\\r\\n});\\r\\n\\r\\n\\r\\nvar CHAR_INFO = C.Struct.create({\\r\\n\\tUnicodeChar : 2, //size of WCHAR!!\\r\\n\\tAttributes  : WORD\\r\\n});\\r\\n\\r\\n\\r\\nvar info = new CONSOLE_SCREEN_BUFFER_INFO();\\r\\n\\r\\nvar FillConsoleOutputAttribute = kernel.GetProcAddress('FillConsoleOutputAttribute', 0, 5);\\r\\nvar GetConsoleScreenBufferInfo = kernel.GetProcAddress('GetConsoleScreenBufferInfo', 0, 2);\\r\\nvar FillConsoleOutputCharacter = kernel.GetProcAddress('FillConsoleOutputCharacterW', 0, 5);\\r\\nvar ScrollConsoleScreenBuffer  = kernel.GetProcAddress('ScrollConsoleScreenBufferW', 0, 5);\\r\\nvar SetConsoleTextAttribute    = kernel.GetProcAddress('SetConsoleTextAttribute', 0, 2);\\r\\nvar SetConsoleCursorPosition   = kernel.GetProcAddress('SetConsoleCursorPosition', 0, 2);\\r\\nvar GetConsoleCursorInfo       = kernel.GetProcAddress('GetConsoleCursorInfo', 0, 2);\\r\\nvar SetConsoleCursorInfo       = kernel.GetProcAddress('SetConsoleCursorInfo', 0, 2);\\r\\n\\r\\nvar WriteConsole               = kernel.GetProcAddress('WriteConsoleW', 0, 5);\\r\\n\\r\\n\\r\\nGetConsoleScreenBufferInfo(syscall.Stdout, info);\\r\\nvar oldattr = info.wAttributes;\\r\\n\\r\\nfunction _splitArgs (str){\\r\\n\\treturn str.split(';');\\r\\n}\\r\\n\\r\\nvar numberOfWritten = new C.void( C.sizeOf.uint32 );\\r\\nvar translateAnsiActions = {};\\r\\nvar empty     = new Buffer(\\\" \\\\0\\\", 'ucs2');\\r\\nvar CHAR_BUFF = new Buffer(' ', 'ucs2');\\r\\n\\r\\n// ESC[#J\\r\\ntranslateAnsiActions.J   = function(args, cHandle, info, pos){\\r\\n\\tvar len = 0;\\r\\n\\t// ESC[0J Erase from the cursor to the end of the screen.\\r\\n\\tif (args[0] == 0){\\r\\n\\t\\tpos.X = info.dwCursorPosition.X;\\r\\n\\t\\tpos.Y = info.dwCursorPosition.Y;\\r\\n\\r\\n\\t\\tlen = (info.dwSize.Y - info.dwCursorPosition.Y - 1) * info.dwSize.X\\r\\n\\t\\t\\t+ info.dwSize.X - info.dwCursorPosition.X - 1;\\r\\n\\r\\n\\t\\tFillConsoleOutputCharacter( cHandle, C.address(empty), len, C.address(pos), numberOfWritten );\\r\\n\\t\\tFillConsoleOutputAttribute( cHandle, info.wAttributes, len, C.address(pos), numberOfWritten );\\r\\n\\t}\\r\\n\\t// ESC[1J erase from start to cursor.\\r\\n\\telse if (args[0] == 1){\\r\\n\\t\\tpos.X = 0;\\r\\n\\t\\tpos.Y = 0;\\r\\n\\t\\tlen   = info.dwCursorPosition.Y * info.dwSize.X\\r\\n\\t\\t\\t+ info.dwCursorPosition.X + 1;\\r\\n\\r\\n\\t\\tFillConsoleOutputCharacter( cHandle, C.address(empty), len, C.address(pos), numberOfWritten );\\r\\n\\t\\tFillConsoleOutputAttribute( cHandle, info.wAttributes, len, C.address(pos), numberOfWritten );\\r\\n\\t}\\r\\n\\t// ESC[2J \\tclear screen and home cursor\\r\\n\\telse if (args[0] == 2){\\r\\n\\t\\tpos.X = 0;\\r\\n\\t\\tpos.Y = 0;\\r\\n\\t\\tlen   = info.dwSize.X * info.dwSize.Y;\\r\\n\\r\\n\\t\\tFillConsoleOutputCharacter( cHandle, C.address(empty), len, C.address(pos), numberOfWritten );\\r\\n\\t\\tFillConsoleOutputAttribute( cHandle, info.wAttributes, len, C.address(pos), numberOfWritten );\\r\\n\\t\\tSetConsoleCursorPosition( cHandle,  C.address(pos));\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\n// ESC[#X Erase # characters.\\r\\ntranslateAnsiActions.X = function(args, cHandle, info, pos){\\r\\n\\tvar val = (args[0] | 0) || 1;\\r\\n\\tFillConsoleOutputCharacter( cHandle, C.address(empty), val,\\r\\n\\t\\tC.address(info.dwCursorPosition),\\r\\n\\t\\tnumberOfWritten );\\r\\n\\r\\n\\tFillConsoleOutputAttribute( cHandle, info.wAttributes, val,\\r\\n\\t\\tC.address(info.dwCursorPosition),\\r\\n\\t\\tnumberOfWritten );\\r\\n};\\r\\n\\r\\n\\r\\n// ESC[#L Insert # blank lines.\\r\\ntranslateAnsiActions.L = function(args, cHandle, info, pos){\\r\\n\\tvar val = (args[0] | 0) || 1;\\r\\n\\tvar Rect = new SMALL_RECT();\\r\\n\\tvar CharInfo = new CHAR_INFO();\\r\\n\\r\\n\\tRect.Left   = 0;\\r\\n\\tRect.Top    = info.dwCursorPosition.Y;\\r\\n\\tRect.Right  = info.dwSize.X - 1;\\r\\n\\tRect.Bottom = info.dwSize.Y - 1;\\r\\n\\r\\n\\tpos.X = 0;\\r\\n\\tpos.Y = info.dwCursorPosition.Y + val;\\r\\n\\r\\n\\tCharInfo.UnicodeChar = CHAR_BUFF;\\r\\n\\tCharInfo.Attributes  = info.wAttributes;\\r\\n\\tScrollConsoleScreenBuffer( cHandle, Rect, null, C.address(pos), CharInfo );\\r\\n};\\r\\n\\r\\n// ESC[#M Delete # lines.\\r\\ntranslateAnsiActions.M = function(args, cHandle, info, pos){\\r\\n\\tvar val = (args[0] | 0) || 1;\\r\\n\\tvar Rect = new SMALL_RECT();\\r\\n\\tvar CharInfo = new CHAR_INFO();\\r\\n\\r\\n\\tif (val > info.dwSize.Y - info.dwCursorPosition.Y) {\\r\\n\\t\\tval = info.dwSize.Y - info.dwCursorPosition.Y;\\r\\n\\t}\\r\\n\\r\\n\\tRect.Left   = 0;\\r\\n\\tRect.Top    = info.dwCursorPosition.Y + val;\\r\\n\\tRect.Right  = info.dwSize.X - 1;\\r\\n\\tRect.Bottom = info.dwSize.Y - 1;\\r\\n\\r\\n\\tpos.X = 0;\\r\\n\\tpos.Y = info.dwCursorPosition.Y;\\r\\n\\r\\n\\tCharInfo.UnicodeChar = CHAR_BUFF;\\r\\n\\tCharInfo.Attributes  = info.wAttributes;\\r\\n\\tScrollConsoleScreenBuffer( cHandle, Rect, null, C.address(pos), CharInfo );\\r\\n};\\r\\n\\r\\n\\r\\n// ESC[#P Delete # characters.\\r\\ntranslateAnsiActions.P = function(args, cHandle, info, pos){\\r\\n\\tvar val = (args[0] | 0) || 1;\\r\\n\\tvar Rect = new SMALL_RECT();\\r\\n\\tvar CharInfo = new CHAR_INFO();\\r\\n\\r\\n\\tif (info.dwCursorPosition.X + val > info.dwSize.X - 1) {\\r\\n\\t\\tval = info.dwSize.X - info.dwCursorPosition.X;\\r\\n\\t}\\r\\n\\r\\n\\tRect.Left   = info.dwCursorPosition.X + val;\\r\\n\\tRect.Top    = info.dwCursorPosition.Y;\\r\\n\\tRect.Right  = info.dwSize.X - 1;\\r\\n\\tRect.Bottom = info.dwCursorPosition.Y;\\r\\n\\r\\n\\tCharInfo.UnicodeChar = CHAR_BUFF;\\r\\n\\tCharInfo.Attributes  = info.wAttributes;\\r\\n\\tScrollConsoleScreenBuffer( cHandle, Rect, null, info.dwCursorPosition, CharInfo );\\r\\n};\\r\\n\\r\\n\\r\\n // ESC[#@ Insert # blank characters.\\r\\ntranslateAnsiActions['@'] = function(args, cHandle, info, pos){\\r\\n\\tvar val = (args[0] | 0) || 1;\\r\\n\\tvar Rect = new SMALL_RECT();\\r\\n\\tvar CharInfo = new CHAR_INFO();\\r\\n\\r\\n\\tif (info.dwCursorPosition.X + val > info.dwSize.X - 1) {\\r\\n\\t\\tval = info.dwSize.X - info.dwCursorPosition.X;\\r\\n\\t}\\r\\n\\r\\n\\tRect.Left   = info.dwCursorPosition.X;\\r\\n\\tRect.Top    = info.dwCursorPosition.Y;\\r\\n\\tRect.Right  = info.dwSize.X - 1 - val;\\r\\n\\tRect.Bottom = info.dwCursorPosition.Y;\\r\\n\\r\\n\\tpos.X = info.dwCursorPosition.X + val;\\r\\n\\tpos.Y = info.dwCursorPosition.Y;\\r\\n\\r\\n\\tCharInfo.UnicodeChar = CHAR_BUFF;\\r\\n\\tCharInfo.Attributes = info.wAttributes;\\r\\n\\tScrollConsoleScreenBuffer( cHandle, Rect, null, C.address(pos), CharInfo );\\r\\n};\\r\\n\\r\\n\\r\\n// ESC[#A\\r\\n// ESC[#k  - Moves cursor up # lines\\r\\ntranslateAnsiActions.A =\\r\\ntranslateAnsiActions.k = function(args, cHandle, info, pos){\\r\\n\\tvar val = (args[0] | 0) || 1;\\r\\n\\tpos.Y = info.dwCursorPosition.Y - val;\\r\\n\\tif (pos.Y < 0) pos.Y = 0;\\r\\n\\tpos.X = info.dwCursorPosition.X;\\r\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\r\\n};\\r\\n\\r\\n\\r\\n// ESC[#B\\r\\n// ESC[#e Moves cursor down # lines\\r\\ntranslateAnsiActions.B =\\r\\ntranslateAnsiActions.e = function(args, cHandle, info, pos){\\r\\n\\tvar val = (args[0] | 0) || 1;\\r\\n\\tpos.Y = info.dwCursorPosition.Y + val;\\r\\n\\tif (pos.Y >= info.dwSize.Y) pos.Y = info.dwSize.Y - 1;\\r\\n\\tpos.X = info.dwCursorPosition.X;\\r\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\r\\n};\\r\\n\\r\\n\\r\\n\\r\\n// ESC[#C\\r\\n// ESC[#a Moves cursor forward # spaces\\r\\ntranslateAnsiActions.C =\\r\\ntranslateAnsiActions.a = function(args, cHandle, info, pos){\\r\\n\\tvar val = (args[0] | 0) || 1;\\r\\n\\tpos.X = info.dwCursorPosition.X + val;\\r\\n\\tif (pos.X >= info.dwSize.X) pos.X = info.dwSize.X - 1;\\r\\n\\tpos.Y = info.dwCursorPosition.Y;\\r\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\r\\n};\\r\\n\\r\\n\\r\\n// ESC[#j\\r\\n// ESC[#D Moves cursor back # spaces\\r\\ntranslateAnsiActions.D =\\r\\ntranslateAnsiActions.j = function(args, cHandle, info, pos){\\r\\n\\tvar val = (args[0] | 0) || 1;\\r\\n\\tpos.X = info.dwCursorPosition.X - val;\\r\\n\\tif (pos.X < 0) pos.X = 0;\\r\\n\\tpos.Y = info.dwCursorPosition.Y;\\r\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\r\\n};\\r\\n\\r\\n\\r\\n\\r\\n// ESC[#E Moves cursor down # lines, column 1.\\r\\ntranslateAnsiActions.E = function(args, cHandle, info, pos){\\r\\n\\tvar val = (args[0] | 0) || 1;\\r\\n\\tpos.Y = info.dwCursorPosition.Y + val;\\r\\n\\tif (pos.Y >= info.dwSize.Y) pos.Y = info.dwSize.Y - 1;\\r\\n\\tpos.X = 0;\\r\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\r\\n};\\r\\n\\r\\n\\r\\n// ESC[#F Moves cursor up # lines, column 1.\\r\\ntranslateAnsiActions.F = function(args, cHandle, info, pos){\\r\\n\\tvar val = (args[0] | 0) || 1;\\r\\n\\tpos.Y = info.dwCursorPosition.Y - val;\\r\\n\\tif (pos.Y < 0) pos.Y = 0;\\r\\n\\tpos.X = 0;\\r\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\r\\n};\\r\\n\\r\\n\\r\\n// ESC[#`\\r\\n// ESC[#G Moves cursor column # in current row.\\r\\ntranslateAnsiActions.G    =\\r\\ntranslateAnsiActions['`'] = function(args, cHandle, info, pos){\\r\\n\\tvar val = (args[0] | 0) || 1;\\r\\n\\tpos.X = val - 1;\\r\\n\\tif (pos.X >= info.dwSize.X) pos.X = info.dwSize.X - 1;\\r\\n\\tif (pos.X < 0) pos.X = 0;\\r\\n\\tpos.Y = info.dwCursorPosition.Y;\\r\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\r\\n};\\r\\n\\r\\n\\r\\n// ESC[#d Moves cursor row #, current column.\\r\\ntranslateAnsiActions.d = function(args, cHandle, info, pos){\\r\\n\\tvar val  = (args[0] | 0) || 1;\\r\\n\\tpos.Y = val - 1;\\r\\n\\tif (pos.Y < 0) pos.Y = 0;\\r\\n\\tif (pos.Y >= info.dwSize.Y) pos.Y = info.dwSize.Y - 1;\\r\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\r\\n};\\r\\n\\r\\n\\r\\n// ESC[#;#f\\r\\n// ESC[#;#H Moves cursor to line #, column #\\r\\ntranslateAnsiActions.f =\\r\\ntranslateAnsiActions.H = function(args, cHandle, info, pos){\\r\\n\\tvar val  = (args[0] | 0) || 1;\\r\\n\\tvar val2 = (args[1] | 0) || 1;\\r\\n\\r\\n\\tif (args.length > 2) return;\\r\\n\\tpos.X = val2 - 1;\\r\\n\\tif (pos.X < 0) pos.X = 0;\\r\\n\\tif (pos.X >= info.dwSize.X) pos.X = info.dwSize.X - 1;\\r\\n\\tpos.Y = val - 1;\\r\\n\\tif (pos.Y < 0) pos.Y = 0;\\r\\n\\tif (pos.Y >= info.dwSize.Y) pos.Y = info.dwSize.Y - 1;\\r\\n\\tSetConsoleCursorPosition( cHandle, C.address(pos) );\\r\\n};\\r\\n\\r\\n\\r\\n// ESC[s Saves cursor position for recall later\\r\\nvar SavePos = new COORD();\\r\\ntranslateAnsiActions.s = function(args, cHandle, info, pos){\\r\\n\\tSavePos.X = info.dwCursorPosition.X;\\r\\n\\tSavePos.Y = info.dwCursorPosition.Y;\\r\\n};\\r\\n\\r\\n\\r\\n// ESC[u Return to saved cursor position\\r\\ntranslateAnsiActions.u = function(args, cHandle, info, pos){\\r\\n\\tSetConsoleCursorPosition( cHandle, C.address(SavePos) );\\r\\n};\\r\\n\\r\\n\\r\\ntranslateAnsiActions.m   = function(args, cHandle, info, pos){\\r\\n\\tfor (var i = 0; i < args.length; i++){\\r\\n\\t\\tvar val = args[i] | 0;\\r\\n\\t\\tvar attr = info.wAttributes;\\r\\n\\t\\tif (val === 0){\\r\\n\\t\\t\\tSetConsoleTextAttribute(cHandle, oldattr);\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\t// forground color\\r\\n\\t\\tif (val >= 30 && val <= 37){\\r\\n\\t\\t\\tattr = (attr & BACKGROUND_MASK);\\r\\n\\t\\t\\tif ( ((val - 30) & 1) !== 0 ){\\r\\n\\t\\t\\t\\tattr |= FOREGROUND_RED;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif ( ((val - 30) & 2) !== 0 ){\\r\\n\\t\\t\\t\\tattr |= FOREGROUND_GREEN;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif ( ((val - 30) & 4) !== 0 ) {\\r\\n\\t\\t\\t\\tattr |= FOREGROUND_BLUE;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t// reset forground color\\r\\n\\t\\telse if (val === 39){\\r\\n\\t\\t\\tattr &= BACKGROUND_MASK;\\r\\n\\t\\t\\tattr |= oldattr & FOREGROUND_MASK;\\r\\n\\t\\t}\\r\\n\\t\\t// background color\\r\\n\\t\\telse if (val >= 40 && val <= 47){\\r\\n\\t\\t\\tattr = (attr & FOREGROUND_MASK)\\r\\n\\t\\t\\tif ( ((val - 40) & 1) !== 0 ) {\\r\\n\\t\\t\\t\\tattr |= BACKGROUND_GREEN;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif ( ((val - 40) & 2 ) !== 0 ) {\\r\\n\\t\\t\\t\\tattr |= BACKGROUND_GREEN;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif ( ((val - 40) & 4 ) !== 0 ) {\\r\\n\\t\\t\\t\\tattr |= BACKGROUND_BLUE;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t// reset background\\r\\n\\t\\telse if (val === 49){\\r\\n\\t\\t\\tattr &= FOREGROUND_MASK;\\r\\n\\t\\t\\tattr |= w.oldattr & BACKGROUND_MASK;\\r\\n\\t\\t}\\r\\n\\t\\tSetConsoleTextAttribute(cHandle, attr);\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nfunction _write_string (cHandle, str){\\r\\n\\tvar utf16Buffer = new Buffer(str + '\\\\0', 'ucs2');\\r\\n\\tvar ret = WriteConsole(cHandle, utf16Buffer, str.length, numberOfWritten, null);\\r\\n\\tif (ret === null){\\r\\n\\t\\tthrow new Error(process.errno);\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nvar coord = new COORD();\\r\\nvar ansiParserRegex = /([\\\\s\\\\S]*?)\\\\x1b\\\\[([\\\\s\\\\S]*?)([\\\\?|\\\\`|\\\\@|a-zA-Z])/g;\\r\\nfunction write (stdHandle, str){\\r\\n\\tvar match;\\r\\n\\tvar matched = 0;\\r\\n\\twhile (match = ansiParserRegex.exec(str)) {\\r\\n\\t\\tmatched += match[0].length;\\r\\n\\t\\tvar stringToWrite = match[1];\\r\\n\\t\\tvar suffix        = match[3];\\r\\n\\t\\tif (stringToWrite) {\\r\\n\\t\\t\\t_write_string(stdHandle, stringToWrite);\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tif (translateAnsiActions[suffix]){\\r\\n\\t\\t\\t// get current screen buffer info and pass it\\r\\n\\t\\t\\t// to translateansi action we need to use it\\r\\n\\t\\t\\tif (GetConsoleScreenBufferInfo(stdHandle, info) === null){\\r\\n\\t\\t\\t\\tthrow new Error(\\\"can't get console buffer info\\\");\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar args = _splitArgs(match[2]);\\r\\n\\t\\t\\ttranslateAnsiActions[suffix]( args,\\r\\n\\t\\t\\t\\tstdHandle /* console handle */,\\r\\n\\t\\t\\t\\tinfo, /* console buffer info */\\r\\n\\t\\t\\t\\tcoord /* coord struct for position */);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// nothing matched at all, the whole string\\r\\n\\t// doesn't contain ansi escape sequence\\r\\n\\tif (!matched){\\r\\n\\t\\t_write_string(stdHandle, str);\\r\\n\\t} else {\\r\\n\\t\\t// matched but normal string left without\\r\\n\\t\\t// writing at the end\\r\\n\\t\\tif (str.length > matched){\\r\\n\\t\\t\\t_write_string(stdHandle, str.slice(matched, str.length));\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nexports.write = write;\\r\\n\\r\\n// TODO move all structs and win API functions to syscall\\r\\nexports.GetConsoleScreenBufferInfo = GetConsoleScreenBufferInfo;\\r\\nexports.CONSOLE_SCREEN_BUFFER_INFO = CONSOLE_SCREEN_BUFFER_INFO;\\r\\n\",\"uv/tty/linux\":\"var uv       = require('uv');\\r\\nvar posix    = process.binding('posix');\\r\\nvar stream   = require('uv/stream');\\r\\nvar syscall  = require('syscall');\\r\\nvar C        = require('C');\\r\\nvar sock     = require('socket');\\r\\n\\r\\nvar libc       = syscall.LoadLibrary(null);\\r\\nvar tcsetattr  = libc.GetProcAddress('tcsetattr', -1, 3);\\r\\nvar tcgetattr  = libc.GetProcAddress('tcgetattr', -1, 2);\\r\\nvar cfmakeraw  = libc.GetProcAddress('cfmakeraw', -1, 1);\\r\\n\\r\\nconst IGNBRK  = 0000001;\\r\\nconst BRKINT  = 0000002;\\r\\nconst IGNPAR  = 0000004;\\r\\nconst PARMRK  = 0000010;\\r\\nconst INPCK   = 0000020;\\r\\nconst ISTRIP  = 0000040;\\r\\nconst INLCR   = 0000100;\\r\\nconst IGNCR   = 0000200;\\r\\nconst ICRNL   = 0000400;\\r\\nconst IUCLC   = 0001000;\\r\\nconst IXON    = 0002000;\\r\\nconst IXANY   = 0004000;\\r\\nconst IXOFF   = 0010000;\\r\\nconst IMAXBEL = 0020000;\\r\\nconst IUTF8   = 0040000;\\r\\n\\r\\nconst TCSANOW   = 0;\\r\\nconst TCSADRAIN = 1;\\r\\nconst TCSAFLUSH = 2;\\r\\n\\r\\nvar orig_termios_fd = -1;\\r\\nvar orig_termios;\\r\\n\\r\\nvar termios = C.Struct.create({\\r\\n\\tc_iflag    : 'uint',\\r\\n\\tc_oflag    : 'uint',\\r\\n\\tc_cflag    : 'uint',\\r\\n\\tc_lflag    : 'uint',\\r\\n\\tc_line     : 'uint8',\\r\\n\\tc_cc       : 32,\\r\\n\\t__c_ispeed : 'uint',\\r\\n\\t__c_ospeed : 'uint'\\r\\n});\\r\\n\\r\\n\\r\\nmodule.exports = function (fd, readable){\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tvar newfd = uv.open(\\\"/dev/tty\\\", uv.O_RDWR);\\r\\n\\tvar r = posix.dup2(newfd, fd);\\r\\n\\tif (r === null && process.errno !== errno.EINVAL){\\r\\n\\t\\tuv.close(newfd);\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\tthis.fd = r;\\r\\n\\tuv.nonblock(this.fd, 1);\\r\\n\\tuv.cloexec(this.fd, 1);\\r\\n\\tif (readable){\\r\\n\\t\\tthis.readable = true;\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nuv.TTY.prototype.read_start = function(cb){\\r\\n\\tvar self = this;\\r\\n\\tthis._doread = true;\\r\\n\\tthis.read_cb = cb;\\r\\n\\tif (!this.readable) return;\\r\\n\\tif (this.timer) clearInterval(this.timer);\\r\\n\\r\\n\\tvar b = Buffer(10);\\r\\n\\tself.timer = setInterval(function(){\\r\\n\\t\\twhile (self._doread){\\r\\n\\t\\t\\tvar n = sock.can_read(self.fd, 1);\\r\\n\\t\\t\\tif (n){\\r\\n\\t\\t\\t\\tvar n = posix.read(self.fd, b);\\r\\n\\t\\t\\t\\tself.read_cb(0, b.toString().slice(0, n));\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}, 1);\\r\\n};\\r\\n\\r\\n\\r\\nuv.TTY.prototype.read_stop = function(cb){\\r\\n\\tthis._doread = false;\\r\\n\\tif (this.timer) clearInterval(this.timer);\\r\\n\\tthis.timer = false;\\r\\n};\\r\\n\\r\\n\\r\\nuv.TTY.prototype.write = function(data){\\r\\n\\tposix.writeBuffer(this.fd, Buffer(data));\\r\\n};\\r\\n\\r\\n\\r\\nuv.TTY.prototype.stop = function(){\\r\\n\\tthrow new Error('win tty stop');\\r\\n};\\r\\n\\r\\nuv.TTY.prototype.close = function(cb){\\r\\n\\tthis._doread = false;\\r\\n\\tif (this.timer) clearInterval(this.timer);\\r\\n\\tthis.timer = false;\\r\\n};\\r\\n\\r\\nuv.TTY.prototype.get_winsize = function(){\\r\\n\\tvar fd = this.fd;\\r\\n\\tvar ws = new syscall.WinSize();\\r\\n\\tif (syscall.ioctl(fd, syscall.SYS.TIOCGWINSZ, ws) === null){\\r\\n\\t\\treturn null;\\r\\n\\t}\\r\\n\\treturn {\\r\\n\\t\\twidth  :  ws.ws_col,\\r\\n\\t\\theight :  ws.ws_row\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nuv.TTY.prototype.set_mode = function(mode){\\r\\n\\tif (this.mode === mode) return;\\r\\n\\tthis.mode = mode;\\r\\n\\r\\n\\tif (!this.orig_termios){\\r\\n\\t\\tthis.orig_termios = new termios();\\r\\n\\t\\tif (tcgetattr(this.fd, this.orig_termios) === null){\\r\\n\\t\\t\\tthrow new Error(process.errno);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!orig_termios){\\r\\n\\t\\t\\torig_termios_fd = this.fd;\\r\\n\\t\\t\\torig_termios = new termios(this.orig_termios);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tvar temp = new termios(this.orig_termios);\\r\\n\\r\\n\\tif (mode){\\r\\n\\t\\ttemp.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\\r\\n\\t\\ttemp.c_oflag |= (0000004);\\r\\n\\t\\ttemp.c_cflag |= (0000060);\\r\\n\\t\\ttemp.c_lflag &= ~(0000010 | 0000002 | 0100000 | 0000001);\\r\\n\\t\\ttemp.c_cc[6] = 1;\\r\\n\\t\\ttemp.c_cc[5] = 0;\\r\\n\\t}\\r\\n\\r\\n\\tif (tcsetattr(this.fd, TCSADRAIN, temp) === null) {\\r\\n\\t\\tthrow new Error('cant set raw');\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nprocess.on('exit', function(){\\r\\n\\tif (orig_termios_fd !== -1){\\r\\n\\t\\ttcsetattr(orig_termios_fd, TCSANOW, orig_termios);\\r\\n\\t}\\r\\n});\\r\\n\",\"internal/util\":\"'use strict';\\r\\n\\r\\nvar prefix = '(node) ';\\r\\n\\r\\n// All the internal deprecations have to use this function only, as this will\\r\\n// prepend the prefix to the actual message.\\r\\nexports.deprecate = function(fn, msg) {\\r\\n  return exports._deprecate(fn, prefix + msg);\\r\\n};\\r\\n\\r\\n// All the internal deprecations have to use this function only, as this will\\r\\n// prepend the prefix to the actual message.\\r\\nexports.printDeprecationMessage = function(msg, warned) {\\r\\n  return exports._printDeprecationMessage(prefix + msg, warned);\\r\\n};\\r\\n\\r\\nexports._printDeprecationMessage = function(msg, warned) {\\r\\n  if (process.noDeprecation)\\r\\n    return true;\\r\\n\\r\\n  if (warned)\\r\\n    return warned;\\r\\n\\r\\n  if (process.throwDeprecation)\\r\\n    throw new Error(msg);\\r\\n  else if (process.traceDeprecation)\\r\\n    console.trace(msg.startsWith(prefix) ? msg.replace(prefix, '') : msg);\\r\\n  else\\r\\n    console.error(msg);\\r\\n\\r\\n  return true;\\r\\n};\\r\\n\\r\\n// Mark that a method should not be used.\\r\\n// Returns a modified function which warns once by default.\\r\\n// If --no-deprecation is set, then it is a no-op.\\r\\nexports._deprecate = function(fn, msg) {\\r\\n  // Allow for deprecating things in the process of starting up.\\r\\n  if (global.process === undefined) {\\r\\n    return function() {\\r\\n      return exports._deprecate(fn, msg).apply(this, arguments);\\r\\n    };\\r\\n  }\\r\\n\\r\\n  if (process.noDeprecation === true) {\\r\\n    return fn;\\r\\n  }\\r\\n\\r\\n  var warned = false;\\r\\n  function deprecated() {\\r\\n    warned = exports._printDeprecationMessage(msg, warned);\\r\\n    return fn.apply(this, arguments);\\r\\n  }\\r\\n\\r\\n  return deprecated;\\r\\n};\\r\\n\",\"internal/linkedlist\":\"'use strict';\\r\\n\\r\\nfunction init(list) {\\r\\n  list._idleNext = list;\\r\\n  list._idlePrev = list;\\r\\n}\\r\\nexports.init = init;\\r\\n\\r\\n\\r\\n// show the most idle item\\r\\nfunction peek(list) {\\r\\n  if (list._idlePrev == list) return null;\\r\\n  return list._idlePrev;\\r\\n}\\r\\nexports.peek = peek;\\r\\n\\r\\n\\r\\n// remove the most idle item from the list\\r\\nfunction shift(list) {\\r\\n  var first = list._idlePrev;\\r\\n  remove(first);\\r\\n  return first;\\r\\n}\\r\\nexports.shift = shift;\\r\\n\\r\\n\\r\\n// remove a item from its list\\r\\nfunction remove(item) {\\r\\n  if (item._idleNext) {\\r\\n    item._idleNext._idlePrev = item._idlePrev;\\r\\n  }\\r\\n\\r\\n  if (item._idlePrev) {\\r\\n    item._idlePrev._idleNext = item._idleNext;\\r\\n  }\\r\\n\\r\\n  item._idleNext = null;\\r\\n  item._idlePrev = null;\\r\\n}\\r\\nexports.remove = remove;\\r\\n\\r\\n\\r\\n// remove a item from its list and place at the end.\\r\\nfunction append(list, item) {\\r\\n  remove(item);\\r\\n  item._idleNext = list._idleNext;\\r\\n  list._idleNext._idlePrev = item;\\r\\n  item._idlePrev = list;\\r\\n  list._idleNext = item;\\r\\n}\\r\\nexports.append = append;\\r\\n\\r\\n\\r\\nfunction isEmpty(list) {\\r\\n  return list._idleNext === list;\\r\\n}\\r\\nexports.isEmpty = isEmpty;\\r\\n\",\"buffer\":\"/* eslint-disable require-buffer */\\r\\n'use strict';\\r\\nexports.Buffer = Buffer;\\r\\nvar binding = process.binding('buffer_wrap');\\r\\n\\r\\nvar internalUtil = require('internal/util');\\r\\nvar bindingObj = {};\\r\\n\\r\\nexports.Buffer = Buffer;\\r\\nexports.SlowBuffer = SlowBuffer;\\r\\nexports.INSPECT_MAX_BYTES = 50;\\r\\nexports.kMaxLength = binding.kMaxLength;\\r\\n\\r\\nBuffer.poolSize = 8 * 1024;\\r\\nvar poolSize, poolOffset, allocPool;\\r\\n\\r\\nbinding.setupBufferJS(Buffer.prototype, bindingObj);\\r\\nvar flags = bindingObj.flags;\\r\\nvar kNoZeroFill = 0;\\r\\n\\r\\n\\r\\nfunction createPool() {\\r\\n\\tpoolSize = Buffer.poolSize;\\r\\n\\tif (poolSize > 0)\\r\\n\\t\\tflags[kNoZeroFill] = 1;\\r\\n\\tallocPool = new Uint8Array(poolSize);\\r\\n\\tObject.setPrototypeOf(allocPool, Buffer.prototype);\\r\\n\\tpoolOffset = 0;\\r\\n}\\r\\ncreatePool();\\r\\n\\r\\nfunction alignPool() {\\r\\n\\t// Ensure aligned slices\\r\\n\\tif (poolOffset & 0x7) {\\r\\n\\t\\tpoolOffset |= 0x7;\\r\\n\\t\\tpoolOffset++;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfunction Buffer(arg, encoding) {\\r\\n\\t// Common case.\\r\\n\\tif (typeof arg === 'number') {\\r\\n\\t\\t// If less than zero, or NaN.\\r\\n\\t\\tif (arg < 0 || arg !== arg)\\r\\n\\t\\t\\targ = 0;\\r\\n\\r\\n\\t\\tvar t = new Uint8Array(arg);\\r\\n\\t\\tObject.setPrototypeOf(t, Buffer.prototype);\\r\\n\\t\\treturn t;\\r\\n\\t}\\r\\n\\r\\n\\t// Slightly less common case.\\r\\n\\tif (typeof arg === 'string') {\\r\\n\\t\\treturn binding.createFromString(arg, encoding);\\r\\n\\t}\\r\\n\\r\\n\\t// Unusual.\\r\\n\\treturn fromObject(arg);\\r\\n}\\r\\n\\r\\n// function Buffer(arg, encoding) {\\r\\n//   // Common case.\\r\\n//   if (typeof arg === 'number') {\\r\\n//     // If less than zero, or NaN.\\r\\n//     if (arg < 0 || arg !== arg)\\r\\n//       arg = 0;\\r\\n//     return allocate(arg);\\r\\n//   }\\r\\n\\r\\n//   // Slightly less common case.\\r\\n//   if (typeof arg === 'string') {\\r\\n//     return fromString(arg, encoding);\\r\\n//   }\\r\\n\\r\\n//   // Unusual.\\r\\n//   return fromObject(arg);\\r\\n// }\\r\\n\\r\\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\\r\\nObject.setPrototypeOf(Buffer, Uint8Array);\\r\\n\\r\\n\\r\\nfunction SlowBuffer(length) {\\r\\n\\tif (+length != length)\\r\\n\\t\\tlength = 0;\\r\\n\\tif (length > 0)\\r\\n\\t\\tflags[kNoZeroFill] = 1;\\r\\n\\tvar ui8 = new Uint8Array(+length);\\r\\n\\tObject.setPrototypeOf(ui8, Buffer.prototype);\\r\\n\\treturn ui8;\\r\\n}\\r\\n\\r\\nObject.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);\\r\\nObject.setPrototypeOf(SlowBuffer, Uint8Array);\\r\\n\\r\\n\\r\\nfunction allocate(size) {\\r\\n\\tif (size === 0) {\\r\\n\\t\\tvar ui8 = new Uint8Array(size);\\r\\n\\t\\tObject.setPrototypeOf(ui8, Buffer.prototype);\\r\\n\\t\\treturn ui8;\\r\\n\\t}\\r\\n\\tif (size < (Buffer.poolSize >>> 1)) {\\r\\n\\t\\tif (size > (poolSize - poolOffset))\\r\\n\\t\\t\\tcreatePool();\\r\\n\\t\\tvar b = allocPool.slice(poolOffset, poolOffset + size);\\r\\n\\t\\tpoolOffset += size;\\r\\n\\t\\talignPool();\\r\\n\\t\\treturn b;\\r\\n\\t} else {\\r\\n\\t\\t// Even though this is checked above, the conditional is a safety net and\\r\\n\\t\\t// sanity check to prevent any subsequent typed array allocation from not\\r\\n\\t\\t// being zero filled.\\r\\n\\t\\tif (size > 0)\\r\\n\\t\\t\\tflags[kNoZeroFill] = 1;\\r\\n\\t\\tvar ui8 = new Uint8Array(size);\\r\\n\\t\\tObject.setPrototypeOf(ui8, Buffer.prototype);\\r\\n\\t\\treturn ui8;\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nfunction fromString(string, encoding) {\\r\\n\\tif (typeof encoding !== 'string' || encoding === '')\\r\\n\\t\\tencoding = 'utf8';\\r\\n\\r\\n\\tvar length = byteLength(string, encoding);\\r\\n\\tif (length >= (Buffer.poolSize >>> 1))\\r\\n\\t\\treturn binding.createFromString(string, encoding);\\r\\n\\r\\n\\tif (length > (poolSize - poolOffset))\\r\\n\\t\\tcreatePool();\\r\\n\\tvar actual = allocPool.write(string, poolOffset, encoding);\\r\\n\\tvar b = allocPool.slice(poolOffset, poolOffset + actual);\\r\\n\\tpoolOffset += actual;\\r\\n\\talignPool();\\r\\n\\treturn b;\\r\\n}\\r\\n\\r\\n\\r\\nfunction fromObject(obj) {\\r\\n\\tif (obj instanceof Buffer) {\\r\\n\\t\\tvar b = allocate(obj.length);\\r\\n\\t\\tobj.copy(b, 0, 0, obj.length);\\r\\n\\t\\treturn b;\\r\\n\\t}\\r\\n\\r\\n\\tif (Array.isArray(obj)) {\\r\\n\\t\\tvar length = obj.length;\\r\\n\\t\\tvar b = allocate(length);\\r\\n\\t\\tfor (var i = 0; i < length; i++)\\r\\n\\t\\t\\tb[i] = obj[i] & 255;\\r\\n\\t\\treturn b;\\r\\n\\t}\\r\\n\\r\\n\\tif (obj == null) {\\r\\n\\t\\tthrow new TypeError('Must start with number, buffer, array or string');\\r\\n\\t}\\r\\n\\r\\n\\tif (obj instanceof ArrayBuffer) {\\r\\n\\t\\treturn binding.createFromArrayBuffer(obj);\\r\\n\\t}\\r\\n\\r\\n\\tif (obj.buffer instanceof ArrayBuffer || obj.length) {\\r\\n\\t\\tvar length;\\r\\n\\t\\tif (typeof obj.length !== 'number' || obj.length !== obj.length)\\r\\n\\t\\t\\tlength = 0;\\r\\n\\t\\telse\\r\\n\\t\\t\\tlength = obj.length;\\r\\n\\t\\tvar b = allocate(length);\\r\\n\\t\\tfor (var i = 0; i < length; i++) {\\r\\n\\t\\t\\tb[i] = obj[i] & 255;\\r\\n\\t\\t}\\r\\n\\t\\treturn b;\\r\\n\\t}\\r\\n\\r\\n\\tif (obj.type === 'Buffer' && Array.isArray(obj.data)) {\\r\\n\\t\\tvar array = obj.data;\\r\\n\\t\\tvar b = allocate(array.length);\\r\\n\\t\\tfor (var i = 0; i < array.length; i++)\\r\\n\\t\\t\\tb[i] = array[i] & 255;\\r\\n\\t\\treturn b;\\r\\n\\t}\\r\\n\\r\\n\\tthrow new TypeError('Must start with number, buffer, array or string');\\r\\n}\\r\\n\\r\\n\\r\\n// Static methods\\r\\n\\r\\nBuffer.isBuffer = function isBuffer(b) {\\r\\n\\treturn b instanceof Buffer;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.compare = function compare(a, b) {\\r\\n\\tif (!(a instanceof Buffer) ||\\r\\n\\t\\t\\t!(b instanceof Buffer)) {\\r\\n\\t\\tthrow new TypeError('Arguments must be Buffers');\\r\\n\\t}\\r\\n\\r\\n\\tif (a === b) {\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\treturn binding.compare(a, b);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.isEncoding = function(encoding) {\\r\\n\\tvar loweredCase = false;\\r\\n\\tfor (;;) {\\r\\n\\t\\tswitch (encoding) {\\r\\n\\t\\t\\tcase 'hex':\\r\\n\\t\\t\\tcase 'utf8':\\r\\n\\t\\t\\tcase 'utf-8':\\r\\n\\t\\t\\tcase 'ascii':\\r\\n\\t\\t\\tcase 'binary':\\r\\n\\t\\t\\tcase 'base64':\\r\\n\\t\\t\\tcase 'ucs2':\\r\\n\\t\\t\\tcase 'ucs-2':\\r\\n\\t\\t\\tcase 'utf16le':\\r\\n\\t\\t\\tcase 'utf-16le':\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tif (loweredCase)\\r\\n\\t\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t\\tencoding = ('' + encoding).toLowerCase();\\r\\n\\t\\t\\t\\tloweredCase = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.concat = function(list, length) {\\r\\n\\tif (!Array.isArray(list))\\r\\n\\t\\tthrow new TypeError('\\\"list\\\" argument must be an Array of Buffers');\\r\\n\\r\\n\\tif (list.length === 0)\\r\\n\\t\\treturn new Buffer(0);\\r\\n\\r\\n\\tif (length === undefined) {\\r\\n\\t\\tlength = 0;\\r\\n\\t\\tfor (var i = 0; i < list.length; i++)\\r\\n\\t\\t\\tlength += list[i].length;\\r\\n\\t} else {\\r\\n\\t\\tlength = length >>> 0;\\r\\n\\t}\\r\\n\\r\\n\\tvar buffer = new Buffer(length);\\r\\n\\tvar pos = 0;\\r\\n\\tfor (var i = 0; i < list.length; i++) {\\r\\n\\t\\tvar buf = list[i];\\r\\n\\t\\tbuf.copy(buffer, pos);\\r\\n\\t\\tpos += buf.length;\\r\\n\\t}\\r\\n\\r\\n\\treturn buffer;\\r\\n};\\r\\n\\r\\n\\r\\nfunction base64ByteLength(str, bytes) {\\r\\n\\t// Handle padding\\r\\n\\tif (str.charCodeAt(bytes - 1) === 0x3D)\\r\\n\\t\\tbytes--;\\r\\n\\tif (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D)\\r\\n\\t\\tbytes--;\\r\\n\\r\\n\\t// Base64 ratio: 3/4\\r\\n\\treturn (bytes * 3) >>> 2;\\r\\n}\\r\\n\\r\\n\\r\\nfunction byteLength(string, encoding) {\\r\\n\\tif (typeof string !== 'string')\\r\\n\\t\\tstring = '' + string;\\r\\n\\r\\n\\tvar len = string.length;\\r\\n\\tif (len === 0)\\r\\n\\t\\treturn 0;\\r\\n\\r\\n\\t// Use a for loop to avoid recursion\\r\\n\\tvar loweredCase = false;\\r\\n\\tfor (;;) {\\r\\n\\t\\tswitch (encoding) {\\r\\n\\t\\t\\tcase 'ascii':\\r\\n\\t\\t\\tcase 'binary':\\r\\n\\t\\t\\t\\treturn len;\\r\\n\\r\\n\\t\\t\\tcase 'utf8':\\r\\n\\t\\t\\tcase 'utf-8':\\r\\n\\t\\t\\tcase undefined:\\r\\n\\t\\t\\t\\treturn binding.byteLengthUtf8(string);\\r\\n\\r\\n\\t\\t\\tcase 'ucs2':\\r\\n\\t\\t\\tcase 'ucs-2':\\r\\n\\t\\t\\tcase 'utf16le':\\r\\n\\t\\t\\tcase 'utf-16le':\\r\\n\\t\\t\\t\\treturn len * 2;\\r\\n\\r\\n\\t\\t\\tcase 'hex':\\r\\n\\t\\t\\t\\treturn len >>> 1;\\r\\n\\r\\n\\t\\t\\tcase 'base64':\\r\\n\\t\\t\\t\\treturn base64ByteLength(string, len);\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\t// The C++ binding defaulted to UTF8, we should too.\\r\\n\\t\\t\\t\\tif (loweredCase)\\r\\n\\t\\t\\t\\t\\treturn binding.byteLengthUtf8(string);\\r\\n\\r\\n\\t\\t\\t\\tencoding = ('' + encoding).toLowerCase();\\r\\n\\t\\t\\t\\tloweredCase = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nBuffer.byteLength = byteLength;\\r\\n\\r\\n\\r\\n// For backwards compatibility.\\r\\nObject.defineProperty(Buffer.prototype, 'parent', {\\r\\n\\tenumerable: true,\\r\\n\\tget: function() {\\r\\n\\t\\tif (!(this instanceof Buffer))\\r\\n\\t\\t\\treturn undefined;\\r\\n\\t\\tif (this.byteLength === 0 ||\\r\\n\\t\\t\\t\\tthis.byteLength === this.buffer.byteLength) {\\r\\n\\t\\t\\treturn undefined;\\r\\n\\t\\t}\\r\\n\\t\\treturn this.buffer;\\r\\n\\t}\\r\\n});\\r\\nObject.defineProperty(Buffer.prototype, 'offset', {\\r\\n\\tenumerable: true,\\r\\n\\tget: function() {\\r\\n\\t\\tif (!(this instanceof Buffer))\\r\\n\\t\\t\\treturn undefined;\\r\\n\\t\\treturn this.byteOffset;\\r\\n\\t}\\r\\n});\\r\\n\\r\\n\\r\\nfunction slowToString(encoding, start, end) {\\r\\n\\tvar loweredCase = false;\\r\\n\\r\\n\\t// No need to verify that \\\"this.length <= MAX_UINT32\\\" since it's a read-only\\r\\n\\t// property of a typed array.\\r\\n\\r\\n\\t// This behaves neither like String nor Uint8Array in that we set start/end\\r\\n\\t// to their upper/lower bounds if the value passed is out of range.\\r\\n\\t// undefined is handled specially as per ECMA-262 6th Edition,\\r\\n\\t// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\\r\\n\\tif (start === undefined || start < 0)\\r\\n\\t\\tstart = 0;\\r\\n\\t// Return early if start > this.length. Done here to prevent potential uint32\\r\\n\\t// coercion fail below.\\r\\n\\tif (start > this.length)\\r\\n\\t\\treturn '';\\r\\n\\r\\n\\tif (end === undefined || end > this.length)\\r\\n\\t\\tend = this.length;\\r\\n\\r\\n\\tif (end <= 0)\\r\\n\\t\\treturn '';\\r\\n\\r\\n\\t// Force coersion to uint32. This will also coerce falsey/NaN values to 0.\\r\\n\\tend >>>= 0;\\r\\n\\tstart >>>= 0;\\r\\n\\r\\n\\tif (end <= start)\\r\\n\\t\\treturn '';\\r\\n\\r\\n\\tif (!encoding) encoding = 'utf8';\\r\\n\\r\\n\\twhile (true) {\\r\\n\\t\\tswitch (encoding) {\\r\\n\\t\\t\\tcase 'hex':\\r\\n\\t\\t\\t\\treturn this.hexSlice(start, end);\\r\\n\\r\\n\\t\\t\\tcase 'utf8':\\r\\n\\t\\t\\tcase 'utf-8':\\r\\n\\t\\t\\t\\treturn this.utf8Slice(start, end);\\r\\n\\r\\n\\t\\t\\tcase 'ascii':\\r\\n\\t\\t\\t\\treturn this.asciiSlice(start, end);\\r\\n\\r\\n\\t\\t\\tcase 'binary':\\r\\n\\t\\t\\t\\treturn this.binarySlice(start, end);\\r\\n\\r\\n\\t\\t\\tcase 'base64':\\r\\n\\t\\t\\t\\treturn this.base64Slice(start, end);\\r\\n\\r\\n\\t\\t\\tcase 'ucs2':\\r\\n\\t\\t\\tcase 'ucs-2':\\r\\n\\t\\t\\tcase 'utf16le':\\r\\n\\t\\t\\tcase 'utf-16le':\\r\\n\\t\\t\\t\\treturn this.ucs2Slice(start, end);\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tif (loweredCase)\\r\\n\\t\\t\\t\\t\\tthrow new TypeError('Unknown encoding: ' + encoding);\\r\\n\\t\\t\\t\\tencoding = (encoding + '').toLowerCase();\\r\\n\\t\\t\\t\\tloweredCase = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nBuffer.prototype.toString = function() {\\r\\n\\tif (arguments.length === 0) {\\r\\n\\t\\tvar result = this.utf8Slice(0, this.length);\\r\\n\\t} else {\\r\\n\\t\\tvar result = slowToString.apply(this, arguments);\\r\\n\\t}\\r\\n\\tif (result === undefined)\\r\\n\\t\\tthrow new Error('\\\"toString()\\\" failed');\\r\\n\\treturn result;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.equals = function equals(b) {\\r\\n\\tif (!(b instanceof Buffer))\\r\\n\\t\\tthrow new TypeError('Argument must be a Buffer');\\r\\n\\r\\n\\tif (this === b)\\r\\n\\t\\treturn true;\\r\\n\\r\\n\\treturn binding.compare(this, b) === 0;\\r\\n};\\r\\n\\r\\n\\r\\n// Inspect\\r\\nBuffer.prototype.inspect = function inspect() {\\r\\n\\tvar str = '';\\r\\n\\tvar max = exports.INSPECT_MAX_BYTES;\\r\\n\\tif (this.length > 0) {\\r\\n\\t\\tstr = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\\r\\n\\t\\tif (this.length > max)\\r\\n\\t\\t\\tstr += ' ... ';\\r\\n\\t}\\r\\n\\treturn '<' + this.constructor.name + ' ' + str + '>';\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.compare = function compare(b) {\\r\\n\\tif (!(b instanceof Buffer))\\r\\n\\t\\tthrow new TypeError('Argument must be a Buffer');\\r\\n\\r\\n\\tif (this === b)\\r\\n\\t\\treturn 0;\\r\\n\\r\\n\\treturn binding.compare(this, b);\\r\\n};\\r\\n\\r\\nfunction slowIndexOf(buffer, val, byteOffset, encoding) {\\r\\n\\tvar loweredCase = false;\\r\\n\\tfor (;;) {\\r\\n\\t\\tswitch (encoding) {\\r\\n\\t\\t\\tcase 'utf8':\\r\\n\\t\\t\\tcase 'utf-8':\\r\\n\\t\\t\\tcase 'ucs2':\\r\\n\\t\\t\\tcase 'ucs-2':\\r\\n\\t\\t\\tcase 'utf16le':\\r\\n\\t\\t\\tcase 'utf-16le':\\r\\n\\t\\t\\tcase 'binary':\\r\\n\\t\\t\\t\\treturn binding.indexOfString(buffer, val, byteOffset, encoding);\\r\\n\\r\\n\\t\\t\\tcase 'base64':\\r\\n\\t\\t\\tcase 'ascii':\\r\\n\\t\\t\\tcase 'hex':\\r\\n\\t\\t\\t\\treturn binding.indexOfBuffer(\\r\\n\\t\\t\\t\\t\\t\\tbuffer, Buffer(val, encoding), byteOffset, encoding);\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tif (loweredCase) {\\r\\n\\t\\t\\t\\t\\tthrow new TypeError('Unknown encoding: ' + encoding);\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tencoding = ('' + encoding).toLowerCase();\\r\\n\\t\\t\\t\\tloweredCase = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\\r\\n\\tif (byteOffset > 0x7fffffff)\\r\\n\\t\\tbyteOffset = 0x7fffffff;\\r\\n\\telse if (byteOffset < -0x80000000)\\r\\n\\t\\tbyteOffset = -0x80000000;\\r\\n\\tbyteOffset >>= 0;\\r\\n\\r\\n\\tif (typeof val === 'string') {\\r\\n\\t\\tif (encoding === undefined) {\\r\\n\\t\\t\\treturn binding.indexOfString(this, val, byteOffset, encoding);\\r\\n\\t\\t}\\r\\n\\t\\treturn slowIndexOf(this, val, byteOffset, encoding);\\r\\n\\t} else if (val instanceof Buffer) {\\r\\n\\t\\treturn binding.indexOfBuffer(this, val, byteOffset, encoding);\\r\\n\\t} else if (typeof val === 'number') {\\r\\n\\t\\treturn binding.indexOfNumber(this, val, byteOffset);\\r\\n\\t}\\r\\n\\r\\n\\tthrow new TypeError('\\\"val\\\" argument must be string, number or Buffer');\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\\r\\n\\treturn this.indexOf(val, byteOffset, encoding) !== -1;\\r\\n};\\r\\n\\r\\n//FIXME: fast implementation\\r\\nif (typeof NODE_BUFFER === 'undefined'){\\r\\n\\tBuffer.prototype.fill = NODE_BUFFER.prototype.fill;\\r\\n} else {\\r\\n\\tBuffer.prototype.fill = function fill(val, start, end) {\\r\\n\\t\\tstart = start >> 0;\\r\\n\\t\\tend = (end === undefined) ? this.length : end >> 0;\\r\\n\\r\\n\\t\\tif (start < 0 || end > this.length)\\r\\n\\t\\t\\tthrow new RangeError('Out of range index');\\r\\n\\t\\tif (end <= start)\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\tif (typeof val !== 'string') {\\r\\n\\t\\t\\tval = val >>> 0;\\r\\n\\t\\t} else if (val.length === 1) {\\r\\n\\t\\t\\tvar code = val.charCodeAt(0);\\r\\n\\t\\t\\tif (code < 256)\\r\\n\\t\\t\\t\\tval = code;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tbinding.fill(this, val, start, end);\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\t};\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n// XXX remove in v0.13\\r\\nBuffer.prototype.get = internalUtil.deprecate(function get(offset) {\\r\\n\\toffset = ~~offset;\\r\\n\\tif (offset < 0 || offset >= this.length)\\r\\n\\t\\tthrow new RangeError('Index out of range');\\r\\n\\treturn this[offset];\\r\\n}, 'Buffer.get is deprecated. Use array indexes instead.');\\r\\n\\r\\n\\r\\n// XXX remove in v0.13\\r\\nBuffer.prototype.set = internalUtil.deprecate(function set(offset, v) {\\r\\n\\toffset = ~~offset;\\r\\n\\tif (offset < 0 || offset >= this.length)\\r\\n\\t\\tthrow new RangeError('Index out of range');\\r\\n\\treturn this[offset] = v;\\r\\n}, 'Buffer.set is deprecated. Use array indexes instead.');\\r\\n\\r\\n\\r\\n// TODO(trevnorris): fix these checks to follow new standard\\r\\n// write(string, offset = 0, length = buffer.length, encoding = 'utf8')\\r\\nvar writeWarned = false;\\r\\nvar writeMsg = 'Buffer.write(string, encoding, offset, length) is ' +\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t 'deprecated. Use write(string[, offset[, length]]' +\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t '[, encoding]) instead.';\\r\\nBuffer.prototype.write = function(string, offset, length, encoding) {\\r\\n\\t// Buffer#write(string);\\r\\n\\tif (offset === undefined) {\\r\\n\\t\\tencoding = 'utf8';\\r\\n\\t\\tlength = this.length;\\r\\n\\t\\toffset = 0;\\r\\n\\r\\n\\t// Buffer#write(string, encoding)\\r\\n\\t} else if (length === undefined && typeof offset === 'string') {\\r\\n\\t\\tencoding = offset;\\r\\n\\t\\tlength = this.length;\\r\\n\\t\\toffset = 0;\\r\\n\\r\\n\\t// Buffer#write(string, offset[, length][, encoding])\\r\\n\\t} else if (isFinite(offset)) {\\r\\n\\t\\toffset = offset >>> 0;\\r\\n\\t\\tif (isFinite(length)) {\\r\\n\\t\\t\\tlength = length >>> 0;\\r\\n\\t\\t\\tif (encoding === undefined)\\r\\n\\t\\t\\t\\tencoding = 'utf8';\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tencoding = length;\\r\\n\\t\\t\\tlength = undefined;\\r\\n\\t\\t}\\r\\n\\r\\n\\t// XXX legacy write(string, encoding, offset, length) - remove in v0.13\\r\\n\\t} else {\\r\\n\\t\\twriteWarned = internalUtil.printDeprecationMessage(writeMsg, writeWarned);\\r\\n\\t\\tvar swap = encoding;\\r\\n\\t\\tencoding = offset;\\r\\n\\t\\toffset = length >>> 0;\\r\\n\\t\\tlength = swap;\\r\\n\\t}\\r\\n\\r\\n\\tvar remaining = this.length - offset;\\r\\n\\tif (length === undefined || length > remaining)\\r\\n\\t\\tlength = remaining;\\r\\n\\r\\n\\tif (string.length > 0 && (length < 0 || offset < 0))\\r\\n\\t\\tthrow new RangeError('Attempt to write outside buffer bounds');\\r\\n\\r\\n\\tif (!encoding)\\r\\n\\t\\tencoding = 'utf8';\\r\\n\\r\\n\\tvar loweredCase = false;\\r\\n\\tfor (;;) {\\r\\n\\t\\tswitch (encoding) {\\r\\n\\t\\t\\tcase 'hex':\\r\\n\\t\\t\\t\\treturn this.hexWrite(string, offset, length);\\r\\n\\r\\n\\t\\t\\tcase 'utf8':\\r\\n\\t\\t\\tcase 'utf-8':\\r\\n\\t\\t\\t\\treturn this.utf8Write(string, offset, length);\\r\\n\\r\\n\\t\\t\\tcase 'ascii':\\r\\n\\t\\t\\t\\treturn this.asciiWrite(string, offset, length);\\r\\n\\r\\n\\t\\t\\tcase 'binary':\\r\\n\\t\\t\\t\\treturn this.binaryWrite(string, offset, length);\\r\\n\\r\\n\\t\\t\\tcase 'base64':\\r\\n\\t\\t\\t\\t// Warning: maxLength not taken into account in base64Write\\r\\n\\t\\t\\t\\treturn this.base64Write(string, offset, length);\\r\\n\\r\\n\\t\\t\\tcase 'ucs2':\\r\\n\\t\\t\\tcase 'ucs-2':\\r\\n\\t\\t\\tcase 'utf16le':\\r\\n\\t\\t\\tcase 'utf-16le':\\r\\n\\t\\t\\t\\treturn this.ucs2Write(string, offset, length);\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tif (loweredCase)\\r\\n\\t\\t\\t\\t\\tthrow new TypeError('Unknown encoding: ' + encoding);\\r\\n\\t\\t\\t\\tencoding = ('' + encoding).toLowerCase();\\r\\n\\t\\t\\t\\tloweredCase = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.toJSON = function() {\\r\\n\\treturn {\\r\\n\\t\\ttype: 'Buffer',\\r\\n\\t\\tdata: Array.prototype.slice.call(this, 0)\\r\\n\\t};\\r\\n};\\r\\n\\r\\n\\r\\n// TODO(trevnorris): currently works like Array.prototype.slice(), which\\r\\n// doesn't follow the new standard for throwing on out of range indexes.\\r\\nBuffer.prototype.slice = function slice(start, end) {\\r\\n\\tvar buffer = this.subarray(start, end);\\r\\n\\tObject.setPrototypeOf(buffer, Buffer.prototype);\\r\\n\\treturn buffer;\\r\\n};\\r\\n\\r\\n\\r\\nfunction checkOffset(offset, ext, length) {\\r\\n\\tif (offset + ext > length)\\r\\n\\t\\tthrow new RangeError('Index out of range');\\r\\n}\\r\\n\\r\\n\\r\\nBuffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tbyteLength = byteLength >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, byteLength, this.length);\\r\\n\\r\\n\\tvar val = this[offset];\\r\\n\\tvar mul = 1;\\r\\n\\tvar i = 0;\\r\\n\\twhile (++i < byteLength && (mul *= 0x100))\\r\\n\\t\\tval += this[offset + i] * mul;\\r\\n\\r\\n\\treturn val;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tbyteLength = byteLength >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, byteLength, this.length);\\r\\n\\r\\n\\tvar val = this[offset + --byteLength];\\r\\n\\tvar mul = 1;\\r\\n\\twhile (byteLength > 0 && (mul *= 0x100))\\r\\n\\t\\tval += this[offset + --byteLength] * mul;\\r\\n\\r\\n\\treturn val;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 1, this.length);\\r\\n\\treturn this[offset];\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 2, this.length);\\r\\n\\treturn this[offset] | (this[offset + 1] << 8);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 2, this.length);\\r\\n\\treturn (this[offset] << 8) | this[offset + 1];\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 4, this.length);\\r\\n\\r\\n\\treturn ((this[offset]) |\\r\\n\\t\\t\\t(this[offset + 1] << 8) |\\r\\n\\t\\t\\t(this[offset + 2] << 16)) +\\r\\n\\t\\t\\t(this[offset + 3] * 0x1000000);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 4, this.length);\\r\\n\\r\\n\\treturn (this[offset] * 0x1000000) +\\r\\n\\t\\t\\t((this[offset + 1] << 16) |\\r\\n\\t\\t\\t(this[offset + 2] << 8) |\\r\\n\\t\\t\\tthis[offset + 3]);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readIntLE = function(offset, byteLength, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tbyteLength = byteLength >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, byteLength, this.length);\\r\\n\\r\\n\\tvar val = this[offset];\\r\\n\\tvar mul = 1;\\r\\n\\tvar i = 0;\\r\\n\\twhile (++i < byteLength && (mul *= 0x100))\\r\\n\\t\\tval += this[offset + i] * mul;\\r\\n\\tmul *= 0x80;\\r\\n\\r\\n\\tif (val >= mul)\\r\\n\\t\\tval -= Math.pow(2, 8 * byteLength);\\r\\n\\r\\n\\treturn val;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readIntBE = function(offset, byteLength, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tbyteLength = byteLength >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, byteLength, this.length);\\r\\n\\r\\n\\tvar i = byteLength;\\r\\n\\tvar mul = 1;\\r\\n\\tvar val = this[offset + --i];\\r\\n\\twhile (i > 0 && (mul *= 0x100))\\r\\n\\t\\tval += this[offset + --i] * mul;\\r\\n\\tmul *= 0x80;\\r\\n\\r\\n\\tif (val >= mul)\\r\\n\\t\\tval -= Math.pow(2, 8 * byteLength);\\r\\n\\r\\n\\treturn val;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readInt8 = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 1, this.length);\\r\\n\\tvar val = this[offset];\\r\\n\\treturn !(val & 0x80) ? val : (0xff - val + 1) * -1;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 2, this.length);\\r\\n\\tvar val = this[offset] | (this[offset + 1] << 8);\\r\\n\\treturn (val & 0x8000) ? val | 0xFFFF0000 : val;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 2, this.length);\\r\\n\\tvar val = this[offset + 1] | (this[offset] << 8);\\r\\n\\treturn (val & 0x8000) ? val | 0xFFFF0000 : val;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 4, this.length);\\r\\n\\r\\n\\treturn (this[offset]) |\\r\\n\\t\\t\\t(this[offset + 1] << 8) |\\r\\n\\t\\t\\t(this[offset + 2] << 16) |\\r\\n\\t\\t\\t(this[offset + 3] << 24);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 4, this.length);\\r\\n\\r\\n\\treturn (this[offset] << 24) |\\r\\n\\t\\t\\t(this[offset + 1] << 16) |\\r\\n\\t\\t\\t(this[offset + 2] << 8) |\\r\\n\\t\\t\\t(this[offset + 3]);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 4, this.length);\\r\\n\\treturn binding.readFloatLE(this, offset);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 4, this.length);\\r\\n\\treturn binding.readFloatBE(this, offset);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 8, this.length);\\r\\n\\treturn binding.readDoubleLE(this, offset);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 8, this.length);\\r\\n\\treturn binding.readDoubleBE(this, offset);\\r\\n};\\r\\n\\r\\n\\r\\nfunction checkInt(buffer, value, offset, ext, max, min) {\\r\\n\\tif (!(buffer instanceof Buffer))\\r\\n\\t\\tthrow new TypeError('\\\"buffer\\\" argument must be a Buffer instance');\\r\\n\\tif (value > max || value < min)\\r\\n\\t\\tthrow new TypeError('\\\"value\\\" argument is out of bounds');\\r\\n\\tif (offset + ext > buffer.length)\\r\\n\\t\\tthrow new RangeError('Index out of range');\\r\\n}\\r\\n\\r\\n\\r\\nBuffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tbyteLength = byteLength >>> 0;\\r\\n\\tif (!noAssert) {\\r\\n\\t\\tvar maxBytes = Math.pow(2, 8 * byteLength) - 1;\\r\\n\\t\\tcheckInt(this, value, offset, byteLength, maxBytes, 0);\\r\\n\\t}\\r\\n\\r\\n\\tvar mul = 1;\\r\\n\\tvar i = 0;\\r\\n\\tthis[offset] = value;\\r\\n\\twhile (++i < byteLength && (mul *= 0x100))\\r\\n\\t\\tthis[offset + i] = (value / mul) >>> 0;\\r\\n\\r\\n\\treturn offset + byteLength;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tbyteLength = byteLength >>> 0;\\r\\n\\tif (!noAssert) {\\r\\n\\t\\tvar maxBytes = Math.pow(2, 8 * byteLength) - 1;\\r\\n\\t\\tcheckInt(this, value, offset, byteLength, maxBytes, 0);\\r\\n\\t}\\r\\n\\r\\n\\tvar i = byteLength - 1;\\r\\n\\tvar mul = 1;\\r\\n\\tthis[offset + i] = value;\\r\\n\\twhile (--i >= 0 && (mul *= 0x100))\\r\\n\\t\\tthis[offset + i] = (value / mul) >>> 0;\\r\\n\\r\\n\\treturn offset + byteLength;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 1, 0xff, 0);\\r\\n\\tthis[offset] = value;\\r\\n\\treturn offset + 1;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 2, 0xffff, 0);\\r\\n\\tthis[offset] = value;\\r\\n\\tthis[offset + 1] = (value >>> 8);\\r\\n\\treturn offset + 2;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 2, 0xffff, 0);\\r\\n\\tthis[offset] = (value >>> 8);\\r\\n\\tthis[offset + 1] = value;\\r\\n\\treturn offset + 2;\\r\\n};\\r\\n\\r\\nif (typeof NODE_BUFFER !== 'undefined'){\\r\\n\\tBuffer.prototype.writeUInt32LE = NODE_BUFFER.prototype.writeUInt32LE;\\r\\n} else {\\r\\n\\tBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\\r\\n\\t\\tvalue = +value;\\r\\n\\t\\toffset = offset >>> 0;\\r\\n\\t\\tif (!noAssert)\\r\\n\\t\\t\\tcheckInt(this, value, offset, 4, 0xffffffff, 0);\\r\\n\\t\\tthis[offset + 3] = (value >>> 24);\\r\\n\\t\\tthis[offset + 2] = (value >>> 16);\\r\\n\\t\\tthis[offset + 1] = (value >>> 8);\\r\\n\\t\\tthis[offset] = value;\\r\\n\\t\\treturn offset + 4;\\r\\n\\t};\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 4, 0xffffffff, 0);\\r\\n\\tthis[offset] = (value >>> 24);\\r\\n\\tthis[offset + 1] = (value >>> 16);\\r\\n\\tthis[offset + 2] = (value >>> 8);\\r\\n\\tthis[offset + 3] = value;\\r\\n\\treturn offset + 4;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert) {\\r\\n\\t\\tcheckInt(this,\\r\\n\\t\\t\\t\\t\\t\\t value,\\r\\n\\t\\t\\t\\t\\t\\t offset,\\r\\n\\t\\t\\t\\t\\t\\t byteLength,\\r\\n\\t\\t\\t\\t\\t\\t Math.pow(2, 8 * byteLength - 1) - 1,\\r\\n\\t\\t\\t\\t\\t\\t -Math.pow(2, 8 * byteLength - 1));\\r\\n\\t}\\r\\n\\r\\n\\tvar i = 0;\\r\\n\\tvar mul = 1;\\r\\n\\tvar sub = 0;\\r\\n\\tthis[offset] = value;\\r\\n\\twhile (++i < byteLength && (mul *= 0x100)) {\\r\\n\\t\\tif (value < 0 && sub === 0 && this[offset + i - 1] !== 0)\\r\\n\\t\\t\\tsub = 1;\\r\\n\\t\\tthis[offset + i] = ((value / mul) >> 0) - sub;\\r\\n\\t}\\r\\n\\r\\n\\treturn offset + byteLength;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert) {\\r\\n\\t\\tcheckInt(this,\\r\\n\\t\\t\\t\\t\\t\\t value,\\r\\n\\t\\t\\t\\t\\t\\t offset,\\r\\n\\t\\t\\t\\t\\t\\t byteLength,\\r\\n\\t\\t\\t\\t\\t\\t Math.pow(2, 8 * byteLength - 1) - 1,\\r\\n\\t\\t\\t\\t\\t\\t -Math.pow(2, 8 * byteLength - 1));\\r\\n\\t}\\r\\n\\r\\n\\tvar i = byteLength - 1;\\r\\n\\tvar mul = 1;\\r\\n\\tvar sub = 0;\\r\\n\\tthis[offset + i] = value;\\r\\n\\twhile (--i >= 0 && (mul *= 0x100)) {\\r\\n\\t\\tif (value < 0 && sub === 0 && this[offset + i + 1] !== 0)\\r\\n\\t\\t\\tsub = 1;\\r\\n\\t\\tthis[offset + i] = ((value / mul) >> 0) - sub;\\r\\n\\t}\\r\\n\\r\\n\\treturn offset + byteLength;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 1, 0x7f, -0x80);\\r\\n\\tthis[offset] = value;\\r\\n\\treturn offset + 1;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 2, 0x7fff, -0x8000);\\r\\n\\tthis[offset] = value;\\r\\n\\tthis[offset + 1] = (value >>> 8);\\r\\n\\treturn offset + 2;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 2, 0x7fff, -0x8000);\\r\\n\\tthis[offset] = (value >>> 8);\\r\\n\\tthis[offset + 1] = value;\\r\\n\\treturn offset + 2;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\\r\\n\\tthis[offset] = value;\\r\\n\\tthis[offset + 1] = (value >>> 8);\\r\\n\\tthis[offset + 2] = (value >>> 16);\\r\\n\\tthis[offset + 3] = (value >>> 24);\\r\\n\\treturn offset + 4;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\\r\\n\\tthis[offset] = (value >>> 24);\\r\\n\\tthis[offset + 1] = (value >>> 16);\\r\\n\\tthis[offset + 2] = (value >>> 8);\\r\\n\\tthis[offset + 3] = value;\\r\\n\\treturn offset + 4;\\r\\n};\\r\\n\\r\\nif (typeof NODE_BUFFER !== 'undefined'){\\r\\n\\tBuffer.prototype.writeFloatLE = NODE_BUFFER.prototype.writeFloatLE;\\r\\n} else {\\r\\n\\tBuffer.prototype.writeFloatLE = function writeFloatLE(val, offset, noAssert) {\\r\\n\\t\\tval = +val;\\r\\n\\t\\toffset = offset >>> 0;\\r\\n\\t\\tif (!noAssert)\\r\\n\\t\\t\\tbinding.writeFloatLE(this, val, offset);\\r\\n\\t\\telse\\r\\n\\t\\t\\tbinding.writeFloatLE(this, val, offset, true);\\r\\n\\t\\treturn offset + 4;\\r\\n\\t};\\r\\n}\\r\\n\\r\\nif (typeof NODE_BUFFER !== 'undefined'){\\r\\n\\tBuffer.prototype.writeFloatBE = NODE_BUFFER.prototype.writeFloatBE;\\r\\n} else {\\r\\n\\tBuffer.prototype.writeFloatBE = function writeFloatBE(val, offset, noAssert) {\\r\\n\\t\\tval = +val;\\r\\n\\t\\toffset = offset >>> 0;\\r\\n\\t\\tif (!noAssert)\\r\\n\\t\\t\\tbinding.writeFloatBE(this, val, offset);\\r\\n\\t\\telse\\r\\n\\t\\t\\tbinding.writeFloatBE(this, val, offset, true);\\r\\n\\t\\treturn offset + 4;\\r\\n\\t};\\r\\n}\\r\\n\\r\\nif (typeof NODE_BUFFER !== 'undefined'){\\r\\n\\tBuffer.prototype.writeDoubleLE = NODE_BUFFER.prototype.writeDoubleLE;\\r\\n} else {\\r\\n\\tBuffer.prototype.writeDoubleLE = function writeDoubleLE(val, offset, noAssert) {\\r\\n\\t\\tval = +val;\\r\\n\\t\\toffset = offset >>> 0;\\r\\n\\t\\tif (!noAssert)\\r\\n\\t\\t\\tbinding.writeDoubleLE(this, val, offset);\\r\\n\\t\\telse\\r\\n\\t\\t\\tbinding.writeDoubleLE(this, val, offset, true);\\r\\n\\t\\treturn offset + 8;\\r\\n\\t};\\r\\n}\\r\\n\\r\\nif (typeof NODE_BUFFER !== 'undefined'){\\r\\n\\tBuffer.prototype.writeDoubleBE = NODE_BUFFER.prototype.writeDoubleBE;\\r\\n} else {\\r\\n\\tBuffer.prototype.writeDoubleBE = function writeDoubleBE(val, offset, noAssert) {\\r\\n\\t\\tval = +val;\\r\\n\\t\\toffset = offset >>> 0;\\r\\n\\t\\tif (!noAssert)\\r\\n\\t\\t\\tbinding.writeDoubleBE(this, val, offset);\\r\\n\\t\\telse\\r\\n\\t\\t\\tbinding.writeDoubleBE(this, val, offset, true);\\r\\n\\t\\treturn offset + 8;\\r\\n\\t};\\r\\n}\\r\\n\",\"util\":\"//// Copyright Joyent, Inc. and other Node contributors.\\r\\n////\\r\\n//// Permission is hereby granted, free of charge, to any person obtaining a\\r\\n//// copy of this software and associated documentation files (the\\r\\n//// \\\"Software\\\"), to deal in the Software without restriction, including\\r\\n//// without limitation the rights to use, copy, modify, merge, publish,\\r\\n//// distribute, sublicense, and/or sell copies of the Software, and to permit\\r\\n//// persons to whom the Software is furnished to do so, subject to the\\r\\n//// following conditions:\\r\\n////\\r\\n//// The above copyright notice and this permission notice shall be included\\r\\n//// in all copies or substantial portions of the Software.\\r\\n////\\r\\n//// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\r\\n//// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\r\\n//// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\r\\n//// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\r\\n//// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\r\\n//// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\r\\n//// USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\nexports._exceptionWithHostPort = function(err,\\r\\n                                          syscall,\\r\\n                                          address,\\r\\n                                          port,\\r\\n                                          additional) {\\r\\n  var details;\\r\\n  if (port && port > 0) {\\r\\n    details = address + ':' + port;\\r\\n  } else {\\r\\n    details = address;\\r\\n  }\\r\\n\\r\\n  if (additional) {\\r\\n    details += ' - Local (' + additional + ')';\\r\\n  }\\r\\n  var ex = exports._errnoException(err, syscall, details);\\r\\n  ex.address = address;\\r\\n  if (port) {\\r\\n    ex.port = port;\\r\\n  }\\r\\n  return ex;\\r\\n};\\r\\n\\r\\nvar formatRegExp = /%[sdj%]/g;\\r\\nexports.format = function(f) {\\r\\n  if (!isString(f)) {\\r\\n    var objects = [];\\r\\n    for (var i = 0; i < arguments.length; i++) {\\r\\n      objects.push(inspect(arguments[i]));\\r\\n    }\\r\\n    return objects.join(' ');\\r\\n  }\\r\\n\\r\\n  var i = 1;\\r\\n  var args = arguments;\\r\\n  var len = args.length;\\r\\n  var str = String(f).replace(formatRegExp, function(x) {\\r\\n    if (x === '%%') return '%';\\r\\n    if (i >= len) return x;\\r\\n    switch (x) {\\r\\n      case '%s': return String(args[i++]);\\r\\n      case '%d': return Number(args[i++]);\\r\\n      case '%j':\\r\\n        try {\\r\\n          return JSON.stringify(args[i++]);\\r\\n        } catch (_) {\\r\\n          return '[Circular]';\\r\\n        }\\r\\n      default:\\r\\n        return x;\\r\\n    }\\r\\n  });\\r\\n  for (var x = args[i]; i < len; x = args[++i]) {\\r\\n    if (isNull(x) || !isObject(x)) {\\r\\n      str += ' ' + x;\\r\\n    } else {\\r\\n      str += ' ' + inspect(x);\\r\\n    }\\r\\n  }\\r\\n  return str;\\r\\n};\\r\\n\\r\\n// Mark that a method should not be used.\\r\\n// Returns a modified function which warns once by default.\\r\\n// If --no-deprecation is set, then it is a no-op.\\r\\nexports.deprecate = function(fn, msg) {\\r\\n  // Allow for deprecating things in the process of starting up.\\r\\n  if (isUndefined(global.process)) {\\r\\n    return function() {\\r\\n      return exports.deprecate(fn, msg).apply(this, arguments);\\r\\n    };\\r\\n  }\\r\\n\\r\\n  if (process.noDeprecation === true) {\\r\\n    return fn;\\r\\n  }\\r\\n\\r\\n  var warned = false;\\r\\n  function deprecated() {\\r\\n    if (!warned) {\\r\\n      if (process.throwDeprecation) {\\r\\n        throw new Error(msg);\\r\\n      } else if (process.traceDeprecation) {\\r\\n        console.trace(msg);\\r\\n      } else {\\r\\n        console.error(msg);\\r\\n      }\\r\\n      warned = true;\\r\\n    }\\r\\n    return fn.apply(this, arguments);\\r\\n  }\\r\\n\\r\\n  return deprecated;\\r\\n};\\r\\n\\r\\n\\r\\nvar debugs = {};\\r\\nvar debugEnviron;\\r\\nexports.debuglog = function(set) {\\r\\n  if (isUndefined(debugEnviron))\\r\\n    debugEnviron = process.env.NODE_DEBUG || '';\\r\\n  set = set.toUpperCase();\\r\\n  if (!debugs[set]) {\\r\\n    if (new RegExp('\\\\\\\\b' + set + '\\\\\\\\b', 'i').test(debugEnviron)) {\\r\\n      var pid = process.pid;\\r\\n      debugs[set] = function() {\\r\\n        var msg = exports.format.apply(exports, arguments);\\r\\n        console.error('%s %d: %s', set, pid, msg);\\r\\n      };\\r\\n    } else {\\r\\n      debugs[set] = function() {};\\r\\n    }\\r\\n  }\\r\\n  return debugs[set];\\r\\n};\\r\\n\\r\\n/**\\r\\n * Echos the value of a value. Trys to print the value out\\r\\n * in the best way possible given the different types.\\r\\n *\\r\\n * @param {Object} obj The object to print out.\\r\\n * @param {Object} opts Optional options object that alters the output.\\r\\n */\\r\\n/* legacy: obj, showHidden, depth, colors*/\\r\\nfunction inspect(obj, opts) {\\r\\n  // default options\\r\\n  var ctx = {\\r\\n    seen: [],\\r\\n    stylize: stylizeNoColor\\r\\n  };\\r\\n  // legacy...\\r\\n  if (arguments.length >= 3) ctx.depth = arguments[2];\\r\\n  if (arguments.length >= 4) ctx.colors = arguments[3];\\r\\n  if (isBoolean(opts)) {\\r\\n    // legacy...\\r\\n    ctx.showHidden = opts;\\r\\n  } else if (opts) {\\r\\n    // got an \\\"options\\\" object\\r\\n    exports._extend(ctx, opts);\\r\\n  }\\r\\n  // set default options\\r\\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\\r\\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\\r\\n  if (isUndefined(ctx.colors)) ctx.colors = false;\\r\\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\\r\\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\\r\\n  return formatValue(ctx, obj, ctx.depth);\\r\\n}\\r\\nexports.inspect = inspect;\\r\\n\\r\\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\\r\\ninspect.colors = {\\r\\n  'bold' : [1, 22],\\r\\n  'italic' : [3, 23],\\r\\n  'underline' : [4, 24],\\r\\n  'inverse' : [7, 27],\\r\\n  'white' : [37, 39],\\r\\n  'grey' : [90, 39],\\r\\n  'black' : [30, 39],\\r\\n  'blue' : [34, 39],\\r\\n  'cyan' : [36, 39],\\r\\n  'green' : [32, 39],\\r\\n  'magenta' : [35, 39],\\r\\n  'red' : [31, 39],\\r\\n  'yellow' : [33, 39]\\r\\n};\\r\\n\\r\\n// Don't use 'blue' not visible on cmd.exe\\r\\ninspect.styles = {\\r\\n  'special': 'cyan',\\r\\n  'number': 'yellow',\\r\\n  'boolean': 'yellow',\\r\\n  'undefined': 'grey',\\r\\n  'null': 'bold',\\r\\n  'string': 'green',\\r\\n  'date': 'magenta',\\r\\n  // \\\"name\\\": intentionally not styling\\r\\n  'regexp': 'red'\\r\\n};\\r\\n\\r\\n\\r\\nfunction stylizeWithColor(str, styleType) {\\r\\n  var style = inspect.styles[styleType];\\r\\n\\r\\n  if (style) {\\r\\n    return '\\\\u001b[' + inspect.colors[style][0] + 'm' + str +\\r\\n           '\\\\u001b[' + inspect.colors[style][1] + 'm';\\r\\n  } else {\\r\\n    return str;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nfunction stylizeNoColor(str, styleType) {\\r\\n  return str;\\r\\n}\\r\\n\\r\\n\\r\\nfunction arrayToHash(array) {\\r\\n  var hash = {};\\r\\n\\r\\n  array.forEach(function(val, idx) {\\r\\n    hash[val] = true;\\r\\n  });\\r\\n\\r\\n  return hash;\\r\\n}\\r\\n\\r\\n\\r\\nfunction formatValue(ctx, value, recurseTimes) {\\r\\n  // Provide a hook for user-specified inspect functions.\\r\\n  // Check that value is an object with an inspect function on it\\r\\n  if (ctx.customInspect &&\\r\\n      value &&\\r\\n      isFunction(value.inspect) &&\\r\\n      // Filter out the util module, it's inspect function is special\\r\\n      value.inspect !== exports.inspect &&\\r\\n      // Also filter out any prototype objects using the circular check.\\r\\n      !(value.constructor && value.constructor.prototype === value)) {\\r\\n    var ret = value.inspect(recurseTimes, ctx);\\r\\n    if (!isString(ret)) {\\r\\n      ret = formatValue(ctx, ret, recurseTimes);\\r\\n    }\\r\\n    return ret;\\r\\n  }\\r\\n\\r\\n  // Primitive types cannot have properties\\r\\n  var primitive = formatPrimitive(ctx, value);\\r\\n  if (primitive) {\\r\\n    return primitive;\\r\\n  }\\r\\n\\r\\n  // Look up the keys of the object.\\r\\n  var keys = Object.keys(value);\\r\\n  var visibleKeys = arrayToHash(keys);\\r\\n\\r\\n  if (ctx.showHidden) {\\r\\n    keys = Object.getOwnPropertyNames(value);\\r\\n  }\\r\\n\\r\\n  // This could be a boxed primitive (new String(), etc.), check valueOf()\\r\\n  // NOTE: Avoid calling `valueOf` on `Date` instance because it will return\\r\\n  // a number which, when object has some additional user-stored `keys`,\\r\\n  // will be printed out.\\r\\n  var formatted;\\r\\n  var raw = value;\\r\\n  try {\\r\\n    // the .valueOf() call can fail for a multitude of reasons\\r\\n    if (!isDate(value))\\r\\n      raw = value.valueOf();\\r\\n  } catch (e) {\\r\\n    // ignore...\\r\\n  }\\r\\n\\r\\n  if (isString(raw)) {\\r\\n    // for boxed Strings, we have to remove the 0-n indexed entries,\\r\\n    // since they just noisey up the output and are redundant\\r\\n    keys = keys.filter(function(key) {\\r\\n      return !(key >= 0 && key < raw.length);\\r\\n    });\\r\\n  }\\r\\n\\r\\n  // Some type of object without properties can be shortcutted.\\r\\n  if (keys.length === 0) {\\r\\n    if (isFunction(value)) {\\r\\n      var name = value.name ? ': ' + value.name : '';\\r\\n      return ctx.stylize('[Function' + name + ']', 'special');\\r\\n    }\\r\\n    if (isRegExp(value)) {\\r\\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\\r\\n    }\\r\\n    if (isDate(value)) {\\r\\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\\r\\n    }\\r\\n    if (isError(value)) {\\r\\n      return formatError(value);\\r\\n    }\\r\\n    // now check the `raw` value to handle boxed primitives\\r\\n    if (isString(raw)) {\\r\\n      formatted = formatPrimitiveNoColor(ctx, raw);\\r\\n      return ctx.stylize('[String: ' + formatted + ']', 'string');\\r\\n    }\\r\\n    if (isNumber(raw)) {\\r\\n      formatted = formatPrimitiveNoColor(ctx, raw);\\r\\n      return ctx.stylize('[Number: ' + formatted + ']', 'number');\\r\\n    }\\r\\n    if (isBoolean(raw)) {\\r\\n      formatted = formatPrimitiveNoColor(ctx, raw);\\r\\n      return ctx.stylize('[Boolean: ' + formatted + ']', 'boolean');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var base = '', array = false, braces = ['{', '}'];\\r\\n\\r\\n  // Make Array say that they are Array\\r\\n  if (isArray(value)) {\\r\\n    array = true;\\r\\n    braces = ['[', ']'];\\r\\n  }\\r\\n\\r\\n  // Make functions say that they are functions\\r\\n  if (isFunction(value)) {\\r\\n    var n = value.name ? ': ' + value.name : '';\\r\\n    base = ' [Function' + n + ']';\\r\\n  }\\r\\n\\r\\n  // Make RegExps say that they are RegExps\\r\\n  if (isRegExp(value)) {\\r\\n    base = ' ' + RegExp.prototype.toString.call(value);\\r\\n  }\\r\\n\\r\\n  // Make dates with properties first say the date\\r\\n  if (isDate(value)) {\\r\\n    base = ' ' + Date.prototype.toUTCString.call(value);\\r\\n  }\\r\\n\\r\\n  // Make error with message first say the error\\r\\n  if (isError(value)) {\\r\\n    base = ' ' + formatError(value);\\r\\n  }\\r\\n\\r\\n  // Make boxed primitive Strings look like such\\r\\n  if (isString(raw)) {\\r\\n    formatted = formatPrimitiveNoColor(ctx, raw);\\r\\n    base = ' ' + '[String: ' + formatted + ']';\\r\\n  }\\r\\n\\r\\n  // Make boxed primitive Numbers look like such\\r\\n  if (isNumber(raw)) {\\r\\n    formatted = formatPrimitiveNoColor(ctx, raw);\\r\\n    base = ' ' + '[Number: ' + formatted + ']';\\r\\n  }\\r\\n\\r\\n  // Make boxed primitive Booleans look like such\\r\\n  if (isBoolean(raw)) {\\r\\n    formatted = formatPrimitiveNoColor(ctx, raw);\\r\\n    base = ' ' + '[Boolean: ' + formatted + ']';\\r\\n  }\\r\\n\\r\\n  if (keys.length === 0 && (!array || value.length === 0)) {\\r\\n    return braces[0] + base + braces[1];\\r\\n  }\\r\\n\\r\\n  if (recurseTimes < 0) {\\r\\n    if (isRegExp(value)) {\\r\\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\\r\\n    } else {\\r\\n      return ctx.stylize('[Object]', 'special');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  ctx.seen.push(value);\\r\\n\\r\\n  var output;\\r\\n  if (array) {\\r\\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\\r\\n  } else {\\r\\n    output = keys.map(function(key) {\\r\\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\\r\\n    });\\r\\n  }\\r\\n\\r\\n  ctx.seen.pop();\\r\\n\\r\\n  return reduceToSingleString(output, base, braces);\\r\\n}\\r\\n\\r\\n\\r\\nfunction formatPrimitive(ctx, value) {\\r\\n  if (isUndefined(value))\\r\\n    return ctx.stylize('undefined', 'undefined');\\r\\n  if (isString(value)) {\\r\\n    var simple = '\\\\'' + JSON.stringify(value).replace(/^\\\"|\\\"$/g, '')\\r\\n                                             .replace(/'/g, \\\"\\\\\\\\'\\\")\\r\\n                                             .replace(/\\\\\\\\\\\"/g, '\\\"') + '\\\\'';\\r\\n    return ctx.stylize(simple, 'string');\\r\\n  }\\r\\n  if (isNumber(value)) {\\r\\n    // Format -0 as '-0'. Strict equality won't distinguish 0 from -0,\\r\\n    // so instead we use the fact that 1 / -0 < 0 whereas 1 / 0 > 0 .\\r\\n    if (value === 0 && 1 / value < 0)\\r\\n      return ctx.stylize('-0', 'number');\\r\\n    return ctx.stylize('' + value, 'number');\\r\\n  }\\r\\n  if (isBoolean(value))\\r\\n    return ctx.stylize('' + value, 'boolean');\\r\\n  // For some reason typeof null is \\\"object\\\", so special case here.\\r\\n  if (isNull(value))\\r\\n    return ctx.stylize('null', 'null');\\r\\n\\r\\n  if (typeof value !== 'object' && typeof value !== 'function')\\r\\n    return ctx.stylize('[Pointer: ' + value + ']', 'string');\\r\\n}\\r\\n\\r\\n\\r\\nfunction formatPrimitiveNoColor(ctx, value) {\\r\\n  var stylize = ctx.stylize;\\r\\n  ctx.stylize = stylizeNoColor;\\r\\n  var str = formatPrimitive(ctx, value);\\r\\n  ctx.stylize = stylize;\\r\\n  return str;\\r\\n}\\r\\n\\r\\n\\r\\nfunction formatError(value) {\\r\\n  return '[' + Error.prototype.toString.call(value) + ']';\\r\\n}\\r\\n\\r\\n\\r\\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\\r\\n  var output = [];\\r\\n  for (var i = 0, l = value.length; i < l; ++i) {\\r\\n    if (hasOwnProperty(value, String(i))) {\\r\\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\\r\\n          String(i), true));\\r\\n    } else {\\r\\n      output.push('');\\r\\n    }\\r\\n  }\\r\\n  keys.forEach(function(key) {\\r\\n    if (!key.match(/^\\\\d+$/)) {\\r\\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\\r\\n          key, true));\\r\\n    }\\r\\n  });\\r\\n  return output;\\r\\n}\\r\\n\\r\\n\\r\\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\\r\\n  var name, str, desc;\\r\\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\\r\\n  if (desc.get) {\\r\\n    if (desc.set) {\\r\\n      str = ctx.stylize('[Getter/Setter]', 'special');\\r\\n    } else {\\r\\n      str = ctx.stylize('[Getter]', 'special');\\r\\n    }\\r\\n  } else {\\r\\n    if (desc.set) {\\r\\n      str = ctx.stylize('[Setter]', 'special');\\r\\n    }\\r\\n  }\\r\\n  if (!hasOwnProperty(visibleKeys, key)) {\\r\\n    name = '[' + key + ']';\\r\\n  }\\r\\n  if (!str) {\\r\\n    if (ctx.seen.indexOf(desc.value) < 0) {\\r\\n      if (isNull(recurseTimes)) {\\r\\n        str = formatValue(ctx, desc.value, null);\\r\\n      } else {\\r\\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\\r\\n      }\\r\\n      if (str.indexOf('\\\\n') > -1) {\\r\\n        if (array) {\\r\\n          str = str.split('\\\\n').map(function(line) {\\r\\n            return '  ' + line;\\r\\n          }).join('\\\\n').substr(2);\\r\\n        } else {\\r\\n          str = '\\\\n' + str.split('\\\\n').map(function(line) {\\r\\n            return '   ' + line;\\r\\n          }).join('\\\\n');\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      str = ctx.stylize('[Circular]', 'special');\\r\\n    }\\r\\n  }\\r\\n  if (isUndefined(name)) {\\r\\n    if (array && key.match(/^\\\\d+$/)) {\\r\\n      return str;\\r\\n    }\\r\\n    name = JSON.stringify('' + key);\\r\\n    if (name.match(/^\\\"([a-zA-Z_][a-zA-Z_0-9]*)\\\"$/)) {\\r\\n      name = name.substr(1, name.length - 2);\\r\\n      name = ctx.stylize(name, 'name');\\r\\n    } else {\\r\\n      name = name.replace(/'/g, \\\"\\\\\\\\'\\\")\\r\\n                 .replace(/\\\\\\\\\\\"/g, '\\\"')\\r\\n                 .replace(/(^\\\"|\\\"$)/g, \\\"'\\\")\\r\\n                 .replace(/\\\\\\\\\\\\\\\\/g, '\\\\\\\\');\\r\\n      name = ctx.stylize(name, 'string');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return name + ': ' + str;\\r\\n}\\r\\n\\r\\n\\r\\nfunction reduceToSingleString(output, base, braces) {\\r\\n  var length = output.reduce(function(prev, cur) {\\r\\n    return prev + cur.replace(/\\\\u001b\\\\[\\\\d\\\\d?m/g, '').length + 1;\\r\\n  }, 0);\\r\\n\\r\\n  if (length > 60) {\\r\\n    return braces[0] +\\r\\n           (base === '' ? '' : base + '\\\\n ') +\\r\\n           ' ' +\\r\\n           output.join(',\\\\n  ') +\\r\\n           ' ' +\\r\\n           braces[1];\\r\\n  }\\r\\n\\r\\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\\r\\n}\\r\\n\\r\\n\\r\\n// NOTE: These type checking functions intentionally don't use `instanceof`\\r\\n// because it is fragile and can be easily faked with `Object.create()`.\\r\\nvar isArray = exports.isArray = Array.isArray;\\r\\n\\r\\nfunction isBoolean(arg) {\\r\\n  return typeof arg === 'boolean';\\r\\n}\\r\\nexports.isBoolean = isBoolean;\\r\\n\\r\\nfunction isNull(arg) {\\r\\n  return arg === null;\\r\\n}\\r\\nexports.isNull = isNull;\\r\\n\\r\\nfunction isNullOrUndefined(arg) {\\r\\n  return arg == null;\\r\\n}\\r\\nexports.isNullOrUndefined = isNullOrUndefined;\\r\\n\\r\\nfunction isNumber(arg) {\\r\\n  return typeof arg === 'number';\\r\\n}\\r\\nexports.isNumber = isNumber;\\r\\n\\r\\nfunction isString(arg) {\\r\\n  return typeof arg === 'string';\\r\\n}\\r\\nexports.isString = isString;\\r\\n\\r\\nfunction isSymbol(arg) {\\r\\n  return typeof arg === 'symbol';\\r\\n}\\r\\nexports.isSymbol = isSymbol;\\r\\n\\r\\nfunction isUndefined(arg) {\\r\\n  return arg === void 0;\\r\\n}\\r\\nexports.isUndefined = isUndefined;\\r\\n\\r\\nfunction isRegExp(re) {\\r\\n  return isObject(re) && objectToString(re) === '[object RegExp]';\\r\\n}\\r\\nexports.isRegExp = isRegExp;\\r\\n\\r\\nfunction isObject(arg) {\\r\\n  return typeof arg === 'object' && arg !== null;\\r\\n}\\r\\nexports.isObject = isObject;\\r\\n\\r\\nfunction isDate(d) {\\r\\n  return isObject(d) && objectToString(d) === '[object Date]';\\r\\n}\\r\\nexports.isDate = isDate;\\r\\n\\r\\nfunction isError(e) {\\r\\n  return isObject(e) &&\\r\\n      (objectToString(e) === '[object Error]' || e instanceof Error);\\r\\n}\\r\\nexports.isError = isError;\\r\\n\\r\\nfunction isFunction(arg) {\\r\\n  return typeof arg === 'function';\\r\\n}\\r\\nexports.isFunction = isFunction;\\r\\n\\r\\nfunction isPrimitive(arg) {\\r\\n  return arg === null ||\\r\\n         typeof arg === 'boolean' ||\\r\\n         typeof arg === 'number' ||\\r\\n         typeof arg === 'string' ||\\r\\n         typeof arg === 'symbol' ||  // ES6 symbol\\r\\n         typeof arg === 'undefined';\\r\\n}\\r\\nexports.isPrimitive = isPrimitive;\\r\\n\\r\\nfunction isBuffer(b) {\\r\\n  return b instanceof Buffer;\\r\\n}\\r\\nexports.isBuffer = isBuffer;\\r\\n\\r\\nfunction objectToString(o) {\\r\\n  return Object.prototype.toString.call(o);\\r\\n}\\r\\n\\r\\n\\r\\nfunction pad(n) {\\r\\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\\r\\n}\\r\\n\\r\\n\\r\\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\\r\\n              'Oct', 'Nov', 'Dec'];\\r\\n\\r\\n// 26 Feb 16:19:34\\r\\nfunction timestamp() {\\r\\n  var d = new Date();\\r\\n  var time = [pad(d.getHours()),\\r\\n              pad(d.getMinutes()),\\r\\n              pad(d.getSeconds())].join(':');\\r\\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\\r\\n}\\r\\n\\r\\n\\r\\n// log is just a thin wrapper to console.log that prepends a timestamp\\r\\nexports.log = function() {\\r\\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\\r\\n};\\r\\n\\r\\n\\r\\n/**\\r\\n * Inherit the prototype methods from one constructor into another.\\r\\n *\\r\\n * The Function.prototype.inherits from lang.js rewritten as a standalone\\r\\n * function (not on Function.prototype). NOTE: If this file is to be loaded\\r\\n * during bootstrapping this function needs to be rewritten using some native\\r\\n * functions as prototype setup using normal JavaScript does not work as\\r\\n * expected during bootstrapping (see mirror.js in r114903).\\r\\n *\\r\\n * @param {function} ctor Constructor function which needs to inherit the\\r\\n *     prototype.\\r\\n * @param {function} superCtor Constructor function to inherit prototype from.\\r\\n */\\r\\nexports.inherits = function(ctor, superCtor) {\\r\\n  ctor.super_ = superCtor;\\r\\n  ctor.prototype = Object.create(superCtor.prototype, {\\r\\n    constructor: {\\r\\n      value: ctor,\\r\\n      enumerable: false,\\r\\n      writable: true,\\r\\n      configurable: true\\r\\n    }\\r\\n  });\\r\\n};\\r\\n\\r\\nexports._extend = function(origin, add) {\\r\\n  // Don't do anything if add isn't an object\\r\\n  if (!add || !isObject(add)) return origin;\\r\\n\\r\\n  var keys = Object.keys(add);\\r\\n  var i = keys.length;\\r\\n  while (i--) {\\r\\n    origin[keys[i]] = add[keys[i]];\\r\\n  }\\r\\n  return origin;\\r\\n};\\r\\n\\r\\nfunction hasOwnProperty(obj, prop) {\\r\\n  return Object.prototype.hasOwnProperty.call(obj, prop);\\r\\n}\\r\\n\\r\\n\\r\\n//Deprecated old stuff.\\r\\n\\r\\nexports.p = exports.deprecate(function() {\\r\\n  for (var i = 0, len = arguments.length; i < len; ++i) {\\r\\n    console.error(exports.inspect(arguments[i]));\\r\\n  }\\r\\n}, 'util.p: Use console.error() instead');\\r\\n\\r\\n\\r\\nexports.exec = exports.deprecate(function() {\\r\\n  return require('child_process').exec.apply(this, arguments);\\r\\n}, 'util.exec is now called `child_process.exec`.');\\r\\n\\r\\n\\r\\nexports.print = exports.deprecate(function() {\\r\\n  for (var i = 0, len = arguments.length; i < len; ++i) {\\r\\n    process.stdout.write(String(arguments[i]));\\r\\n  }\\r\\n}, 'util.print: Use console.log instead');\\r\\n\\r\\n\\r\\nexports.puts = exports.deprecate(function() {\\r\\n  for (var i = 0, len = arguments.length; i < len; ++i) {\\r\\n    process.stdout.write(arguments[i] + '\\\\n');\\r\\n  }\\r\\n}, 'util.puts: Use console.log instead');\\r\\n\\r\\n\\r\\nexports.debug = exports.deprecate(function(x) {\\r\\n  process.stderr.write('DEBUG: ' + x + '\\\\n');\\r\\n}, 'util.debug: Use console.error instead');\\r\\n\\r\\n\\r\\nexports.error = exports.deprecate(function(x) {\\r\\n  for (var i = 0, len = arguments.length; i < len; ++i) {\\r\\n    process.stderr.write(arguments[i] + '\\\\n');\\r\\n  }\\r\\n}, 'util.error: Use console.error instead');\\r\\n\\r\\n\\r\\nexports.pump = exports.deprecate(function(readStream, writeStream, callback) {\\r\\n  var callbackCalled = false;\\r\\n\\r\\n  function call(a, b, c) {\\r\\n    if (callback && !callbackCalled) {\\r\\n      callback(a, b, c);\\r\\n      callbackCalled = true;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  readStream.addListener('data', function(chunk) {\\r\\n    if (writeStream.write(chunk) === false) readStream.pause();\\r\\n  });\\r\\n\\r\\n  writeStream.addListener('drain', function() {\\r\\n    readStream.resume();\\r\\n  });\\r\\n\\r\\n  readStream.addListener('end', function() {\\r\\n    writeStream.end();\\r\\n  });\\r\\n\\r\\n  readStream.addListener('close', function() {\\r\\n    call();\\r\\n  });\\r\\n\\r\\n  readStream.addListener('error', function(err) {\\r\\n    writeStream.end();\\r\\n    call(err);\\r\\n  });\\r\\n\\r\\n  writeStream.addListener('error', function(err) {\\r\\n    readStream.destroy();\\r\\n    call(err);\\r\\n  });\\r\\n}, 'util.pump(): Use readableStream.pipe() instead');\\r\\n\\r\\n\\r\\nvar uv;\\r\\nexports._errnoException = function(err, syscall, original) {\\r\\n  if (isUndefined(uv)) uv = process.binding('uv');\\r\\n  var errname = uv.errname(err);\\r\\n  var message = syscall + ' ' + errname;\\r\\n  if (original)\\r\\n    message += ' ' + original;\\r\\n  var e = new Error(message);\\r\\n  e.code = errname;\\r\\n  e.errno = errname;\\r\\n  e.syscall = syscall;\\r\\n  return e;\\r\\n};\\r\\n\",\"path\":\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n\\nvar isWindows = process.platform === 'win32';\\nvar util = require('util');\\n\\n\\n// resolves . and .. elements in a path array with directory names there\\n// must be no slashes, empty elements, or device names (c:\\\\) in the array\\n// (so also no leading and trailing slashes - it does not distinguish\\n// relative and absolute paths)\\nfunction normalizeArray(parts, allowAboveRoot) {\\n  // if the path tries to go above the root, `up` ends up > 0\\n  var up = 0;\\n  for (var i = parts.length - 1; i >= 0; i--) {\\n    var last = parts[i];\\n    if (last === '.') {\\n      parts.splice(i, 1);\\n    } else if (last === '..') {\\n      parts.splice(i, 1);\\n      up++;\\n    } else if (up) {\\n      parts.splice(i, 1);\\n      up--;\\n    }\\n  }\\n\\n  // if the path is allowed to go above the root, restore leading ..s\\n  if (allowAboveRoot) {\\n    for (; up--; up) {\\n      parts.unshift('..');\\n    }\\n  }\\n\\n  return parts;\\n}\\n\\n\\nif (isWindows) {\\n  // Regex to split a windows path into three parts: [*, device, slash,\\n  // tail] windows-only\\n  var splitDeviceRe =\\n      /^([a-zA-Z]:|[\\\\\\\\\\\\/]{2}[^\\\\\\\\\\\\/]+[\\\\\\\\\\\\/]+[^\\\\\\\\\\\\/]+)?([\\\\\\\\\\\\/])?([\\\\s\\\\S]*?)$/;\\n\\n  // Regex to split the tail part of the above into [*, dir, basename, ext]\\n  var splitTailRe =\\n      /^([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\\\\\\\\\/]+?|)(\\\\.[^.\\\\/\\\\\\\\]*|))(?:[\\\\\\\\\\\\/]*)$/;\\n\\n  // Function to split a filename into [root, dir, basename, ext]\\n  // windows version\\n  var splitPath = function(filename) {\\n    // Separate device+slash from tail\\n    var result = splitDeviceRe.exec(filename),\\n        device = (result[1] || '') + (result[2] || ''),\\n        tail = result[3] || '';\\n    // Split the tail into dir, basename and extension\\n    var result2 = splitTailRe.exec(tail),\\n        dir = result2[1],\\n        basename = result2[2],\\n        ext = result2[3];\\n    return [device, dir, basename, ext];\\n  };\\n\\n  var normalizeUNCRoot = function(device) {\\n    return '\\\\\\\\\\\\\\\\' + device.replace(/^[\\\\\\\\\\\\/]+/, '').replace(/[\\\\\\\\\\\\/]+/g, '\\\\\\\\');\\n  };\\n\\n  // path.resolve([from ...], to)\\n  // windows version\\n  exports.resolve = function() {\\n    var resolvedDevice = '',\\n        resolvedTail = '',\\n        resolvedAbsolute = false;\\n\\n    for (var i = arguments.length - 1; i >= -1; i--) {\\n      var path;\\n      if (i >= 0) {\\n        path = arguments[i];\\n      } else if (!resolvedDevice) {\\n        path = process.cwd();\\n      } else {\\n        // Windows has the concept of drive-specific current working\\n        // directories. If we've resolved a drive letter but not yet an\\n        // absolute path, get cwd for that drive. We're sure the device is not\\n        // an unc path at this points, because unc paths are always absolute.\\n        path = process.env['=' + resolvedDevice];\\n        // Verify that a drive-local cwd was found and that it actually points\\n        // to our drive. If not, default to the drive's root.\\n        if (!path || path.substr(0, 3).toLowerCase() !==\\n            resolvedDevice.toLowerCase() + '\\\\\\\\') {\\n          path = resolvedDevice + '\\\\\\\\';\\n        }\\n      }\\n\\n      // Skip empty and invalid entries\\n      if (!util.isString(path)) {\\n        throw new TypeError('Arguments to path.resolve must be strings');\\n      } else if (!path) {\\n        continue;\\n      }\\n\\n      var result = splitDeviceRe.exec(path),\\n          device = result[1] || '',\\n          isUnc = device && device.charAt(1) !== ':',\\n          isAbsolute = exports.isAbsolute(path),\\n          tail = result[3];\\n\\n      if (device &&\\n          resolvedDevice &&\\n          device.toLowerCase() !== resolvedDevice.toLowerCase()) {\\n        // This path points to another device so it is not applicable\\n        continue;\\n      }\\n\\n      if (!resolvedDevice) {\\n        resolvedDevice = device;\\n      }\\n      if (!resolvedAbsolute) {\\n        resolvedTail = tail + '\\\\\\\\' + resolvedTail;\\n        resolvedAbsolute = isAbsolute;\\n      }\\n\\n      if (resolvedDevice && resolvedAbsolute) {\\n        break;\\n      }\\n    }\\n\\n    // Convert slashes to backslashes when `resolvedDevice` points to an UNC\\n    // root. Also squash multiple slashes into a single one where appropriate.\\n    if (isUnc) {\\n      resolvedDevice = normalizeUNCRoot(resolvedDevice);\\n    }\\n\\n    // At this point the path should be resolved to a full absolute path,\\n    // but handle relative paths to be safe (might happen when process.cwd()\\n    // fails)\\n\\n    // Normalize the tail path\\n\\n    function f(p) {\\n      return !!p;\\n    }\\n\\n    resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\\\\\\\/]+/).filter(f),\\n                                  !resolvedAbsolute).join('\\\\\\\\');\\n\\n    return (resolvedDevice + (resolvedAbsolute ? '\\\\\\\\' : '') + resolvedTail) ||\\n           '.';\\n  };\\n\\n  // windows version\\n  exports.normalize = function(path) {\\n    var result = splitDeviceRe.exec(path),\\n        device = result[1] || '',\\n        isUnc = device && device.charAt(1) !== ':',\\n        isAbsolute = exports.isAbsolute(path),\\n        tail = result[3],\\n        trailingSlash = /[\\\\\\\\\\\\/]$/.test(tail);\\n\\n    // If device is a drive letter, we'll normalize to lower case.\\n    if (device && device.charAt(1) === ':') {\\n      device = device[0].toLowerCase() + device.substr(1);\\n    }\\n\\n    // Normalize the tail path\\n    tail = normalizeArray(tail.split(/[\\\\\\\\\\\\/]+/).filter(function(p) {\\n      return !!p;\\n    }), !isAbsolute).join('\\\\\\\\');\\n\\n    if (!tail && !isAbsolute) {\\n      tail = '.';\\n    }\\n    if (tail && trailingSlash) {\\n      tail += '\\\\\\\\';\\n    }\\n\\n    // Convert slashes to backslashes when `device` points to an UNC root.\\n    // Also squash multiple slashes into a single one where appropriate.\\n    if (isUnc) {\\n      device = normalizeUNCRoot(device);\\n    }\\n\\n    return device + (isAbsolute ? '\\\\\\\\' : '') + tail;\\n  };\\n\\n  // windows version\\n  exports.isAbsolute = function(path) {\\n    var result = splitDeviceRe.exec(path),\\n        device = result[1] || '',\\n        isUnc = !!device && device.charAt(1) !== ':';\\n    // UNC paths are always absolute\\n    return !!result[2] || isUnc;\\n  };\\n\\n  // windows version\\n  exports.join = function() {\\n    function f(p) {\\n      if (!util.isString(p)) {\\n        throw new TypeError('Arguments to path.join must be strings');\\n      }\\n      return p;\\n    }\\n\\n    var paths = Array.prototype.filter.call(arguments, f);\\n    var joined = paths.join('\\\\\\\\');\\n\\n    // Make sure that the joined path doesn't start with two slashes, because\\n    // normalize() will mistake it for an UNC path then.\\n    //\\n    // This step is skipped when it is very clear that the user actually\\n    // intended to point at an UNC path. This is assumed when the first\\n    // non-empty string arguments starts with exactly two slashes followed by\\n    // at least one more non-slash character.\\n    //\\n    // Note that for normalize() to treat a path as an UNC path it needs to\\n    // have at least 2 components, so we don't filter for that here.\\n    // This means that the user can use join to construct UNC paths from\\n    // a server name and a share name; for example:\\n    //   path.join('//server', 'share') -> '\\\\\\\\\\\\\\\\server\\\\\\\\share\\\\')\\n    if (!/^[\\\\\\\\\\\\/]{2}[^\\\\\\\\\\\\/]/.test(paths[0])) {\\n      joined = joined.replace(/^[\\\\\\\\\\\\/]{2,}/, '\\\\\\\\');\\n    }\\n\\n    return exports.normalize(joined);\\n  };\\n\\n  // path.relative(from, to)\\n  // it will solve the relative path from 'from' to 'to', for instance:\\n  // from = 'C:\\\\\\\\orandea\\\\\\\\test\\\\\\\\aaa'\\n  // to = 'C:\\\\\\\\orandea\\\\\\\\impl\\\\\\\\bbb'\\n  // The output of the function should be: '..\\\\\\\\..\\\\\\\\impl\\\\\\\\bbb'\\n  // windows version\\n  exports.relative = function(from, to) {\\n    from = exports.resolve(from);\\n    to = exports.resolve(to);\\n\\n    // windows is not case sensitive\\n    var lowerFrom = from.toLowerCase();\\n    var lowerTo = to.toLowerCase();\\n\\n    function trim(arr) {\\n      var start = 0;\\n      for (; start < arr.length; start++) {\\n        if (arr[start] !== '') break;\\n      }\\n\\n      var end = arr.length - 1;\\n      for (; end >= 0; end--) {\\n        if (arr[end] !== '') break;\\n      }\\n\\n      if (start > end) return [];\\n      return arr.slice(start, end + 1);\\n    }\\n\\n    var toParts = trim(to.split('\\\\\\\\'));\\n\\n    var lowerFromParts = trim(lowerFrom.split('\\\\\\\\'));\\n    var lowerToParts = trim(lowerTo.split('\\\\\\\\'));\\n\\n    var length = Math.min(lowerFromParts.length, lowerToParts.length);\\n    var samePartsLength = length;\\n    for (var i = 0; i < length; i++) {\\n      if (lowerFromParts[i] !== lowerToParts[i]) {\\n        samePartsLength = i;\\n        break;\\n      }\\n    }\\n\\n    if (samePartsLength == 0) {\\n      return to;\\n    }\\n\\n    var outputParts = [];\\n    for (var i = samePartsLength; i < lowerFromParts.length; i++) {\\n      outputParts.push('..');\\n    }\\n\\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\\n\\n    return outputParts.join('\\\\\\\\');\\n  };\\n\\n  exports.sep = '\\\\\\\\';\\n  exports.delimiter = ';';\\n\\n} else /* posix */ {\\n\\n  // Split a filename into [root, dir, basename, ext], unix version\\n  // 'root' is just a slash, or nothing.\\n  var splitPathRe =\\n      /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;\\n  var splitPath = function(filename) {\\n    return splitPathRe.exec(filename).slice(1);\\n  };\\n\\n  // path.resolve([from ...], to)\\n  // posix version\\n  exports.resolve = function() {\\n    var resolvedPath = '',\\n        resolvedAbsolute = false;\\n\\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\\n      var path = (i >= 0) ? arguments[i] : process.cwd();\\n\\n      // Skip empty and invalid entries\\n      if (!util.isString(path)) {\\n        throw new TypeError('Arguments to path.resolve must be strings');\\n      } else if (!path) {\\n        continue;\\n      }\\n\\n      resolvedPath = path + '/' + resolvedPath;\\n      resolvedAbsolute = path.charAt(0) === '/';\\n    }\\n\\n    // At this point the path should be resolved to a full absolute path, but\\n    // handle relative paths to be safe (might happen when process.cwd() fails)\\n\\n    // Normalize the path\\n    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {\\n      return !!p;\\n    }), !resolvedAbsolute).join('/');\\n\\n    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\\n  };\\n\\n  // path.normalize(path)\\n  // posix version\\n  exports.normalize = function(path) {\\n    var isAbsolute = exports.isAbsolute(path),\\n        trailingSlash = path[path.length - 1] === '/',\\n        segments = path.split('/'),\\n        nonEmptySegments = [];\\n\\n    // Normalize the path\\n    for (var i = 0; i < segments.length; i++) {\\n      if (segments[i]) {\\n        nonEmptySegments.push(segments[i]);\\n      }\\n    }\\n    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');\\n\\n    if (!path && !isAbsolute) {\\n      path = '.';\\n    }\\n    if (path && trailingSlash) {\\n      path += '/';\\n    }\\n\\n    return (isAbsolute ? '/' : '') + path;\\n  };\\n\\n  // posix version\\n  exports.isAbsolute = function(path) {\\n    return path.charAt(0) === '/';\\n  };\\n\\n  // posix version\\n  exports.join = function() {\\n    var path = '';\\n    for (var i = 0; i < arguments.length; i++) {\\n      var segment = arguments[i];\\n      if (!util.isString(segment)) {\\n        throw new TypeError('Arguments to path.join must be strings');\\n      }\\n      if (segment) {\\n        if (!path) {\\n          path += segment;\\n        } else {\\n          path += '/' + segment;\\n        }\\n      }\\n    }\\n    return exports.normalize(path);\\n  };\\n\\n\\n  // path.relative(from, to)\\n  // posix version\\n  exports.relative = function(from, to) {\\n    from = exports.resolve(from).substr(1);\\n    to = exports.resolve(to).substr(1);\\n\\n    function trim(arr) {\\n      var start = 0;\\n      for (; start < arr.length; start++) {\\n        if (arr[start] !== '') break;\\n      }\\n\\n      var end = arr.length - 1;\\n      for (; end >= 0; end--) {\\n        if (arr[end] !== '') break;\\n      }\\n\\n      if (start > end) return [];\\n      return arr.slice(start, end + 1);\\n    }\\n\\n    var fromParts = trim(from.split('/'));\\n    var toParts = trim(to.split('/'));\\n\\n    var length = Math.min(fromParts.length, toParts.length);\\n    var samePartsLength = length;\\n    for (var i = 0; i < length; i++) {\\n      if (fromParts[i] !== toParts[i]) {\\n        samePartsLength = i;\\n        break;\\n      }\\n    }\\n\\n    var outputParts = [];\\n    for (var i = samePartsLength; i < fromParts.length; i++) {\\n      outputParts.push('..');\\n    }\\n\\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\\n\\n    return outputParts.join('/');\\n  };\\n\\n  exports.sep = '/';\\n  exports.delimiter = ':';\\n}\\n\\nexports.dirname = function(path) {\\n  var result = splitPath(path),\\n      root = result[0],\\n      dir = result[1];\\n\\n  if (!root && !dir) {\\n    // No dirname whatsoever\\n    return '.';\\n  }\\n\\n  if (dir) {\\n    // It has a dirname, strip trailing slash\\n    dir = dir.substr(0, dir.length - 1);\\n  }\\n\\n  return root + dir;\\n};\\n\\n\\nexports.basename = function(path, ext) {\\n  var f = splitPath(path)[2];\\n  // TODO: make this comparison case-insensitive on windows?\\n  if (ext && f.substr(-1 * ext.length) === ext) {\\n    f = f.substr(0, f.length - ext.length);\\n  }\\n  return f;\\n};\\n\\n\\nexports.extname = function(path) {\\n  return splitPath(path)[3];\\n};\\n\\n\\nexports.exists = util.deprecate(function(path, callback) {\\n  require('fs').exists(path, callback);\\n}, 'path.exists is now called `fs.exists`.');\\n\\n\\nexports.existsSync = util.deprecate(function(path) {\\n  return require('fs').existsSync(path);\\n}, 'path.existsSync is now called `fs.existsSync`.');\\n\\n\\nif (isWindows) {\\n  exports._makeLong = function(path) {\\n    // Note: this will *probably* throw somewhere.\\n    if (!util.isString(path))\\n      return path;\\n\\n    if (!path) {\\n      return '';\\n    }\\n\\n    var resolvedPath = exports.resolve(path);\\n\\n    if (/^[a-zA-Z]\\\\:\\\\\\\\/.test(resolvedPath)) {\\n      // path is local filesystem path, which needs to be converted\\n      // to long UNC path.\\n      return '\\\\\\\\\\\\\\\\?\\\\\\\\' + resolvedPath;\\n    } else if (/^\\\\\\\\\\\\\\\\[^?.]/.test(resolvedPath)) {\\n      // path is network UNC path, which needs to be converted\\n      // to long UNC path.\\n      return '\\\\\\\\\\\\\\\\?\\\\\\\\UNC\\\\\\\\' + resolvedPath.substring(2);\\n    }\\n\\n    return path;\\n  };\\n} else {\\n  exports._makeLong = function(path) {\\n    return path;\\n  };\\n}\\n\",\"fs\":\"// Maintainers, keep in mind that ES1-style octal literals (`0666`) are not\\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\\n\\n//changes const => var\\n//changes 0o666 => 438 [octal represntation]\\n\\n'use strict';\\n\\nvar SlowBuffer = require('buffer').SlowBuffer;\\nvar util = require('util');\\nvar pathModule = require('path');\\n\\nvar binding = process.binding('fs_wrap');\\nvar constants = require('constants');\\nvar fs = exports;\\nvar Buffer = require('buffer').Buffer;\\nvar Stream = require('stream').Stream;\\nvar EventEmitter = require('events');\\nvar FSReqWrap = binding.FSReqWrap;\\nvar FSEvent = process.binding('fs_event_wrap').FSEvent;\\n\\nvar Readable = Stream.Readable;\\nvar Writable = Stream.Writable;\\n\\nvar kMinPoolSpace = 128;\\nvar kMaxLength = require('buffer').kMaxLength;\\n\\nvar O_APPEND = constants.O_APPEND || 0;\\nvar O_CREAT = constants.O_CREAT || 0;\\nvar O_EXCL = constants.O_EXCL || 0;\\nvar O_RDONLY = constants.O_RDONLY || 0;\\nvar O_RDWR = constants.O_RDWR || 0;\\nvar O_SYNC = constants.O_SYNC || 0;\\nvar O_TRUNC = constants.O_TRUNC || 0;\\nvar O_WRONLY = constants.O_WRONLY || 0;\\n\\nvar isWindows = process.platform === 'win32';\\n\\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\\nvar errnoException = util._errnoException;\\n\\nfunction throwOptionsError(options) {\\n  throw new TypeError('Expected options to be either an object or a string, ' +\\n    'but got ' + typeof options + ' instead');\\n}\\n\\nfunction rethrow() {\\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\\n  // is fairly slow to generate.\\n  if (DEBUG) {\\n    var backtrace = new Error();\\n    return function(err) {\\n      if (err) {\\n        backtrace.stack = err.name + ': ' + err.message +\\n                          backtrace.stack.substr(backtrace.name.length);\\n        throw backtrace;\\n      }\\n    };\\n  }\\n\\n  return function(err) {\\n    if (err) {\\n      throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\\n    }\\n  };\\n}\\n\\nfunction maybeCallback(cb) {\\n  return typeof cb === 'function' ? cb : rethrow();\\n}\\n\\n// Ensure that callbacks run in the global context. Only use this function\\n// for callbacks that are passed to the binding layer, callbacks that are\\n// invoked from JS already run in the proper scope.\\nfunction makeCallback(cb) {\\n  if (cb === undefined) {\\n    return rethrow();\\n  }\\n\\n  if (typeof cb !== 'function') {\\n    throw new TypeError('callback must be a function');\\n  }\\n\\n  return function() {\\n    return cb.apply(null, arguments);\\n  };\\n}\\n\\nfunction assertEncoding(encoding) {\\n  if (encoding && !Buffer.isEncoding(encoding)) {\\n    throw new Error('Unknown encoding: ' + encoding);\\n  }\\n}\\n\\nfunction nullCheck(path, callback) {\\n  if (('' + path).indexOf('\\\\u0000') !== -1) {\\n    var er = new Error('Path must be a string without null bytes.');\\n    er.code = 'ENOENT';\\n    if (typeof callback !== 'function')\\n      throw er;\\n    process.nextTick(callback, er);\\n    return false;\\n  }\\n  return true;\\n}\\n\\nfunction isFd(path) {\\n  return (path >>> 0) === path;\\n}\\n\\n// Static method to set the stats properties on a Stats object.\\nfs.Stats = function(\\n    dev,\\n    mode,\\n    nlink,\\n    uid,\\n    gid,\\n    rdev,\\n    blksize,\\n    ino,\\n    size,\\n    blocks,\\n    atim_msec,\\n    mtim_msec,\\n    ctim_msec,\\n    birthtim_msec) {\\n  this.dev = dev;\\n  this.mode = mode;\\n  this.nlink = nlink;\\n  this.uid = uid;\\n  this.gid = gid;\\n  this.rdev = rdev;\\n  this.blksize = blksize;\\n  this.ino = ino;\\n  this.size = size;\\n  this.blocks = blocks;\\n  this.atime = new Date(atim_msec);\\n  this.mtime = new Date(mtim_msec);\\n  this.ctime = new Date(ctim_msec);\\n  this.birthtime = new Date(birthtim_msec);\\n};\\n\\n// Create a C++ binding to the function which creates a Stats object.\\nbinding.FSInitialize(fs.Stats);\\n\\nfs.Stats.prototype._checkModeProperty = function(property) {\\n  return ((this.mode & constants.S_IFMT) === property);\\n};\\n\\nfs.Stats.prototype.isDirectory = function() {\\n  return this._checkModeProperty(constants.S_IFDIR);\\n};\\n\\nfs.Stats.prototype.isFile = function() {\\n  return this._checkModeProperty(constants.S_IFREG);\\n};\\n\\nfs.Stats.prototype.isBlockDevice = function() {\\n  return this._checkModeProperty(constants.S_IFBLK);\\n};\\n\\nfs.Stats.prototype.isCharacterDevice = function() {\\n  return this._checkModeProperty(constants.S_IFCHR);\\n};\\n\\nfs.Stats.prototype.isSymbolicLink = function() {\\n  return this._checkModeProperty(constants.S_IFLNK);\\n};\\n\\nfs.Stats.prototype.isFIFO = function() {\\n  return this._checkModeProperty(constants.S_IFIFO);\\n};\\n\\nfs.Stats.prototype.isSocket = function() {\\n  return this._checkModeProperty(constants.S_IFSOCK);\\n};\\n\\n// Don't allow mode to accidentally be overwritten.\\n['F_OK', 'R_OK', 'W_OK', 'X_OK'].forEach(function(key) {\\n  Object.defineProperty(fs, key, {\\n    enumerable: true, value: constants[key] || 0, writable: false\\n  });\\n});\\n\\nfs.access = function(path, mode, callback) {\\n  if (typeof mode === 'function') {\\n    callback = mode;\\n    mode = fs.F_OK;\\n  } else if (typeof callback !== 'function') {\\n    throw new TypeError('callback must be a function');\\n  }\\n\\n  if (!nullCheck(path, callback))\\n    return;\\n\\n  mode = mode | 0;\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.access(pathModule._makeLong(path), mode, req);\\n};\\n\\nfs.accessSync = function(path, mode) {\\n  nullCheck(path);\\n\\n  if (mode === undefined)\\n    mode = fs.F_OK;\\n  else\\n    mode = mode | 0;\\n\\n  binding.access(pathModule._makeLong(path), mode);\\n};\\n\\nfs.exists = function(path, callback) {\\n  if (!nullCheck(path, cb)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = cb;\\n  binding.stat(pathModule._makeLong(path), req);\\n  function cb(err, stats) {\\n    if (callback) callback(err ? false : true);\\n  }\\n};\\n\\nfs.existsSync = function(path) {\\n  try {\\n    nullCheck(path);\\n    binding.stat(pathModule._makeLong(path));\\n    return true;\\n  } catch (e) {\\n    return false;\\n  }\\n};\\n\\nfs.readFile = function(path, options, callback_) {\\n  var callback = maybeCallback(arguments[arguments.length - 1]);\\n\\n  if (!options || typeof options === 'function') {\\n    options = { encoding: null, flag: 'r' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, flag: 'r' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  var encoding = options.encoding;\\n  assertEncoding(encoding);\\n\\n  var flag = options.flag || 'r';\\n\\n  if (!nullCheck(path, callback))\\n    return;\\n\\n  var context = new ReadFileContext(callback, encoding);\\n  context.isUserFd = isFd(path); // file descriptor ownership\\n  var req = new FSReqWrap();\\n  req.context = context;\\n  req.oncomplete = readFileAfterOpen;\\n\\n  if (context.isUserFd) {\\n    process.nextTick(function() {\\n      req.oncomplete(null, path);\\n    });\\n    return;\\n  }\\n\\n  binding.open(pathModule._makeLong(path),\\n               stringToFlags(flag),\\n               438,\\n               req);\\n};\\n\\nvar kReadFileBufferLength = 8 * 1024;\\n\\nfunction ReadFileContext(callback, encoding) {\\n  this.fd = undefined;\\n  this.isUserFd = undefined;\\n  this.size = undefined;\\n  this.callback = callback;\\n  this.buffers = null;\\n  this.buffer = null;\\n  this.pos = 0;\\n  this.encoding = encoding;\\n  this.err = null;\\n}\\n\\nReadFileContext.prototype.read = function() {\\n  var buffer;\\n  var offset;\\n  var length;\\n\\n  if (this.size === 0) {\\n    buffer = this.buffer = new SlowBuffer(kReadFileBufferLength);\\n    offset = 0;\\n    length = kReadFileBufferLength;\\n  } else {\\n    buffer = this.buffer;\\n    offset = this.pos;\\n    length = this.size - this.pos;\\n  }\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = readFileAfterRead;\\n  req.context = this;\\n\\n  binding.read(this.fd, buffer, offset, length, -1, req);\\n};\\n\\nReadFileContext.prototype.close = function(err) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = readFileAfterClose;\\n  req.context = this;\\n  this.err = err;\\n\\n  if (this.isUserFd) {\\n    process.nextTick(function() {\\n      req.oncomplete(null);\\n    });\\n    return;\\n  }\\n\\n  binding.close(this.fd, req);\\n};\\n\\nfunction readFileAfterOpen(err, fd) {\\n  var context = this.context;\\n\\n  if (err) {\\n    context.callback(err);\\n    return;\\n  }\\n\\n  context.fd = fd;\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = readFileAfterStat;\\n  req.context = context;\\n  binding.fstat(fd, req);\\n}\\n\\nfunction readFileAfterStat(err, st) {\\n  var context = this.context;\\n\\n  if (err)\\n    return context.close(err);\\n\\n  var size = context.size = st.isFile() ? st.size : 0;\\n\\n  if (size === 0) {\\n    context.buffers = [];\\n    context.read();\\n    return;\\n  }\\n\\n  if (size > kMaxLength) {\\n    err = new RangeError('File size is greater than possible Buffer: ');\\n    // err = new RangeError('File size is greater than possible Buffer: ' +\\n    //                      `0x${kMaxLength.toString(16)} bytes`);\\n    return context.close(err);\\n  }\\n\\n  context.buffer = new SlowBuffer(size);\\n  context.read();\\n}\\n\\nfunction readFileAfterRead(err, bytesRead) {\\n  var context = this.context;\\n\\n  if (err)\\n    return context.close(err);\\n\\n  if (bytesRead === 0)\\n    return context.close();\\n\\n  context.pos += bytesRead;\\n\\n  if (context.size !== 0) {\\n    if (context.pos === context.size)\\n      context.close();\\n    else\\n      context.read();\\n  } else {\\n    // unknown size, just read until we don't get bytes.\\n    context.buffers.push(context.buffer.slice(0, bytesRead));\\n    context.read();\\n  }\\n}\\n\\nfunction readFileAfterClose(err) {\\n  var context = this.context;\\n  var buffer = null;\\n  var callback = context.callback;\\n\\n  if (context.err)\\n    return callback(context.err);\\n\\n  if (context.size === 0)\\n    buffer = Buffer.concat(context.buffers, context.pos);\\n  else if (context.pos < context.size)\\n    buffer = context.buffer.slice(0, context.pos);\\n  else\\n    buffer = context.buffer;\\n\\n  if (err) return callback(err, buffer);\\n\\n  if (context.encoding) {\\n    return tryToString(buffer, context.encoding, callback);\\n  }\\n\\n  callback(null, buffer);\\n}\\n\\nfunction tryToString(buf, encoding, callback) {\\n  var e = null;\\n  try {\\n    buf = buf.toString(encoding);\\n  } catch (err) {\\n    e = err;\\n  }\\n  callback(e, buf);\\n}\\n\\nfs.readFileSync = function(path, options) {\\n  if (!options) {\\n    options = { encoding: null, flag: 'r' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, flag: 'r' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  var encoding = options.encoding;\\n  assertEncoding(encoding);\\n\\n  var flag = options.flag || 'r';\\n  var isUserFd = isFd(path); // file descriptor ownership\\n  var fd = isUserFd ? path : fs.openSync(path, flag, 438);\\n\\n  var st;\\n  var size;\\n  var threw = true;\\n  try {\\n    st = fs.fstatSync(fd);\\n    size = st.isFile() ? st.size : 0;\\n    threw = false;\\n  } finally {\\n    if (threw && !isUserFd) fs.closeSync(fd);\\n  }\\n\\n  var pos = 0;\\n  var buffer; // single buffer with file data\\n  var buffers; // list for when size is unknown\\n\\n  if (size === 0) {\\n    buffers = [];\\n  } else {\\n    threw = true;\\n    try {\\n      buffer = Buffer(size);\\n      threw = false;\\n    } finally {\\n      if (threw && !isUserFd) fs.closeSync(fd);\\n    }\\n  }\\n\\n  var done = false;\\n  var bytesRead;\\n\\n  while (!done) {\\n    threw = true;\\n    try {\\n      if (size !== 0) {\\n        bytesRead = fs.readSync(fd, buffer, pos, size - pos);\\n      } else {\\n        // the kernel lies about many files.\\n        // Go ahead and try to read some bytes.\\n        buffer = Buffer(8192);\\n        bytesRead = fs.readSync(fd, buffer, 0, 8192);\\n        if (bytesRead) {\\n          buffers.push(buffer.slice(0, bytesRead));\\n        }\\n      }\\n      threw = false;\\n    } finally {\\n      if (threw && !isUserFd) fs.closeSync(fd);\\n    }\\n\\n    pos += bytesRead;\\n    done = (bytesRead === 0) || (size !== 0 && pos >= size);\\n  }\\n\\n  if (!isUserFd)\\n    fs.closeSync(fd);\\n\\n  if (size === 0) {\\n    // data was collected into the buffers list.\\n    buffer = Buffer.concat(buffers, pos);\\n  } else if (pos < size) {\\n    buffer = buffer.slice(0, pos);\\n  }\\n\\n  if (encoding) buffer = buffer.toString(encoding);\\n  return buffer;\\n};\\n\\n\\n// Used by binding.open and friends\\nfunction stringToFlags(flag) {\\n  // Only mess with strings\\n  if (typeof flag !== 'string') {\\n    return flag;\\n  }\\n\\n  switch (flag) {\\n    case 'r' : return O_RDONLY;\\n    case 'rs' : // fall through\\n    case 'sr' : return O_RDONLY | O_SYNC;\\n    case 'r+' : return O_RDWR;\\n    case 'rs+' : // fall through\\n    case 'sr+' : return O_RDWR | O_SYNC;\\n\\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\\n    case 'wx' : // fall through\\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\\n\\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\\n    case 'wx+': // fall through\\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\\n\\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\\n    case 'ax' : // fall through\\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\\n\\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\\n    case 'ax+': // fall through\\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\\n  }\\n\\n  throw new Error('Unknown file open flag: ' + flag);\\n}\\n\\n// exported but hidden, only used by test/simple/test-fs-open-flags.js\\nObject.defineProperty(exports, '_stringToFlags', {\\n  enumerable: false,\\n  value: stringToFlags\\n});\\n\\n\\n// Yes, the follow could be easily DRYed up but I provide the explicit\\n// list to make the arguments clear.\\n\\nfs.close = function(fd, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.close(fd, req);\\n};\\n\\nfs.closeSync = function(fd) {\\n  return binding.close(fd);\\n};\\n\\nfunction modeNum(m, def) {\\n  if (typeof m === 'number')\\n    return m;\\n  if (typeof m === 'string')\\n    return parseInt(m, 8);\\n  if (def)\\n    return modeNum(def);\\n  return undefined;\\n}\\n\\nfs.open = function(path, flags, mode, callback_) {\\n  var callback = makeCallback(arguments[arguments.length - 1]);\\n  mode = modeNum(mode, 438);\\n\\n  if (!nullCheck(path, callback)) return;\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n\\n  binding.open(pathModule._makeLong(path),\\n               stringToFlags(flags),\\n               mode,\\n               req);\\n};\\n\\nfs.openSync = function(path, flags, mode) {\\n  mode = modeNum(mode, 438);\\n  nullCheck(path);\\n  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);\\n};\\n\\nfs.read = function(fd, buffer, offset, length, position, callback) {\\n  if (!(Buffer.isBuffer(buffer))) {\\n    // legacy string interface (fd, length, position, encoding, callback)\\n    var cb = arguments[4],\\n        encoding = arguments[3];\\n\\n    assertEncoding(encoding);\\n\\n    position = arguments[2];\\n    length = arguments[1];\\n    buffer = Buffer(length);\\n    offset = 0;\\n\\n    callback = function(err, bytesRead) {\\n      if (!cb) return;\\n      if (err) return cb(err);\\n\\n      if (bytesRead > 0) {\\n        tryToStringWithEnd(buffer, encoding, bytesRead, cb);\\n      } else {\\n        (cb)(err, '', bytesRead);\\n      }\\n    };\\n  }\\n\\n  function wrapper(err, bytesRead) {\\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\\n    callback && callback(err, bytesRead || 0, buffer);\\n  }\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = wrapper;\\n\\n  binding.read(fd, buffer, offset, length, position, req);\\n};\\n\\nfunction tryToStringWithEnd(buf, encoding, end, callback) {\\n  var e;\\n  try {\\n    buf = buf.toString(encoding, 0, end);\\n  } catch (err) {\\n    e = err;\\n  }\\n  callback(e, buf, end);\\n}\\n\\nfs.readSync = function(fd, buffer, offset, length, position) {\\n  var legacy = false;\\n  var encoding;\\n\\n  if (!(util.isBuffer(buffer))) {\\n    // legacy string interface (fd, length, position, encoding, callback)\\n    legacy = true;\\n    encoding = arguments[3];\\n\\n    assertEncoding(encoding);\\n\\n    position = arguments[2];\\n    length = arguments[1];\\n    buffer = Buffer(length);\\n\\n    offset = 0;\\n  }\\n\\n  var r = binding.read(fd, buffer, offset, length, position);\\n  if (!legacy) {\\n    return r;\\n  }\\n\\n  var str = (r > 0) ? buffer.toString(encoding, 0, r) : '';\\n  return [str, r];\\n};\\n\\n// usage:\\n//  fs.write(fd, buffer, offset, length[, position], callback);\\n// OR\\n//  fs.write(fd, string[, position[, encoding]], callback);\\nfs.write = function(fd, buffer, offset, length, position, callback) {\\n  function wrapper(err, written) {\\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\\n    callback(err, written || 0, buffer);\\n  }\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = wrapper;\\n\\n  if (util.isBuffer(buffer)) {\\n    // if no position is passed then assume null\\n    if (typeof position === 'function') {\\n      callback = position;\\n      position = null;\\n    }\\n    callback = maybeCallback(callback);\\n    return binding.writeBuffer(fd, buffer, offset, length, position, req);\\n  }\\n\\n  if (typeof buffer !== 'string')\\n    buffer += '';\\n  if (typeof position !== 'function') {\\n    if (typeof offset === 'function') {\\n      position = offset;\\n      offset = null;\\n    } else {\\n      position = length;\\n    }\\n    length = 'utf8';\\n  }\\n  callback = maybeCallback(position);\\n  return binding.writeString(fd, buffer, offset, length, req);\\n};\\n\\n// usage:\\n//  fs.writeSync(fd, buffer, offset, length[, position]);\\n// OR\\n//  fs.writeSync(fd, string[, position[, encoding]]);\\nfs.writeSync = function(fd, buffer, offset, length, position) {\\n  if (util.isBuffer(buffer)) {\\n    if (position === undefined)\\n      position = null;\\n    return binding.writeBuffer(fd, buffer, offset, length, position);\\n  }\\n  if (typeof buffer !== 'string')\\n    buffer += '';\\n  if (offset === undefined)\\n    offset = null;\\n  return binding.writeString(fd, buffer, offset, length, position);\\n};\\n\\nfs.rename = function(oldPath, newPath, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(oldPath, callback)) return;\\n  if (!nullCheck(newPath, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.rename(pathModule._makeLong(oldPath),\\n                 pathModule._makeLong(newPath),\\n                 req);\\n};\\n\\nfs.renameSync = function(oldPath, newPath) {\\n  nullCheck(oldPath);\\n  nullCheck(newPath);\\n  return binding.rename(pathModule._makeLong(oldPath),\\n                        pathModule._makeLong(newPath));\\n};\\n\\nfs.truncate = function(path, len, callback) {\\n  if (typeof path === 'number') {\\n    return fs.ftruncate(path, len, callback);\\n  }\\n  if (typeof len === 'function') {\\n    callback = len;\\n    len = 0;\\n  } else if (len === undefined) {\\n    len = 0;\\n  }\\n\\n  callback = maybeCallback(callback);\\n  fs.open(path, 'r+', function(er, fd) {\\n    if (er) return callback(er);\\n    var req = new FSReqWrap();\\n    req.oncomplete = function ftruncateCb(er) {\\n      fs.close(fd, function(er2) {\\n        callback(er || er2);\\n      });\\n    };\\n    binding.ftruncate(fd, len, req);\\n  });\\n};\\n\\nfs.truncateSync = function(path, len) {\\n  if (typeof path === 'number') {\\n    // legacy\\n    return fs.ftruncateSync(path, len);\\n  }\\n  if (len === undefined) {\\n    len = 0;\\n  }\\n  // allow error to be thrown, but still close fd.\\n  var fd = fs.openSync(path, 'r+');\\n  var ret;\\n\\n  try {\\n    ret = fs.ftruncateSync(fd, len);\\n  } finally {\\n    fs.closeSync(fd);\\n  }\\n  return ret;\\n};\\n\\nfs.ftruncate = function(fd, len, callback) {\\n  if (typeof len === 'function') {\\n    callback = len;\\n    len = 0;\\n  } else if (len === undefined) {\\n    len = 0;\\n  }\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.ftruncate(fd, len, req);\\n};\\n\\nfs.ftruncateSync = function(fd, len) {\\n  if (len === undefined) {\\n    len = 0;\\n  }\\n  return binding.ftruncate(fd, len);\\n};\\n\\nfs.rmdir = function(path, callback) {\\n  callback = maybeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.rmdir(pathModule._makeLong(path), req);\\n};\\n\\nfs.rmdirSync = function(path) {\\n  nullCheck(path);\\n  return binding.rmdir(pathModule._makeLong(path));\\n};\\n\\nfs.fdatasync = function(fd, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fdatasync(fd, req);\\n};\\n\\nfs.fdatasyncSync = function(fd) {\\n  return binding.fdatasync(fd);\\n};\\n\\nfs.fsync = function(fd, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fsync(fd, req);\\n};\\n\\nfs.fsyncSync = function(fd) {\\n  return binding.fsync(fd);\\n};\\n\\nfs.mkdir = function(path, mode, callback) {\\n  if (typeof mode === 'function') callback = mode;\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.mkdir(pathModule._makeLong(path),\\n                modeNum(mode, 511),\\n                req);\\n};\\n\\nfs.mkdirSync = function(path, mode) {\\n  nullCheck(path);\\n  return binding.mkdir(pathModule._makeLong(path),\\n                       modeNum(mode, 511));\\n};\\n\\nfs.readdir = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.readdir(pathModule._makeLong(path), req);\\n};\\n\\nfs.readdirSync = function(path) {\\n  nullCheck(path);\\n  return binding.readdir(pathModule._makeLong(path));\\n};\\n\\nfs.fstat = function(fd, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fstat(fd, req);\\n};\\n\\nfs.lstat = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.lstat(pathModule._makeLong(path), req);\\n};\\n\\nfs.stat = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.stat(pathModule._makeLong(path), req);\\n};\\n\\nfs.fstatSync = function(fd) {\\n  return binding.fstat(fd);\\n};\\n\\nfs.lstatSync = function(path) {\\n  nullCheck(path);\\n  return binding.lstat(pathModule._makeLong(path));\\n};\\n\\nfs.statSync = function(path) {\\n  nullCheck(path);\\n  return binding.stat(pathModule._makeLong(path));\\n};\\n\\nfs.readlink = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.readlink(pathModule._makeLong(path), req);\\n};\\n\\nfs.readlinkSync = function(path) {\\n  nullCheck(path);\\n  return binding.readlink(pathModule._makeLong(path));\\n};\\n\\nfunction preprocessSymlinkDestination(path, type, linkPath) {\\n  if (!isWindows) {\\n    // No preprocessing is needed on Unix.\\n    return path;\\n  } else if (type === 'junction') {\\n    // Junctions paths need to be absolute and \\\\\\\\?\\\\-prefixed.\\n    // A relative target is relative to the link's parent directory.\\n    path = pathModule.resolve(linkPath, '..', path);\\n    return pathModule._makeLong(path);\\n  } else {\\n    // Windows symlinks don't tolerate forward slashes.\\n    return ('' + path).replace(/\\\\//g, '\\\\\\\\');\\n  }\\n}\\n\\nfs.symlink = function(target, path, type_, callback_) {\\n  var type = (typeof type_ === 'string' ? type_ : null);\\n  var callback = makeCallback(arguments[arguments.length - 1]);\\n\\n  if (!nullCheck(target, callback)) return;\\n  if (!nullCheck(path, callback)) return;\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n\\n  binding.symlink(preprocessSymlinkDestination(target, type, path),\\n                  pathModule._makeLong(path),\\n                  type,\\n                  req);\\n};\\n\\nfs.symlinkSync = function(target, path, type) {\\n  type = (typeof type === 'string' ? type : null);\\n\\n  nullCheck(target);\\n  nullCheck(path);\\n\\n  return binding.symlink(preprocessSymlinkDestination(target, type, path),\\n                         pathModule._makeLong(path),\\n                         type);\\n};\\n\\nfs.link = function(srcpath, dstpath, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(srcpath, callback)) return;\\n  if (!nullCheck(dstpath, callback)) return;\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n\\n  binding.link(pathModule._makeLong(srcpath),\\n               pathModule._makeLong(dstpath),\\n               req);\\n};\\n\\nfs.linkSync = function(srcpath, dstpath) {\\n  nullCheck(srcpath);\\n  nullCheck(dstpath);\\n  return binding.link(pathModule._makeLong(srcpath),\\n                      pathModule._makeLong(dstpath));\\n};\\n\\nfs.unlink = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.unlink(pathModule._makeLong(path), req);\\n};\\n\\nfs.unlinkSync = function(path) {\\n  nullCheck(path);\\n  return binding.unlink(pathModule._makeLong(path));\\n};\\n\\nfs.fchmod = function(fd, mode, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fchmod(fd, modeNum(mode), req);\\n};\\n\\nfs.fchmodSync = function(fd, mode) {\\n  return binding.fchmod(fd, modeNum(mode));\\n};\\n\\nif (constants.hasOwnProperty('O_SYMLINK')) {\\n  fs.lchmod = function(path, mode, callback) {\\n    callback = maybeCallback(callback);\\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\\n      if (err) {\\n        callback(err);\\n        return;\\n      }\\n      // prefer to return the chmod error, if one occurs,\\n      // but still try to close, and report closing errors if they occur.\\n      fs.fchmod(fd, mode, function(err) {\\n        fs.close(fd, function(err2) {\\n          callback(err || err2);\\n        });\\n      });\\n    });\\n  };\\n\\n  fs.lchmodSync = function(path, mode) {\\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\\n\\n    // prefer to return the chmod error, if one occurs,\\n    // but still try to close, and report closing errors if they occur.\\n    var err, err2, ret;\\n    try {\\n      ret = fs.fchmodSync(fd, mode);\\n    } catch (er) {\\n      err = er;\\n    }\\n    try {\\n      fs.closeSync(fd);\\n    } catch (er) {\\n      err2 = er;\\n    }\\n    if (err || err2) throw (err || err2);\\n    return ret;\\n  };\\n}\\n\\n\\nfs.chmod = function(path, mode, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.chmod(pathModule._makeLong(path),\\n                modeNum(mode),\\n                req);\\n};\\n\\nfs.chmodSync = function(path, mode) {\\n  nullCheck(path);\\n  return binding.chmod(pathModule._makeLong(path), modeNum(mode));\\n};\\n\\nif (constants.hasOwnProperty('O_SYMLINK')) {\\n  fs.lchown = function(path, uid, gid, callback) {\\n    callback = maybeCallback(callback);\\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\\n      if (err) {\\n        callback(err);\\n        return;\\n      }\\n      fs.fchown(fd, uid, gid, callback);\\n    });\\n  };\\n\\n  fs.lchownSync = function(path, uid, gid) {\\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\\n    return fs.fchownSync(fd, uid, gid);\\n  };\\n}\\n\\nfs.fchown = function(fd, uid, gid, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fchown(fd, uid, gid, req);\\n};\\n\\nfs.fchownSync = function(fd, uid, gid) {\\n  return binding.fchown(fd, uid, gid);\\n};\\n\\nfs.chown = function(path, uid, gid, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.chown(pathModule._makeLong(path), uid, gid, req);\\n};\\n\\nfs.chownSync = function(path, uid, gid) {\\n  nullCheck(path);\\n  return binding.chown(pathModule._makeLong(path), uid, gid);\\n};\\n\\n// converts Date or number to a fractional UNIX timestamp\\nfunction toUnixTimestamp(time) {\\n  if (typeof time === 'string' && +time == time) {\\n    return +time;\\n  }\\n  if (typeof time === 'number') {\\n    if (!Number.isFinite(time) || time < 0) {\\n      return Date.now() / 1000;\\n    }\\n    return time;\\n  }\\n  if (util.isDate(time)) {\\n    // convert to 123.456 UNIX timestamp\\n    return time.getTime() / 1000;\\n  }\\n  throw new Error('Cannot parse time: ' + time);\\n}\\n\\n// exported for unit tests, not for public consumption\\nfs._toUnixTimestamp = toUnixTimestamp;\\n\\nfs.utimes = function(path, atime, mtime, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.utimes(pathModule._makeLong(path),\\n                 toUnixTimestamp(atime),\\n                 toUnixTimestamp(mtime),\\n                 req);\\n};\\n\\nfs.utimesSync = function(path, atime, mtime) {\\n  nullCheck(path);\\n  atime = toUnixTimestamp(atime);\\n  mtime = toUnixTimestamp(mtime);\\n  binding.utimes(pathModule._makeLong(path), atime, mtime);\\n};\\n\\nfs.futimes = function(fd, atime, mtime, callback) {\\n  atime = toUnixTimestamp(atime);\\n  mtime = toUnixTimestamp(mtime);\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.futimes(fd, atime, mtime, req);\\n};\\n\\nfs.futimesSync = function(fd, atime, mtime) {\\n  atime = toUnixTimestamp(atime);\\n  mtime = toUnixTimestamp(mtime);\\n  binding.futimes(fd, atime, mtime);\\n};\\n\\nfunction writeAll(fd, isUserFd, buffer, offset, length, position, callback_) {\\n  var callback = maybeCallback(arguments[arguments.length - 1]);\\n\\n  // write(fd, buffer, offset, length, position, callback)\\n  fs.write(fd, buffer, offset, length, position, function(writeErr, written) {\\n    if (writeErr) {\\n      if (isUserFd) {\\n        if (callback) callback(writeErr);\\n      } else {\\n        fs.close(fd, function() {\\n          if (callback) callback(writeErr);\\n        });\\n      }\\n    } else {\\n      if (written === length) {\\n        if (isUserFd) {\\n          if (callback) callback(null);\\n        } else {\\n          fs.close(fd, callback);\\n        }\\n      } else {\\n        offset += written;\\n        length -= written;\\n        if (position !== null) {\\n          position += written;\\n        }\\n        writeAll(fd, isUserFd, buffer, offset, length, position, callback);\\n      }\\n    }\\n  });\\n}\\n\\nfs.writeFile = function(path, data, options, callback_) {\\n  var callback = maybeCallback(arguments[arguments.length - 1]);\\n\\n  if (!options || typeof options === 'function') {\\n    options = { encoding: 'utf8', mode: 438, flag: 'w' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, mode: 438, flag: 'w' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  assertEncoding(options.encoding);\\n\\n  var flag = options.flag || 'w';\\n\\n  if (isFd(path)) {\\n    writeFd(path, true);\\n    return;\\n  }\\n\\n  fs.open(path, flag, options.mode, function(openErr, fd) {\\n    if (openErr) {\\n      if (callback) callback(openErr);\\n    } else {\\n      writeFd(fd, false);\\n    }\\n  });\\n\\n  function writeFd(fd, isUserFd) {\\n    var buffer = (util.isBuffer(data)) ? data : Buffer('' + data,\\n        options.encoding || 'utf8');\\n    var position = /a/.test(flag) ? null : 0;\\n\\n    writeAll(fd, isUserFd, buffer, 0, buffer.length, position, callback);\\n  }\\n};\\n\\nfs.writeFileSync = function(path, data, options) {\\n  if (!options) {\\n    options = { encoding: 'utf8', mode: 438, flag: 'w' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, mode: 438, flag: 'w' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  assertEncoding(options.encoding);\\n\\n  var flag = options.flag || 'w';\\n  var isUserFd = isFd(path); // file descriptor ownership\\n  var fd = isUserFd ? path : fs.openSync(path, flag, options.mode);\\n\\n  if (!(util.isBuffer(data))) {\\n    data = Buffer('' + data, options.encoding || 'utf8');\\n  }\\n  var offset = 0;\\n  var length = data.length;\\n  var position = /a/.test(flag) ? null : 0;\\n  try {\\n    while (length > 0) {\\n      var written = fs.writeSync(fd, data, offset, length, position);\\n      offset += written;\\n      length -= written;\\n      if (position !== null) {\\n        position += written;\\n      }\\n    }\\n  } finally {\\n    if (!isUserFd) fs.closeSync(fd);\\n  }\\n};\\n\\nfs.appendFile = function(path, data, options, callback_) {\\n  var callback = maybeCallback(arguments[arguments.length - 1]);\\n\\n  if (!options || typeof options === 'function') {\\n    options = { encoding: 'utf8', mode: 438, flag: 'a' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, mode: 438, flag: 'a' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  if (!options.flag)\\n    options = util._extend({ flag: 'a' }, options);\\n\\n  // force append behavior when using a supplied file descriptor\\n  if (isFd(path))\\n    options.flag = 'a';\\n\\n  fs.writeFile(path, data, options, callback);\\n};\\n\\nfs.appendFileSync = function(path, data, options) {\\n  if (!options) {\\n    options = { encoding: 'utf8', mode: 438, flag: 'a' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, mode: 438, flag: 'a' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  if (!options.flag)\\n    options = util._extend({ flag: 'a' }, options);\\n\\n  // force append behavior when using a supplied file descriptor\\n  if (isFd(path))\\n    options.flag = 'a';\\n\\n  fs.writeFileSync(path, data, options);\\n};\\n\\nfunction FSWatcher() {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n  this._handle = new FSEvent();\\n  this._handle.owner = this;\\n\\n  this._handle.onchange = function(status, event, filename) {\\n    if (status < 0) {\\n      self._handle.close();\\n      var error = errnoException(status, 'watch ' + filename);\\n      error.filename = filename;\\n      self.emit('error', error);\\n    } else {\\n      self.emit('change', event, filename);\\n    }\\n  };\\n}\\nutil.inherits(FSWatcher, EventEmitter);\\n\\nFSWatcher.prototype.start = function(filename, persistent, recursive) {\\n  nullCheck(filename);\\n  var err = this._handle.start(pathModule._makeLong(filename),\\n                               persistent,\\n                               recursive);\\n  if (err) {\\n    this._handle.close();\\n    var error = errnoException(err, 'watch ' + filename);\\n    error.filename = filename;\\n    throw error;\\n  }\\n};\\n\\nFSWatcher.prototype.close = function() {\\n  this._handle.close();\\n};\\n\\nfs.watch = function(filename) {\\n  nullCheck(filename);\\n  var watcher;\\n  var options;\\n  var listener;\\n\\n  if (arguments[1] !== null && typeof arguments[1] === 'object') {\\n    options = arguments[1];\\n    listener = arguments[2];\\n  } else {\\n    options = {};\\n    listener = arguments[1];\\n  }\\n\\n  if (options.persistent === undefined) options.persistent = true;\\n  if (options.recursive === undefined) options.recursive = false;\\n\\n  watcher = new FSWatcher();\\n  watcher.start(filename, options.persistent, options.recursive);\\n\\n  if (listener) {\\n    watcher.addListener('change', listener);\\n  }\\n\\n  return watcher;\\n};\\n\\n\\n// Stat Change Watchers\\n\\nfunction StatWatcher() {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n  this._handle = new binding.StatWatcher();\\n\\n  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\\n  // the sake of backwards compatibility\\n  var oldStatus = -1;\\n\\n  this._handle.onchange = function(current, previous, newStatus) {\\n    if (oldStatus === -1 &&\\n        newStatus === -1 &&\\n        current.nlink === previous.nlink) return;\\n\\n    oldStatus = newStatus;\\n    self.emit('change', current, previous);\\n  };\\n\\n  this._handle.onstop = function() {\\n    self.emit('stop');\\n  };\\n}\\nutil.inherits(StatWatcher, EventEmitter);\\n\\n\\nStatWatcher.prototype.start = function(filename, persistent, interval) {\\n  nullCheck(filename);\\n  this._handle.start(pathModule._makeLong(filename), persistent, interval);\\n};\\n\\n\\nStatWatcher.prototype.stop = function() {\\n  this._handle.stop();\\n};\\n\\n\\nfunction _Map (){\\n  this.list = {};\\n  this.set = function(name, val){\\n    this.list[name] = val;\\n  };\\n\\n  this.get = function(name){\\n    return this.list[name];\\n  };\\n\\n  this.delete = function(name){\\n    delete this.list[name];\\n  };\\n}\\n\\nvar statWatchers = new _Map();\\n\\nfs.watchFile = function(filename, options, listener) {\\n  nullCheck(filename);\\n  filename = pathModule.resolve(filename);\\n  var stat;\\n\\n  var defaults = {\\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\\n    // a little on the slow side but let's stick with it for now to keep\\n    // behavioral changes to a minimum.\\n    interval: 5007,\\n    persistent: true\\n  };\\n\\n  if (options !== null && typeof options === 'object') {\\n    options = util._extend(defaults, options);\\n  } else {\\n    listener = options;\\n    options = defaults;\\n  }\\n\\n  if (typeof listener !== 'function') {\\n    throw new Error('watchFile requires a listener function');\\n  }\\n\\n  stat = statWatchers.get(filename);\\n\\n  if (stat === undefined) {\\n    stat = new StatWatcher();\\n    stat.start(filename, options.persistent, options.interval);\\n    statWatchers.set(filename, stat);\\n  }\\n\\n  stat.addListener('change', listener);\\n  return stat;\\n};\\n\\nfs.unwatchFile = function(filename, listener) {\\n  nullCheck(filename);\\n  filename = pathModule.resolve(filename);\\n  var stat = statWatchers.get(filename);\\n\\n  if (stat === undefined) return;\\n\\n  if (typeof listener === 'function') {\\n    stat.removeListener('change', listener);\\n  } else {\\n    stat.removeAllListeners('change');\\n  }\\n\\n  if (stat.listenerCount('change') === 0) {\\n    stat.stop();\\n    statWatchers.delete(filename);\\n  }\\n};\\n\\n// Regexp that finds the next partion of a (partial) path\\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\\nif (isWindows) {\\n  var nextPartRe = /(.*?)(?:[\\\\/\\\\\\\\]+|$)/g;\\n} else {\\n  var nextPartRe = /(.*?)(?:[\\\\/]+|$)/g;\\n}\\n\\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\\\\\'.\\nif (isWindows) {\\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\\\\\\\/]{2}[^\\\\\\\\\\\\/]+[\\\\\\\\\\\\/][^\\\\\\\\\\\\/]+)?[\\\\\\\\\\\\/]*/;\\n} else {\\n  var splitRootRe = /^[\\\\/]*/;\\n}\\n\\nfs.realpathSync = function realpathSync(p, cache) {\\n  // make p is absolute\\n  p = pathModule.resolve(p);\\n\\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\\n    return cache[p];\\n  }\\n\\n  var original = p,\\n      seenLinks = {},\\n      knownHard = {};\\n\\n  // current character position in p\\n  var pos;\\n  // the partial path so far, including a trailing slash if any\\n  var current;\\n  // the partial path without a trailing slash (except when pointing at a root)\\n  var base;\\n  // the partial path scanned in the previous round, with slash\\n  var previous;\\n\\n  start();\\n\\n  function start() {\\n    // Skip over roots\\n    var m = splitRootRe.exec(p);\\n    pos = m[0].length;\\n    current = m[0];\\n    base = m[0];\\n    previous = '';\\n\\n    // On windows, check that the root exists. On unix there is no need.\\n    if (isWindows && !knownHard[base]) {\\n      fs.lstatSync(base);\\n      knownHard[base] = true;\\n    }\\n  }\\n\\n  // walk down the path, swapping out linked pathparts for their real\\n  // values\\n  // NB: p.length changes.\\n  while (pos < p.length) {\\n    // find the next part\\n    nextPartRe.lastIndex = pos;\\n    var result = nextPartRe.exec(p);\\n    previous = current;\\n    current += result[0];\\n    base = previous + result[1];\\n    pos = nextPartRe.lastIndex;\\n\\n    // continue if not a symlink\\n    if (knownHard[base] || (cache && cache[base] === base)) {\\n      continue;\\n    }\\n\\n    var resolvedLink;\\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\\n      // some known symbolic link.  no need to stat again.\\n      resolvedLink = cache[base];\\n    } else {\\n      var stat = fs.lstatSync(base);\\n      if (!stat.isSymbolicLink()) {\\n        knownHard[base] = true;\\n        if (cache) cache[base] = base;\\n        continue;\\n      }\\n\\n      // read the link if it wasn't read before\\n      // dev/ino always return 0 on windows, so skip the check.\\n      var linkTarget = null;\\n      if (!isWindows) {\\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\\n        if (seenLinks.hasOwnProperty(id)) {\\n          linkTarget = seenLinks[id];\\n        }\\n      }\\n      if (linkTarget === null) {\\n        fs.statSync(base);\\n        linkTarget = fs.readlinkSync(base);\\n      }\\n      resolvedLink = pathModule.resolve(previous, linkTarget);\\n      // track this, if given a cache.\\n      if (cache) cache[base] = resolvedLink;\\n      if (!isWindows) seenLinks[id] = linkTarget;\\n    }\\n\\n    // resolve the link, then start over\\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\\n    start();\\n  }\\n\\n  if (cache) cache[original] = p;\\n\\n  return p;\\n};\\n\\n\\nfs.realpath = function realpath(p, cache, cb) {\\n  if (typeof cb !== 'function') {\\n    cb = maybeCallback(cache);\\n    cache = null;\\n  }\\n\\n  // make p is absolute\\n  p = pathModule.resolve(p);\\n\\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\\n    return process.nextTick(cb.bind(null, null, cache[p]));\\n  }\\n\\n  var original = p,\\n      seenLinks = {},\\n      knownHard = {};\\n\\n  // current character position in p\\n  var pos;\\n  // the partial path so far, including a trailing slash if any\\n  var current;\\n  // the partial path without a trailing slash (except when pointing at a root)\\n  var base;\\n  // the partial path scanned in the previous round, with slash\\n  var previous;\\n\\n  start();\\n\\n  function start() {\\n    // Skip over roots\\n    var m = splitRootRe.exec(p);\\n    pos = m[0].length;\\n    current = m[0];\\n    base = m[0];\\n    previous = '';\\n\\n    // On windows, check that the root exists. On unix there is no need.\\n    if (isWindows && !knownHard[base]) {\\n      fs.lstat(base, function(err) {\\n        if (err) return cb(err);\\n        knownHard[base] = true;\\n        LOOP();\\n      });\\n    } else {\\n      process.nextTick(LOOP);\\n    }\\n  }\\n\\n  // walk down the path, swapping out linked pathparts for their real\\n  // values\\n  function LOOP() {\\n    // stop if scanned past end of path\\n    if (pos >= p.length) {\\n      if (cache) cache[original] = p;\\n      return cb(null, p);\\n    }\\n\\n    // find the next part\\n    nextPartRe.lastIndex = pos;\\n    var result = nextPartRe.exec(p);\\n    previous = current;\\n    current += result[0];\\n    base = previous + result[1];\\n    pos = nextPartRe.lastIndex;\\n\\n    // continue if not a symlink\\n    if (knownHard[base] || (cache && cache[base] === base)) {\\n      return process.nextTick(LOOP);\\n    }\\n\\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\\n      // known symbolic link.  no need to stat again.\\n      return gotResolvedLink(cache[base]);\\n    }\\n\\n    return fs.lstat(base, gotStat);\\n  }\\n\\n  function gotStat(err, stat) {\\n    if (err) return cb(err);\\n\\n    // if not a symlink, skip to the next path part\\n    if (!stat.isSymbolicLink()) {\\n      knownHard[base] = true;\\n      if (cache) cache[base] = base;\\n      return process.nextTick(LOOP);\\n    }\\n\\n    // stat & read the link if not read before\\n    // call gotTarget as soon as the link target is known\\n    // dev/ino always return 0 on windows, so skip the check.\\n    if (!isWindows) {\\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\\n      if (seenLinks.hasOwnProperty(id)) {\\n        return gotTarget(null, seenLinks[id], base);\\n      }\\n    }\\n    fs.stat(base, function(err) {\\n      if (err) return cb(err);\\n\\n      fs.readlink(base, function(err, target) {\\n        if (!isWindows) seenLinks[id] = target;\\n        gotTarget(err, target);\\n      });\\n    });\\n  }\\n\\n  function gotTarget(err, target, base) {\\n    if (err) return cb(err);\\n\\n    var resolvedLink = pathModule.resolve(previous, target);\\n    if (cache) cache[base] = resolvedLink;\\n    gotResolvedLink(resolvedLink);\\n  }\\n\\n  function gotResolvedLink(resolvedLink) {\\n    // resolve the link, then start over\\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\\n    start();\\n  }\\n};\\n\\n\\nvar pool;\\nvar poolUsed = 0;\\nfunction allocNewPool(poolSize) {\\n  pool = Buffer(poolSize);\\n  poolUsed = 0;\\n}\\n\\n\\nfs.createReadStream = function(path, options) {\\n  return new ReadStream(path, options);\\n};\\n\\nutil.inherits(ReadStream, Readable);\\nfs.ReadStream = ReadStream;\\n\\nfunction ReadStream(path, options) {\\n  if (!(this instanceof ReadStream))\\n    return new ReadStream(path, options);\\n\\n  if (options === undefined)\\n    options = {};\\n  else if (typeof options === 'string')\\n    options = { encoding: options };\\n  else if (options === null || typeof options !== 'object')\\n    throw new TypeError('\\\"options\\\" argument must be a string or an object');\\n\\n  // a little bit bigger buffer and water marks by default\\n  options = Object.create(options);\\n  if (options.highWaterMark === undefined)\\n    options.highWaterMark = 64 * 1024;\\n\\n  Readable.call(this, options);\\n\\n  this.path = path;\\n  this.fd = options.fd === undefined ? null : options.fd;\\n  this.flags = options.flags === undefined ? 'r' : options.flags;\\n  this.mode = options.mode === undefined ? 438 : options.mode;\\n\\n  this.start = options.start;\\n  this.end = options.end;\\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\\n  this.pos = undefined;\\n\\n  if (this.start !== undefined) {\\n    if (typeof this.start !== 'number') {\\n      throw new TypeError('start must be a Number');\\n    }\\n    if (this.end === undefined) {\\n      this.end = Infinity;\\n    } else if (typeof this.end !== 'number') {\\n      throw new TypeError('end must be a Number');\\n    }\\n\\n    if (this.start > this.end) {\\n      throw new Error('start must be <= end');\\n    }\\n\\n    this.pos = this.start;\\n  }\\n\\n  if (typeof this.fd !== 'number')\\n    this.open();\\n\\n  this.on('end', function() {\\n    if (this.autoClose) {\\n      this.destroy();\\n    }\\n  });\\n}\\n\\nfs.FileReadStream = fs.ReadStream; // support the legacy name\\n\\nReadStream.prototype.open = function() {\\n  var self = this;\\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\\n    if (er) {\\n      if (self.autoClose) {\\n        self.destroy();\\n      }\\n      self.emit('error', er);\\n      return;\\n    }\\n\\n    self.fd = fd;\\n    self.emit('open', fd);\\n    // start the flow of data.\\n    self.read();\\n  });\\n};\\n\\nReadStream.prototype._read = function(n) {\\n  if (typeof this.fd !== 'number')\\n    return this.once('open', function() {\\n      this._read(n);\\n    });\\n\\n  if (this.destroyed)\\n    return;\\n\\n  if (!pool || pool.length - poolUsed < kMinPoolSpace) {\\n    // discard the old pool.\\n    pool = null;\\n    allocNewPool(this._readableState.highWaterMark);\\n  }\\n\\n  // Grab another reference to the pool in the case that while we're\\n  // in the thread pool another read() finishes up the pool, and\\n  // allocates a new one.\\n  var thisPool = pool;\\n  var toRead = Math.min(pool.length - poolUsed, n);\\n  var start = poolUsed;\\n\\n  if (this.pos !== undefined)\\n    toRead = Math.min(this.end - this.pos + 1, toRead);\\n\\n  // already read everything we were supposed to read!\\n  // treat as EOF.\\n  if (toRead <= 0)\\n    return this.push(null);\\n\\n  // the actual read.\\n  var self = this;\\n  fs.read(this.fd, pool, poolUsed, toRead, this.pos, onread);\\n\\n  // move the pool positions, and internal position for reading.\\n  if (this.pos !== undefined)\\n    this.pos += toRead;\\n  poolUsed += toRead;\\n\\n  function onread(er, bytesRead) {\\n    if (er) {\\n      if (self.autoClose) {\\n        self.destroy();\\n      }\\n      self.emit('error', er);\\n    } else {\\n      var b = null;\\n      if (bytesRead > 0)\\n        b = thisPool.slice(start, start + bytesRead);\\n\\n      self.push(b);\\n    }\\n  }\\n};\\n\\n\\nReadStream.prototype.destroy = function() {\\n  if (this.destroyed)\\n    return;\\n  this.destroyed = true;\\n  this.close();\\n};\\n\\n\\nReadStream.prototype.close = function(cb) {\\n  var self = this;\\n  if (cb)\\n    this.once('close', cb);\\n  if (this.closed || typeof this.fd !== 'number') {\\n    if (typeof this.fd !== 'number') {\\n      this.once('open', close);\\n      return;\\n    }\\n    return process.nextTick(this.emit.bind(this, 'close'));\\n  }\\n  this.closed = true;\\n  close();\\n\\n  function close(fd) {\\n    fs.close(fd || self.fd, function(er) {\\n      if (er)\\n        self.emit('error', er);\\n      else\\n        self.emit('close');\\n    });\\n    self.fd = null;\\n  }\\n};\\n\\n\\nfs.createWriteStream = function(path, options) {\\n  return new WriteStream(path, options);\\n};\\n\\nutil.inherits(WriteStream, Writable);\\nfs.WriteStream = WriteStream;\\nfunction WriteStream(path, options) {\\n  if (!(this instanceof WriteStream))\\n    return new WriteStream(path, options);\\n\\n  if (options === undefined)\\n    options = {};\\n  else if (typeof options === 'string')\\n    options = { encoding: options };\\n  else if (options === null || typeof options !== 'object')\\n    throw new TypeError('\\\"options\\\" argument must be a string or an object');\\n\\n  options = Object.create(options);\\n\\n  Writable.call(this, options);\\n\\n  this.path = path;\\n  this.fd = options.fd === undefined ? null : options.fd;\\n  this.flags = options.flags === undefined ? 'w' : options.flags;\\n  this.mode = options.mode === undefined ? 438 : options.mode;\\n\\n  this.start = options.start;\\n  this.pos = undefined;\\n  this.bytesWritten = 0;\\n\\n  if (this.start !== undefined) {\\n    if (typeof this.start !== 'number') {\\n      throw new TypeError('start must be a Number');\\n    }\\n    if (this.start < 0) {\\n      throw new Error('start must be >= zero');\\n    }\\n\\n    this.pos = this.start;\\n  }\\n\\n  if (options.encoding)\\n    this.setDefaultEncoding(options.encoding);\\n\\n  if (typeof this.fd !== 'number')\\n    this.open();\\n\\n  // dispose on finish.\\n  this.once('finish', this.close);\\n}\\n\\nfs.FileWriteStream = fs.WriteStream; // support the legacy name\\n\\n\\nWriteStream.prototype.open = function() {\\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\\n    if (er) {\\n      this.destroy();\\n      this.emit('error', er);\\n      return;\\n    }\\n\\n    this.fd = fd;\\n    this.emit('open', fd);\\n  }.bind(this));\\n};\\n\\n\\nWriteStream.prototype._write = function(data, encoding, cb) {\\n  if (!(util.isBuffer(data)))\\n    return this.emit('error', new Error('Invalid data'));\\n\\n  if (typeof this.fd !== 'number')\\n    return this.once('open', function() {\\n      this._write(data, encoding, cb);\\n    });\\n\\n  var self = this;\\n  fs.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {\\n    if (er) {\\n      self.destroy();\\n      return cb(er);\\n    }\\n    self.bytesWritten += bytes;\\n    cb();\\n  });\\n\\n  if (this.pos !== undefined)\\n    this.pos += data.length;\\n};\\n\\n\\nfunction writev(fd, chunks, position, callback) {\\n  function wrapper(err, written) {\\n    // Retain a reference to chunks so that they can't be GC'ed too soon.\\n    callback(err, written || 0, chunks);\\n  }\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = wrapper;\\n  binding.writeBuffers(fd, chunks, position, req);\\n}\\n\\n\\nWriteStream.prototype._writev = function(data, cb) {\\n  if (typeof this.fd !== 'number')\\n    return this.once('open', function() {\\n      this._writev(data, cb);\\n    });\\n\\n  var self = this;\\n  var len = data.length;\\n  var chunks = new Array(len);\\n  var size = 0;\\n\\n  for (var i = 0; i < len; i++) {\\n    var chunk = data[i].chunk;\\n\\n    chunks[i] = chunk;\\n    size += chunk.length;\\n  }\\n\\n  writev(this.fd, chunks, this.pos, function(er, bytes) {\\n    if (er) {\\n      self.destroy();\\n      return cb(er);\\n    }\\n    self.bytesWritten += bytes;\\n    cb();\\n  });\\n\\n  if (this.pos !== undefined)\\n    this.pos += size;\\n};\\n\\n\\nWriteStream.prototype.destroy = ReadStream.prototype.destroy;\\nWriteStream.prototype.close = ReadStream.prototype.close;\\n\\n// There is no shutdown() for files.\\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\\n\\n\\n// SyncWriteStream is internal. DO NOT USE.\\n// Temporary hack for process.stdout and process.stderr when piped to files.\\nfunction SyncWriteStream(fd, options) {\\n  Stream.call(this);\\n\\n  options = options || {};\\n\\n  this.fd = fd;\\n  this.writable = true;\\n  this.readable = false;\\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\\n}\\n\\nutil.inherits(SyncWriteStream, Stream);\\n\\n\\n// Export\\nObject.defineProperty(fs, 'SyncWriteStream', {\\n    configurable: true,\\n    writable: true,\\n    value: SyncWriteStream\\n});\\n\\nSyncWriteStream.prototype.write = function(data, arg1, arg2) {\\n  var encoding, cb;\\n\\n  // parse arguments\\n  if (arg1) {\\n    if (typeof arg1 === 'string') {\\n      encoding = arg1;\\n      cb = arg2;\\n    } else if (typeof arg1 === 'function') {\\n      cb = arg1;\\n    } else {\\n      throw new Error('bad arg');\\n    }\\n  }\\n  assertEncoding(encoding);\\n\\n  // Change strings to buffers. SLOW\\n  if (typeof data === 'string') {\\n    data = Buffer(data, encoding);\\n  }\\n\\n  fs.writeSync(this.fd, data, 0, data.length);\\n\\n  if (cb) {\\n    process.nextTick(cb);\\n  }\\n\\n  return true;\\n};\\n\\n\\nSyncWriteStream.prototype.end = function(data, arg1, arg2) {\\n  if (data) {\\n    this.write(data, arg1, arg2);\\n  }\\n  this.destroy();\\n};\\n\\n\\nSyncWriteStream.prototype.destroy = function() {\\n  if (this.autoClose)\\n    fs.closeSync(this.fd);\\n  this.fd = null;\\n  this.emit('close');\\n  return true;\\n};\\n\\nSyncWriteStream.prototype.destroySoon = SyncWriteStream.prototype.destroy;\\n\",\"url\":\"'use strict';\\r\\n\\r\\n// var punycode = require('punycode');\\r\\n\\r\\nexports.parse = urlParse;\\r\\nexports.resolve = urlResolve;\\r\\nexports.resolveObject = urlResolveObject;\\r\\nexports.format = urlFormat;\\r\\n\\r\\nexports.Url = Url;\\r\\n\\r\\nfunction Url() {\\r\\n  this.protocol = null;\\r\\n  this.slashes = null;\\r\\n  this.auth = null;\\r\\n  this.host = null;\\r\\n  this.port = null;\\r\\n  this.hostname = null;\\r\\n  this.hash = null;\\r\\n  this.search = null;\\r\\n  this.query = null;\\r\\n  this.pathname = null;\\r\\n  this.path = null;\\r\\n  this.href = null;\\r\\n}\\r\\n\\r\\n// Reference: RFC 3986, RFC 1808, RFC 2396\\r\\n\\r\\n// define these here so at least they only have to be\\r\\n// compiled once on the first module load.\\r\\nvar protocolPattern = /^([a-z0-9.+-]+:)/i;\\r\\nvar portPattern = /:[0-9]*$/;\\r\\n\\r\\n// Special case for a simple path URL\\r\\nvar simplePathPattern = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/;\\r\\n\\r\\n// RFC 2396: characters reserved for delimiting URLs.\\r\\n// We actually just auto-escape these.\\r\\nvar delims = ['<', '>', '\\\"', '`', ' ', '\\\\r', '\\\\n', '\\\\t'];\\r\\n\\r\\n// RFC 2396: characters not allowed for various reasons.\\r\\nvar unwise = ['{', '}', '|', '\\\\\\\\', '^', '`'].concat(delims);\\r\\n\\r\\n// Allowed by RFCs, but cause of XSS attacks.  Always escape these.\\r\\nvar autoEscape = ['\\\\''].concat(unwise);\\r\\n\\r\\n// Characters that are never ever allowed in a hostname.\\r\\n// Note that any invalid chars are also handled, but these\\r\\n// are the ones that are *expected* to be seen, so we fast-path them.\\r\\nvar nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape);\\r\\nvar hostEndingChars = ['/', '?', '#'];\\r\\nvar hostnameMaxLen = 255;\\r\\nvar hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;\\r\\nvar hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;\\r\\n// protocols that can allow \\\"unsafe\\\" and \\\"unwise\\\" chars.\\r\\nvar unsafeProtocol = {\\r\\n  'javascript': true,\\r\\n  'javascript:': true\\r\\n};\\r\\n// protocols that never have a hostname.\\r\\nvar hostlessProtocol = {\\r\\n  'javascript': true,\\r\\n  'javascript:': true\\r\\n};\\r\\n// protocols that always contain a // bit.\\r\\nvar slashedProtocol = {\\r\\n  'http': true,\\r\\n  'https': true,\\r\\n  'ftp': true,\\r\\n  'gopher': true,\\r\\n  'file': true,\\r\\n  'http:': true,\\r\\n  'https:': true,\\r\\n  'ftp:': true,\\r\\n  'gopher:': true,\\r\\n  'file:': true\\r\\n};\\r\\nvar querystring = require('querystring');\\r\\n\\r\\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\\r\\n  if (url instanceof Url) return url;\\r\\n\\r\\n  var u = new Url();\\r\\n  u.parse(url, parseQueryString, slashesDenoteHost);\\r\\n  return u;\\r\\n}\\r\\n\\r\\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\\r\\n  if (typeof url !== 'string') {\\r\\n    throw new TypeError('Parameter \\\"url\\\" must be a string, not ' + typeof url);\\r\\n  }\\r\\n\\r\\n  // Copy chrome, IE, opera backslash-handling behavior.\\r\\n  // Back slashes before the query string get converted to forward slashes\\r\\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\\r\\n  var queryIndex = url.indexOf('?'),\\r\\n      splitter =\\r\\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\\r\\n      uSplit = url.split(splitter),\\r\\n      slashRegex = /\\\\\\\\/g;\\r\\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\\r\\n  url = uSplit.join(splitter);\\r\\n\\r\\n  var rest = url;\\r\\n\\r\\n  // trim before proceeding.\\r\\n  // This is to support parse stuff like \\\"  http://foo.com  \\\\n\\\"\\r\\n  rest = rest.trim();\\r\\n\\r\\n  if (!slashesDenoteHost && url.split('#').length === 1) {\\r\\n    // Try fast path regexp\\r\\n    var simplePath = simplePathPattern.exec(rest);\\r\\n    if (simplePath) {\\r\\n      this.path = rest;\\r\\n      this.href = rest;\\r\\n      this.pathname = simplePath[1];\\r\\n      if (simplePath[2]) {\\r\\n        this.search = simplePath[2];\\r\\n        if (parseQueryString) {\\r\\n          this.query = querystring.parse(this.search.substr(1));\\r\\n        } else {\\r\\n          this.query = this.search.substr(1);\\r\\n        }\\r\\n      } else if (parseQueryString) {\\r\\n        this.search = '';\\r\\n        this.query = {};\\r\\n      }\\r\\n      return this;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var proto = protocolPattern.exec(rest);\\r\\n  if (proto) {\\r\\n    proto = proto[0];\\r\\n    var lowerProto = proto.toLowerCase();\\r\\n    this.protocol = lowerProto;\\r\\n    rest = rest.substr(proto.length);\\r\\n  }\\r\\n\\r\\n  // figure out if it's got a host\\r\\n  // user@server is *always* interpreted as a hostname, and url\\r\\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\\r\\n  // how the browser resolves relative URLs.\\r\\n  if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {\\r\\n    var slashes = rest.substr(0, 2) === '//';\\r\\n    if (slashes && !(proto && hostlessProtocol[proto])) {\\r\\n      rest = rest.substr(2);\\r\\n      this.slashes = true;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (!hostlessProtocol[proto] &&\\r\\n      (slashes || (proto && !slashedProtocol[proto]))) {\\r\\n\\r\\n    // there's a hostname.\\r\\n    // the first instance of /, ?, ;, or # ends the host.\\r\\n    //\\r\\n    // If there is an @ in the hostname, then non-host chars *are* allowed\\r\\n    // to the left of the last @ sign, unless some host-ending character\\r\\n    // comes *before* the @-sign.\\r\\n    // URLs are obnoxious.\\r\\n    //\\r\\n    // ex:\\r\\n    // http://a@b@c/ => user:a@b host:c\\r\\n    // http://a@b?@c => user:a host:b path:/?@c\\r\\n\\r\\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\\r\\n    // Review our test case against browsers more comprehensively.\\r\\n\\r\\n    // find the first instance of any hostEndingChars\\r\\n    var hostEnd = -1;\\r\\n    for (var i = 0; i < hostEndingChars.length; i++) {\\r\\n      var hec = rest.indexOf(hostEndingChars[i]);\\r\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\\r\\n        hostEnd = hec;\\r\\n    }\\r\\n\\r\\n    // at this point, either we have an explicit point where the\\r\\n    // auth portion cannot go past, or the last @ char is the decider.\\r\\n    var auth, atSign;\\r\\n    if (hostEnd === -1) {\\r\\n      // atSign can be anywhere.\\r\\n      atSign = rest.lastIndexOf('@');\\r\\n    } else {\\r\\n      // atSign must be in auth portion.\\r\\n      // http://a@b/c@d => host:b auth:a path:/c@d\\r\\n      atSign = rest.lastIndexOf('@', hostEnd);\\r\\n    }\\r\\n\\r\\n    // Now we have a portion which is definitely the auth.\\r\\n    // Pull that off.\\r\\n    if (atSign !== -1) {\\r\\n      auth = rest.slice(0, atSign);\\r\\n      rest = rest.slice(atSign + 1);\\r\\n      this.auth = decodeURIComponent(auth);\\r\\n    }\\r\\n\\r\\n    // the host is the remaining to the left of the first non-host char\\r\\n    hostEnd = -1;\\r\\n    for (var i = 0; i < nonHostChars.length; i++) {\\r\\n      var hec = rest.indexOf(nonHostChars[i]);\\r\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\\r\\n        hostEnd = hec;\\r\\n    }\\r\\n    // if we still have not hit it, then the entire thing is a host.\\r\\n    if (hostEnd === -1)\\r\\n      hostEnd = rest.length;\\r\\n\\r\\n    this.host = rest.slice(0, hostEnd);\\r\\n    rest = rest.slice(hostEnd);\\r\\n\\r\\n    // pull out port.\\r\\n    this.parseHost();\\r\\n\\r\\n    // we've indicated that there is a hostname,\\r\\n    // so even if it's empty, it has to be present.\\r\\n    this.hostname = this.hostname || '';\\r\\n\\r\\n    // if hostname begins with [ and ends with ]\\r\\n    // assume that it's an IPv6 address.\\r\\n    var ipv6Hostname = this.hostname[0] === '[' &&\\r\\n        this.hostname[this.hostname.length - 1] === ']';\\r\\n\\r\\n    // validate a little.\\r\\n    if (!ipv6Hostname) {\\r\\n      var hostparts = this.hostname.split(/\\\\./);\\r\\n      for (var i = 0, l = hostparts.length; i < l; i++) {\\r\\n        var part = hostparts[i];\\r\\n        if (!part) continue;\\r\\n        if (!part.match(hostnamePartPattern)) {\\r\\n          var newpart = '';\\r\\n          for (var j = 0, k = part.length; j < k; j++) {\\r\\n            if (part.charCodeAt(j) > 127) {\\r\\n              // we replace non-ASCII char with a temporary placeholder\\r\\n              // we need this to make sure size of hostname is not\\r\\n              // broken by replacing non-ASCII by nothing\\r\\n              newpart += 'x';\\r\\n            } else {\\r\\n              newpart += part[j];\\r\\n            }\\r\\n          }\\r\\n          // we test again with ASCII char only\\r\\n          if (!newpart.match(hostnamePartPattern)) {\\r\\n            var validParts = hostparts.slice(0, i);\\r\\n            var notHost = hostparts.slice(i + 1);\\r\\n            var bit = part.match(hostnamePartStart);\\r\\n            if (bit) {\\r\\n              validParts.push(bit[1]);\\r\\n              notHost.unshift(bit[2]);\\r\\n            }\\r\\n            if (notHost.length) {\\r\\n              rest = '/' + notHost.join('.') + rest;\\r\\n            }\\r\\n            this.hostname = validParts.join('.');\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (this.hostname.length > hostnameMaxLen) {\\r\\n      this.hostname = '';\\r\\n    } else {\\r\\n      // hostnames are always lower case.\\r\\n      this.hostname = this.hostname.toLowerCase();\\r\\n    }\\r\\n\\r\\n    if (!ipv6Hostname) {\\r\\n      // IDNA Support: Returns a punycoded representation of \\\"domain\\\".\\r\\n      // It only converts parts of the domain name that\\r\\n      // have non-ASCII characters, i.e. it doesn't matter if\\r\\n      // you call it with a domain that already is ASCII-only.\\r\\n      // this.hostname = punycode.toASCII(this.hostname);\\r\\n    }\\r\\n\\r\\n    var p = this.port ? ':' + this.port : '';\\r\\n    var h = this.hostname || '';\\r\\n    this.host = h + p;\\r\\n\\r\\n    // strip [ and ] from the hostname\\r\\n    // the host field still retains them, though\\r\\n    if (ipv6Hostname) {\\r\\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\\r\\n      if (rest[0] !== '/') {\\r\\n        rest = '/' + rest;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // now rest is set to the post-host stuff.\\r\\n  // chop off any delim chars.\\r\\n  if (!unsafeProtocol[lowerProto]) {\\r\\n\\r\\n    // First, make 100% sure that any \\\"autoEscape\\\" chars get\\r\\n    // escaped, even if encodeURIComponent doesn't think they\\r\\n    // need to be.\\r\\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\\r\\n      var ae = autoEscape[i];\\r\\n      if (rest.indexOf(ae) === -1)\\r\\n        continue;\\r\\n      var esc = encodeURIComponent(ae);\\r\\n      if (esc === ae) {\\r\\n        esc = escape(ae);\\r\\n      }\\r\\n      rest = rest.split(ae).join(esc);\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n  // chop off from the tail first.\\r\\n  var hash = rest.indexOf('#');\\r\\n  if (hash !== -1) {\\r\\n    // got a fragment string.\\r\\n    this.hash = rest.substr(hash);\\r\\n    rest = rest.slice(0, hash);\\r\\n  }\\r\\n  var qm = rest.indexOf('?');\\r\\n  if (qm !== -1) {\\r\\n    this.search = rest.substr(qm);\\r\\n    this.query = rest.substr(qm + 1);\\r\\n    if (parseQueryString) {\\r\\n      this.query = querystring.parse(this.query);\\r\\n    }\\r\\n    rest = rest.slice(0, qm);\\r\\n  } else if (parseQueryString) {\\r\\n    // no query string, but parseQueryString still requested\\r\\n    this.search = '';\\r\\n    this.query = {};\\r\\n  }\\r\\n  if (rest) this.pathname = rest;\\r\\n  if (slashedProtocol[lowerProto] &&\\r\\n      this.hostname && !this.pathname) {\\r\\n    this.pathname = '/';\\r\\n  }\\r\\n\\r\\n  //to support http.request\\r\\n  if (this.pathname || this.search) {\\r\\n    var p = this.pathname || '';\\r\\n    var s = this.search || '';\\r\\n    this.path = p + s;\\r\\n  }\\r\\n\\r\\n  // finally, reconstruct the href based on what has been validated.\\r\\n  this.href = this.format();\\r\\n  return this;\\r\\n};\\r\\n\\r\\n// format a parsed object into a url string\\r\\nfunction urlFormat(obj) {\\r\\n  // ensure it's an object, and not a string url.\\r\\n  // If it's an obj, this is a no-op.\\r\\n  // this way, you can call url_format() on strings\\r\\n  // to clean up potentially wonky urls.\\r\\n  if (typeof obj === 'string') obj = urlParse(obj);\\r\\n\\r\\n  else if (typeof obj !== 'object' || obj === null)\\r\\n    throw new TypeError('Parameter \\\"urlObj\\\" must be an object, not ' +\\r\\n                        obj === null ? 'null' : typeof obj);\\r\\n\\r\\n  else if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\\r\\n\\r\\n  return obj.format();\\r\\n}\\r\\n\\r\\nUrl.prototype.format = function() {\\r\\n  var auth = this.auth || '';\\r\\n  if (auth) {\\r\\n    auth = encodeURIComponent(auth);\\r\\n    auth = auth.replace(/%3A/i, ':');\\r\\n    auth += '@';\\r\\n  }\\r\\n\\r\\n  var protocol = this.protocol || '',\\r\\n      pathname = this.pathname || '',\\r\\n      hash = this.hash || '',\\r\\n      host = false,\\r\\n      query = '';\\r\\n\\r\\n  if (this.host) {\\r\\n    host = auth + this.host;\\r\\n  } else if (this.hostname) {\\r\\n    host = auth + (this.hostname.indexOf(':') === -1 ?\\r\\n        this.hostname :\\r\\n        '[' + this.hostname + ']');\\r\\n    if (this.port) {\\r\\n      host += ':' + this.port;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (this.query !== null &&\\r\\n      typeof this.query === 'object' &&\\r\\n      Object.keys(this.query).length) {\\r\\n    query = querystring.stringify(this.query);\\r\\n  }\\r\\n\\r\\n  var search = this.search || (query && ('?' + query)) || '';\\r\\n\\r\\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\\r\\n\\r\\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\\r\\n  // unless they had them to begin with.\\r\\n  if (this.slashes ||\\r\\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\\r\\n    host = '//' + (host || '');\\r\\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\\r\\n  } else if (!host) {\\r\\n    host = '';\\r\\n  }\\r\\n\\r\\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\\r\\n  if (search && search.charAt(0) !== '?') search = '?' + search;\\r\\n\\r\\n  pathname = pathname.replace(/[?#]/g, function(match) {\\r\\n    return encodeURIComponent(match);\\r\\n  });\\r\\n  search = search.replace('#', '%23');\\r\\n\\r\\n  return protocol + host + pathname + search + hash;\\r\\n};\\r\\n\\r\\nfunction urlResolve(source, relative) {\\r\\n  return urlParse(source, false, true).resolve(relative);\\r\\n}\\r\\n\\r\\nUrl.prototype.resolve = function(relative) {\\r\\n  return this.resolveObject(urlParse(relative, false, true)).format();\\r\\n};\\r\\n\\r\\nfunction urlResolveObject(source, relative) {\\r\\n  if (!source) return relative;\\r\\n  return urlParse(source, false, true).resolveObject(relative);\\r\\n}\\r\\n\\r\\nUrl.prototype.resolveObject = function(relative) {\\r\\n  if (typeof relative === 'string') {\\r\\n    var rel = new Url();\\r\\n    rel.parse(relative, false, true);\\r\\n    relative = rel;\\r\\n  }\\r\\n\\r\\n  var result = new Url();\\r\\n  var tkeys = Object.keys(this);\\r\\n  for (var tk = 0; tk < tkeys.length; tk++) {\\r\\n    var tkey = tkeys[tk];\\r\\n    result[tkey] = this[tkey];\\r\\n  }\\r\\n\\r\\n  // hash is always overridden, no matter what.\\r\\n  // even href=\\\"\\\" will remove it.\\r\\n  result.hash = relative.hash;\\r\\n\\r\\n  // if the relative url is empty, then there's nothing left to do here.\\r\\n  if (relative.href === '') {\\r\\n    result.href = result.format();\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  // hrefs like //foo/bar always cut to the protocol.\\r\\n  if (relative.slashes && !relative.protocol) {\\r\\n    // take everything except the protocol from relative\\r\\n    var rkeys = Object.keys(relative);\\r\\n    for (var rk = 0; rk < rkeys.length; rk++) {\\r\\n      var rkey = rkeys[rk];\\r\\n      if (rkey !== 'protocol')\\r\\n        result[rkey] = relative[rkey];\\r\\n    }\\r\\n\\r\\n    //urlParse appends trailing / to urls like http://www.example.com\\r\\n    if (slashedProtocol[result.protocol] &&\\r\\n        result.hostname && !result.pathname) {\\r\\n      result.path = result.pathname = '/';\\r\\n    }\\r\\n\\r\\n    result.href = result.format();\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  if (relative.protocol && relative.protocol !== result.protocol) {\\r\\n    // if it's a known url protocol, then changing\\r\\n    // the protocol does weird things\\r\\n    // first, if it's not file:, then we MUST have a host,\\r\\n    // and if there was a path\\r\\n    // to begin with, then we MUST have a path.\\r\\n    // if it is file:, then the host is dropped,\\r\\n    // because that's known to be hostless.\\r\\n    // anything else is assumed to be absolute.\\r\\n    if (!slashedProtocol[relative.protocol]) {\\r\\n      var keys = Object.keys(relative);\\r\\n      for (var v = 0; v < keys.length; v++) {\\r\\n        var k = keys[v];\\r\\n        result[k] = relative[k];\\r\\n      }\\r\\n      result.href = result.format();\\r\\n      return result;\\r\\n    }\\r\\n\\r\\n    result.protocol = relative.protocol;\\r\\n    if (!relative.host &&\\r\\n        !/^file:?$/.test(relative.protocol) &&\\r\\n        !hostlessProtocol[relative.protocol]) {\\r\\n      var relPath = (relative.pathname || '').split('/');\\r\\n      while (relPath.length && !(relative.host = relPath.shift()));\\r\\n      if (!relative.host) relative.host = '';\\r\\n      if (!relative.hostname) relative.hostname = '';\\r\\n      if (relPath[0] !== '') relPath.unshift('');\\r\\n      if (relPath.length < 2) relPath.unshift('');\\r\\n      result.pathname = relPath.join('/');\\r\\n    } else {\\r\\n      result.pathname = relative.pathname;\\r\\n    }\\r\\n    result.search = relative.search;\\r\\n    result.query = relative.query;\\r\\n    result.host = relative.host || '';\\r\\n    result.auth = relative.auth;\\r\\n    result.hostname = relative.hostname || relative.host;\\r\\n    result.port = relative.port;\\r\\n    // to support http.request\\r\\n    if (result.pathname || result.search) {\\r\\n      var p = result.pathname || '';\\r\\n      var s = result.search || '';\\r\\n      result.path = p + s;\\r\\n    }\\r\\n    result.slashes = result.slashes || relative.slashes;\\r\\n    result.href = result.format();\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\\r\\n      isRelAbs = (\\r\\n          relative.host ||\\r\\n          relative.pathname && relative.pathname.charAt(0) === '/'\\r\\n      ),\\r\\n      mustEndAbs = (isRelAbs || isSourceAbs ||\\r\\n                    (result.host && relative.pathname)),\\r\\n      removeAllDots = mustEndAbs,\\r\\n      srcPath = result.pathname && result.pathname.split('/') || [],\\r\\n      relPath = relative.pathname && relative.pathname.split('/') || [],\\r\\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\\r\\n\\r\\n  // if the url is a non-slashed url, then relative\\r\\n  // links like ../.. should be able\\r\\n  // to crawl up to the hostname, as well.  This is strange.\\r\\n  // result.protocol has already been set by now.\\r\\n  // Later on, put the first path part into the host field.\\r\\n  if (psychotic) {\\r\\n    result.hostname = '';\\r\\n    result.port = null;\\r\\n    if (result.host) {\\r\\n      if (srcPath[0] === '') srcPath[0] = result.host;\\r\\n      else srcPath.unshift(result.host);\\r\\n    }\\r\\n    result.host = '';\\r\\n    if (relative.protocol) {\\r\\n      relative.hostname = null;\\r\\n      relative.port = null;\\r\\n      if (relative.host) {\\r\\n        if (relPath[0] === '') relPath[0] = relative.host;\\r\\n        else relPath.unshift(relative.host);\\r\\n      }\\r\\n      relative.host = null;\\r\\n    }\\r\\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\\r\\n  }\\r\\n\\r\\n  if (isRelAbs) {\\r\\n    // it's absolute.\\r\\n    result.host = (relative.host || relative.host === '') ?\\r\\n                  relative.host : result.host;\\r\\n    result.hostname = (relative.hostname || relative.hostname === '') ?\\r\\n                      relative.hostname : result.hostname;\\r\\n    result.search = relative.search;\\r\\n    result.query = relative.query;\\r\\n    srcPath = relPath;\\r\\n    // fall through to the dot-handling below.\\r\\n  } else if (relPath.length) {\\r\\n    // it's relative\\r\\n    // throw away the existing file, and take the new path instead.\\r\\n    if (!srcPath) srcPath = [];\\r\\n    srcPath.pop();\\r\\n    srcPath = srcPath.concat(relPath);\\r\\n    result.search = relative.search;\\r\\n    result.query = relative.query;\\r\\n  } else if (relative.search !== null && relative.search !== undefined) {\\r\\n    // just pull out the search.\\r\\n    // like href='?foo'.\\r\\n    // Put this after the other two cases because it simplifies the booleans\\r\\n    if (psychotic) {\\r\\n      result.hostname = result.host = srcPath.shift();\\r\\n      //occationaly the auth can get stuck only in host\\r\\n      //this especially happens in cases like\\r\\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\r\\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\\r\\n                       result.host.split('@') : false;\\r\\n      if (authInHost) {\\r\\n        result.auth = authInHost.shift();\\r\\n        result.host = result.hostname = authInHost.shift();\\r\\n      }\\r\\n    }\\r\\n    result.search = relative.search;\\r\\n    result.query = relative.query;\\r\\n    //to support http.request\\r\\n    if (result.pathname !== null || result.search !== null) {\\r\\n      result.path = (result.pathname ? result.pathname : '') +\\r\\n                    (result.search ? result.search : '');\\r\\n    }\\r\\n    result.href = result.format();\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  if (!srcPath.length) {\\r\\n    // no path at all.  easy.\\r\\n    // we've already handled the other stuff above.\\r\\n    result.pathname = null;\\r\\n    //to support http.request\\r\\n    if (result.search) {\\r\\n      result.path = '/' + result.search;\\r\\n    } else {\\r\\n      result.path = null;\\r\\n    }\\r\\n    result.href = result.format();\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  // if a url ENDs in . or .., then it must get a trailing slash.\\r\\n  // however, if it ends in anything else non-slashy,\\r\\n  // then it must NOT get a trailing slash.\\r\\n  var last = srcPath.slice(-1)[0];\\r\\n  var hasTrailingSlash = (\\r\\n      (result.host || relative.host || srcPath.length > 1) &&\\r\\n      (last === '.' || last === '..') || last === '');\\r\\n\\r\\n  // strip single dots, resolve double dots to parent dir\\r\\n  // if the path tries to go above the root, `up` ends up > 0\\r\\n  var up = 0;\\r\\n  for (var i = srcPath.length; i >= 0; i--) {\\r\\n    last = srcPath[i];\\r\\n    if (last === '.') {\\r\\n      spliceOne(srcPath, i);\\r\\n    } else if (last === '..') {\\r\\n      spliceOne(srcPath, i);\\r\\n      up++;\\r\\n    } else if (up) {\\r\\n      spliceOne(srcPath, i);\\r\\n      up--;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // if the path is allowed to go above the root, restore leading ..s\\r\\n  if (!mustEndAbs && !removeAllDots) {\\r\\n    for (; up--; up) {\\r\\n      srcPath.unshift('..');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (mustEndAbs && srcPath[0] !== '' &&\\r\\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\\r\\n    srcPath.unshift('');\\r\\n  }\\r\\n\\r\\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\\r\\n    srcPath.push('');\\r\\n  }\\r\\n\\r\\n  var isAbsolute = srcPath[0] === '' ||\\r\\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\\r\\n\\r\\n  // put the host back\\r\\n  if (psychotic) {\\r\\n    result.hostname = result.host = isAbsolute ? '' :\\r\\n                                    srcPath.length ? srcPath.shift() : '';\\r\\n    //occationaly the auth can get stuck only in host\\r\\n    //this especially happens in cases like\\r\\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\r\\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\\r\\n                     result.host.split('@') : false;\\r\\n    if (authInHost) {\\r\\n      result.auth = authInHost.shift();\\r\\n      result.host = result.hostname = authInHost.shift();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\\r\\n\\r\\n  if (mustEndAbs && !isAbsolute) {\\r\\n    srcPath.unshift('');\\r\\n  }\\r\\n\\r\\n  if (!srcPath.length) {\\r\\n    result.pathname = null;\\r\\n    result.path = null;\\r\\n  } else {\\r\\n    result.pathname = srcPath.join('/');\\r\\n  }\\r\\n\\r\\n  //to support request.http\\r\\n  if (result.pathname !== null || result.search !== null) {\\r\\n    result.path = (result.pathname ? result.pathname : '') +\\r\\n                  (result.search ? result.search : '');\\r\\n  }\\r\\n  result.auth = relative.auth || result.auth;\\r\\n  result.slashes = result.slashes || relative.slashes;\\r\\n  result.href = result.format();\\r\\n  return result;\\r\\n};\\r\\n\\r\\nUrl.prototype.parseHost = function() {\\r\\n  var host = this.host;\\r\\n  var port = portPattern.exec(host);\\r\\n  if (port) {\\r\\n    port = port[0];\\r\\n    if (port !== ':') {\\r\\n      this.port = port.substr(1);\\r\\n    }\\r\\n    host = host.substr(0, host.length - port.length);\\r\\n  }\\r\\n  if (host) this.hostname = host;\\r\\n};\\r\\n\\r\\n// About 1.5x faster than the two-arg version of Array#splice().\\r\\nfunction spliceOne(list, index) {\\r\\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\\r\\n    list[i] = list[k];\\r\\n  list.pop();\\r\\n}\\r\\n\",\"readline\":\"// Inspiration for this code comes from Salvatore Sanfilippo's linenoise.\\r\\n// https://github.com/antirez/linenoise\\r\\n// Reference:\\r\\n// * http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\\r\\n// * http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html\\r\\n\\r\\n'use strict';\\r\\n\\r\\n/*! https://mths.be/codepointat v0.2.0 by @mathias */\\r\\nif (!String.prototype.codePointAt) {\\r\\n  (function() {\\r\\n    'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\\r\\n    var defineProperty = (function() {\\r\\n      // IE 8 only supports `Object.defineProperty` on DOM elements\\r\\n      try {\\r\\n        var object = {};\\r\\n        var $defineProperty = Object.defineProperty;\\r\\n        var result = $defineProperty(object, object, object) && $defineProperty;\\r\\n      } catch(error) {}\\r\\n      return result;\\r\\n    }());\\r\\n    var codePointAt = function(position) {\\r\\n      if (this == null) {\\r\\n        throw TypeError();\\r\\n      }\\r\\n      var string = String(this);\\r\\n      var size = string.length;\\r\\n      // `ToInteger`\\r\\n      var index = position ? Number(position) : 0;\\r\\n      if (index != index) { // better `isNaN`\\r\\n        index = 0;\\r\\n      }\\r\\n      // Account for out-of-bounds indices:\\r\\n      if (index < 0 || index >= size) {\\r\\n        return undefined;\\r\\n      }\\r\\n      // Get the first code unit\\r\\n      var first = string.charCodeAt(index);\\r\\n      var second;\\r\\n      if ( // check if its the start of a surrogate pair\\r\\n        first >= 0xD800 && first <= 0xDBFF && // high surrogate\\r\\n        size > index + 1 // there is a next code unit\\r\\n      ) {\\r\\n        second = string.charCodeAt(index + 1);\\r\\n        if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\\r\\n          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\\r\\n          return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\\r\\n        }\\r\\n      }\\r\\n      return first;\\r\\n    };\\r\\n    if (defineProperty) {\\r\\n      defineProperty(String.prototype, 'codePointAt', {\\r\\n        'value': codePointAt,\\r\\n        'configurable': true,\\r\\n        'writable': true\\r\\n      });\\r\\n    } else {\\r\\n      String.prototype.codePointAt = codePointAt;\\r\\n    }\\r\\n  }());\\r\\n}\\r\\n\\r\\nvar kHistorySize = 30;\\r\\n\\r\\nvar util = require('util');\\r\\nvar inherits = util.inherits;\\r\\nvar EventEmitter = require('events').EventEmitter;\\r\\n\\r\\n\\r\\nexports.createInterface = function(input, output, completer, terminal) {\\r\\n  var rl;\\r\\n  if (arguments.length === 1) {\\r\\n    rl = new Interface(input);\\r\\n  } else {\\r\\n    rl = new Interface(input, output, completer, terminal);\\r\\n  }\\r\\n  return rl;\\r\\n};\\r\\n\\r\\n\\r\\nfunction Interface(input, output, completer, terminal) {\\r\\n  if (!(this instanceof Interface)) {\\r\\n    // call the varructor preserving original number of arguments\\r\\n    var self = Object.create(Interface.prototype);\\r\\n    Interface.apply(self, arguments);\\r\\n    return self;\\r\\n  }\\r\\n\\r\\n  this._sawReturn = false;\\r\\n\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  if (arguments.length === 1) {\\r\\n    // an options object was given\\r\\n    output = input.output;\\r\\n    completer = input.completer;\\r\\n    terminal = input.terminal;\\r\\n    input = input.input;\\r\\n  }\\r\\n\\r\\n  completer = completer || function() { return []; };\\r\\n\\r\\n  if (typeof completer !== 'function') {\\r\\n    throw new TypeError('Argument \\\\'completer\\\\' must be a function');\\r\\n  }\\r\\n\\r\\n  // backwards compat; check the isTTY prop of the output stream\\r\\n  //  when `terminal` was not specified\\r\\n  if (terminal === undefined && !(output === null || output === undefined)) {\\r\\n    terminal = !!output.isTTY;\\r\\n  }\\r\\n\\r\\n  var self = this;\\r\\n\\r\\n  this.output = output;\\r\\n  this.input = input;\\r\\n\\r\\n  // Check arity, 2 - for async, 1 for sync\\r\\n  this.completer = completer.length === 2 ? completer : function(v, callback) {\\r\\n    callback(null, completer(v));\\r\\n  };\\r\\n\\r\\n  this.setPrompt('> ');\\r\\n\\r\\n  this.terminal = !!terminal;\\r\\n\\r\\n  function ondata(data) {\\r\\n    self._normalWrite(data);\\r\\n  }\\r\\n\\r\\n  function onend() {\\r\\n    if (typeof self._line_buffer === 'string' &&\\r\\n        self._line_buffer.length > 0) {\\r\\n      self.emit('line', self._line_buffer);\\r\\n    }\\r\\n    self.close();\\r\\n  }\\r\\n\\r\\n  function ontermend() {\\r\\n    if (typeof self.line === 'string' && self.line.length > 0) {\\r\\n      self.emit('line', self.line);\\r\\n    }\\r\\n    self.close();\\r\\n  }\\r\\n\\r\\n  function onkeypress(s, key) {\\r\\n    self._ttyWrite(s, key);\\r\\n  }\\r\\n\\r\\n  function onresize() {\\r\\n    self._refreshLine();\\r\\n  }\\r\\n\\r\\n  if (!this.terminal) {\\r\\n    input.on('data', ondata);\\r\\n    input.on('end', onend);\\r\\n    self.once('close', function() {\\r\\n      input.removeListener('data', ondata);\\r\\n      input.removeListener('end', onend);\\r\\n    });\\r\\n    var StringDecoder = require('string_decoder').StringDecoder; // lazy load\\r\\n    this._decoder = new StringDecoder('utf8');\\r\\n\\r\\n  } else {\\r\\n\\r\\n    exports.emitKeypressEvents(input);\\r\\n\\r\\n    // input usually refers to stdin\\r\\n    input.on('keypress', onkeypress);\\r\\n    input.on('end', ontermend);\\r\\n\\r\\n    // Current line\\r\\n    this.line = '';\\r\\n\\r\\n    this._setRawMode(true);\\r\\n    this.terminal = true;\\r\\n\\r\\n    // Cursor position on the line.\\r\\n    this.cursor = 0;\\r\\n\\r\\n    this.history = [];\\r\\n    this.historyIndex = -1;\\r\\n\\r\\n    if (output !== null && output !== undefined)\\r\\n      output.on('resize', onresize);\\r\\n\\r\\n    self.once('close', function() {\\r\\n      input.removeListener('keypress', onkeypress);\\r\\n      input.removeListener('end', ontermend);\\r\\n      if (output !== null && output !== undefined) {\\r\\n        output.removeListener('resize', onresize);\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  input.resume();\\r\\n}\\r\\n\\r\\ninherits(Interface, EventEmitter);\\r\\n\\r\\nInterface.prototype.__defineGetter__('columns', function() {\\r\\n  var columns = Infinity;\\r\\n  if (this.output && this.output.columns)\\r\\n    columns = this.output.columns;\\r\\n  return columns;\\r\\n});\\r\\n\\r\\nInterface.prototype.setPrompt = function(prompt) {\\r\\n  this._prompt = prompt;\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._setRawMode = function(mode) {\\r\\n  if (typeof this.input.setRawMode === 'function') {\\r\\n    return this.input.setRawMode(mode);\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.prompt = function(preserveCursor) {\\r\\n  if (this.paused) this.resume();\\r\\n  if (this.terminal) {\\r\\n    if (!preserveCursor) this.cursor = 0;\\r\\n    this._refreshLine();\\r\\n  } else {\\r\\n    this._writeToOutput(this._prompt);\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.question = function(query, cb) {\\r\\n  if (typeof cb === 'function') {\\r\\n    if (this._questionCallback) {\\r\\n      this.prompt();\\r\\n    } else {\\r\\n      this._oldPrompt = this._prompt;\\r\\n      this.setPrompt(query);\\r\\n      this._questionCallback = cb;\\r\\n      this.prompt();\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._onLine = function(line) {\\r\\n  if (this._questionCallback) {\\r\\n    var cb = this._questionCallback;\\r\\n    this._questionCallback = null;\\r\\n    this.setPrompt(this._oldPrompt);\\r\\n    cb(line);\\r\\n  } else {\\r\\n    this.emit('line', line);\\r\\n  }\\r\\n};\\r\\n\\r\\nInterface.prototype._writeToOutput = function _writeToOutput(stringToWrite) {\\r\\n  if (typeof stringToWrite !== 'string')\\r\\n    throw new TypeError('stringToWrite must be a string');\\r\\n\\r\\n  if (this.output !== null && this.output !== undefined)\\r\\n    this.output.write(stringToWrite);\\r\\n};\\r\\n\\r\\nInterface.prototype._addHistory = function() {\\r\\n  if (this.line.length === 0) return '';\\r\\n\\r\\n  if (this.history.length === 0 || this.history[0] !== this.line) {\\r\\n    this.history.unshift(this.line);\\r\\n\\r\\n    // Only store so many\\r\\n    if (this.history.length > kHistorySize) this.history.pop();\\r\\n  }\\r\\n\\r\\n  this.historyIndex = -1;\\r\\n  return this.history[0];\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._refreshLine = function() {\\r\\n  // line length\\r\\n  var line = this._prompt + this.line;\\r\\n  var dispPos = this._getDisplayPos(line);\\r\\n  var lineCols = dispPos.cols;\\r\\n  var lineRows = dispPos.rows;\\r\\n\\r\\n  // cursor position\\r\\n  var cursorPos = this._getCursorPos();\\r\\n\\r\\n  // first move to the bottom of the current line, based on cursor pos\\r\\n  var prevRows = this.prevRows || 0;\\r\\n  if (prevRows > 0) {\\r\\n    exports.moveCursor(this.output, 0, -prevRows);\\r\\n  }\\r\\n\\r\\n  // Cursor to left edge.\\r\\n  exports.cursorTo(this.output, 0);\\r\\n  // erase data\\r\\n  exports.clearScreenDown(this.output);\\r\\n\\r\\n  // Write the prompt and the current buffer content.\\r\\n  this._writeToOutput(line);\\r\\n\\r\\n  // Force terminal to allocate a new line\\r\\n  if (lineCols === 0) {\\r\\n    this._writeToOutput(' ');\\r\\n  }\\r\\n\\r\\n  // Move cursor to original position.\\r\\n  exports.cursorTo(this.output, cursorPos.cols);\\r\\n\\r\\n  var diff = lineRows - cursorPos.rows;\\r\\n  if (diff > 0) {\\r\\n    exports.moveCursor(this.output, 0, -diff);\\r\\n  }\\r\\n\\r\\n  this.prevRows = cursorPos.rows;\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.close = function() {\\r\\n  if (this.closed) return;\\r\\n  this.pause();\\r\\n  if (this.terminal) {\\r\\n    this._setRawMode(false);\\r\\n  }\\r\\n  this.closed = true;\\r\\n  this.emit('close');\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.pause = function() {\\r\\n  if (this.paused) return;\\r\\n  this.input.pause();\\r\\n  this.paused = true;\\r\\n  this.emit('pause');\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.resume = function() {\\r\\n  if (!this.paused) return;\\r\\n  this.input.resume();\\r\\n  this.paused = false;\\r\\n  this.emit('resume');\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.write = function(d, key) {\\r\\n  if (this.paused) this.resume();\\r\\n  this.terminal ? this._ttyWrite(d, key) : this._normalWrite(d);\\r\\n};\\r\\n\\r\\n// \\\\r\\\\n, \\\\n, or \\\\r followed by something other than \\\\n\\r\\nvar lineEnding = /\\\\r?\\\\n|\\\\r(?!\\\\n)/;\\r\\nInterface.prototype._normalWrite = function(b) {\\r\\n  if (b === undefined) {\\r\\n    return;\\r\\n  }\\r\\n  var string = this._decoder.write(b);\\r\\n  if (this._sawReturn) {\\r\\n    string = string.replace(/^\\\\n/, '');\\r\\n    this._sawReturn = false;\\r\\n  }\\r\\n\\r\\n  // Run test() on the new string chunk, not on the entire line buffer.\\r\\n  var newPartContainsEnding = lineEnding.test(string);\\r\\n\\r\\n  if (this._line_buffer) {\\r\\n    string = this._line_buffer + string;\\r\\n    this._line_buffer = null;\\r\\n  }\\r\\n  if (newPartContainsEnding) {\\r\\n    this._sawReturn = /\\\\r$/.test(string);\\r\\n\\r\\n    // got one or more newlines; process into \\\"line\\\" events\\r\\n    var lines = string.split(lineEnding);\\r\\n    // either '' or (concievably) the unfinished portion of the next line\\r\\n    string = lines.pop();\\r\\n    this._line_buffer = string;\\r\\n    lines.forEach(function(line) {\\r\\n      this._onLine(line);\\r\\n    }, this);\\r\\n  } else if (string) {\\r\\n    // no newlines this time, save what we have for next time\\r\\n    this._line_buffer = string;\\r\\n  }\\r\\n};\\r\\n\\r\\nInterface.prototype._insertString = function(c) {\\r\\n  //BUG: Problem when adding tabs with following content.\\r\\n  //     Perhaps the bug is in _refreshLine(). Not sure.\\r\\n  //     A hack would be to insert spaces instead of literal '\\\\t'.\\r\\n  if (this.cursor < this.line.length) {\\r\\n    var beg = this.line.slice(0, this.cursor);\\r\\n    var end = this.line.slice(this.cursor, this.line.length);\\r\\n    this.line = beg + c + end;\\r\\n    this.cursor += c.length;\\r\\n    this._refreshLine();\\r\\n  } else {\\r\\n    this.line += c;\\r\\n    this.cursor += c.length;\\r\\n\\r\\n    if (this._getCursorPos().cols === 0) {\\r\\n      this._refreshLine();\\r\\n    } else {\\r\\n      this._writeToOutput(c);\\r\\n    }\\r\\n\\r\\n    // a hack to get the line refreshed if it's needed\\r\\n    this._moveCursor(0);\\r\\n  }\\r\\n};\\r\\n\\r\\nInterface.prototype._tabComplete = function() {\\r\\n  var self = this;\\r\\n\\r\\n  self.pause();\\r\\n  self.completer(self.line.slice(0, self.cursor), function(err, rv) {\\r\\n    self.resume();\\r\\n\\r\\n    if (err) {\\r\\n      // XXX Log it somewhere?\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    var completions = rv[0],\\r\\n        completeOn = rv[1];  // the text that was completed\\r\\n    if (completions && completions.length) {\\r\\n      // Apply/show completions.\\r\\n      if (completions.length === 1) {\\r\\n        self._insertString(completions[0].slice(completeOn.length));\\r\\n      } else {\\r\\n        self._writeToOutput('\\\\r\\\\n');\\r\\n        var width = completions.reduce(function(a, b) {\\r\\n          return a.length > b.length ? a : b;\\r\\n        }).length + 2;  // 2 space padding\\r\\n        var maxColumns = Math.floor(self.columns / width) || 1;\\r\\n        var group = [], c;\\r\\n        for (var i = 0, compLen = completions.length; i < compLen; i++) {\\r\\n          c = completions[i];\\r\\n          if (c === '') {\\r\\n            handleGroup(self, group, width, maxColumns);\\r\\n            group = [];\\r\\n          } else {\\r\\n            group.push(c);\\r\\n          }\\r\\n        }\\r\\n        handleGroup(self, group, width, maxColumns);\\r\\n\\r\\n        // If there is a common prefix to all matches, then apply that\\r\\n        // portion.\\r\\n        var f = completions.filter(function(e) { if (e) return e; });\\r\\n        var prefix = commonPrefix(f);\\r\\n        if (prefix.length > completeOn.length) {\\r\\n          self._insertString(prefix.slice(completeOn.length));\\r\\n        }\\r\\n\\r\\n      }\\r\\n      self._refreshLine();\\r\\n    }\\r\\n  });\\r\\n};\\r\\n\\r\\n// this = Interface instance\\r\\nfunction handleGroup(self, group, width, maxColumns) {\\r\\n  if (group.length == 0) {\\r\\n    return;\\r\\n  }\\r\\n  var minRows = Math.ceil(group.length / maxColumns);\\r\\n  for (var row = 0; row < minRows; row++) {\\r\\n    for (var col = 0; col < maxColumns; col++) {\\r\\n      var idx = row * maxColumns + col;\\r\\n      if (idx >= group.length) {\\r\\n        break;\\r\\n      }\\r\\n      var item = group[idx];\\r\\n      self._writeToOutput(item);\\r\\n      if (col < maxColumns - 1) {\\r\\n        for (var s = 0, itemLen = item.length; s < width - itemLen;\\r\\n             s++) {\\r\\n          self._writeToOutput(' ');\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    self._writeToOutput('\\\\r\\\\n');\\r\\n  }\\r\\n  self._writeToOutput('\\\\r\\\\n');\\r\\n}\\r\\n\\r\\nfunction commonPrefix(strings) {\\r\\n  if (!strings || strings.length == 0) {\\r\\n    return '';\\r\\n  }\\r\\n  var sorted = strings.slice().sort();\\r\\n  var min = sorted[0];\\r\\n  var max = sorted[sorted.length - 1];\\r\\n  for (var i = 0, len = min.length; i < len; i++) {\\r\\n    if (min[i] != max[i]) {\\r\\n      return min.slice(0, i);\\r\\n    }\\r\\n  }\\r\\n  return min;\\r\\n}\\r\\n\\r\\n\\r\\nInterface.prototype._wordLeft = function() {\\r\\n  if (this.cursor > 0) {\\r\\n    var leading = this.line.slice(0, this.cursor);\\r\\n    var match = leading.match(/([^\\\\w\\\\s]+|\\\\w+|)\\\\s*$/);\\r\\n    this._moveCursor(-match[0].length);\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._wordRight = function() {\\r\\n  if (this.cursor < this.line.length) {\\r\\n    var trailing = this.line.slice(this.cursor);\\r\\n    var match = trailing.match(/^(\\\\s+|\\\\W+|\\\\w+)\\\\s*/);\\r\\n    this._moveCursor(match[0].length);\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._deleteLeft = function() {\\r\\n  if (this.cursor > 0 && this.line.length > 0) {\\r\\n    this.line = this.line.slice(0, this.cursor - 1) +\\r\\n                this.line.slice(this.cursor, this.line.length);\\r\\n\\r\\n    this.cursor--;\\r\\n    this._refreshLine();\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._deleteRight = function() {\\r\\n  this.line = this.line.slice(0, this.cursor) +\\r\\n              this.line.slice(this.cursor + 1, this.line.length);\\r\\n  this._refreshLine();\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._deleteWordLeft = function() {\\r\\n  if (this.cursor > 0) {\\r\\n    var leading = this.line.slice(0, this.cursor);\\r\\n    var match = leading.match(/([^\\\\w\\\\s]+|\\\\w+|)\\\\s*$/);\\r\\n    leading = leading.slice(0, leading.length - match[0].length);\\r\\n    this.line = leading + this.line.slice(this.cursor, this.line.length);\\r\\n    this.cursor = leading.length;\\r\\n    this._refreshLine();\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._deleteWordRight = function() {\\r\\n  if (this.cursor < this.line.length) {\\r\\n    var trailing = this.line.slice(this.cursor);\\r\\n    var match = trailing.match(/^(\\\\s+|\\\\W+|\\\\w+)\\\\s*/);\\r\\n    this.line = this.line.slice(0, this.cursor) +\\r\\n                trailing.slice(match[0].length);\\r\\n    this._refreshLine();\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._deleteLineLeft = function() {\\r\\n  this.line = this.line.slice(this.cursor);\\r\\n  this.cursor = 0;\\r\\n  this._refreshLine();\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._deleteLineRight = function() {\\r\\n  this.line = this.line.slice(0, this.cursor);\\r\\n  this._refreshLine();\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.clearLine = function() {\\r\\n  this._moveCursor(+Infinity);\\r\\n  this._writeToOutput('\\\\r\\\\n');\\r\\n  this.line = '';\\r\\n  this.cursor = 0;\\r\\n  this.prevRows = 0;\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._line = function() {\\r\\n  var line = this._addHistory();\\r\\n  this.clearLine();\\r\\n  this._onLine(line);\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._historyNext = function() {\\r\\n  if (this.historyIndex > 0) {\\r\\n    this.historyIndex--;\\r\\n    this.line = this.history[this.historyIndex];\\r\\n    this.cursor = this.line.length; // set cursor to end of line.\\r\\n    this._refreshLine();\\r\\n\\r\\n  } else if (this.historyIndex === 0) {\\r\\n    this.historyIndex = -1;\\r\\n    this.cursor = 0;\\r\\n    this.line = '';\\r\\n    this._refreshLine();\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._historyPrev = function() {\\r\\n  if (this.historyIndex + 1 < this.history.length) {\\r\\n    this.historyIndex++;\\r\\n    this.line = this.history[this.historyIndex];\\r\\n    this.cursor = this.line.length; // set cursor to end of line.\\r\\n\\r\\n    this._refreshLine();\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\n// Returns the last character's display position of the given string\\r\\nInterface.prototype._getDisplayPos = function(str) {\\r\\n  var offset = 0;\\r\\n  var col = this.columns;\\r\\n  var row = 0;\\r\\n  var code;\\r\\n  str = stripVTControlCharacters(str);\\r\\n  for (var i = 0, len = str.length; i < len; i++) {\\r\\n    code = str.codePointAt(i);\\r\\n    if (code >= 0x10000) { // surrogates\\r\\n      i++;\\r\\n    }\\r\\n    if (code === 0x0a) { // new line \\\\n\\r\\n      offset = 0;\\r\\n      row += 1;\\r\\n      continue;\\r\\n    }\\r\\n    if (isFullWidthCodePoint(code)) {\\r\\n      if ((offset + 1) % col === 0) {\\r\\n        offset++;\\r\\n      }\\r\\n      offset += 2;\\r\\n    } else {\\r\\n      offset++;\\r\\n    }\\r\\n  }\\r\\n  var cols = offset % col;\\r\\n  var rows = row + (offset - cols) / col;\\r\\n  return {cols: cols, rows: rows};\\r\\n};\\r\\n\\r\\n\\r\\n// Returns current cursor's position and line\\r\\nInterface.prototype._getCursorPos = function() {\\r\\n  var columns = this.columns;\\r\\n  var strBeforeCursor = this._prompt + this.line.substring(0, this.cursor);\\r\\n  var dispPos = this._getDisplayPos(stripVTControlCharacters(strBeforeCursor));\\r\\n  var cols = dispPos.cols;\\r\\n  var rows = dispPos.rows;\\r\\n  // If the cursor is on a full-width character which steps over the line,\\r\\n  // move the cursor to the beginning of the next line.\\r\\n  if (cols + 1 === columns &&\\r\\n      this.cursor < this.line.length &&\\r\\n      isFullWidthCodePoint(this.line.codePointAt(this.cursor))) {\\r\\n    rows++;\\r\\n    cols = 0;\\r\\n  }\\r\\n  return {cols: cols, rows: rows};\\r\\n};\\r\\n\\r\\n\\r\\n// This function moves cursor dx places to the right\\r\\n// (-dx for left) and refreshes the line if it is needed\\r\\nInterface.prototype._moveCursor = function(dx) {\\r\\n  var oldcursor = this.cursor;\\r\\n  var oldPos = this._getCursorPos();\\r\\n  this.cursor += dx;\\r\\n\\r\\n  // bounds check\\r\\n  if (this.cursor < 0) this.cursor = 0;\\r\\n  else if (this.cursor > this.line.length) this.cursor = this.line.length;\\r\\n\\r\\n  var newPos = this._getCursorPos();\\r\\n\\r\\n  // check if cursors are in the same line\\r\\n  if (oldPos.rows === newPos.rows) {\\r\\n    var diffCursor = this.cursor - oldcursor;\\r\\n    var diffWidth;\\r\\n    if (diffCursor < 0) {\\r\\n      diffWidth = -getStringWidth(\\r\\n          this.line.substring(this.cursor, oldcursor)\\r\\n          );\\r\\n    } else if (diffCursor > 0) {\\r\\n      diffWidth = getStringWidth(\\r\\n          this.line.substring(this.cursor, oldcursor)\\r\\n          );\\r\\n    }\\r\\n    exports.moveCursor(this.output, diffWidth, 0);\\r\\n    this.prevRows = newPos.rows;\\r\\n  } else {\\r\\n    this._refreshLine();\\r\\n  }\\r\\n};\\r\\n\\r\\n// handle a write from the tty\\r\\nInterface.prototype._ttyWrite = function(s, key) {\\r\\n  key = key || {};\\r\\n  // Ignore escape key - Fixes #2876\\r\\n  if (key.name == 'escape') return;\\r\\n\\r\\n  if (key.ctrl && key.shift) {\\r\\n    /* Control and shift pressed */\\r\\n    switch (key.name) {\\r\\n      case 'backspace':\\r\\n        this._deleteLineLeft();\\r\\n        break;\\r\\n\\r\\n      case 'delete':\\r\\n        this._deleteLineRight();\\r\\n        break;\\r\\n    }\\r\\n\\r\\n  } else if (key.ctrl) {\\r\\n    /* Control key pressed */\\r\\n\\r\\n    switch (key.name) {\\r\\n      case 'c':\\r\\n        if (EventEmitter.listenerCount(this, 'SIGINT') > 0) {\\r\\n          this.emit('SIGINT');\\r\\n        } else {\\r\\n          // This readline instance is finished\\r\\n          this.close();\\r\\n        }\\r\\n        break;\\r\\n\\r\\n      case 'h': // delete left\\r\\n        this._deleteLeft();\\r\\n        break;\\r\\n\\r\\n      case 'd': // delete right or EOF\\r\\n        if (this.cursor === 0 && this.line.length === 0) {\\r\\n          // This readline instance is finished\\r\\n          this.close();\\r\\n        } else if (this.cursor < this.line.length) {\\r\\n          this._deleteRight();\\r\\n        }\\r\\n        break;\\r\\n\\r\\n      case 'u': // delete the whole line\\r\\n        this.cursor = 0;\\r\\n        this.line = '';\\r\\n        this._refreshLine();\\r\\n        break;\\r\\n\\r\\n      case 'k': // delete from current to end of line\\r\\n        this._deleteLineRight();\\r\\n        break;\\r\\n\\r\\n      case 'a': // go to the start of the line\\r\\n        this._moveCursor(-Infinity);\\r\\n        break;\\r\\n\\r\\n      case 'e': // go to the end of the line\\r\\n        this._moveCursor(+Infinity);\\r\\n        break;\\r\\n\\r\\n      case 'b': // back one character\\r\\n        this._moveCursor(-1);\\r\\n        break;\\r\\n\\r\\n      case 'f': // forward one character\\r\\n        this._moveCursor(+1);\\r\\n        break;\\r\\n\\r\\n      case 'l': // clear the whole screen\\r\\n        exports.cursorTo(this.output, 0, 0);\\r\\n        exports.clearScreenDown(this.output);\\r\\n        this._refreshLine();\\r\\n        break;\\r\\n\\r\\n      case 'n': // next history item\\r\\n        this._historyNext();\\r\\n        break;\\r\\n\\r\\n      case 'p': // previous history item\\r\\n        this._historyPrev();\\r\\n        break;\\r\\n\\r\\n      case 'z':\\r\\n        if (process.platform == 'win32') break;\\r\\n        if (EventEmitter.listenerCount(this, 'SIGTSTP') > 0) {\\r\\n          this.emit('SIGTSTP');\\r\\n        } else {\\r\\n          process.once('SIGCONT', (function(self) {\\r\\n            return function() {\\r\\n              // Don't raise events if stream has already been abandoned.\\r\\n              if (!self.paused) {\\r\\n                // Stream must be paused and resumed after SIGCONT to catch\\r\\n                // SIGINT, SIGTSTP, and EOF.\\r\\n                self.pause();\\r\\n                self.emit('SIGCONT');\\r\\n              }\\r\\n              // explicitly re-enable \\\"raw mode\\\" and move the cursor to\\r\\n              // the correct position.\\r\\n              // See https://github.com/joyent/node/issues/3295.\\r\\n              self._setRawMode(true);\\r\\n              self._refreshLine();\\r\\n            };\\r\\n          })(this));\\r\\n          this._setRawMode(false);\\r\\n          process.kill(process.pid, 'SIGTSTP');\\r\\n        }\\r\\n        break;\\r\\n\\r\\n      case 'w': // delete backwards to a word boundary\\r\\n      case 'backspace':\\r\\n        this._deleteWordLeft();\\r\\n        break;\\r\\n\\r\\n      case 'delete': // delete forward to a word boundary\\r\\n        this._deleteWordRight();\\r\\n        break;\\r\\n\\r\\n      case 'left':\\r\\n        this._wordLeft();\\r\\n        break;\\r\\n\\r\\n      case 'right':\\r\\n        this._wordRight();\\r\\n        break;\\r\\n    }\\r\\n\\r\\n  } else if (key.meta) {\\r\\n    /* Meta key pressed */\\r\\n\\r\\n    switch (key.name) {\\r\\n      case 'b': // backward word\\r\\n        this._wordLeft();\\r\\n        break;\\r\\n\\r\\n      case 'f': // forward word\\r\\n        this._wordRight();\\r\\n        break;\\r\\n\\r\\n      case 'd': // delete forward word\\r\\n      case 'delete':\\r\\n        this._deleteWordRight();\\r\\n        break;\\r\\n\\r\\n      case 'backspace': // delete backwards to a word boundary\\r\\n        this._deleteWordLeft();\\r\\n        break;\\r\\n    }\\r\\n\\r\\n  } else {\\r\\n    /* No modifier keys used */\\r\\n\\r\\n    // \\\\r bookkeeping is only relevant if a \\\\n comes right after.\\r\\n    if (this._sawReturn && key.name !== 'enter')\\r\\n      this._sawReturn = false;\\r\\n\\r\\n    switch (key.name) {\\r\\n      case 'return':  // carriage return, i.e. \\\\r\\r\\n        this._sawReturn = true;\\r\\n        this._line();\\r\\n        break;\\r\\n\\r\\n      case 'enter':\\r\\n        if (this._sawReturn)\\r\\n          this._sawReturn = false;\\r\\n        else\\r\\n          this._line();\\r\\n        break;\\r\\n\\r\\n      case 'backspace':\\r\\n        this._deleteLeft();\\r\\n        break;\\r\\n\\r\\n      case 'delete':\\r\\n        this._deleteRight();\\r\\n        break;\\r\\n\\r\\n      case 'tab': // tab completion\\r\\n        this._tabComplete();\\r\\n        break;\\r\\n\\r\\n      case 'left':\\r\\n        this._moveCursor(-1);\\r\\n        break;\\r\\n\\r\\n      case 'right':\\r\\n        this._moveCursor(+1);\\r\\n        break;\\r\\n\\r\\n      case 'home':\\r\\n        this._moveCursor(-Infinity);\\r\\n        break;\\r\\n\\r\\n      case 'end':\\r\\n        this._moveCursor(+Infinity);\\r\\n        break;\\r\\n\\r\\n      case 'up':\\r\\n        this._historyPrev();\\r\\n        break;\\r\\n\\r\\n      case 'down':\\r\\n        this._historyNext();\\r\\n        break;\\r\\n\\r\\n      default:\\r\\n        if (s instanceof Buffer)\\r\\n          s = s.toString('utf-8');\\r\\n\\r\\n        if (s) {\\r\\n          var lines = s.split(/\\\\r\\\\n|\\\\n|\\\\r/);\\r\\n          for (var i = 0, len = lines.length; i < len; i++) {\\r\\n            if (i > 0) {\\r\\n              this._line();\\r\\n            }\\r\\n            this._insertString(lines[i]);\\r\\n          }\\r\\n        }\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nexports.Interface = Interface;\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * accepts a readable Stream instance and makes it emit \\\"keypress\\\" events\\r\\n */\\r\\n\\r\\nfunction emitKeypressEvents(stream) {\\r\\n  if (stream._keypressDecoder) return;\\r\\n  var StringDecoder = require('string_decoder').StringDecoder; // lazy load\\r\\n  stream._keypressDecoder = new StringDecoder('utf8');\\r\\n\\r\\n  function onData(b) {\\r\\n    if (EventEmitter.listenerCount(stream, 'keypress') > 0) {\\r\\n      var r = stream._keypressDecoder.write(b);\\r\\n      if (r) emitKeys(stream, r);\\r\\n    } else {\\r\\n      // Nobody's watching anyway\\r\\n      stream.removeListener('data', onData);\\r\\n      stream.on('newListener', onNewListener);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function onNewListener(event) {\\r\\n    if (event == 'keypress') {\\r\\n      stream.on('data', onData);\\r\\n      stream.removeListener('newListener', onNewListener);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (EventEmitter.listenerCount(stream, 'keypress') > 0) {\\r\\n    stream.on('data', onData);\\r\\n  } else {\\r\\n    stream.on('newListener', onNewListener);\\r\\n  }\\r\\n}\\r\\nexports.emitKeypressEvents = emitKeypressEvents;\\r\\n\\r\\n/*\\r\\n  Some patterns seen in terminal key escape codes, derived from combos seen\\r\\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\\r\\n\\r\\n  ESC letter\\r\\n  ESC [ letter\\r\\n  ESC [ modifier letter\\r\\n  ESC [ 1 ; modifier letter\\r\\n  ESC [ num char\\r\\n  ESC [ num ; modifier char\\r\\n  ESC O letter\\r\\n  ESC O modifier letter\\r\\n  ESC O 1 ; modifier letter\\r\\n  ESC N letter\\r\\n  ESC [ [ num ; modifier char\\r\\n  ESC [ [ 1 ; modifier letter\\r\\n  ESC ESC [ num char\\r\\n  ESC ESC O letter\\r\\n\\r\\n  - char is usually ~ but $ and ^ also happen with rxvt\\r\\n  - modifier is 1 +\\r\\n                (shift     * 1) +\\r\\n                (left_alt  * 2) +\\r\\n                (ctrl      * 4) +\\r\\n                (right_alt * 8)\\r\\n  - two leading ESCs apparently mean the same as one leading ESC\\r\\n*/\\r\\n\\r\\n// Regexes used for ansi escape code splitting\\r\\nvar metaKeyCodeReAnywhere = /(?:\\\\x1b)([a-zA-Z0-9])/;\\r\\nvar metaKeyCodeRe = new RegExp('^' + metaKeyCodeReAnywhere.source + '$');\\r\\nvar functionKeyCodeReAnywhere = new RegExp('(?:\\\\x1b+)(O|N|\\\\\\\\[|\\\\\\\\[\\\\\\\\[)(?:' + [\\r\\n  '(\\\\\\\\d+)(?:;(\\\\\\\\d+))?([~^$])',\\r\\n  '(?:M([@ #!a`])(.)(.))', // mouse\\r\\n  '(?:1;)?(\\\\\\\\d+)?([a-zA-Z])'\\r\\n].join('|') + ')');\\r\\nvar functionKeyCodeRe = new RegExp('^' + functionKeyCodeReAnywhere.source);\\r\\nvar escapeCodeReAnywhere = new RegExp([\\r\\n  functionKeyCodeReAnywhere.source, metaKeyCodeReAnywhere.source, /\\\\x1b./.source\\r\\n].join('|'));\\r\\n\\r\\nfunction emitKeys(stream, s) {\\r\\n  if (s instanceof Buffer) {\\r\\n    if (s[0] > 127 && s[1] === undefined) {\\r\\n      s[0] -= 128;\\r\\n      s = '\\\\x1b' + s.toString(stream.encoding || 'utf-8');\\r\\n    } else {\\r\\n      s = s.toString(stream.encoding || 'utf-8');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var buffer = [];\\r\\n  var match;\\r\\n  while (match = escapeCodeReAnywhere.exec(s)) {\\r\\n    buffer = buffer.concat(s.slice(0, match.index).split(''));\\r\\n    buffer.push(match[0]);\\r\\n    s = s.slice(match.index + match[0].length);\\r\\n  }\\r\\n  buffer = buffer.concat(s.split(''));\\r\\n\\r\\n  buffer.forEach(function(s) {\\r\\n    var ch,\\r\\n        key = {\\r\\n          sequence: s,\\r\\n          name: undefined,\\r\\n          ctrl: false,\\r\\n          meta: false,\\r\\n          shift: false\\r\\n        },\\r\\n        parts;\\r\\n\\r\\n    if (s === '\\\\r') {\\r\\n      // carriage return\\r\\n      key.name = 'return';\\r\\n\\r\\n    } else if (s === '\\\\n') {\\r\\n      // enter, should have been called linefeed\\r\\n      key.name = 'enter';\\r\\n\\r\\n    } else if (s === '\\\\t') {\\r\\n      // tab\\r\\n      key.name = 'tab';\\r\\n\\r\\n    } else if (s === '\\\\b' || s === '\\\\x7f' ||\\r\\n               s === '\\\\x1b\\\\x7f' || s === '\\\\x1b\\\\b') {\\r\\n      // backspace or ctrl+h\\r\\n      key.name = 'backspace';\\r\\n      key.meta = (s.charAt(0) === '\\\\x1b');\\r\\n\\r\\n    } else if (s === '\\\\x1b' || s === '\\\\x1b\\\\x1b') {\\r\\n      // escape key\\r\\n      key.name = 'escape';\\r\\n      key.meta = (s.length === 2);\\r\\n\\r\\n    } else if (s === ' ' || s === '\\\\x1b ') {\\r\\n      key.name = 'space';\\r\\n      key.meta = (s.length === 2);\\r\\n\\r\\n    } else if (s.length === 1 && s <= '\\\\x1a') {\\r\\n      // ctrl+letter\\r\\n      key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);\\r\\n      key.ctrl = true;\\r\\n\\r\\n    } else if (s.length === 1 && s >= 'a' && s <= 'z') {\\r\\n      // lowercase letter\\r\\n      key.name = s;\\r\\n\\r\\n    } else if (s.length === 1 && s >= 'A' && s <= 'Z') {\\r\\n      // shift+letter\\r\\n      key.name = s.toLowerCase();\\r\\n      key.shift = true;\\r\\n\\r\\n    } else if (parts = metaKeyCodeRe.exec(s)) {\\r\\n      // meta+character key\\r\\n      key.name = parts[1].toLowerCase();\\r\\n      key.meta = true;\\r\\n      key.shift = /^[A-Z]$/.test(parts[1]);\\r\\n\\r\\n    } else if (parts = functionKeyCodeRe.exec(s)) {\\r\\n      // ansi escape sequence\\r\\n\\r\\n      // reassemble the key code leaving out leading \\\\x1b's,\\r\\n      // the modifier key bitflag and any meaningless \\\"1;\\\" sequence\\r\\n      var code = (parts[1] || '') + (parts[2] || '') +\\r\\n                 (parts[4] || '') + (parts[9] || ''),\\r\\n          modifier = (parts[3] || parts[8] || 1) - 1;\\r\\n\\r\\n      // Parse the key modifier\\r\\n      key.ctrl = !!(modifier & 4);\\r\\n      key.meta = !!(modifier & 10);\\r\\n      key.shift = !!(modifier & 1);\\r\\n      key.code = code;\\r\\n\\r\\n      // Parse the key itself\\r\\n      switch (code) {\\r\\n        /* xterm/gnome ESC O letter */\\r\\n        case 'OP': key.name = 'f1'; break;\\r\\n        case 'OQ': key.name = 'f2'; break;\\r\\n        case 'OR': key.name = 'f3'; break;\\r\\n        case 'OS': key.name = 'f4'; break;\\r\\n\\r\\n        /* xterm/rxvt ESC [ number ~ */\\r\\n        case '[11~': key.name = 'f1'; break;\\r\\n        case '[12~': key.name = 'f2'; break;\\r\\n        case '[13~': key.name = 'f3'; break;\\r\\n        case '[14~': key.name = 'f4'; break;\\r\\n\\r\\n        /* from Cygwin and used in libuv */\\r\\n        case '[[A': key.name = 'f1'; break;\\r\\n        case '[[B': key.name = 'f2'; break;\\r\\n        case '[[C': key.name = 'f3'; break;\\r\\n        case '[[D': key.name = 'f4'; break;\\r\\n        case '[[E': key.name = 'f5'; break;\\r\\n\\r\\n        /* common */\\r\\n        case '[15~': key.name = 'f5'; break;\\r\\n        case '[17~': key.name = 'f6'; break;\\r\\n        case '[18~': key.name = 'f7'; break;\\r\\n        case '[19~': key.name = 'f8'; break;\\r\\n        case '[20~': key.name = 'f9'; break;\\r\\n        case '[21~': key.name = 'f10'; break;\\r\\n        case '[23~': key.name = 'f11'; break;\\r\\n        case '[24~': key.name = 'f12'; break;\\r\\n\\r\\n        /* xterm ESC [ letter */\\r\\n        case '[A': key.name = 'up'; break;\\r\\n        case '[B': key.name = 'down'; break;\\r\\n        case '[C': key.name = 'right'; break;\\r\\n        case '[D': key.name = 'left'; break;\\r\\n        case '[E': key.name = 'clear'; break;\\r\\n        case '[F': key.name = 'end'; break;\\r\\n        case '[H': key.name = 'home'; break;\\r\\n\\r\\n        /* xterm/gnome ESC O letter */\\r\\n        case 'OA': key.name = 'up'; break;\\r\\n        case 'OB': key.name = 'down'; break;\\r\\n        case 'OC': key.name = 'right'; break;\\r\\n        case 'OD': key.name = 'left'; break;\\r\\n        case 'OE': key.name = 'clear'; break;\\r\\n        case 'OF': key.name = 'end'; break;\\r\\n        case 'OH': key.name = 'home'; break;\\r\\n\\r\\n        /* xterm/rxvt ESC [ number ~ */\\r\\n        case '[1~': key.name = 'home'; break;\\r\\n        case '[2~': key.name = 'insert'; break;\\r\\n        case '[3~': key.name = 'delete'; break;\\r\\n        case '[4~': key.name = 'end'; break;\\r\\n        case '[5~': key.name = 'pageup'; break;\\r\\n        case '[6~': key.name = 'pagedown'; break;\\r\\n\\r\\n        /* putty */\\r\\n        case '[[5~': key.name = 'pageup'; break;\\r\\n        case '[[6~': key.name = 'pagedown'; break;\\r\\n\\r\\n        /* rxvt */\\r\\n        case '[7~': key.name = 'home'; break;\\r\\n        case '[8~': key.name = 'end'; break;\\r\\n\\r\\n        /* rxvt keys with modifiers */\\r\\n        case '[a': key.name = 'up'; key.shift = true; break;\\r\\n        case '[b': key.name = 'down'; key.shift = true; break;\\r\\n        case '[c': key.name = 'right'; key.shift = true; break;\\r\\n        case '[d': key.name = 'left'; key.shift = true; break;\\r\\n        case '[e': key.name = 'clear'; key.shift = true; break;\\r\\n\\r\\n        case '[2$': key.name = 'insert'; key.shift = true; break;\\r\\n        case '[3$': key.name = 'delete'; key.shift = true; break;\\r\\n        case '[5$': key.name = 'pageup'; key.shift = true; break;\\r\\n        case '[6$': key.name = 'pagedown'; key.shift = true; break;\\r\\n        case '[7$': key.name = 'home'; key.shift = true; break;\\r\\n        case '[8$': key.name = 'end'; key.shift = true; break;\\r\\n\\r\\n        case 'Oa': key.name = 'up'; key.ctrl = true; break;\\r\\n        case 'Ob': key.name = 'down'; key.ctrl = true; break;\\r\\n        case 'Oc': key.name = 'right'; key.ctrl = true; break;\\r\\n        case 'Od': key.name = 'left'; key.ctrl = true; break;\\r\\n        case 'Oe': key.name = 'clear'; key.ctrl = true; break;\\r\\n\\r\\n        case '[2^': key.name = 'insert'; key.ctrl = true; break;\\r\\n        case '[3^': key.name = 'delete'; key.ctrl = true; break;\\r\\n        case '[5^': key.name = 'pageup'; key.ctrl = true; break;\\r\\n        case '[6^': key.name = 'pagedown'; key.ctrl = true; break;\\r\\n        case '[7^': key.name = 'home'; key.ctrl = true; break;\\r\\n        case '[8^': key.name = 'end'; key.ctrl = true; break;\\r\\n\\r\\n        /* misc. */\\r\\n        case '[Z': key.name = 'tab'; key.shift = true; break;\\r\\n        default: key.name = 'undefined'; break;\\r\\n\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Don't emit a key if no name was found\\r\\n    if (key.name === undefined) {\\r\\n      key = undefined;\\r\\n    }\\r\\n\\r\\n    if (s.length === 1) {\\r\\n      ch = s;\\r\\n    }\\r\\n\\r\\n    if (key || ch) {\\r\\n      stream.emit('keypress', ch, key);\\r\\n    }\\r\\n  });\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * moves the cursor to the x and y coordinate on the given stream\\r\\n */\\r\\n\\r\\nfunction cursorTo(stream, x, y) {\\r\\n  if (stream === null || stream === undefined)\\r\\n    return;\\r\\n\\r\\n  if (typeof x !== 'number' && typeof y !== 'number')\\r\\n    return;\\r\\n\\r\\n  if (typeof x !== 'number')\\r\\n    throw new Error(\\\"Can't set cursor row without also setting it's column\\\");\\r\\n\\r\\n  if (typeof y !== 'number') {\\r\\n    stream.write('\\\\x1b[' + (x + 1) + 'G');\\r\\n  } else {\\r\\n    stream.write('\\\\x1b[' + (y + 1) + ';' + (x + 1) + 'H');\\r\\n  }\\r\\n}\\r\\nexports.cursorTo = cursorTo;\\r\\n\\r\\n\\r\\n/**\\r\\n * moves the cursor relative to its current location\\r\\n */\\r\\n\\r\\nfunction moveCursor(stream, dx, dy) {\\r\\n  if (stream === null || stream === undefined)\\r\\n    return;\\r\\n\\r\\n  if (dx < 0) {\\r\\n    stream.write('\\\\x1b[' + (-dx) + 'D');\\r\\n  } else if (dx > 0) {\\r\\n    stream.write('\\\\x1b[' + dx + 'C');\\r\\n  }\\r\\n\\r\\n  if (dy < 0) {\\r\\n    stream.write('\\\\x1b[' + (-dy) + 'A');\\r\\n  } else if (dy > 0) {\\r\\n    stream.write('\\\\x1b[' + dy + 'B');\\r\\n  }\\r\\n}\\r\\nexports.moveCursor = moveCursor;\\r\\n\\r\\n\\r\\n/**\\r\\n * clears the current line the cursor is on:\\r\\n *   -1 for left of the cursor\\r\\n *   +1 for right of the cursor\\r\\n *    0 for the entire line\\r\\n */\\r\\n\\r\\nfunction clearLine(stream, dir) {\\r\\n  if (stream === null || stream === undefined)\\r\\n    return;\\r\\n\\r\\n  if (dir < 0) {\\r\\n    // to the beginning\\r\\n    stream.write('\\\\x1b[1K');\\r\\n  } else if (dir > 0) {\\r\\n    // to the end\\r\\n    stream.write('\\\\x1b[0K');\\r\\n  } else {\\r\\n    // entire line\\r\\n    stream.write('\\\\x1b[2K');\\r\\n  }\\r\\n}\\r\\nexports.clearLine = clearLine;\\r\\n\\r\\n\\r\\n/**\\r\\n * clears the screen from the current position of the cursor down\\r\\n */\\r\\n\\r\\nfunction clearScreenDown(stream) {\\r\\n  if (stream === null || stream === undefined)\\r\\n    return;\\r\\n\\r\\n  stream.write('\\\\x1b[0J');\\r\\n}\\r\\nexports.clearScreenDown = clearScreenDown;\\r\\n\\r\\n\\r\\n/**\\r\\n * Returns the number of columns required to display the given string.\\r\\n */\\r\\n\\r\\nfunction getStringWidth(str) {\\r\\n  var width = 0;\\r\\n  str = stripVTControlCharacters(str);\\r\\n  for (var i = 0, len = str.length; i < len; i++) {\\r\\n    var code = str.codePointAt(i);\\r\\n    if (code >= 0x10000) { // surrogates\\r\\n      i++;\\r\\n    }\\r\\n    if (isFullWidthCodePoint(code)) {\\r\\n      width += 2;\\r\\n    } else {\\r\\n      width++;\\r\\n    }\\r\\n  }\\r\\n  return width;\\r\\n}\\r\\nexports.getStringWidth = getStringWidth;\\r\\n\\r\\n\\r\\n/**\\r\\n * Returns true if the character represented by a given\\r\\n * Unicode code point is full-width. Otherwise returns false.\\r\\n */\\r\\n\\r\\nfunction isFullWidthCodePoint(code) {\\r\\n  if (isNaN(code)) {\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  // Code points are derived from:\\r\\n  // http://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\\r\\n  if (code >= 0x1100 && (\\r\\n      code <= 0x115f ||  // Hangul Jamo\\r\\n      0x2329 === code || // LEFT-POINTING ANGLE BRACKET\\r\\n      0x232a === code || // RIGHT-POINTING ANGLE BRACKET\\r\\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\\r\\n      (0x2e80 <= code && code <= 0x3247 && code !== 0x303f) ||\\r\\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\\r\\n      0x3250 <= code && code <= 0x4dbf ||\\r\\n      // CJK Unified Ideographs .. Yi Radicals\\r\\n      0x4e00 <= code && code <= 0xa4c6 ||\\r\\n      // Hangul Jamo Extended-A\\r\\n      0xa960 <= code && code <= 0xa97c ||\\r\\n      // Hangul Syllables\\r\\n      0xac00 <= code && code <= 0xd7a3 ||\\r\\n      // CJK Compatibility Ideographs\\r\\n      0xf900 <= code && code <= 0xfaff ||\\r\\n      // Vertical Forms\\r\\n      0xfe10 <= code && code <= 0xfe19 ||\\r\\n      // CJK Compatibility Forms .. Small Form Variants\\r\\n      0xfe30 <= code && code <= 0xfe6b ||\\r\\n      // Halfwidth and Fullwidth Forms\\r\\n      0xff01 <= code && code <= 0xff60 ||\\r\\n      0xffe0 <= code && code <= 0xffe6 ||\\r\\n      // Kana Supplement\\r\\n      0x1b000 <= code && code <= 0x1b001 ||\\r\\n      // Enclosed Ideographic Supplement\\r\\n      0x1f200 <= code && code <= 0x1f251 ||\\r\\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\\r\\n      0x20000 <= code && code <= 0x3fffd)) {\\r\\n    return true;\\r\\n  }\\r\\n  return false;\\r\\n}\\r\\nexports.isFullWidthCodePoint = isFullWidthCodePoint;\\r\\n\\r\\n\\r\\n/**\\r\\n * Returns the Unicode code point for the character at the\\r\\n * given index in the given string. Similar to String.charCodeAt(),\\r\\n * but this function handles surrogates (code point >= 0x10000).\\r\\n */\\r\\n\\r\\nfunction codePointAt(str, index) {\\r\\n  var code = str.charCodeAt(index);\\r\\n  var low;\\r\\n  if (0xd800 <= code && code <= 0xdbff) { // High surrogate\\r\\n    low = str.charCodeAt(index + 1);\\r\\n    if (!isNaN(low)) {\\r\\n      code = 0x10000 + (code - 0xd800) * 0x400 + (low - 0xdc00);\\r\\n    }\\r\\n  }\\r\\n  return code;\\r\\n}\\r\\nexports.codePointAt = util.deprecate(codePointAt,\\r\\n    'codePointAt() is deprecated. Use String.prototype.codePointAt');\\r\\n\\r\\n\\r\\n/**\\r\\n * Tries to remove all VT control characters. Use to estimate displayed\\r\\n * string width. May be buggy due to not running a real state machine\\r\\n */\\r\\nfunction stripVTControlCharacters(str) {\\r\\n  str = str.replace(new RegExp(functionKeyCodeReAnywhere.source, 'g'), '');\\r\\n  return str.replace(new RegExp(metaKeyCodeReAnywhere.source, 'g'), '');\\r\\n}\\r\\nexports.stripVTControlCharacters = stripVTControlCharacters;\\r\\n\",\"querystring\":\"// Query String Utilities\\r\\n\\r\\n'use strict';\\r\\n\\r\\nvar QueryString = exports;\\r\\nvar Buffer = require('buffer').Buffer;\\r\\n\\r\\n\\r\\nfunction charCode(c) {\\r\\n  return c.charCodeAt(0);\\r\\n}\\r\\n\\r\\n\\r\\n// a safe fast alternative to decodeURIComponent\\r\\nQueryString.unescapeBuffer = function(s, decodeSpaces) {\\r\\n  var out = new Buffer(s.length);\\r\\n  var state = 'CHAR'; // states: CHAR, HEX0, HEX1\\r\\n  var n, m, hexchar;\\r\\n\\r\\n  for (var inIndex = 0, outIndex = 0; inIndex <= s.length; inIndex++) {\\r\\n    var c = s.charCodeAt(inIndex);\\r\\n    switch (state) {\\r\\n      case 'CHAR':\\r\\n        switch (c) {\\r\\n          case charCode('%'):\\r\\n            n = 0;\\r\\n            m = 0;\\r\\n            state = 'HEX0';\\r\\n            break;\\r\\n          case charCode('+'):\\r\\n            if (decodeSpaces) c = charCode(' ');\\r\\n            // falls through\\r\\n          default:\\r\\n            out[outIndex++] = c;\\r\\n            break;\\r\\n        }\\r\\n        break;\\r\\n\\r\\n      case 'HEX0':\\r\\n        state = 'HEX1';\\r\\n        hexchar = c;\\r\\n        if (charCode('0') <= c && c <= charCode('9')) {\\r\\n          n = c - charCode('0');\\r\\n        } else if (charCode('a') <= c && c <= charCode('f')) {\\r\\n          n = c - charCode('a') + 10;\\r\\n        } else if (charCode('A') <= c && c <= charCode('F')) {\\r\\n          n = c - charCode('A') + 10;\\r\\n        } else {\\r\\n          out[outIndex++] = charCode('%');\\r\\n          out[outIndex++] = c;\\r\\n          state = 'CHAR';\\r\\n          break;\\r\\n        }\\r\\n        break;\\r\\n\\r\\n      case 'HEX1':\\r\\n        state = 'CHAR';\\r\\n        if (charCode('0') <= c && c <= charCode('9')) {\\r\\n          m = c - charCode('0');\\r\\n        } else if (charCode('a') <= c && c <= charCode('f')) {\\r\\n          m = c - charCode('a') + 10;\\r\\n        } else if (charCode('A') <= c && c <= charCode('F')) {\\r\\n          m = c - charCode('A') + 10;\\r\\n        } else {\\r\\n          out[outIndex++] = charCode('%');\\r\\n          out[outIndex++] = hexchar;\\r\\n          out[outIndex++] = c;\\r\\n          break;\\r\\n        }\\r\\n        out[outIndex++] = 16 * n + m;\\r\\n        break;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // TODO support returning arbitrary buffers.\\r\\n\\r\\n  return out.slice(0, outIndex - 1);\\r\\n};\\r\\n\\r\\n\\r\\nQueryString.unescape = function(s, decodeSpaces) {\\r\\n  try {\\r\\n    return decodeURIComponent(s);\\r\\n  } catch (e) {\\r\\n    return QueryString.unescapeBuffer(s, decodeSpaces).toString();\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nvar hexTable = new Array(256);\\r\\nfor (var i = 0; i < 256; ++i)\\r\\n  hexTable[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\\r\\nQueryString.escape = function(str) {\\r\\n  // replaces encodeURIComponent\\r\\n  // http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3.4\\r\\n  str = '' + str;\\r\\n  var len = str.length;\\r\\n  var out = '';\\r\\n  var i, c;\\r\\n\\r\\n  if (len === 0)\\r\\n    return str;\\r\\n\\r\\n  for (i = 0; i < len; ++i) {\\r\\n    c = str.charCodeAt(i);\\r\\n\\r\\n    // These characters do not need escaping (in order):\\r\\n    // ! - . _ ~\\r\\n    // ' ( ) *\\r\\n    // digits\\r\\n    // alpha (uppercase)\\r\\n    // alpha (lowercase)\\r\\n    if (c === 0x21 || c === 0x2D || c === 0x2E || c === 0x5F || c === 0x7E ||\\r\\n        (c >= 0x27 && c <= 0x2A) ||\\r\\n        (c >= 0x30 && c <= 0x39) ||\\r\\n        (c >= 0x41 && c <= 0x5A) ||\\r\\n        (c >= 0x61 && c <= 0x7A)) {\\r\\n      out += str[i];\\r\\n      continue;\\r\\n    }\\r\\n\\r\\n    // Other ASCII characters\\r\\n    if (c < 0x80) {\\r\\n      out += hexTable[c];\\r\\n      continue;\\r\\n    }\\r\\n\\r\\n    // Multi-byte characters ...\\r\\n    if (c < 0x800) {\\r\\n      out += hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)];\\r\\n      continue;\\r\\n    }\\r\\n    if (c < 0xD800 || c >= 0xE000) {\\r\\n      out += hexTable[0xE0 | (c >> 12)] +\\r\\n             hexTable[0x80 | ((c >> 6) & 0x3F)] +\\r\\n             hexTable[0x80 | (c & 0x3F)];\\r\\n      continue;\\r\\n    }\\r\\n    // Surrogate pair\\r\\n    ++i;\\r\\n    c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));\\r\\n    out += hexTable[0xF0 | (c >> 18)] +\\r\\n           hexTable[0x80 | ((c >> 12) & 0x3F)] +\\r\\n           hexTable[0x80 | ((c >> 6) & 0x3F)] +\\r\\n           hexTable[0x80 | (c & 0x3F)];\\r\\n  }\\r\\n  return out;\\r\\n};\\r\\n\\r\\nvar stringifyPrimitive = function(v) {\\r\\n  if (typeof v === 'string')\\r\\n    return v;\\r\\n  if (typeof v === 'number' && isFinite(v))\\r\\n    return '' + v;\\r\\n  if (typeof v === 'boolean')\\r\\n    return v ? 'true' : 'false';\\r\\n  return '';\\r\\n};\\r\\n\\r\\n\\r\\nQueryString.stringify = QueryString.encode = function(obj, sep, eq, options) {\\r\\n  sep = sep || '&';\\r\\n  eq = eq || '=';\\r\\n\\r\\n  var encode = QueryString.escape;\\r\\n  if (options && typeof options.encodeURIComponent === 'function') {\\r\\n    encode = options.encodeURIComponent;\\r\\n  }\\r\\n\\r\\n  if (obj !== null && typeof obj === 'object') {\\r\\n    var keys = Object.keys(obj);\\r\\n    var len = keys.length;\\r\\n    var flast = len - 1;\\r\\n    var fields = '';\\r\\n    for (var i = 0; i < len; ++i) {\\r\\n      var k = keys[i];\\r\\n      var v = obj[k];\\r\\n      var ks = encode(stringifyPrimitive(k)) + eq;\\r\\n\\r\\n      if (Array.isArray(v)) {\\r\\n        var vlen = v.length;\\r\\n        var vlast = vlen - 1;\\r\\n        for (var j = 0; j < vlen; ++j) {\\r\\n          fields += ks + encode(stringifyPrimitive(v[j]));\\r\\n          if (j < vlast)\\r\\n            fields += sep;\\r\\n        }\\r\\n        if (vlen && i < flast)\\r\\n          fields += sep;\\r\\n      } else {\\r\\n        fields += ks + encode(stringifyPrimitive(v));\\r\\n        if (i < flast)\\r\\n          fields += sep;\\r\\n      }\\r\\n    }\\r\\n    return fields;\\r\\n  }\\r\\n  return '';\\r\\n};\\r\\n\\r\\n// Parse a key=val string.\\r\\nQueryString.parse = QueryString.decode = function(qs, sep, eq, options) {\\r\\n  sep = sep || '&';\\r\\n  eq = eq || '=';\\r\\n  var eqLen = eq.length;\\r\\n  var obj = {};\\r\\n\\r\\n  if (typeof qs !== 'string' || qs.length === 0) {\\r\\n    return obj;\\r\\n  }\\r\\n\\r\\n  var regexp = /\\\\+/g;\\r\\n  qs = qs.split(sep);\\r\\n\\r\\n  var maxKeys = 1000;\\r\\n  if (options && typeof options.maxKeys === 'number') {\\r\\n    maxKeys = options.maxKeys;\\r\\n  }\\r\\n\\r\\n  var len = qs.length;\\r\\n  // maxKeys <= 0 means that we should not limit keys count\\r\\n  if (maxKeys > 0 && len > maxKeys) {\\r\\n    len = maxKeys;\\r\\n  }\\r\\n\\r\\n  var decode = QueryString.unescape;\\r\\n  if (options && typeof options.decodeURIComponent === 'function') {\\r\\n    decode = options.decodeURIComponent;\\r\\n  }\\r\\n\\r\\n  var keys = [];\\r\\n  for (var i = 0; i < len; ++i) {\\r\\n    var x = qs[i].replace(regexp, '%20'),\\r\\n        idx = x.indexOf(eq),\\r\\n        k, v;\\r\\n\\r\\n    if (idx >= 0) {\\r\\n      k = decodeStr(x.substring(0, idx), decode);\\r\\n      v = decodeStr(x.substring(idx + eqLen), decode);\\r\\n    } else {\\r\\n      k = decodeStr(x, decode);\\r\\n      v = '';\\r\\n    }\\r\\n\\r\\n    if (keys.indexOf(k) === -1) {\\r\\n      obj[k] = v;\\r\\n      keys.push(k);\\r\\n    } else if (Array.isArray(obj[k])) {\\r\\n      obj[k].push(v);\\r\\n    } else {\\r\\n      obj[k] = [obj[k], v];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return obj;\\r\\n};\\r\\n\\r\\n\\r\\nfunction decodeStr(s, decoder) {\\r\\n  try {\\r\\n    return decoder(s);\\r\\n  } catch (e) {\\r\\n    return QueryString.unescape(s, true);\\r\\n  }\\r\\n}\\r\\n\",\"assert\":\"// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\\r\\n//\\r\\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\\r\\n//\\r\\n// Originally from narwhal.js (http://narwhaljs.org)\\r\\n// Copyright (c) 2009 Thomas Robinson <280north.com>\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n// of this software and associated documentation files (the 'Software'), to\\r\\n// deal in the Software without restriction, including without limitation the\\r\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\\r\\n// sell copies of the Software, and to permit persons to whom the Software is\\r\\n// furnished to do so, subject to the following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included in\\r\\n// all copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\\r\\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\\r\\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n\\r\\n// UTILITY\\r\\nvar util = require('util');\\r\\nvar pSlice = Array.prototype.slice;\\r\\n\\r\\n// 1. The assert module provides functions that throw\\r\\n// AssertionError's when particular conditions are not met. The\\r\\n// assert module must conform to the following interface.\\r\\n\\r\\nvar assert = module.exports = ok;\\r\\n\\r\\n// 2. The AssertionError is defined in assert.\\r\\n// new assert.AssertionError({ message: message,\\r\\n//                             actual: actual,\\r\\n//                             expected: expected })\\r\\n\\r\\nassert.AssertionError = function AssertionError(options) {\\r\\n  this.name = 'AssertionError';\\r\\n  this.actual = options.actual;\\r\\n  this.expected = options.expected;\\r\\n  this.operator = options.operator;\\r\\n  if (options.message) {\\r\\n    this.message = options.message;\\r\\n    this.generatedMessage = false;\\r\\n  } else {\\r\\n    this.message = getMessage(this);\\r\\n    this.generatedMessage = true;\\r\\n  }\\r\\n  var stackStartFunction = options.stackStartFunction || fail;\\r\\n  //Error.captureStackTrace(this, stackStartFunction);\\r\\n};\\r\\n\\r\\n// assert.AssertionError instanceof Error\\r\\nutil.inherits(assert.AssertionError, Error);\\r\\n\\r\\nfunction replacer(key, value) {\\r\\n  if (util.isUndefined(value)) {\\r\\n    return '' + value;\\r\\n  }\\r\\n  if (util.isNumber(value) && !isFinite(value)) {\\r\\n    return value.toString();\\r\\n  }\\r\\n  if (util.isFunction(value) || util.isRegExp(value)) {\\r\\n    return value.toString();\\r\\n  }\\r\\n  return value;\\r\\n}\\r\\n\\r\\nfunction truncate(s, n) {\\r\\n  if (util.isString(s)) {\\r\\n    return s.length < n ? s : s.slice(0, n);\\r\\n  } else {\\r\\n    return s;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction getMessage(self) {\\r\\n  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +\\r\\n         self.operator + ' ' +\\r\\n         truncate(JSON.stringify(self.expected, replacer), 128);\\r\\n}\\r\\n\\r\\n// At present only the three keys mentioned above are used and\\r\\n// understood by the spec. Implementations or sub modules can pass\\r\\n// other keys to the AssertionError's constructor - they will be\\r\\n// ignored.\\r\\n\\r\\n// 3. All of the following functions must throw an AssertionError\\r\\n// when a corresponding condition is not met, with a message that\\r\\n// may be undefined if not provided.  All assertion methods provide\\r\\n// both the actual and expected values to the assertion error for\\r\\n// display purposes.\\r\\n\\r\\nfunction fail(actual, expected, message, operator, stackStartFunction) {\\r\\n  throw new assert.AssertionError({\\r\\n    message: message,\\r\\n    actual: actual,\\r\\n    expected: expected,\\r\\n    operator: operator,\\r\\n    stackStartFunction: stackStartFunction\\r\\n  });\\r\\n}\\r\\n\\r\\n// EXTENSION! allows for well behaved errors defined elsewhere.\\r\\nassert.fail = fail;\\r\\n\\r\\n// 4. Pure assertion tests whether a value is truthy, as determined\\r\\n// by !!guard.\\r\\n// assert.ok(guard, message_opt);\\r\\n// This statement is equivalent to assert.equal(true, !!guard,\\r\\n// message_opt);. To test strictly for the value true, use\\r\\n// assert.strictEqual(true, guard, message_opt);.\\r\\n\\r\\nfunction ok(value, message) {\\r\\n  if (!value) fail(value, true, message, '==', assert.ok);\\r\\n}\\r\\nassert.ok = ok;\\r\\n\\r\\n// 5. The equality assertion tests shallow, coercive equality with\\r\\n// ==.\\r\\n// assert.equal(actual, expected, message_opt);\\r\\n\\r\\nassert.equal = function equal(actual, expected, message) {\\r\\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\\r\\n};\\r\\n\\r\\n// 6. The non-equality assertion tests for whether two objects are not equal\\r\\n// with != assert.notEqual(actual, expected, message_opt);\\r\\n\\r\\nassert.notEqual = function notEqual(actual, expected, message) {\\r\\n  if (actual == expected) {\\r\\n    fail(actual, expected, message, '!=', assert.notEqual);\\r\\n  }\\r\\n};\\r\\n\\r\\n// 7. The equivalence assertion tests a deep equality relation.\\r\\n// assert.deepEqual(actual, expected, message_opt);\\r\\n\\r\\nassert.deepEqual = function deepEqual(actual, expected, message) {\\r\\n  if (!_deepEqual(actual, expected)) {\\r\\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\\r\\n  }\\r\\n};\\r\\n\\r\\nfunction _deepEqual(actual, expected) {\\r\\n  // 7.1. All identical values are equivalent, as determined by ===.\\r\\n  if (actual === expected) {\\r\\n    return true;\\r\\n\\r\\n  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {\\r\\n    if (actual.length != expected.length) return false;\\r\\n\\r\\n    for (var i = 0; i < actual.length; i++) {\\r\\n      if (actual[i] !== expected[i]) return false;\\r\\n    }\\r\\n\\r\\n    return true;\\r\\n\\r\\n  // 7.2. If the expected value is a Date object, the actual value is\\r\\n  // equivalent if it is also a Date object that refers to the same time.\\r\\n  } else if (util.isDate(actual) && util.isDate(expected)) {\\r\\n    return actual.getTime() === expected.getTime();\\r\\n\\r\\n  // 7.3 If the expected value is a RegExp object, the actual value is\\r\\n  // equivalent if it is also a RegExp object with the same source and\\r\\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\\r\\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\\r\\n    return actual.source === expected.source &&\\r\\n           actual.global === expected.global &&\\r\\n           actual.multiline === expected.multiline &&\\r\\n           actual.lastIndex === expected.lastIndex &&\\r\\n           actual.ignoreCase === expected.ignoreCase;\\r\\n\\r\\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\\r\\n  // equivalence is determined by ==.\\r\\n  } else if (!util.isObject(actual) && !util.isObject(expected)) {\\r\\n    return actual == expected;\\r\\n\\r\\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\\r\\n  // determined by having the same number of owned properties (as verified\\r\\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\\r\\n  // (although not necessarily the same order), equivalent values for every\\r\\n  // corresponding key, and an identical 'prototype' property. Note: this\\r\\n  // accounts for both named and indexed properties on Arrays.\\r\\n  } else {\\r\\n    return objEquiv(actual, expected);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction isArguments(object) {\\r\\n  return Object.prototype.toString.call(object) == '[object Arguments]';\\r\\n}\\r\\n\\r\\nfunction objEquiv(a, b) {\\r\\n  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))\\r\\n    return false;\\r\\n  // an identical 'prototype' property.\\r\\n  if (a.prototype !== b.prototype) return false;\\r\\n  //~~~I've managed to break Object.keys through screwy arguments passing.\\r\\n  //   Converting to array solves the problem.\\r\\n  var aIsArgs = isArguments(a),\\r\\n      bIsArgs = isArguments(b);\\r\\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\\r\\n    return false;\\r\\n  if (aIsArgs) {\\r\\n    a = pSlice.call(a);\\r\\n    b = pSlice.call(b);\\r\\n    return _deepEqual(a, b);\\r\\n  }\\r\\n  try {\\r\\n    var ka = Object.keys(a),\\r\\n        kb = Object.keys(b),\\r\\n        key, i;\\r\\n  } catch (e) {//happens when one is a string literal and the other isn't\\r\\n    return false;\\r\\n  }\\r\\n  // having the same number of owned properties (keys incorporates\\r\\n  // hasOwnProperty)\\r\\n  if (ka.length != kb.length)\\r\\n    return false;\\r\\n  //the same set of keys (although not necessarily the same order),\\r\\n  ka.sort();\\r\\n  kb.sort();\\r\\n  //~~~cheap key test\\r\\n  for (i = ka.length - 1; i >= 0; i--) {\\r\\n    if (ka[i] != kb[i])\\r\\n      return false;\\r\\n  }\\r\\n  //equivalent values for every corresponding key, and\\r\\n  //~~~possibly expensive deep test\\r\\n  for (i = ka.length - 1; i >= 0; i--) {\\r\\n    key = ka[i];\\r\\n    if (!_deepEqual(a[key], b[key])) return false;\\r\\n  }\\r\\n  return true;\\r\\n}\\r\\n\\r\\n// 8. The non-equivalence assertion tests for any deep inequality.\\r\\n// assert.notDeepEqual(actual, expected, message_opt);\\r\\n\\r\\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\\r\\n  if (_deepEqual(actual, expected)) {\\r\\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\\r\\n  }\\r\\n};\\r\\n\\r\\n// 9. The strict equality assertion tests strict equality, as determined by ===.\\r\\n// assert.strictEqual(actual, expected, message_opt);\\r\\n\\r\\nassert.strictEqual = function strictEqual(actual, expected, message) {\\r\\n  if (actual !== expected) {\\r\\n    fail(actual, expected, message, '===', assert.strictEqual);\\r\\n  }\\r\\n};\\r\\n\\r\\n// 10. The strict non-equality assertion tests for strict inequality, as\\r\\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\\r\\n\\r\\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\\r\\n  if (actual === expected) {\\r\\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\\r\\n  }\\r\\n};\\r\\n\\r\\nfunction expectedException(actual, expected) {\\r\\n  if (!actual || !expected) {\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\\r\\n    return expected.test(actual);\\r\\n  } else if (actual instanceof expected) {\\r\\n    return true;\\r\\n  } else if (expected.call({}, actual) === true) {\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  return false;\\r\\n}\\r\\n\\r\\nfunction _throws(shouldThrow, block, expected, message) {\\r\\n  var actual;\\r\\n\\r\\n  if (util.isString(expected)) {\\r\\n    message = expected;\\r\\n    expected = null;\\r\\n  }\\r\\n\\r\\n  try {\\r\\n    block();\\r\\n  } catch (e) {\\r\\n    actual = e;\\r\\n  }\\r\\n\\r\\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\\r\\n            (message ? ' ' + message : '.');\\r\\n\\r\\n  if (shouldThrow && !actual) {\\r\\n    fail(actual, expected, 'Missing expected exception' + message);\\r\\n  }\\r\\n\\r\\n  if (!shouldThrow && expectedException(actual, expected)) {\\r\\n    fail(actual, expected, 'Got unwanted exception' + message);\\r\\n  }\\r\\n\\r\\n  if ((shouldThrow && actual && expected &&\\r\\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\\r\\n    throw actual;\\r\\n  }\\r\\n}\\r\\n\\r\\n// 11. Expected to throw an error:\\r\\n// assert.throws(block, Error_opt, message_opt);\\r\\n\\r\\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\\r\\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\\r\\n};\\r\\n\\r\\n// EXTENSION! This is annoying to write outside this module.\\r\\nassert.doesNotThrow = function(block, /*optional*/message) {\\r\\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\\r\\n};\\r\\n\\r\\nassert.ifError = function(err) {\\r\\n  if (err) {throw new Error(err);}\\r\\n};\\r\\n\",\"console\":\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nvar util = require('util');\\nvar NEWLINE = '';\\n\\nfunction Console(stdout, stderr) {\\n  if (!(this instanceof Console)) {\\n    return new Console(stdout, stderr);\\n  }\\n  if (!stdout || !util.isFunction(stdout.write)) {\\n    throw new TypeError('Console expects a writable stream instance');\\n  }\\n  if (!stderr) {\\n    stderr = stdout;\\n  }\\n  var prop = {\\n    writable: true,\\n    enumerable: false,\\n    configurable: true\\n  };\\n  prop.value = stdout;\\n  Object.defineProperty(this, '_stdout', prop);\\n  prop.value = stderr;\\n  Object.defineProperty(this, '_stderr', prop);\\n  prop.value = {};\\n  Object.defineProperty(this, '_times', prop);\\n\\n  // bind the prototype functions to this Console instance\\n  Object.keys(Console.prototype).forEach(function(k) {\\n    this[k] = this[k].bind(this);\\n  }, this);\\n}\\n\\nConsole.prototype.log = function() {\\n  this._stdout.write(util.format.apply(this, arguments) + NEWLINE );\\n};\\n\\n\\nConsole.prototype.info = Console.prototype.log;\\n\\n\\nConsole.prototype.warn = function() {\\n  this._stderr.write(util.format.apply(this, arguments) + NEWLINE );\\n};\\n\\n\\nConsole.prototype.error = Console.prototype.warn;\\n\\n\\nConsole.prototype.dir = function(object, options) {\\n  this._stdout.write(util.inspect(object, util._extend({\\n    customInspect: false\\n  }, options)) + NEWLINE );\\n};\\n\\n\\nConsole.prototype.time = function(label) {\\n  this._times[label] = Date.now();\\n};\\n\\n\\nConsole.prototype.timeEnd = function(label) {\\n  var time = this._times[label];\\n  if (!time) {\\n    throw new Error('No such label: ' + label);\\n  }\\n  var duration = Date.now() - time;\\n  this.log('%s: %dms', label, duration);\\n};\\n\\n\\nConsole.prototype.trace = function() {\\n  // TODO probably can to do this better with V8's debug object once that is\\n  // exposed.\\n  var err = new Error;\\n  err.name = 'Trace';\\n  err.message = util.format.apply(this, arguments);\\n  Error.captureStackTrace(err, arguments.callee);\\n  this.error(err.stack);\\n};\\n\\n\\nConsole.prototype.assert = function(expression) {\\n  if (!expression) {\\n    var arr = Array.prototype.slice.call(arguments, 1);\\n    require('assert').ok(false, util.format.apply(this, arr));\\n  }\\n};\\n\\nvar std = {\\n  write : print\\n};\\n\\nmodule.exports = new Console(std, std);\\nmodule.exports.Console = Console;\\n\",\"constants\":\"'use strict';\\r\\n\\r\\nmodule.exports = process.binding('constants');\\r\\n\",\"events\":\"'use strict';\\n\\nvar domain;\\n\\nfunction EventEmitter() {\\n  EventEmitter.init.call(this);\\n}\\nmodule.exports = EventEmitter;\\n\\n// Backwards-compat with node 0.10.x\\nEventEmitter.EventEmitter = EventEmitter;\\n\\nEventEmitter.usingDomains = false;\\n\\nEventEmitter.prototype.domain = undefined;\\nEventEmitter.prototype._events = undefined;\\nEventEmitter.prototype._maxListeners = undefined;\\n\\n// By default EventEmitters will print a warning if more than 10 listeners are\\n// added to it. This is a useful default which helps finding memory leaks.\\nEventEmitter.defaultMaxListeners = 10;\\n\\nEventEmitter.init = function() {\\n  this.domain = null;\\n  if (EventEmitter.usingDomains) {\\n    // if there is an active domain, then attach to it.\\n    domain = domain || require('domain');\\n    if (domain.active && !(this instanceof domain.Domain)) {\\n      this.domain = domain.active;\\n    }\\n  }\\n\\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\\n    this._events = {};\\n    this._eventsCount = 0;\\n  }\\n\\n  this._maxListeners = this._maxListeners || undefined;\\n};\\n\\n// Obviously not all Emitters should be limited to 10. This function allows\\n// that to be increased. Set to zero for unlimited.\\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\\n    throw new TypeError('\\\"n\\\" argument must be a positive number');\\n  this._maxListeners = n;\\n  return this;\\n};\\n\\nfunction $getMaxListeners(that) {\\n  if (that._maxListeners === undefined)\\n    return EventEmitter.defaultMaxListeners;\\n  return that._maxListeners;\\n}\\n\\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\\n  return $getMaxListeners(this);\\n};\\n\\n// These standalone emit* functions are used to optimize calling of event\\n// handlers for fast cases because emit() itself often has a variable number of\\n// arguments and can be deoptimized because of that. These functions always have\\n// the same number of arguments and thus do not get deoptimized, so the code\\n// inside them can execute faster.\\nfunction emitNone(handler, isFn, self) {\\n  if (isFn)\\n    handler.call(self);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].call(self);\\n  }\\n}\\nfunction emitOne(handler, isFn, self, arg1) {\\n  if (isFn)\\n    handler.call(self, arg1);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].call(self, arg1);\\n  }\\n}\\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\\n  if (isFn)\\n    handler.call(self, arg1, arg2);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].call(self, arg1, arg2);\\n  }\\n}\\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\\n  if (isFn)\\n    handler.call(self, arg1, arg2, arg3);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].call(self, arg1, arg2, arg3);\\n  }\\n}\\n\\nfunction emitMany(handler, isFn, self, args) {\\n  if (isFn)\\n    handler.apply(self, args);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].apply(self, args);\\n  }\\n}\\n\\nEventEmitter.prototype.emit = function emit(type) {\\n  var er, handler, len, args, i, events, domain;\\n  var needDomainExit = false;\\n  var doError = (type === 'error');\\n\\n  events = this._events;\\n  if (events)\\n    doError = (doError && events.error == null);\\n  else if (!doError)\\n    return false;\\n\\n  domain = this.domain;\\n\\n  // If there is no 'error' event listener then throw.\\n  if (doError) {\\n    er = arguments[1];\\n    if (domain) {\\n      if (!er)\\n        er = new Error('Uncaught, unspecified \\\"error\\\" event');\\n      er.domainEmitter = this;\\n      er.domain = domain;\\n      er.domainThrown = false;\\n      domain.emit('error', er);\\n    } else if (er instanceof Error) {\\n      throw er; // Unhandled 'error' event\\n    } else {\\n      // At least give some kind of context to the user\\n      var err = new Error('Uncaught, unspecified \\\"error\\\" event. (' + er + ')');\\n      err.context = er;\\n      throw err;\\n    }\\n    return false;\\n  }\\n\\n  handler = events[type];\\n\\n  if (!handler)\\n    return false;\\n\\n  if (domain && this !== process) {\\n    domain.enter();\\n    needDomainExit = true;\\n  }\\n\\n  var isFn = typeof handler === 'function';\\n  len = arguments.length;\\n  switch (len) {\\n    // fast cases\\n    case 1:\\n      emitNone(handler, isFn, this);\\n      break;\\n    case 2:\\n      emitOne(handler, isFn, this, arguments[1]);\\n      break;\\n    case 3:\\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\\n      break;\\n    case 4:\\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\\n      break;\\n    // slower\\n    default:\\n      args = new Array(len - 1);\\n      for (i = 1; i < len; i++)\\n        args[i - 1] = arguments[i];\\n      emitMany(handler, isFn, this, args);\\n  }\\n\\n  if (needDomainExit)\\n    domain.exit();\\n\\n  return true;\\n};\\n\\nEventEmitter.prototype.addListener = function addListener(type, listener) {\\n  var m;\\n  var events;\\n  var existing;\\n\\n  if (typeof listener !== 'function')\\n    throw new TypeError('\\\"listener\\\" argument must be a function');\\n\\n  events = this._events;\\n  if (!events) {\\n    events = this._events = {};\\n    this._eventsCount = 0;\\n  } else {\\n    // To avoid recursion in the case that type === \\\"newListener\\\"! Before\\n    // adding it to the listeners, first emit \\\"newListener\\\".\\n    if (events.newListener) {\\n      this.emit('newListener', type,\\n                listener.listener ? listener.listener : listener);\\n\\n      // Re-assign `events` because a newListener handler could have caused the\\n      // this._events to be assigned to a new object\\n      events = this._events;\\n    }\\n    existing = events[type];\\n  }\\n\\n  if (!existing) {\\n    // Optimize the case of one listener. Don't need the extra array object.\\n    existing = events[type] = listener;\\n    ++this._eventsCount;\\n  } else {\\n    if (typeof existing === 'function') {\\n      // Adding the second element, need to change to array.\\n      existing = events[type] = [existing, listener];\\n    } else {\\n      // If we've already got an array, just append.\\n      existing.push(listener);\\n    }\\n\\n    // Check for listener leak\\n    if (!existing.warned) {\\n      m = $getMaxListeners(this);\\n      if (m && m > 0 && existing.length > m) {\\n        existing.warned = true;\\n        console.error('(node) warning: possible EventEmitter memory ' +\\n                      'leak detected. %d %s listeners added. ' +\\n                      'Use emitter.setMaxListeners() to increase limit.',\\n                      existing.length, type);\\n        console.trace();\\n      }\\n    }\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\\n\\nEventEmitter.prototype.once = function once(type, listener) {\\n  if (typeof listener !== 'function')\\n    throw new TypeError('\\\"listener\\\" argument must be a function');\\n\\n  var fired = false;\\n\\n  function g() {\\n    this.removeListener(type, g);\\n\\n    if (!fired) {\\n      fired = true;\\n      listener.apply(this, arguments);\\n    }\\n  }\\n\\n  g.listener = listener;\\n  this.on(type, g);\\n\\n  return this;\\n};\\n\\n// emits a 'removeListener' event iff the listener was removed\\nEventEmitter.prototype.removeListener =\\n    function removeListener(type, listener) {\\n      var list, events, position, i;\\n\\n      if (typeof listener !== 'function')\\n        throw new TypeError('\\\"listener\\\" argument must be a function');\\n\\n      events = this._events;\\n      if (!events)\\n        return this;\\n\\n      list = events[type];\\n      if (!list)\\n        return this;\\n\\n      if (list === listener || (list.listener && list.listener === listener)) {\\n        if (--this._eventsCount === 0)\\n          this._events = {};\\n        else {\\n          delete events[type];\\n          if (events.removeListener)\\n            this.emit('removeListener', type, listener);\\n        }\\n      } else if (typeof list !== 'function') {\\n        position = -1;\\n\\n        for (i = list.length; i-- > 0;) {\\n          if (list[i] === listener ||\\n              (list[i].listener && list[i].listener === listener)) {\\n            position = i;\\n            break;\\n          }\\n        }\\n\\n        if (position < 0)\\n          return this;\\n\\n        if (list.length === 1) {\\n          list[0] = undefined;\\n          if (--this._eventsCount === 0) {\\n            this._events = {};\\n            return this;\\n          } else {\\n            delete events[type];\\n          }\\n        } else {\\n          spliceOne(list, position);\\n        }\\n\\n        if (events.removeListener)\\n          this.emit('removeListener', type, listener);\\n      }\\n\\n      return this;\\n    };\\n\\nEventEmitter.prototype.removeAllListeners =\\n    function removeAllListeners(type) {\\n      var listeners, events;\\n\\n      events = this._events;\\n      if (!events)\\n        return this;\\n\\n      // not listening for removeListener, no need to emit\\n      if (!events.removeListener) {\\n        if (arguments.length === 0) {\\n          this._events = {};\\n          this._eventsCount = 0;\\n        } else if (events[type]) {\\n          if (--this._eventsCount === 0)\\n            this._events = {};\\n          else\\n            delete events[type];\\n        }\\n        return this;\\n      }\\n\\n      // emit removeListener for all listeners on all events\\n      if (arguments.length === 0) {\\n        var keys = Object.keys(events);\\n        for (var i = 0, key; i < keys.length; ++i) {\\n          key = keys[i];\\n          if (key === 'removeListener') continue;\\n          this.removeAllListeners(key);\\n        }\\n        this.removeAllListeners('removeListener');\\n        this._events = {};\\n        this._eventsCount = 0;\\n        return this;\\n      }\\n\\n      listeners = events[type];\\n\\n      if (typeof listeners === 'function') {\\n        this.removeListener(type, listeners);\\n      } else if (listeners) {\\n        // LIFO order\\n        do {\\n          this.removeListener(type, listeners[listeners.length - 1]);\\n        } while (listeners[0]);\\n      }\\n\\n      return this;\\n    };\\n\\nEventEmitter.prototype.listeners = function listeners(type) {\\n  var evlistener;\\n  var ret;\\n  var events = this._events;\\n\\n  if (!events)\\n    ret = [];\\n  else {\\n    evlistener = events[type];\\n    if (!evlistener)\\n      ret = [];\\n    else if (typeof evlistener === 'function')\\n      ret = [evlistener];\\n    else\\n      ret = arrayClone(evlistener, evlistener.length);\\n  }\\n\\n  return ret;\\n};\\n\\nEventEmitter.listenerCount = function(emitter, type) {\\n  if (typeof emitter.listenerCount === 'function') {\\n    return emitter.listenerCount(type);\\n  } else {\\n    return listenerCount.call(emitter, type);\\n  }\\n};\\n\\nEventEmitter.prototype.listenerCount = listenerCount;\\nfunction listenerCount(type) {\\n  var events = this._events;\\n\\n  if (events) {\\n    var evlistener = events[type];\\n\\n    if (typeof evlistener === 'function') {\\n      return 1;\\n    } else if (evlistener) {\\n      return evlistener.length;\\n    }\\n  }\\n\\n  return 0;\\n};\\n\\n// About 1.5x faster than the two-arg version of Array#splice().\\nfunction spliceOne(list, index) {\\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\\n    list[i] = list[k];\\n  list.pop();\\n}\\n\\nfunction arrayClone(arr, i) {\\n  var copy = new Array(i);\\n  while (i--)\\n    copy[i] = arr[i];\\n  return copy;\\n}\\n\",\"timers\":\"'use strict';\\n\\nvar Timer = process.binding('timer_wrap').Timer;\\nvar L = require('internal/linkedlist');\\nvar assert = require('assert').ok;\\nvar util = require('util');\\nvar debug = util.debuglog('timer');\\nvar kOnTimeout = Timer.kOnTimeout;\\n\\n// Timeout values > TIMEOUT_MAX are set to 1.\\nvar TIMEOUT_MAX = 2147483647; // 2^31-1\\n\\n// IDLE TIMEOUTS\\n//\\n// Because often many sockets will have the same idle timeout we will not\\n// use one timeout watcher per item. It is too much overhead.  Instead\\n// we'll use a single watcher for all sockets with the same timeout value\\n// and a linked list. This technique is described in the libev manual:\\n// http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts\\n\\n// Object containing all lists, timers\\n// key = time in milliseconds\\n// value = list\\nvar lists = {};\\n\\n\\n// call this whenever the item is active (not idle)\\n// it will reset its timeout.\\n// the main function - creates lists on demand and the watchers associated\\n// with them.\\nexports.active = function(item) {\\n  var msecs = item._idleTimeout;\\n  if (msecs < 0 || msecs === undefined) return;\\n\\n  item._idleStart = Timer.now();\\n\\n  var list;\\n\\n  if (lists[msecs]) {\\n    list = lists[msecs];\\n  } else {\\n    list = new Timer();\\n    list.start(msecs, 0);\\n\\n    L.init(list);\\n\\n    lists[msecs] = list;\\n    list.msecs = msecs;\\n    list[kOnTimeout] = listOnTimeout;\\n  }\\n\\n  L.append(list, item);\\n  assert(!L.isEmpty(list)); // list is not empty\\n};\\n\\nfunction listOnTimeout() {\\n  var msecs = this.msecs;\\n  var list = this;\\n\\n  debug('timeout callback %d', msecs);\\n\\n  var now = Timer.now();\\n  debug('now: %s', now);\\n\\n  var diff, first, threw;\\n  while (first = L.peek(list)) {\\n    diff = now - first._idleStart;\\n    if (diff < msecs) {\\n      list.start(msecs - diff, 0);\\n      debug('%d list wait because diff is %d', msecs, diff);\\n      return;\\n    } else {\\n      L.remove(first);\\n      assert(first !== L.peek(list));\\n\\n      if (!first._onTimeout) continue;\\n\\n      // v0.4 compatibility: if the timer callback throws and the\\n      // domain or uncaughtException handler ignore the exception,\\n      // other timers that expire on this tick should still run.\\n      //\\n      // https://github.com/joyent/node/issues/2631\\n      var domain = first.domain;\\n      if (domain && domain._disposed)\\n        continue;\\n\\n      try {\\n        if (domain)\\n          domain.enter();\\n        threw = true;\\n        first._called = true;\\n        first._onTimeout();\\n        if (domain)\\n          domain.exit();\\n        threw = false;\\n      } finally {\\n        if (threw) {\\n          // We need to continue processing after domain error handling\\n          // is complete, but not by using whatever domain was left over\\n          // when the timeout threw its exception.\\n          var oldDomain = process.domain;\\n          process.domain = null;\\n          process.nextTick(listOnTimeoutNT, list);\\n          process.domain = oldDomain;\\n        }\\n      }\\n    }\\n  }\\n\\n  debug('%d list empty', msecs);\\n  assert(L.isEmpty(list));\\n  list.close();\\n  delete lists[msecs];\\n}\\n\\n\\nfunction listOnTimeoutNT(list) {\\n  list[kOnTimeout]();\\n}\\n\\n\\nfunction reuse(item) {\\n  L.remove(item);\\n\\n  var list = lists[item._idleTimeout];\\n  // if empty - reuse the watcher\\n  if (list && L.isEmpty(list)) {\\n    debug('reuse hit');\\n    list.stop();\\n    delete lists[item._idleTimeout];\\n    return list;\\n  }\\n\\n  return null;\\n}\\n\\n\\nvar unenroll = exports.unenroll = function(item) {\\n  var list = reuse(item);\\n  if (list) {\\n    debug('unenroll: list empty');\\n    list.close();\\n  }\\n  // if active is called later, then we want to make sure not to insert again\\n  item._idleTimeout = -1;\\n};\\n\\n\\n// Does not start the time, just sets up the members needed.\\nexports.enroll = function(item, msecs) {\\n  if (typeof msecs !== 'number') {\\n    throw new TypeError('\\\"msecs\\\" argument must be a number');\\n  }\\n\\n  if (msecs < 0 || !isFinite(msecs)) {\\n    throw new RangeError('\\\"msecs\\\" argument must be ' +\\n                         'a non-negative finite number');\\n  }\\n\\n  // if this item was already in a list somewhere\\n  // then we should unenroll it from that\\n  if (item._idleNext) unenroll(item);\\n\\n  // Ensure that msecs fits into signed int32\\n  if (msecs > TIMEOUT_MAX) {\\n    msecs = TIMEOUT_MAX;\\n  }\\n\\n  item._idleTimeout = msecs;\\n  L.init(item);\\n};\\n\\n\\n/*\\n * DOM-style timers\\n */\\n\\n\\nexports.setTimeout = function(callback, after) {\\n  after *= 1; // coalesce to number or NaN\\n\\n  if (!(after >= 1 && after <= TIMEOUT_MAX)) {\\n    after = 1; // schedule on next tick, follows browser behaviour\\n  }\\n\\n  var timer = new Timeout(after);\\n  var length = arguments.length;\\n  var ontimeout = callback;\\n  switch (length) {\\n    // fast cases\\n    case 0:\\n    case 1:\\n    case 2:\\n      break;\\n    case 3:\\n      ontimeout = callback.bind(timer, arguments[2]);\\n      break;\\n    case 4:\\n      ontimeout = callback.bind(timer, arguments[2], arguments[3]);\\n      break;\\n    case 5:\\n      ontimeout =\\n          callback.bind(timer, arguments[2], arguments[3], arguments[4]);\\n      break;\\n    // slow case\\n    default:\\n      var args = new Array(length - 2);\\n      for (var i = 2; i < length; i++)\\n        args[i - 2] = arguments[i];\\n      ontimeout = callback.apply.bind(callback, timer, args);\\n      break;\\n  }\\n  timer._onTimeout = ontimeout;\\n\\n  if (process.domain) timer.domain = process.domain;\\n\\n  exports.active(timer);\\n\\n  return timer;\\n};\\n\\n\\nexports.clearTimeout = function(timer) {\\n  if (timer && (timer[kOnTimeout] || timer._onTimeout)) {\\n    timer[kOnTimeout] = timer._onTimeout = null;\\n    if (timer instanceof Timeout) {\\n      timer.close(); // for after === 0\\n    } else {\\n      exports.unenroll(timer);\\n    }\\n  }\\n};\\n\\n\\nexports.setInterval = function(callback, repeat) {\\n  repeat *= 1; // coalesce to number or NaN\\n\\n  if (!(repeat >= 1 && repeat <= TIMEOUT_MAX)) {\\n    repeat = 1; // schedule on next tick, follows browser behaviour\\n  }\\n\\n  var timer = new Timeout(repeat);\\n  var length = arguments.length;\\n  var ontimeout = callback;\\n  switch (length) {\\n    case 0:\\n    case 1:\\n    case 2:\\n      break;\\n    case 3:\\n      ontimeout = callback.bind(timer, arguments[2]);\\n      break;\\n    case 4:\\n      ontimeout = callback.bind(timer, arguments[2], arguments[3]);\\n      break;\\n    case 5:\\n      ontimeout =\\n          callback.bind(timer, arguments[2], arguments[3], arguments[4]);\\n      break;\\n    default:\\n      var args = new Array(length - 2);\\n      for (var i = 2; i < length; i += 1)\\n        args[i - 2] = arguments[i];\\n      ontimeout = callback.apply.bind(callback, timer, args);\\n      break;\\n  }\\n  timer._onTimeout = wrapper;\\n  timer._repeat = ontimeout;\\n\\n  if (process.domain) timer.domain = process.domain;\\n  exports.active(timer);\\n\\n  return timer;\\n\\n  function wrapper() {\\n    timer._repeat.call(this);\\n\\n    // Timer might be closed - no point in restarting it\\n    if (!timer._repeat)\\n      return;\\n\\n    // If timer is unref'd (or was - it's permanently removed from the list.)\\n    if (this._handle) {\\n      this._handle.start(repeat, 0);\\n    } else {\\n      timer._idleTimeout = repeat;\\n      exports.active(timer);\\n    }\\n  }\\n};\\n\\n\\nexports.clearInterval = function(timer) {\\n  if (timer && timer._repeat) {\\n    timer._repeat = null;\\n    clearTimeout(timer);\\n  }\\n};\\n\\n\\nvar Timeout = function(after) {\\n  this._called = false;\\n  this._idleTimeout = after;\\n  this._idlePrev = this;\\n  this._idleNext = this;\\n  this._idleStart = null;\\n  this._onTimeout = null;\\n  this._repeat = null;\\n};\\n\\n\\nfunction unrefdHandle() {\\n  this.owner._onTimeout();\\n  if (!this.owner._repeat)\\n    this.owner.close();\\n}\\n\\n\\nTimeout.prototype.unref = function() {\\n  if (this._handle) {\\n    this._handle.unref();\\n  } else if (typeof(this._onTimeout) === 'function') {\\n    var now = Timer.now();\\n    if (!this._idleStart) this._idleStart = now;\\n    var delay = this._idleStart + this._idleTimeout - now;\\n    if (delay < 0) delay = 0;\\n\\n    // Prevent running cb again when unref() is called during the same cb\\n    if (this._called && !this._repeat) {\\n      exports.unenroll(this);\\n      return;\\n    }\\n\\n    var handle = reuse(this);\\n\\n    this._handle = handle || new Timer();\\n    this._handle.owner = this;\\n    this._handle[kOnTimeout] = unrefdHandle;\\n    this._handle.start(delay, 0);\\n    this._handle.domain = this.domain;\\n    this._handle.unref();\\n  }\\n  return this;\\n};\\n\\nTimeout.prototype.ref = function() {\\n  if (this._handle)\\n    this._handle.ref();\\n  return this;\\n};\\n\\nTimeout.prototype.close = function() {\\n  this._onTimeout = null;\\n  if (this._handle) {\\n    this._handle[kOnTimeout] = null;\\n    this._handle.close();\\n  } else {\\n    exports.unenroll(this);\\n  }\\n  return this;\\n};\\n\\n\\nvar immediateQueue = {};\\nL.init(immediateQueue);\\n\\n\\nfunction processImmediate() {\\n  var queue = immediateQueue;\\n  var domain, immediate;\\n\\n  immediateQueue = {};\\n  L.init(immediateQueue);\\n\\n  while (L.isEmpty(queue) === false) {\\n    immediate = L.shift(queue);\\n    domain = immediate.domain;\\n\\n    if (domain)\\n      domain.enter();\\n\\n    var threw = true;\\n    try {\\n      immediate._onImmediate();\\n      threw = false;\\n    } finally {\\n      if (threw) {\\n        if (!L.isEmpty(queue)) {\\n          // Handle any remaining on next tick, assuming we're still\\n          // alive to do so.\\n          while (!L.isEmpty(immediateQueue)) {\\n            L.append(queue, L.shift(immediateQueue));\\n          }\\n          immediateQueue = queue;\\n          process.nextTick(processImmediate);\\n        }\\n      }\\n    }\\n\\n    if (domain)\\n      domain.exit();\\n  }\\n\\n  // Only round-trip to C++ land if we have to. Calling clearImmediate() on an\\n  // immediate that's in |queue| is okay. Worst case is we make a superfluous\\n  // call to NeedImmediateCallbackSetter().\\n  if (L.isEmpty(immediateQueue)) {\\n    process._needImmediateCallback = false;\\n  }\\n}\\n\\n\\nfunction Immediate() { }\\n\\nImmediate.prototype.domain = undefined;\\nImmediate.prototype._onImmediate = undefined;\\nImmediate.prototype._idleNext = undefined;\\nImmediate.prototype._idlePrev = undefined;\\n\\n\\nexports.setImmediate = function(callback, arg1, arg2, arg3) {\\n  var i, args;\\n  var len = arguments.length;\\n  var immediate = new Immediate();\\n\\n  L.init(immediate);\\n\\n  switch (len) {\\n    // fast cases\\n    case 0:\\n    case 1:\\n      immediate._onImmediate = callback;\\n      break;\\n    case 2:\\n      immediate._onImmediate = function() {\\n        callback.call(immediate, arg1);\\n      };\\n      break;\\n    case 3:\\n      immediate._onImmediate = function() {\\n        callback.call(immediate, arg1, arg2);\\n      };\\n      break;\\n    case 4:\\n      immediate._onImmediate = function() {\\n        callback.call(immediate, arg1, arg2, arg3);\\n      };\\n      break;\\n    // slow case\\n    default:\\n      args = new Array(len - 1);\\n      for (i = 1; i < len; i++)\\n        args[i - 1] = arguments[i];\\n\\n      immediate._onImmediate = function() {\\n        callback.apply(immediate, args);\\n      };\\n      break;\\n  }\\n\\n  if (!process._needImmediateCallback) {\\n    process._needImmediateCallback = true;\\n    process._immediateCallback = processImmediate;\\n  }\\n\\n  if (process.domain)\\n    immediate.domain = process.domain;\\n\\n  L.append(immediateQueue, immediate);\\n\\n  return immediate;\\n};\\n\\n\\nexports.clearImmediate = function(immediate) {\\n  if (!immediate) return;\\n\\n  immediate._onImmediate = undefined;\\n\\n  L.remove(immediate);\\n\\n  if (L.isEmpty(immediateQueue)) {\\n    process._needImmediateCallback = false;\\n  }\\n};\\n\\n\\n// Internal APIs that need timeouts should use timers._unrefActive instead of\\n// timers.active as internal timeouts shouldn't hold the loop open\\n\\nvar unrefList, unrefTimer;\\n\\nfunction _makeTimerTimeout(timer) {\\n  var domain = timer.domain;\\n  var msecs = timer._idleTimeout;\\n\\n  L.remove(timer);\\n\\n  // Timer has been unenrolled by another timer that fired at the same time,\\n  // so don't make it timeout.\\n  if (msecs <= 0)\\n    return;\\n\\n  if (!timer._onTimeout)\\n    return;\\n\\n  if (domain) {\\n    if (domain._disposed)\\n      return;\\n\\n    domain.enter();\\n  }\\n\\n  debug('unreftimer firing timeout');\\n  timer._called = true;\\n  _runOnTimeout(timer);\\n\\n  if (domain)\\n    domain.exit();\\n}\\n\\nfunction _runOnTimeout(timer) {\\n  var threw = true;\\n  try {\\n    timer._onTimeout();\\n    threw = false;\\n  } finally {\\n    if (threw) process.nextTick(unrefTimeout);\\n  }\\n}\\n\\nfunction unrefTimeout() {\\n  var now = Timer.now();\\n\\n  debug('unrefTimer fired');\\n\\n  var timeSinceLastActive;\\n  var nextTimeoutTime;\\n  var nextTimeoutDuration;\\n  var minNextTimeoutTime = TIMEOUT_MAX;\\n  var timersToTimeout = [];\\n\\n  // The actual timer fired and has not yet been rearmed,\\n  // let's consider its next firing time is invalid for now.\\n  // It may be set to a relevant time in the future once\\n  // we scanned through the whole list of timeouts and if\\n  // we find a timeout that needs to expire.\\n  unrefTimer.when = -1;\\n\\n  // Iterate over the list of timeouts,\\n  // call the onTimeout callback for those expired,\\n  // and rearm the actual timer if the next timeout to expire\\n  // will expire before the current actual timer.\\n  var cur = unrefList._idlePrev;\\n  while (cur !== unrefList) {\\n    timeSinceLastActive = now - cur._idleStart;\\n\\n    if (timeSinceLastActive < cur._idleTimeout) {\\n      // This timer hasn't expired yet, but check if its expiring time is\\n      // earlier than the actual timer's expiring time\\n\\n      nextTimeoutDuration = cur._idleTimeout - timeSinceLastActive;\\n      nextTimeoutTime = now + nextTimeoutDuration;\\n      if (minNextTimeoutTime === TIMEOUT_MAX ||\\n          (nextTimeoutTime < minNextTimeoutTime)) {\\n        // We found a timeout that will expire earlier,\\n        // store its next timeout time now so that we\\n        // can rearm the actual timer accordingly when\\n        // we scanned through the whole list.\\n        minNextTimeoutTime = nextTimeoutTime;\\n      }\\n    } else {\\n      // We found a timer that expired. Do not call its _onTimeout callback\\n      // right now, as it could mutate any item of the list (including itself).\\n      // Instead, add it to another list that will be processed once the list\\n      // of current timers has been fully traversed.\\n      timersToTimeout.push(cur);\\n    }\\n\\n    cur = cur._idlePrev;\\n  }\\n\\n  var nbTimersToTimeout = timersToTimeout.length;\\n  for (var timerIdx = 0; timerIdx < nbTimersToTimeout; ++timerIdx)\\n    _makeTimerTimeout(timersToTimeout[timerIdx]);\\n\\n\\n  // Rearm the actual timer with the timeout delay\\n  // of the earliest timeout found.\\n  if (minNextTimeoutTime !== TIMEOUT_MAX) {\\n    unrefTimer.start(minNextTimeoutTime - now, 0);\\n    unrefTimer.when = minNextTimeoutTime;\\n    debug('unrefTimer rescheduled');\\n  } else if (L.isEmpty(unrefList)) {\\n    debug('unrefList is empty');\\n  }\\n}\\n\\n\\nexports._unrefActive = function(item) {\\n  var msecs = item._idleTimeout;\\n  if (!msecs || msecs < 0) return;\\n  assert(msecs >= 0);\\n\\n  L.remove(item);\\n\\n  if (!unrefList) {\\n    debug('unrefList initialized');\\n    unrefList = {};\\n    L.init(unrefList);\\n\\n    debug('unrefTimer initialized');\\n    unrefTimer = new Timer();\\n    unrefTimer.unref();\\n    unrefTimer.when = -1;\\n    unrefTimer[kOnTimeout] = unrefTimeout;\\n  }\\n\\n  var now = Timer.now();\\n  item._idleStart = now;\\n\\n  var when = now + msecs;\\n\\n  // If the actual timer is set to fire too late, or not set to fire at all,\\n  // we need to make it fire earlier\\n  if (unrefTimer.when === -1 || unrefTimer.when > when) {\\n    unrefTimer.start(msecs, 0);\\n    unrefTimer.when = when;\\n    debug('unrefTimer scheduled');\\n  }\\n\\n  debug('unrefList append to end');\\n  L.append(unrefList, item);\\n};\\n\",\"net\":\"'use strict';\\r\\n\\r\\nvar EventEmitter = require('events');\\r\\nvar stream = require('stream');\\r\\nvar timers = require('timers');\\r\\nvar util = require('util');\\r\\nvar internalUtil = require('internal/util');\\r\\nvar assert = require('assert');\\r\\nvar cares = process.binding('cares_wrap');\\r\\nvar uv = process.binding('uv');\\r\\n\\r\\nvar Buffer = require('buffer').Buffer;\\r\\nvar TTYWrap = process.binding('tty_wrap');\\r\\nvar TCP = process.binding('tcp_wrap').TCP;\\r\\nvar Pipe = process.binding('pipe_wrap').Pipe;\\r\\nvar TCPConnectWrap = process.binding('tcp_wrap').TCPConnectWrap;\\r\\nvar PipeConnectWrap = process.binding('pipe_wrap').PipeConnectWrap;\\r\\nvar ShutdownWrap = process.binding('stream_wrap').ShutdownWrap;\\r\\nvar WriteWrap = process.binding('stream_wrap').WriteWrap;\\r\\n\\r\\n\\r\\nvar cluster;\\r\\nvar errnoException = util._errnoException;\\r\\nvar exceptionWithHostPort = util._exceptionWithHostPort;\\r\\n\\r\\nfunction noop() {}\\r\\n\\r\\nfunction createHandle(fd) {\\r\\n  var type = TTYWrap.guessHandleType(fd);\\r\\n  if (type === 'PIPE') return new Pipe();\\r\\n  if (type === 'TCP') return new TCP();\\r\\n  throw new TypeError('Unsupported fd type: ' + type);\\r\\n}\\r\\n\\r\\n\\r\\nvar debug = util.debuglog('net');\\r\\n\\r\\nfunction isPipeName(s) {\\r\\n  return typeof s === 'string' && toNumber(s) === false;\\r\\n}\\r\\n\\r\\nexports.createServer = function(options, connectionListener) {\\r\\n  return new Server(options, connectionListener);\\r\\n};\\r\\n\\r\\n\\r\\n// Target API:\\r\\n//\\r\\n// var s = net.connect({port: 80, host: 'google.com'}, function() {\\r\\n//   ...\\r\\n// });\\r\\n//\\r\\n// There are various forms:\\r\\n//\\r\\n// connect(options, [cb])\\r\\n// connect(port, [host], [cb])\\r\\n// connect(path, [cb]);\\r\\n//\\r\\nexports.connect = exports.createConnection = function() {\\r\\n  var args = normalizeConnectArgs(arguments);\\r\\n  debug('createConnection', args);\\r\\n  var s = new Socket(args[0]);\\r\\n  return Socket.prototype.connect.apply(s, args);\\r\\n};\\r\\n\\r\\n// Returns an array [options] or [options, cb]\\r\\n// It is the same as the argument of Socket.prototype.connect().\\r\\nfunction normalizeConnectArgs(args) {\\r\\n  var options = {};\\r\\n\\r\\n  if (args[0] !== null && typeof args[0] === 'object') {\\r\\n    // connect(options, [cb])\\r\\n    options = args[0];\\r\\n  } else if (isPipeName(args[0])) {\\r\\n    // connect(path, [cb]);\\r\\n    options.path = args[0];\\r\\n  } else {\\r\\n    // connect(port, [host], [cb])\\r\\n    options.port = args[0];\\r\\n    if (typeof args[1] === 'string') {\\r\\n      options.host = args[1];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var cb = args[args.length - 1];\\r\\n  return typeof cb === 'function' ? [options, cb] : [options];\\r\\n}\\r\\nexports._normalizeConnectArgs = normalizeConnectArgs;\\r\\n\\r\\n\\r\\n// called when creating new Socket, or when re-using a closed Socket\\r\\nfunction initSocketHandle(self) {\\r\\n  self.destroyed = false;\\r\\n  self.bytesRead = 0;\\r\\n  self._bytesDispatched = 0;\\r\\n  self._sockname = null;\\r\\n\\r\\n  // Handle creation may be deferred to bind() or connect() time.\\r\\n  if (self._handle) {\\r\\n    self._handle.owner = self;\\r\\n    self._handle.onread = onread;\\r\\n\\r\\n    // If handle doesn't support writev - neither do we\\r\\n    if (!self._handle.writev)\\r\\n      self._writev = null;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction Socket(options) {\\r\\n  if (!(this instanceof Socket)) return new Socket(options);\\r\\n\\r\\n  this._connecting = false;\\r\\n  this._hadError = false;\\r\\n  this._handle = null;\\r\\n  this._parent = null;\\r\\n  this._host = null;\\r\\n\\r\\n  if (typeof options === 'number')\\r\\n    options = { fd: options }; // Legacy interface.\\r\\n  else if (options === undefined)\\r\\n    options = {};\\r\\n\\r\\n  stream.Duplex.call(this, options);\\r\\n\\r\\n  if (options.handle) {\\r\\n    this._handle = options.handle; // private\\r\\n  } else if (options.fd !== undefined) {\\r\\n    this._handle = createHandle(options.fd);\\r\\n    this._handle.open(options.fd);\\r\\n    if ((options.fd == 1 || options.fd == 2) &&\\r\\n        (this._handle instanceof Pipe) &&\\r\\n        process.platform === 'win32') {\\r\\n      // Make stdout and stderr blocking on Windows\\r\\n      var err = this._handle.setBlocking(true);\\r\\n      if (err)\\r\\n        throw errnoException(err, 'setBlocking');\\r\\n    }\\r\\n    this.readable = options.readable !== false;\\r\\n    this.writable = options.writable !== false;\\r\\n  } else {\\r\\n    // these will be set once there is a connection\\r\\n    this.readable = this.writable = false;\\r\\n  }\\r\\n\\r\\n  // shut down the socket when we're finished with it.\\r\\n  this.on('finish', onSocketFinish);\\r\\n  this.on('_socketEnd', onSocketEnd);\\r\\n\\r\\n  initSocketHandle(this);\\r\\n\\r\\n  this._pendingData = null;\\r\\n  this._pendingEncoding = '';\\r\\n\\r\\n  // handle strings directly\\r\\n  this._writableState.decodeStrings = false;\\r\\n\\r\\n  // default to *not* allowing half open sockets\\r\\n  this.allowHalfOpen = options && options.allowHalfOpen || false;\\r\\n\\r\\n  // if we have a handle, then start the flow of data into the\\r\\n  // buffer.  if not, then this will happen when we connect\\r\\n  if (this._handle && options.readable !== false) {\\r\\n    if (options.pauseOnCreate) {\\r\\n      // stop the handle from reading and pause the stream\\r\\n      this._handle.reading = false;\\r\\n      this._handle.readStop();\\r\\n      this._readableState.flowing = false;\\r\\n    } else {\\r\\n      this.read(0);\\r\\n    }\\r\\n  }\\r\\n}\\r\\nutil.inherits(Socket, stream.Duplex);\\r\\n\\r\\nSocket.prototype._unrefTimer = function unrefTimer() {\\r\\n  for (var s = this; s !== null; s = s._parent)\\r\\n    timers._unrefActive(s);\\r\\n};\\r\\n\\r\\n// the user has called .end(), and all the bytes have been\\r\\n// sent out to the other side.\\r\\n// If allowHalfOpen is false, or if the readable side has\\r\\n// ended already, then destroy.\\r\\n// If allowHalfOpen is true, then we need to do a shutdown,\\r\\n// so that only the writable side will be cleaned up.\\r\\nfunction onSocketFinish() {\\r\\n  // If still connecting - defer handling 'finish' until 'connect' will happen\\r\\n  if (this._connecting) {\\r\\n    debug('osF: not yet connected');\\r\\n    return this.once('connect', onSocketFinish);\\r\\n  }\\r\\n\\r\\n  debug('onSocketFinish');\\r\\n  if (!this.readable || this._readableState.ended) {\\r\\n    debug('oSF: ended, destroy', this._readableState);\\r\\n    return this.destroy();\\r\\n  }\\r\\n\\r\\n  debug('oSF: not ended, call shutdown()');\\r\\n\\r\\n  // otherwise, just shutdown, or destroy() if not possible\\r\\n  if (!this._handle || !this._handle.shutdown)\\r\\n    return this.destroy();\\r\\n\\r\\n  var req = new ShutdownWrap();\\r\\n  req.oncomplete = afterShutdown;\\r\\n  req.handle = this._handle;\\r\\n  var err = this._handle.shutdown(req);\\r\\n\\r\\n  if (err)\\r\\n    return this._destroy(errnoException(err, 'shutdown'));\\r\\n}\\r\\n\\r\\n\\r\\nfunction afterShutdown(status, handle, req) {\\r\\n  var self = handle.owner;\\r\\n\\r\\n  debug('afterShutdown destroyed=%j', self.destroyed,\\r\\n        self._readableState);\\r\\n\\r\\n  // callback may come after call to destroy.\\r\\n  if (self.destroyed)\\r\\n    return;\\r\\n\\r\\n  if (self._readableState.ended) {\\r\\n    debug('readableState ended, destroying');\\r\\n    self.destroy();\\r\\n  } else {\\r\\n    self.once('_socketEnd', self.destroy);\\r\\n  }\\r\\n}\\r\\n\\r\\n// the EOF has been received, and no more bytes are coming.\\r\\n// if the writable side has ended already, then clean everything\\r\\n// up.\\r\\nfunction onSocketEnd() {\\r\\n  // XXX Should not have to do as much crap in this function.\\r\\n  // ended should already be true, since this is called *after*\\r\\n  // the EOF errno and onread has eof'ed\\r\\n  debug('onSocketEnd', this._readableState);\\r\\n  this._readableState.ended = true;\\r\\n  if (this._readableState.endEmitted) {\\r\\n    this.readable = false;\\r\\n    maybeDestroy(this);\\r\\n  } else {\\r\\n    this.once('end', function() {\\r\\n      this.readable = false;\\r\\n      maybeDestroy(this);\\r\\n    });\\r\\n    this.read(0);\\r\\n  }\\r\\n\\r\\n  if (!this.allowHalfOpen) {\\r\\n    this.write = writeAfterFIN;\\r\\n    this.destroySoon();\\r\\n  }\\r\\n}\\r\\n\\r\\n// Provide a better error message when we call end() as a result\\r\\n// of the other side sending a FIN.  The standard 'write after end'\\r\\n// is overly vague, and makes it seem like the user's code is to blame.\\r\\nfunction writeAfterFIN(chunk, encoding, cb) {\\r\\n  if (typeof encoding === 'function') {\\r\\n    cb = encoding;\\r\\n    encoding = null;\\r\\n  }\\r\\n\\r\\n  var er = new Error('This socket has been ended by the other party');\\r\\n  er.code = 'EPIPE';\\r\\n  var self = this;\\r\\n  // TODO: defer error events consistently everywhere, not just the cb\\r\\n  self.emit('error', er);\\r\\n  if (typeof cb === 'function') {\\r\\n    process.nextTick(cb, er);\\r\\n  }\\r\\n}\\r\\n\\r\\nexports.Socket = Socket;\\r\\nexports.Stream = Socket; // Legacy naming.\\r\\n\\r\\nSocket.prototype.read = function(n) {\\r\\n  if (n === 0)\\r\\n    return stream.Readable.prototype.read.call(this, n);\\r\\n\\r\\n  this.read = stream.Readable.prototype.read;\\r\\n  this._consuming = true;\\r\\n  return this.read(n);\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.listen = function() {\\r\\n  debug('socket.listen');\\r\\n  var self = this;\\r\\n  self.on('connection', arguments[0]);\\r\\n  listen(self, null, null, null);\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.setTimeout = function(msecs, callback) {\\r\\n  if (msecs === 0) {\\r\\n    timers.unenroll(this);\\r\\n    if (callback) {\\r\\n      this.removeListener('timeout', callback);\\r\\n    }\\r\\n  } else {\\r\\n    timers.enroll(this, msecs);\\r\\n    timers._unrefActive(this);\\r\\n    if (callback) {\\r\\n      this.once('timeout', callback);\\r\\n    }\\r\\n  }\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype._onTimeout = function() {\\r\\n  debug('_onTimeout');\\r\\n  this.emit('timeout');\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.setNoDelay = function(enable) {\\r\\n  if (!this._handle) {\\r\\n    this.once('connect',\\r\\n              enable ? this.setNoDelay : this.setNoDelay.bind(this, enable));\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  // backwards compatibility: assume true when `enable` is omitted\\r\\n  if (this._handle.setNoDelay)\\r\\n    this._handle.setNoDelay(enable === undefined ? true : !!enable);\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.setKeepAlive = function(setting, msecs) {\\r\\n  if (!this._handle) {\\r\\n    this.once('connect', this.setKeepAlive.bind(this, setting, msecs));\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  if (this._handle.setKeepAlive)\\r\\n    this._handle.setKeepAlive(setting, ~~(msecs / 1000));\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.address = function() {\\r\\n  return this._getsockname();\\r\\n};\\r\\n\\r\\n\\r\\nObject.defineProperty(Socket.prototype, 'readyState', {\\r\\n  get: function() {\\r\\n    if (this._connecting) {\\r\\n      return 'opening';\\r\\n    } else if (this.readable && this.writable) {\\r\\n      return 'open';\\r\\n    } else if (this.readable && !this.writable) {\\r\\n      return 'readOnly';\\r\\n    } else if (!this.readable && this.writable) {\\r\\n      return 'writeOnly';\\r\\n    } else {\\r\\n      return 'closed';\\r\\n    }\\r\\n  }\\r\\n});\\r\\n\\r\\n\\r\\nObject.defineProperty(Socket.prototype, 'bufferSize', {\\r\\n  get: function() {\\r\\n    if (this._handle) {\\r\\n      return this._handle.writeQueueSize + this._writableState.length;\\r\\n    }\\r\\n  }\\r\\n});\\r\\n\\r\\n\\r\\n// Just call handle.readStart until we have enough in the buffer\\r\\nSocket.prototype._read = function(n) {\\r\\n  debug('_read');\\r\\n\\r\\n  if (this._connecting || !this._handle) {\\r\\n    debug('_read wait for connection');\\r\\n    this.once('connect', this._read.bind(this, n));\\r\\n  } else if (!this._handle.reading) {\\r\\n    // not already reading, start the flow\\r\\n    debug('Socket._read readStart');\\r\\n    this._handle.reading = true;\\r\\n    var err = this._handle.readStart();\\r\\n    if (err)\\r\\n      this._destroy(errnoException(err, 'read'));\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.end = function(data, encoding) {\\r\\n  stream.Duplex.prototype.end.call(this, data, encoding);\\r\\n  this.writable = false;\\r\\n  DTRACE_NET_STREAM_END(this);\\r\\n  LTTNG_NET_STREAM_END(this);\\r\\n\\r\\n  // just in case we're waiting for an EOF.\\r\\n  if (this.readable && !this._readableState.endEmitted)\\r\\n    this.read(0);\\r\\n  else\\r\\n    maybeDestroy(this);\\r\\n};\\r\\n\\r\\n\\r\\n// Call whenever we set writable=false or readable=false\\r\\nfunction maybeDestroy(socket) {\\r\\n  if (!socket.readable &&\\r\\n      !socket.writable &&\\r\\n      !socket.destroyed &&\\r\\n      !socket._connecting &&\\r\\n      !socket._writableState.length) {\\r\\n    socket.destroy();\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nSocket.prototype.destroySoon = function() {\\r\\n  if (this.writable)\\r\\n    this.end();\\r\\n\\r\\n  if (this._writableState.finished)\\r\\n    this.destroy();\\r\\n  else\\r\\n    this.once('finish', this.destroy);\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype._destroy = function(exception, cb) {\\r\\n  debug('destroy');\\r\\n\\r\\n  var self = this;\\r\\n\\r\\n  function fireErrorCallbacks() {\\r\\n    if (cb) cb(exception);\\r\\n    if (exception && !self._writableState.errorEmitted) {\\r\\n      process.nextTick(emitErrorNT, self, exception);\\r\\n      self._writableState.errorEmitted = true;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (this.destroyed) {\\r\\n    debug('already destroyed, fire error callbacks');\\r\\n    fireErrorCallbacks();\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  self._connecting = false;\\r\\n\\r\\n  this.readable = this.writable = false;\\r\\n\\r\\n  for (var s = this; s !== null; s = s._parent)\\r\\n    timers.unenroll(s);\\r\\n\\r\\n  debug('close');\\r\\n  if (this._handle) {\\r\\n    if (this !== process.stderr)\\r\\n      debug('close handle');\\r\\n    var isException = exception ? true : false;\\r\\n    this._handle.close(function() {\\r\\n      debug('emit close');\\r\\n      self.emit('close', isException);\\r\\n    });\\r\\n    this._handle.onread = noop;\\r\\n    this._handle = null;\\r\\n    this._sockname = null;\\r\\n  }\\r\\n\\r\\n  // we set destroyed to true before firing error callbacks in order\\r\\n  // to make it re-entrance safe in case Socket.prototype.destroy()\\r\\n  // is called within callbacks\\r\\n  this.destroyed = true;\\r\\n  fireErrorCallbacks();\\r\\n\\r\\n  if (this.server) {\\r\\n    COUNTER_NET_SERVER_CONNECTION_CLOSE(this);\\r\\n    debug('has server');\\r\\n    this.server._connections--;\\r\\n    if (this.server._emitCloseIfDrained) {\\r\\n      this.server._emitCloseIfDrained();\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.destroy = function(exception) {\\r\\n  debug('destroy', exception);\\r\\n  this._destroy(exception);\\r\\n};\\r\\n\\r\\n\\r\\n// This function is called whenever the handle gets a\\r\\n// buffer, or when there's an error reading.\\r\\nfunction onread(nread, buffer) {\\r\\n  var handle = this;\\r\\n  var self = handle.owner;\\r\\n  assert(handle === self._handle, 'handle != self._handle');\\r\\n\\r\\n  self._unrefTimer();\\r\\n\\r\\n  debug('onread', nread);\\r\\n\\r\\n  if (nread > 0) {\\r\\n    debug('got data');\\r\\n    // read success.\\r\\n    // In theory (and in practice) calling readStop right now\\r\\n    // will prevent this from being called again until _read() gets\\r\\n    // called again.\\r\\n\\r\\n    // if it's not enough data, we'll just call handle.readStart()\\r\\n    // again right away.\\r\\n    self.bytesRead += nread;\\r\\n\\r\\n    // Optimization: emit the original buffer with end points\\r\\n    var ret = self.push(buffer);\\r\\n\\r\\n    if (handle.reading && !ret) {\\r\\n      handle.reading = false;\\r\\n      debug('readStop');\\r\\n      var err = handle.readStop();\\r\\n      if (err)\\r\\n        self._destroy(errnoException(err, 'read'));\\r\\n    }\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // if we didn't get any bytes, that doesn't necessarily mean EOF.\\r\\n  // wait for the next one.\\r\\n  if (nread === 0) {\\r\\n    debug('not any data, keep waiting');\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // Error, possibly EOF.\\r\\n  if (nread !== uv.UV_EOF) {\\r\\n    return self._destroy(errnoException(nread, 'read'));\\r\\n  }\\r\\n\\r\\n  debug('EOF');\\r\\n\\r\\n  if (self._readableState.length === 0) {\\r\\n    self.readable = false;\\r\\n    maybeDestroy(self);\\r\\n  }\\r\\n\\r\\n  // push a null to signal the end of data.\\r\\n  self.push(null);\\r\\n\\r\\n  // internal end event so that we know that the actual socket\\r\\n  // is no longer readable, and we can start the shutdown\\r\\n  // procedure. No need to wait for all the data to be consumed.\\r\\n  self.emit('_socketEnd');\\r\\n}\\r\\n\\r\\n\\r\\nSocket.prototype._getpeername = function() {\\r\\n  if (!this._peername) {\\r\\n    if (!this._handle || !this._handle.getpeername) {\\r\\n      return {};\\r\\n    }\\r\\n    var out = {};\\r\\n    var err = this._handle.getpeername(out);\\r\\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\\r\\n    this._peername = out;\\r\\n  }\\r\\n  return this._peername;\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.__defineGetter__('remoteAddress', function() {\\r\\n  return this._getpeername().address;\\r\\n});\\r\\n\\r\\nSocket.prototype.__defineGetter__('remoteFamily', function() {\\r\\n  return this._getpeername().family;\\r\\n});\\r\\n\\r\\nSocket.prototype.__defineGetter__('remotePort', function() {\\r\\n  return this._getpeername().port;\\r\\n});\\r\\n\\r\\n\\r\\nSocket.prototype._getsockname = function() {\\r\\n  if (!this._handle || !this._handle.getsockname) {\\r\\n    return {};\\r\\n  }\\r\\n  if (!this._sockname) {\\r\\n    var out = {};\\r\\n    var err = this._handle.getsockname(out);\\r\\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\\r\\n    this._sockname = out;\\r\\n  }\\r\\n  return this._sockname;\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.__defineGetter__('localAddress', function() {\\r\\n  return this._getsockname().address;\\r\\n});\\r\\n\\r\\n\\r\\nSocket.prototype.__defineGetter__('localPort', function() {\\r\\n  return this._getsockname().port;\\r\\n});\\r\\n\\r\\n\\r\\nSocket.prototype.write = function(chunk, encoding, cb) {\\r\\n  if (typeof chunk !== 'string' && (!Buffer.isBuffer(chunk)))\\r\\n    throw new TypeError('Invalid data');\\r\\n  return stream.Duplex.prototype.write.apply(this, arguments);\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype._writeGeneric = function(writev, data, encoding, cb) {\\r\\n  // If we are still connecting, then buffer this for later.\\r\\n  // The Writable logic will buffer up any more writes while\\r\\n  // waiting for this one to be done.\\r\\n  if (this._connecting) {\\r\\n    this._pendingData = data;\\r\\n    this._pendingEncoding = encoding;\\r\\n    this.once('connect', function() {\\r\\n      this._writeGeneric(writev, data, encoding, cb);\\r\\n    });\\r\\n    return;\\r\\n  }\\r\\n  this._pendingData = null;\\r\\n  this._pendingEncoding = '';\\r\\n\\r\\n  this._unrefTimer();\\r\\n\\r\\n  if (!this._handle) {\\r\\n    this._destroy(new Error('This socket is closed'), cb);\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  var req = new WriteWrap();\\r\\n  req.handle = this._handle;\\r\\n  req.oncomplete = afterWrite;\\r\\n  req.async = false;\\r\\n  var err;\\r\\n\\r\\n  if (writev) {\\r\\n    var chunks = new Array(data.length << 1);\\r\\n    for (var i = 0; i < data.length; i++) {\\r\\n      var entry = data[i];\\r\\n      var chunk = entry.chunk;\\r\\n      var enc = entry.encoding;\\r\\n      chunks[i * 2] = chunk;\\r\\n      chunks[i * 2 + 1] = enc;\\r\\n    }\\r\\n    err = this._handle.writev(req, chunks);\\r\\n\\r\\n    // Retain chunks\\r\\n    if (err === 0) req._chunks = chunks;\\r\\n  } else {\\r\\n    var enc;\\r\\n    if (typeof data === 'buffer') {\\r\\n      req.buffer = data;  // Keep reference alive.\\r\\n      enc = 'buffer';\\r\\n    } else {\\r\\n      enc = encoding;\\r\\n    }\\r\\n    err = createWriteReq(req, this._handle, data, enc);\\r\\n  }\\r\\n\\r\\n  if (err)\\r\\n    return this._destroy(errnoException(err, 'write', req.error), cb);\\r\\n\\r\\n  this._bytesDispatched += req.bytes;\\r\\n\\r\\n  // If it was entirely flushed, we can write some more right now.\\r\\n  // However, if more is left in the queue, then wait until that clears.\\r\\n  if (req.async && this._handle.writeQueueSize != 0)\\r\\n    req.cb = cb;\\r\\n  else\\r\\n    cb();\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype._writev = function(chunks, cb) {\\r\\n  this._writeGeneric(true, chunks, '', cb);\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype._write = function(data, encoding, cb) {\\r\\n  this._writeGeneric(false, data, encoding, cb);\\r\\n};\\r\\n\\r\\nfunction createWriteReq(req, handle, data, encoding) {\\r\\n  switch (encoding) {\\r\\n    case 'binary':\\r\\n      return handle.writeBinaryString(req, data);\\r\\n\\r\\n    case 'buffer':\\r\\n      return handle.writeBuffer(req, data);\\r\\n\\r\\n    case 'utf8':\\r\\n    case 'utf-8':\\r\\n      return handle.writeUtf8String(req, data);\\r\\n\\r\\n    case 'ascii':\\r\\n      return handle.writeAsciiString(req, data);\\r\\n\\r\\n    case 'ucs2':\\r\\n    case 'ucs-2':\\r\\n    case 'utf16le':\\r\\n    case 'utf-16le':\\r\\n      return handle.writeUcs2String(req, data);\\r\\n\\r\\n    default:\\r\\n      return handle.writeBuffer(req, Buffer(data, encoding));\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nSocket.prototype.__defineGetter__('bytesWritten', function() {\\r\\n  var bytes = this._bytesDispatched,\\r\\n      state = this._writableState,\\r\\n      data = this._pendingData,\\r\\n      encoding = this._pendingEncoding;\\r\\n\\r\\n  if (!state)\\r\\n    return undefined;\\r\\n\\r\\n  state.getBuffer().forEach(function(el) {\\r\\n    if (el.chunk instanceof Buffer)\\r\\n      bytes += el.chunk.length;\\r\\n    else\\r\\n      bytes += Buffer.byteLength(el.chunk, el.encoding);\\r\\n  });\\r\\n\\r\\n  if (data) {\\r\\n    if (data instanceof Buffer)\\r\\n      bytes += data.length;\\r\\n    else\\r\\n      bytes += Buffer.byteLength(data, encoding);\\r\\n  }\\r\\n\\r\\n  return bytes;\\r\\n});\\r\\n\\r\\n\\r\\nfunction afterWrite(status, handle, req, err) {\\r\\n  var self = handle.owner;\\r\\n  if (self !== process.stderr && self !== process.stdout)\\r\\n    debug('afterWrite', status);\\r\\n\\r\\n  // callback may come after call to destroy.\\r\\n  if (self.destroyed) {\\r\\n    debug('afterWrite destroyed');\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  if (status < 0) {\\r\\n    var ex = exceptionWithHostPort(status, 'write', req.address, req.port);\\r\\n    debug('write failure', ex);\\r\\n    self._destroy(ex, req.cb);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  self._unrefTimer();\\r\\n\\r\\n  if (self !== process.stderr && self !== process.stdout)\\r\\n    debug('afterWrite call cb');\\r\\n\\r\\n  if (req.cb)\\r\\n    req.cb.call(self);\\r\\n}\\r\\n\\r\\n\\r\\nfunction connect(self, address, port, addressType, localAddress, localPort) {\\r\\n  // TODO return promise from Socket.prototype.connect which\\r\\n  // wraps _connectReq.\\r\\n\\r\\n  assert.ok(self._connecting);\\r\\n\\r\\n  var err;\\r\\n\\r\\n  if (localAddress || localPort) {\\r\\n    var bind;\\r\\n\\r\\n    if (addressType === 4) {\\r\\n      localAddress = localAddress || '0.0.0.0';\\r\\n      bind = self._handle.bind;\\r\\n    } else if (addressType === 6) {\\r\\n      localAddress = localAddress || '::';\\r\\n      bind = self._handle.bind6;\\r\\n    } else {\\r\\n      self._destroy(new TypeError('Invalid addressType: ' + addressType));\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    debug('binding to localAddress: %s and localPort: %d',\\r\\n          localAddress,\\r\\n          localPort);\\r\\n\\r\\n    bind = bind.bind(self._handle);\\r\\n    err = bind(localAddress, localPort);\\r\\n\\r\\n    if (err) {\\r\\n      var ex = exceptionWithHostPort(err, 'bind', localAddress, localPort);\\r\\n      self._destroy(ex);\\r\\n      return;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (addressType === 6 || addressType === 4) {\\r\\n    var req = new TCPConnectWrap();\\r\\n    req.oncomplete = afterConnect;\\r\\n    req.address = address;\\r\\n    req.port = port;\\r\\n\\r\\n    if (addressType === 4)\\r\\n      err = self._handle.connect(req, address, port);\\r\\n    else\\r\\n      err = self._handle.connect6(req, address, port);\\r\\n\\r\\n  } else {\\r\\n    var req = new PipeConnectWrap();\\r\\n    req.address = address;\\r\\n    req.oncomplete = afterConnect;\\r\\n    err = self._handle.connect(req, address, afterConnect);\\r\\n  }\\r\\n\\r\\n  if (err) {\\r\\n    var sockname = self._getsockname();\\r\\n    var details;\\r\\n\\r\\n    if (sockname) {\\r\\n      details = sockname.address + ':' + sockname.port;\\r\\n    }\\r\\n\\r\\n    var ex = exceptionWithHostPort(err, 'connect', address, port, details);\\r\\n    self._destroy(ex);\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n// Check that the port number is not NaN when coerced to a number,\\r\\n// is an integer and that it falls within the legal range of port numbers.\\r\\nfunction isLegalPort(port) {\\r\\n  if (typeof port === 'string' && port.trim() === '')\\r\\n    return false;\\r\\n  return +port === (port >>> 0) && port >= 0 && port <= 0xFFFF;\\r\\n}\\r\\n\\r\\n\\r\\nSocket.prototype.connect = function(options, cb) {\\r\\n  if (this.write !== Socket.prototype.write)\\r\\n    this.write = Socket.prototype.write;\\r\\n\\r\\n  if (options === null || typeof options !== 'object') {\\r\\n    // Old API:\\r\\n    // connect(port, [host], [cb])\\r\\n    // connect(path, [cb]);\\r\\n    var args = normalizeConnectArgs(arguments);\\r\\n    return Socket.prototype.connect.apply(this, args);\\r\\n  }\\r\\n\\r\\n  if (this.destroyed) {\\r\\n    this._readableState.reading = false;\\r\\n    this._readableState.ended = false;\\r\\n    this._readableState.endEmitted = false;\\r\\n    this._writableState.ended = false;\\r\\n    this._writableState.ending = false;\\r\\n    this._writableState.finished = false;\\r\\n    this._writableState.errorEmitted = false;\\r\\n    this.destroyed = false;\\r\\n    this._handle = null;\\r\\n    this._peername = null;\\r\\n    this._sockname = null;\\r\\n  }\\r\\n\\r\\n  var self = this;\\r\\n  var pipe = !!options.path;\\r\\n  debug('pipe', pipe, options.path);\\r\\n\\r\\n  if (!this._handle) {\\r\\n    this._handle = pipe ? new Pipe() : new TCP();\\r\\n    initSocketHandle(this);\\r\\n  }\\r\\n\\r\\n  if (typeof cb === 'function') {\\r\\n    self.once('connect', cb);\\r\\n  }\\r\\n\\r\\n  this._unrefTimer();\\r\\n\\r\\n  self._connecting = true;\\r\\n  self.writable = true;\\r\\n\\r\\n  if (pipe) {\\r\\n    connect(self, options.path);\\r\\n\\r\\n  } else {\\r\\n    lookupAndConnect(self, options);\\r\\n  }\\r\\n  return self;\\r\\n};\\r\\n\\r\\n\\r\\nfunction lookupAndConnect(self, options) {\\r\\n  var dns = require('dns');\\r\\n  var host = options.host || 'localhost';\\r\\n  var port = options.port;\\r\\n  var localAddress = options.localAddress;\\r\\n  var localPort = options.localPort;\\r\\n\\r\\n  if (localAddress && !exports.isIP(localAddress))\\r\\n    throw new TypeError('\\\"localAddress\\\" option must be a valid IP: ' +\\r\\n                        localAddress);\\r\\n\\r\\n  if (localPort && typeof localPort !== 'number')\\r\\n    throw new TypeError('\\\"localPort\\\" option should be a number: ' + localPort);\\r\\n\\r\\n  if (typeof port !== 'undefined') {\\r\\n    if (typeof port !== 'number' && typeof port !== 'string')\\r\\n      throw new TypeError('\\\"port\\\" option should be a number or string: ' +\\r\\n                          port);\\r\\n    if (!isLegalPort(port))\\r\\n      throw new RangeError('\\\"port\\\" option should be >= 0 and < 65536: ' + port);\\r\\n  }\\r\\n  port |= 0;\\r\\n\\r\\n  // If host is an IP, skip performing a lookup\\r\\n  // TODO(evanlucas) should we hot path this for localhost?\\r\\n  var addressType = exports.isIP(host);\\r\\n  if (addressType) {\\r\\n    process.nextTick(function() {\\r\\n      if (self._connecting)\\r\\n        connect(self, host, port, addressType, localAddress, localPort);\\r\\n    });\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  if (options.lookup && typeof options.lookup !== 'function')\\r\\n    throw new TypeError('\\\"lookup\\\" option should be a function');\\r\\n\\r\\n  var dnsopts = {\\r\\n    family: options.family,\\r\\n    hints: 0\\r\\n  };\\r\\n\\r\\n  if (dnsopts.family !== 4 && dnsopts.family !== 6) {\\r\\n    dnsopts.hints = dns.ADDRCONFIG;\\r\\n    // The AI_V4MAPPED hint is not supported on FreeBSD, and getaddrinfo\\r\\n    // returns EAI_BADFLAGS. However, it seems to be supported on most other\\r\\n    // systems. See\\r\\n    // http://lists.freebsd.org/pipermail/freebsd-bugs/2008-February/028260.html\\r\\n    // for more information on the lack of support for FreeBSD.\\r\\n    if (process.platform !== 'freebsd')\\r\\n      dnsopts.hints |= dns.V4MAPPED;\\r\\n  }\\r\\n\\r\\n  debug('connect: find host ' + host);\\r\\n  debug('connect: dns options', dnsopts);\\r\\n  self._host = host;\\r\\n  var lookup = options.lookup || dns.lookup;\\r\\n  lookup(host, dnsopts, function(err, ip, addressType) {\\r\\n    self.emit('lookup', err, ip, addressType);\\r\\n\\r\\n    // It's possible we were destroyed while looking this up.\\r\\n    // XXX it would be great if we could cancel the promise returned by\\r\\n    // the look up.\\r\\n    if (!self._connecting) return;\\r\\n\\r\\n    if (err) {\\r\\n      // net.createConnection() creates a net.Socket object and\\r\\n      // immediately calls net.Socket.connect() on it (that's us).\\r\\n      // There are no event listeners registered yet so defer the\\r\\n      // error event to the next tick.\\r\\n      err.host = options.host;\\r\\n      err.port = options.port;\\r\\n      err.message = err.message + ' ' + options.host + ':' + options.port;\\r\\n      process.nextTick(connectErrorNT, self, err);\\r\\n    } else {\\r\\n      self._unrefTimer();\\r\\n      connect(self,\\r\\n              ip,\\r\\n              port,\\r\\n              addressType,\\r\\n              localAddress,\\r\\n              localPort);\\r\\n    }\\r\\n  });\\r\\n}\\r\\n\\r\\n\\r\\nfunction connectErrorNT(self, err) {\\r\\n  self.emit('error', err);\\r\\n  self._destroy();\\r\\n}\\r\\n\\r\\n\\r\\nSocket.prototype.ref = function() {\\r\\n  if (!this._handle) {\\r\\n    this.once('connect', this.ref);\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  this._handle.ref();\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.unref = function() {\\r\\n  if (!this._handle) {\\r\\n    this.once('connect', this.unref);\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  this._handle.unref();\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nfunction afterConnect(status, handle, req, readable, writable) {\\r\\n  var self = handle.owner;\\r\\n\\r\\n  // callback may come after call to destroy\\r\\n  if (self.destroyed) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // Update handle if it was wrapped\\r\\n  // TODO(indutny): assert that the handle is actually an ancestor of old one\\r\\n  handle = self._handle;\\r\\n\\r\\n  debug('afterConnect');\\r\\n\\r\\n  assert.ok(self._connecting);\\r\\n  self._connecting = false;\\r\\n  self._sockname = null;\\r\\n\\r\\n  if (status == 0) {\\r\\n    self.readable = readable;\\r\\n    self.writable = writable;\\r\\n    self._unrefTimer();\\r\\n\\r\\n    self.emit('connect');\\r\\n\\r\\n    // start the first read, or get an immediate EOF.\\r\\n    // this doesn't actually consume any bytes, because len=0.\\r\\n    if (readable && !self.isPaused())\\r\\n      self.read(0);\\r\\n\\r\\n  } else {\\r\\n    self._connecting = false;\\r\\n    var details;\\r\\n    if (req.localAddress && req.localPort) {\\r\\n      ex.localAddress = req.localAddress;\\r\\n      ex.localPort = req.localPort;\\r\\n      details = ex.localAddress + ':' + ex.localPort;\\r\\n    }\\r\\n    var ex = exceptionWithHostPort(status,\\r\\n                                   'connect',\\r\\n                                   req.address,\\r\\n                                   req.port,\\r\\n                                   details);\\r\\n    self._destroy(ex);\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nfunction Server(options, connectionListener) {\\r\\n  if (!(this instanceof Server))\\r\\n    return new Server(options, connectionListener);\\r\\n\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  var self = this;\\r\\n  var options;\\r\\n\\r\\n  if (typeof options === 'function') {\\r\\n    connectionListener = options;\\r\\n    options = {};\\r\\n    self.on('connection', connectionListener);\\r\\n  } else {\\r\\n    options = options || {};\\r\\n\\r\\n    if (typeof connectionListener === 'function') {\\r\\n      self.on('connection', connectionListener);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  this._connections = 0;\\r\\n\\r\\n  Object.defineProperty(this, 'connections', {\\r\\n    get: internalUtil.deprecate(function() {\\r\\n\\r\\n      if (self._usingSlaves) {\\r\\n        return null;\\r\\n      }\\r\\n      return self._connections;\\r\\n    }, 'Server.connections property is deprecated. ' +\\r\\n       'Use Server.getConnections method instead.'),\\r\\n    set: internalUtil.deprecate(function(val) {\\r\\n      return (self._connections = val);\\r\\n    }, 'Server.connections property is deprecated.'),\\r\\n    configurable: true, enumerable: false\\r\\n  });\\r\\n\\r\\n  this._handle = null;\\r\\n  this._usingSlaves = false;\\r\\n  this._slaves = [];\\r\\n  this._unref = false;\\r\\n\\r\\n  this.allowHalfOpen = options.allowHalfOpen || false;\\r\\n  this.pauseOnConnect = !!options.pauseOnConnect;\\r\\n}\\r\\nutil.inherits(Server, EventEmitter);\\r\\nexports.Server = Server;\\r\\n\\r\\n\\r\\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\\r\\n\\r\\nfunction _listen(handle, backlog) {\\r\\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\\r\\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\\r\\n  // which will thus give us a backlog of 512 entries.\\r\\n  return handle.listen(backlog || 511);\\r\\n}\\r\\n\\r\\nvar createServerHandle = exports._createServerHandle =\\r\\n    function(address, port, addressType, fd) {\\r\\n  var err = 0;\\r\\n  // assign handle in listen, and clean up if bind or listen fails\\r\\n  var handle;\\r\\n\\r\\n  var isTCP = false;\\r\\n  if (typeof fd === 'number' && fd >= 0) {\\r\\n    try {\\r\\n      handle = createHandle(fd);\\r\\n    }\\r\\n    catch (e) {\\r\\n      // Not a fd we can listen on.  This will trigger an error.\\r\\n      debug('listen invalid fd=' + fd + ': ' + e.message);\\r\\n      return uv.UV_EINVAL;\\r\\n    }\\r\\n    handle.open(fd);\\r\\n    handle.readable = true;\\r\\n    handle.writable = true;\\r\\n    assert(!address && !port);\\r\\n  } else if (port === -1 && addressType === -1) {\\r\\n    handle = new Pipe();\\r\\n    if (process.platform === 'win32') {\\r\\n      var instances = parseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\\r\\n      if (!isNaN(instances)) {\\r\\n        handle.setPendingInstances(instances);\\r\\n      }\\r\\n    }\\r\\n  } else {\\r\\n    handle = new TCP();\\r\\n    isTCP = true;\\r\\n  }\\r\\n\\r\\n  if (address || port || isTCP) {\\r\\n    debug('bind to ' + (address || 'anycast'));\\r\\n    if (!address) {\\r\\n      // Try binding to ipv6 first\\r\\n      err = handle.bind6('::', port);\\r\\n      if (err) {\\r\\n        handle.close();\\r\\n        // Fallback to ipv4\\r\\n        return createServerHandle('0.0.0.0', port);\\r\\n      }\\r\\n    } else if (addressType === 6) {\\r\\n      err = handle.bind6(address, port);\\r\\n    } else {\\r\\n      err = handle.bind(address, port);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (err) {\\r\\n    handle.close();\\r\\n    return err;\\r\\n  }\\r\\n\\r\\n  return handle;\\r\\n};\\r\\n\\r\\n\\r\\nServer.prototype._listen2 = function(address, port, addressType, backlog, fd) {\\r\\n  debug('listen2', address, port, addressType, backlog, fd);\\r\\n  var self = this;\\r\\n\\r\\n  // If there is not yet a handle, we need to create one and bind.\\r\\n  // In the case of a server sent via IPC, we don't need to do this.\\r\\n  if (self._handle) {\\r\\n    debug('_listen2: have a handle already');\\r\\n  } else {\\r\\n    debug('_listen2: create a handle');\\r\\n\\r\\n    var rval = null;\\r\\n\\r\\n    if (!address && typeof fd !== 'number') {\\r\\n      rval = createServerHandle('::', port, 6, fd);\\r\\n\\r\\n      if (typeof rval === 'number') {\\r\\n        rval = null;\\r\\n        address = '0.0.0.0';\\r\\n        addressType = 4;\\r\\n      } else {\\r\\n        address = '::';\\r\\n        addressType = 6;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (rval === null)\\r\\n      rval = createServerHandle(address, port, addressType, fd);\\r\\n\\r\\n    if (typeof rval === 'number') {\\r\\n      var error = exceptionWithHostPort(rval, 'listen', address, port);\\r\\n      process.nextTick(emitErrorNT, self, error);\\r\\n      return;\\r\\n    }\\r\\n    self._handle = rval;\\r\\n  }\\r\\n\\r\\n  self._handle.onconnection = onconnection;\\r\\n  self._handle.owner = self;\\r\\n\\r\\n  var err = _listen(self._handle, backlog);\\r\\n\\r\\n  if (err) {\\r\\n    var ex = exceptionWithHostPort(err, 'listen', address, port);\\r\\n    self._handle.close();\\r\\n    self._handle = null;\\r\\n    process.nextTick(emitErrorNT, self, ex);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // generate connection key, this should be unique to the connection\\r\\n  this._connectionKey = addressType + ':' + address + ':' + port;\\r\\n\\r\\n  // unref the handle if the server was unref'ed prior to listening\\r\\n  if (this._unref)\\r\\n    this.unref();\\r\\n\\r\\n  process.nextTick(emitListeningNT, self);\\r\\n};\\r\\n\\r\\n\\r\\nfunction emitErrorNT(self, err) {\\r\\n  self.emit('error', err);\\r\\n}\\r\\n\\r\\n\\r\\nfunction emitListeningNT(self) {\\r\\n  // ensure handle hasn't closed\\r\\n  if (self._handle)\\r\\n    self.emit('listening');\\r\\n}\\r\\n\\r\\n\\r\\nfunction listen(self, address, port, addressType, backlog, fd, exclusive) {\\r\\n  exclusive = !!exclusive;\\r\\n\\r\\n  if (!cluster) cluster = require('cluster');\\r\\n\\r\\n  if (cluster.isMaster || exclusive) {\\r\\n    self._listen2(address, port, addressType, backlog, fd);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  cluster._getServer(self, {\\r\\n    address: address,\\r\\n    port: port,\\r\\n    addressType: addressType,\\r\\n    fd: fd,\\r\\n    flags: 0\\r\\n  }, cb);\\r\\n\\r\\n  function cb(err, handle) {\\r\\n    // EADDRINUSE may not be reported until we call listen(). To complicate\\r\\n    // matters, a failed bind() followed by listen() will implicitly bind to\\r\\n    // a random port. Ergo, check that the socket is bound to the expected\\r\\n    // port before calling listen().\\r\\n    //\\r\\n    // FIXME(bnoordhuis) Doesn't work for pipe handles, they don't have a\\r\\n    // getsockname() method. Non-issue for now, the cluster module doesn't\\r\\n    // really support pipes anyway.\\r\\n    if (err === 0 && port > 0 && handle.getsockname) {\\r\\n      var out = {};\\r\\n      err = handle.getsockname(out);\\r\\n      if (err === 0 && port !== out.port)\\r\\n        err = uv.UV_EADDRINUSE;\\r\\n    }\\r\\n\\r\\n    if (err) {\\r\\n      var ex = exceptionWithHostPort(err, 'bind', address, port);\\r\\n      return self.emit('error', ex);\\r\\n    }\\r\\n\\r\\n    self._handle = handle;\\r\\n    self._listen2(address, port, addressType, backlog, fd);\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nServer.prototype.listen = function() {\\r\\n  var self = this;\\r\\n\\r\\n  var lastArg = arguments[arguments.length - 1];\\r\\n  if (typeof lastArg === 'function') {\\r\\n    self.once('listening', lastArg);\\r\\n  }\\r\\n\\r\\n  var port = toNumber(arguments[0]);\\r\\n\\r\\n  // The third optional argument is the backlog size.\\r\\n  // When the ip is omitted it can be the second argument.\\r\\n  var backlog = toNumber(arguments[1]) || toNumber(arguments[2]);\\r\\n\\r\\n  if (arguments.length === 0 || typeof arguments[0] === 'function') {\\r\\n    // Bind to a random port.\\r\\n    listen(self, null, 0, null, backlog);\\r\\n  } else if (arguments[0] !== null && typeof arguments[0] === 'object') {\\r\\n    var h = arguments[0];\\r\\n    h = h._handle || h.handle || h;\\r\\n\\r\\n    if (h instanceof TCP) {\\r\\n      self._handle = h;\\r\\n      listen(self, null, -1, -1, backlog);\\r\\n    } else if (typeof h.fd === 'number' && h.fd >= 0) {\\r\\n      listen(self, null, null, null, backlog, h.fd);\\r\\n    } else {\\r\\n      // The first argument is a configuration object\\r\\n      if (h.backlog)\\r\\n        backlog = h.backlog;\\r\\n\\r\\n      if (typeof h.port === 'number' || typeof h.port === 'string' ||\\r\\n          (typeof h.port === 'undefined' && 'port' in h)) {\\r\\n        // Undefined is interpreted as zero (random port) for consistency\\r\\n        // with net.connect().\\r\\n        if (typeof h.port !== 'undefined' && !isLegalPort(h.port))\\r\\n          throw new RangeError('\\\"port\\\" option should be >= 0 and < 65536: ' +\\r\\n                               h.port);\\r\\n        if (h.host)\\r\\n          listenAfterLookup(h.port | 0, h.host, backlog, h.exclusive);\\r\\n        else\\r\\n          listen(self, null, h.port | 0, 4, backlog, undefined, h.exclusive);\\r\\n      } else if (h.path && isPipeName(h.path)) {\\r\\n        var pipeName = self._pipeName = h.path;\\r\\n        listen(self, pipeName, -1, -1, backlog, undefined, h.exclusive);\\r\\n      } else {\\r\\n        throw new Error('Invalid listen argument: ' + h);\\r\\n      }\\r\\n    }\\r\\n  } else if (isPipeName(arguments[0])) {\\r\\n    // UNIX socket or Windows pipe.\\r\\n    var pipeName = self._pipeName = arguments[0];\\r\\n    listen(self, pipeName, -1, -1, backlog);\\r\\n\\r\\n  } else if (arguments[1] === undefined ||\\r\\n             typeof arguments[1] === 'function' ||\\r\\n             typeof arguments[1] === 'number') {\\r\\n    // The first argument is the port, no IP given.\\r\\n    listen(self, null, port, 4, backlog);\\r\\n\\r\\n  } else {\\r\\n    // The first argument is the port, the second an IP.\\r\\n    listenAfterLookup(port, arguments[1], backlog);\\r\\n  }\\r\\n\\r\\n  function listenAfterLookup(port, address, backlog, exclusive) {\\r\\n    require('dns').lookup(address, function(err, ip, addressType) {\\r\\n      if (err) {\\r\\n        self.emit('error', err);\\r\\n      } else {\\r\\n        addressType = ip ? addressType : 4;\\r\\n        listen(self, ip, port, addressType, backlog, undefined, exclusive);\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return self;\\r\\n};\\r\\n\\r\\nServer.prototype.address = function() {\\r\\n  if (this._handle && this._handle.getsockname) {\\r\\n    var out = {};\\r\\n    this._handle.getsockname(out);\\r\\n    // TODO(bnoordhuis) Check err and throw?\\r\\n    return out;\\r\\n  } else if (this._pipeName) {\\r\\n    return this._pipeName;\\r\\n  } else {\\r\\n    return null;\\r\\n  }\\r\\n};\\r\\n\\r\\nfunction onconnection(err, clientHandle) {\\r\\n  var handle = this;\\r\\n  var self = handle.owner;\\r\\n\\r\\n  debug('onconnection');\\r\\n\\r\\n  if (err) {\\r\\n    self.emit('error', errnoException(err, 'accept'));\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\r\\n    clientHandle.close();\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  var socket = new Socket({\\r\\n    handle: clientHandle,\\r\\n    allowHalfOpen: self.allowHalfOpen,\\r\\n    pauseOnCreate: self.pauseOnConnect\\r\\n  });\\r\\n  socket.readable = socket.writable = true;\\r\\n\\r\\n\\r\\n  self._connections++;\\r\\n  socket.server = self;\\r\\n\\r\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\r\\n  LTTNG_NET_SERVER_CONNECTION(socket);\\r\\n  COUNTER_NET_SERVER_CONNECTION(socket);\\r\\n  self.emit('connection', socket);\\r\\n}\\r\\n\\r\\n\\r\\nServer.prototype.getConnections = function(cb) {\\r\\n  function end(err, connections) {\\r\\n    process.nextTick(cb, err, connections);\\r\\n  }\\r\\n\\r\\n  if (!this._usingSlaves) {\\r\\n    return end(null, this._connections);\\r\\n  }\\r\\n\\r\\n  // Poll slaves\\r\\n  var left = this._slaves.length,\\r\\n      total = this._connections;\\r\\n\\r\\n  function oncount(err, count) {\\r\\n    if (err) {\\r\\n      left = -1;\\r\\n      return end(err);\\r\\n    }\\r\\n\\r\\n    total += count;\\r\\n    if (--left === 0) return end(null, total);\\r\\n  }\\r\\n\\r\\n  this._slaves.forEach(function(slave) {\\r\\n    slave.getConnections(oncount);\\r\\n  });\\r\\n};\\r\\n\\r\\n\\r\\nServer.prototype.close = function(cb) {\\r\\n  function onSlaveClose() {\\r\\n    if (--left !== 0) return;\\r\\n\\r\\n    self._connections = 0;\\r\\n    self._emitCloseIfDrained();\\r\\n  }\\r\\n\\r\\n  if (typeof cb === 'function') {\\r\\n    if (!this._handle) {\\r\\n      this.once('close', function() {\\r\\n        cb(new Error('Not running'));\\r\\n      });\\r\\n    } else {\\r\\n      this.once('close', cb);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (this._handle) {\\r\\n    this._handle.close();\\r\\n    this._handle = null;\\r\\n  }\\r\\n\\r\\n  if (this._usingSlaves) {\\r\\n    var self = this,\\r\\n        left = this._slaves.length;\\r\\n\\r\\n    // Increment connections to be sure that, even if all sockets will be closed\\r\\n    // during polling of slaves, `close` event will be emitted only once.\\r\\n    this._connections++;\\r\\n\\r\\n    // Poll slaves\\r\\n    this._slaves.forEach(function(slave) {\\r\\n      slave.close(onSlaveClose);\\r\\n    });\\r\\n  } else {\\r\\n    this._emitCloseIfDrained();\\r\\n  }\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\nServer.prototype._emitCloseIfDrained = function() {\\r\\n  debug('SERVER _emitCloseIfDrained');\\r\\n  var self = this;\\r\\n\\r\\n  if (self._handle || self._connections) {\\r\\n    debug('SERVER handle? %j   connections? %d',\\r\\n          !!self._handle, self._connections);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  process.nextTick(emitCloseNT, self);\\r\\n};\\r\\n\\r\\n\\r\\nfunction emitCloseNT(self) {\\r\\n  debug('SERVER: emit close');\\r\\n  self.emit('close');\\r\\n}\\r\\n\\r\\n\\r\\nServer.prototype.listenFD = internalUtil.deprecate(function(fd, type) {\\r\\n  return this.listen({ fd: fd });\\r\\n}, 'Server.listenFD is deprecated. Use Server.listen({fd: <number>}) instead.');\\r\\n\\r\\nServer.prototype._setupSlave = function(socketList) {\\r\\n  this._usingSlaves = true;\\r\\n  this._slaves.push(socketList);\\r\\n};\\r\\n\\r\\nServer.prototype.ref = function() {\\r\\n  this._unref = false;\\r\\n\\r\\n  if (this._handle)\\r\\n    this._handle.ref();\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\nServer.prototype.unref = function() {\\r\\n  this._unref = true;\\r\\n\\r\\n  if (this._handle)\\r\\n    this._handle.unref();\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nexports.isIP = cares.isIP;\\r\\n\\r\\n\\r\\nexports.isIPv4 = function(input) {\\r\\n  return exports.isIP(input) === 4;\\r\\n};\\r\\n\\r\\n\\r\\nexports.isIPv6 = function(input) {\\r\\n  return exports.isIP(input) === 6;\\r\\n};\\r\\n\\r\\n\\r\\nif (process.platform === 'win32') {\\r\\n  var simultaneousAccepts;\\r\\n\\r\\n  exports._setSimultaneousAccepts = function(handle) {\\r\\n    if (handle === undefined) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    if (simultaneousAccepts === undefined) {\\r\\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\\r\\n                             process.env.NODE_MANY_ACCEPTS !== '0');\\r\\n    }\\r\\n\\r\\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\\r\\n      handle.setSimultaneousAccepts(simultaneousAccepts);\\r\\n      handle._simultaneousAccepts = simultaneousAccepts;\\r\\n    }\\r\\n  };\\r\\n} else {\\r\\n  exports._setSimultaneousAccepts = function(handle) {};\\r\\n}\\r\\n\",\"dns\":\"'use strict';\\r\\n\\r\\nvar net = require('net');\\r\\nvar util = require('util');\\r\\n\\r\\nvar cares = process.binding('cares_wrap');\\r\\nvar uv = process.binding('uv');\\r\\n\\r\\nvar GetAddrInfoReqWrap = cares.GetAddrInfoReqWrap;\\r\\nvar GetNameInfoReqWrap = cares.GetNameInfoReqWrap;\\r\\nvar QueryReqWrap = cares.QueryReqWrap;\\r\\n\\r\\nvar isIp = net.isIP;\\r\\n\\r\\n\\r\\nfunction errnoException(err, syscall, hostname) {\\r\\n  // FIXME(bnoordhuis) Remove this backwards compatibility nonsense and pass\\r\\n  // the true error to the user. ENOTFOUND is not even a proper POSIX error!\\r\\n  if (err === uv.UV_EAI_MEMORY ||\\r\\n      err === uv.UV_EAI_NODATA ||\\r\\n      err === uv.UV_EAI_NONAME) {\\r\\n    err = 'ENOTFOUND';\\r\\n  }\\r\\n  var ex = null;\\r\\n  if (typeof err === 'string') {  // c-ares error code.\\r\\n    ex = new Error(syscall + ' ' + err + (hostname ? ' ' + hostname : ''));\\r\\n    ex.code = err;\\r\\n    ex.errno = err;\\r\\n    ex.syscall = syscall;\\r\\n  } else {\\r\\n    ex = util._errnoException(err, syscall);\\r\\n  }\\r\\n  if (hostname) {\\r\\n    ex.hostname = hostname;\\r\\n  }\\r\\n  return ex;\\r\\n}\\r\\n\\r\\n\\r\\n// c-ares invokes a callback either synchronously or asynchronously,\\r\\n// but the dns API should always invoke a callback asynchronously.\\r\\n//\\r\\n// This function makes sure that the callback is invoked asynchronously.\\r\\n// It returns a function that invokes the callback within nextTick().\\r\\n//\\r\\n// To avoid invoking unnecessary nextTick(), `immediately` property of\\r\\n// returned function should be set to true after c-ares returned.\\r\\n//\\r\\n// Usage:\\r\\n//\\r\\n// function someAPI(callback) {\\r\\n//   callback = makeAsync(callback);\\r\\n//   channel.someAPI(..., callback);\\r\\n//   callback.immediately = true;\\r\\n// }\\r\\nfunction makeAsync(callback) {\\r\\n  if (typeof callback !== 'function') {\\r\\n    return callback;\\r\\n  }\\r\\n  return function asyncCallback() {\\r\\n    if (asyncCallback.immediately) {\\r\\n      // The API already returned, we can invoke the callback immediately.\\r\\n      callback.apply(null, arguments);\\r\\n    } else {\\r\\n      var args = new Array(arguments.length + 1);\\r\\n      args[0] = callback;\\r\\n      for (var i = 1, a = 0; a < arguments.length; ++i, ++a)\\r\\n        args[i] = arguments[a];\\r\\n      process.nextTick.apply(null, args);\\r\\n    }\\r\\n  };\\r\\n}\\r\\n\\r\\n\\r\\nfunction onlookup(err, addresses) {\\r\\n  if (err) {\\r\\n    return this.callback(errnoException(err, 'getaddrinfo', this.hostname));\\r\\n  }\\r\\n  if (this.family) {\\r\\n    this.callback(null, addresses[0], this.family);\\r\\n  } else {\\r\\n    this.callback(null, addresses[0], addresses[0].indexOf(':') >= 0 ? 6 : 4);\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nfunction onlookupall(err, addresses) {\\r\\n  var results = [];\\r\\n  if (err) {\\r\\n    return this.callback(errnoException(err, 'getaddrinfo', this.hostname));\\r\\n  }\\r\\n\\r\\n  for (var i = 0; i < addresses.length; i++) {\\r\\n    results.push({\\r\\n      address: addresses[i],\\r\\n      family: this.family || (addresses[i].indexOf(':') >= 0 ? 6 : 4)\\r\\n    });\\r\\n  }\\r\\n\\r\\n  this.callback(null, results);\\r\\n}\\r\\n\\r\\n\\r\\n// Easy DNS A/AAAA look up\\r\\n// lookup(hostname, [options,] callback)\\r\\nexports.lookup = function lookup(hostname, options, callback) {\\r\\n  var hints = 0;\\r\\n  var family = -1;\\r\\n  var all = false;\\r\\n\\r\\n  // Parse arguments\\r\\n  if (hostname && typeof hostname !== 'string') {\\r\\n    throw new TypeError('Invalid arguments: ' +\\r\\n                        'hostname must be a string or falsey');\\r\\n  } else if (typeof options === 'function') {\\r\\n    callback = options;\\r\\n    family = 0;\\r\\n  } else if (typeof callback !== 'function') {\\r\\n    throw new TypeError('Invalid arguments: callback must be passed');\\r\\n  } else if (options !== null && typeof options === 'object') {\\r\\n    hints = options.hints >>> 0;\\r\\n    family = options.family >>> 0;\\r\\n    all = options.all === true;\\r\\n\\r\\n    if (hints !== 0 &&\\r\\n        hints !== exports.ADDRCONFIG &&\\r\\n        hints !== exports.V4MAPPED &&\\r\\n        hints !== (exports.ADDRCONFIG | exports.V4MAPPED)) {\\r\\n      throw new TypeError('Invalid argument: hints must use valid flags');\\r\\n    }\\r\\n  } else {\\r\\n    family = options >>> 0;\\r\\n  }\\r\\n\\r\\n  if (family !== 0 && family !== 4 && family !== 6)\\r\\n    throw new TypeError('Invalid argument: family must be 4 or 6');\\r\\n\\r\\n  callback = makeAsync(callback);\\r\\n\\r\\n  if (!hostname) {\\r\\n    if (all) {\\r\\n      callback(null, []);\\r\\n    } else {\\r\\n      callback(null, null, family === 6 ? 6 : 4);\\r\\n    }\\r\\n    return {};\\r\\n  }\\r\\n\\r\\n  var matchedFamily = net.isIP(hostname);\\r\\n  if (matchedFamily) {\\r\\n    if (all) {\\r\\n      callback(null, [{address: hostname, family: matchedFamily}]);\\r\\n    } else {\\r\\n      callback(null, hostname, matchedFamily);\\r\\n    }\\r\\n    return {};\\r\\n  }\\r\\n\\r\\n  var req = new GetAddrInfoReqWrap();\\r\\n  req.callback = callback;\\r\\n  req.family = family;\\r\\n  req.hostname = hostname;\\r\\n  req.oncomplete = all ? onlookupall : onlookup;\\r\\n\\r\\n  var err = cares.getaddrinfo(req, hostname, family, hints);\\r\\n  if (err) {\\r\\n    callback(errnoException(err, 'getaddrinfo', hostname));\\r\\n    return {};\\r\\n  }\\r\\n\\r\\n  callback.immediately = true;\\r\\n  return req;\\r\\n};\\r\\n\\r\\n\\r\\nfunction onlookupservice(err, host, service) {\\r\\n  if (err)\\r\\n    return this.callback(errnoException(err, 'getnameinfo', this.host));\\r\\n\\r\\n  this.callback(null, host, service);\\r\\n}\\r\\n\\r\\n\\r\\n// lookupService(address, port, callback)\\r\\nexports.lookupService = function(host, port, callback) {\\r\\n  if (arguments.length !== 3)\\r\\n    throw new Error('Invalid arguments');\\r\\n\\r\\n  if (cares.isIP(host) === 0)\\r\\n    throw new TypeError('\\\"host\\\" argument needs to be a valid IP address');\\r\\n\\r\\n  callback = makeAsync(callback);\\r\\n\\r\\n  var req = new GetNameInfoReqWrap();\\r\\n  req.callback = callback;\\r\\n  req.host = host;\\r\\n  req.port = port;\\r\\n  req.oncomplete = onlookupservice;\\r\\n\\r\\n  var err = cares.getnameinfo(req, host, port);\\r\\n  if (err) throw errnoException(err, 'getnameinfo', host);\\r\\n\\r\\n  callback.immediately = true;\\r\\n  return req;\\r\\n};\\r\\n\\r\\n\\r\\nfunction onresolve(err, result) {\\r\\n  if (err)\\r\\n    this.callback(errnoException(err, this.bindingName, this.hostname));\\r\\n  else\\r\\n    this.callback(null, result);\\r\\n}\\r\\n\\r\\n\\r\\nfunction resolver(bindingName) {\\r\\n  var binding = cares[bindingName];\\r\\n  return function query(name, callback) {\\r\\n    if (typeof name !== 'string') {\\r\\n      throw new Error('\\\"name\\\" argument must be a string');\\r\\n    } else if (typeof callback !== 'function') {\\r\\n      throw new Error('\\\"callback\\\" argument must be a function');\\r\\n    }\\r\\n\\r\\n    callback = makeAsync(callback);\\r\\n    var req = new QueryReqWrap();\\r\\n    req.bindingName = bindingName;\\r\\n    req.callback = callback;\\r\\n    req.hostname = name;\\r\\n    req.oncomplete = onresolve;\\r\\n    var err = binding(req, name);\\r\\n    if (err) throw errnoException(err, bindingName);\\r\\n    callback.immediately = true;\\r\\n    return req;\\r\\n  };\\r\\n}\\r\\n\\r\\n\\r\\nvar resolveMap = {};\\r\\nexports.resolve4 = resolveMap.A = resolver('queryA');\\r\\nexports.resolve6 = resolveMap.AAAA = resolver('queryAaaa');\\r\\nexports.resolveCname = resolveMap.CNAME = resolver('queryCname');\\r\\nexports.resolveMx = resolveMap.MX = resolver('queryMx');\\r\\nexports.resolveNs = resolveMap.NS = resolver('queryNs');\\r\\nexports.resolveTxt = resolveMap.TXT = resolver('queryTxt');\\r\\nexports.resolveSrv = resolveMap.SRV = resolver('querySrv');\\r\\nexports.resolveNaptr = resolveMap.NAPTR = resolver('queryNaptr');\\r\\nexports.resolveSoa = resolveMap.SOA = resolver('querySoa');\\r\\nexports.reverse = resolveMap.PTR = resolver('getHostByAddr');\\r\\n\\r\\n\\r\\nexports.resolve = function(hostname, type_, callback_) {\\r\\n  var resolver, callback;\\r\\n  if (typeof type_ === 'string') {\\r\\n    resolver = resolveMap[type_];\\r\\n    callback = callback_;\\r\\n  } else if (typeof type_ === 'function') {\\r\\n    resolver = exports.resolve4;\\r\\n    callback = type_;\\r\\n  } else {\\r\\n    throw new Error('\\\"type\\\" argument must be a string');\\r\\n  }\\r\\n\\r\\n  if (typeof resolver === 'function') {\\r\\n    return resolver(hostname, callback);\\r\\n  } else {\\r\\n    throw new Error('Unknown type \\\"' + type_ + '\\\"');\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nexports.getServers = function() {\\r\\n  return cares.getServers();\\r\\n};\\r\\n\\r\\n\\r\\nexports.setServers = function(servers) {\\r\\n  // cache the original servers because in the event of an error setting the\\r\\n  // servers cares won't have any servers available for resolution\\r\\n  var orig = cares.getServers();\\r\\n\\r\\n  var newSet = [];\\r\\n\\r\\n  servers.forEach(function(serv) {\\r\\n    var ver = isIp(serv);\\r\\n\\r\\n    if (ver)\\r\\n      return newSet.push([ver, serv]);\\r\\n\\r\\n    var match = serv.match(/\\\\[(.*)\\\\](:\\\\d+)?/);\\r\\n\\r\\n    // we have an IPv6 in brackets\\r\\n    if (match) {\\r\\n      ver = isIp(match[1]);\\r\\n      if (ver)\\r\\n        return newSet.push([ver, match[1]]);\\r\\n    }\\r\\n\\r\\n    var s = serv.split(/:\\\\d+$/)[0];\\r\\n    ver = isIp(s);\\r\\n\\r\\n    if (ver)\\r\\n      return newSet.push([ver, s]);\\r\\n\\r\\n    throw new Error('IP address is not properly formatted: ' + serv);\\r\\n  });\\r\\n\\r\\n  var r = cares.setServers(newSet);\\r\\n\\r\\n  if (r) {\\r\\n    // reset the servers to the old servers, because ares probably unset them\\r\\n    cares.setServers(orig.join(','));\\r\\n\\r\\n    var err = cares.strerror(r);\\r\\n    throw new Error('c-ares failed to set servers: \\\"' + err +\\r\\n                    '\\\" [' + servers + ']');\\r\\n  }\\r\\n};\\r\\n\\r\\n// uv_getaddrinfo flags\\r\\nexports.ADDRCONFIG = cares.AI_ADDRCONFIG;\\r\\nexports.V4MAPPED = cares.AI_V4MAPPED;\\r\\n\\r\\n// ERROR CODES\\r\\nexports.NODATA = 'ENODATA';\\r\\nexports.FORMERR = 'EFORMERR';\\r\\nexports.SERVFAIL = 'ESERVFAIL';\\r\\nexports.NOTFOUND = 'ENOTFOUND';\\r\\nexports.NOTIMP = 'ENOTIMP';\\r\\nexports.REFUSED = 'EREFUSED';\\r\\nexports.BADQUERY = 'EBADQUERY';\\r\\nexports.BADNAME = 'EBADNAME';\\r\\nexports.BADFAMILY = 'EBADFAMILY';\\r\\nexports.BADRESP = 'EBADRESP';\\r\\nexports.CONNREFUSED = 'ECONNREFUSED';\\r\\nexports.TIMEOUT = 'ETIMEOUT';\\r\\nexports.EOF = 'EOF';\\r\\nexports.FILE = 'EFILE';\\r\\nexports.NOMEM = 'ENOMEM';\\r\\nexports.DESTRUCTION = 'EDESTRUCTION';\\r\\nexports.BADSTR = 'EBADSTR';\\r\\nexports.BADFLAGS = 'EBADFLAGS';\\r\\nexports.NONAME = 'ENONAME';\\r\\nexports.BADHINTS = 'EBADHINTS';\\r\\nexports.NOTINITIALIZED = 'ENOTINITIALIZED';\\r\\nexports.LOADIPHLPAPI = 'ELOADIPHLPAPI';\\r\\nexports.ADDRGETNETWORKPARAMS = 'EADDRGETNETWORKPARAMS';\\r\\nexports.CANCELLED = 'ECANCELLED';\\r\\n\",\"cluster\":\"exports.isMaster = true;\\r\\n\",\"string_decoder\":\"'use strict';\\r\\n\\r\\nvar Buffer = require('buffer').Buffer;\\r\\n\\r\\nfunction assertEncoding(encoding) {\\r\\n  // Do not cache `Buffer.isEncoding`, some modules monkey-patch it to support\\r\\n  // additional encodings\\r\\n  if (encoding && !Buffer.isEncoding(encoding)) {\\r\\n    throw new Error('Unknown encoding: ' + encoding);\\r\\n  }\\r\\n}\\r\\n\\r\\n// StringDecoder provides an interface for efficiently splitting a series of\\r\\n// buffers into a series of JS strings without breaking apart multi-byte\\r\\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\\r\\n//\\r\\n// @TODO Handling all encodings inside a single object makes it very difficult\\r\\n// to reason about this code, so it should be split up in the future.\\r\\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\\r\\n// points as used by CESU-8.\\r\\nvar StringDecoder = exports.StringDecoder = function(encoding) {\\r\\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\\r\\n  assertEncoding(encoding);\\r\\n  switch (this.encoding) {\\r\\n    case 'utf8':\\r\\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\\r\\n      this.surrogateSize = 3;\\r\\n      break;\\r\\n    case 'ucs2':\\r\\n    case 'utf16le':\\r\\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\\r\\n      this.surrogateSize = 2;\\r\\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\\r\\n      break;\\r\\n    case 'base64':\\r\\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\\r\\n      this.surrogateSize = 3;\\r\\n      this.detectIncompleteChar = base64DetectIncompleteChar;\\r\\n      break;\\r\\n    default:\\r\\n      this.write = passThroughWrite;\\r\\n      return;\\r\\n  }\\r\\n\\r\\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\\r\\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\\r\\n  this.charBuffer = Buffer(6);\\r\\n  // Number of bytes received for the current incomplete multi-byte character.\\r\\n  this.charReceived = 0;\\r\\n  // Number of bytes expected for the current incomplete multi-byte character.\\r\\n  this.charLength = 0;\\r\\n};\\r\\n\\r\\n\\r\\n// write decodes the given buffer and returns it as JS string that is\\r\\n// guaranteed to not contain any partial multi-byte characters. Any partial\\r\\n// character found at the end of the buffer is buffered up, and will be\\r\\n// returned when calling write again with the remaining bytes.\\r\\n//\\r\\n// Note: Converting a Buffer containing an orphan surrogate to a String\\r\\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\\r\\n// Buffer#write) will replace incomplete surrogates with the unicode\\r\\n// replacement character. See https://codereview.chromium.org/121173009/ .\\r\\nStringDecoder.prototype.write = function(buffer) {\\r\\n  var charStr = '';\\r\\n  var buflen = buffer.length;\\r\\n  var charBuffer = this.charBuffer;\\r\\n  var charLength = this.charLength;\\r\\n  var charReceived = this.charReceived;\\r\\n  var surrogateSize = this.surrogateSize;\\r\\n  var encoding = this.encoding;\\r\\n  // if our last write ended with an incomplete multibyte character\\r\\n  while (charLength) {\\r\\n    // determine how many remaining bytes this buffer has to offer for this char\\r\\n    var diff = charLength - charReceived;\\r\\n    var available = (buflen >= diff) ? diff : buflen;\\r\\n\\r\\n    // add the new bytes to the char buffer\\r\\n    buffer.copy(charBuffer, charReceived, 0, available);\\r\\n    charReceived += available;\\r\\n\\r\\n    if (charReceived < charLength) {\\r\\n      // still not enough chars in this buffer? wait for more ...\\r\\n\\r\\n      this.charLength = charLength;\\r\\n      this.charReceived = charReceived;\\r\\n\\r\\n      return '';\\r\\n    }\\r\\n\\r\\n    // remove bytes belonging to the current character from the buffer\\r\\n    buffer = buffer.slice(available, buflen);\\r\\n    buflen = buffer.length;\\r\\n\\r\\n    // get the character that was split\\r\\n    charStr = charBuffer.toString(encoding, 0, charLength);\\r\\n\\r\\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\\r\\n    var charCode = charStr.charCodeAt(charStr.length - 1);\\r\\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\\r\\n      charLength += surrogateSize;\\r\\n      charStr = '';\\r\\n      continue;\\r\\n    }\\r\\n    charReceived = charLength = 0;\\r\\n\\r\\n    // if there are no more bytes in this buffer, just emit our char\\r\\n    if (buflen === 0) {\\r\\n      this.charLength = charLength;\\r\\n      this.charReceived = charReceived;\\r\\n\\r\\n      return charStr;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // determine and set charLength / charReceived\\r\\n  if (this.detectIncompleteChar(buffer))\\r\\n    charLength = this.charLength;\\r\\n  charReceived = this.charReceived;\\r\\n\\r\\n  var end = buflen;\\r\\n  if (charLength) {\\r\\n    // buffer the incomplete character bytes we got\\r\\n    buffer.copy(charBuffer, 0, buflen - charReceived, end);\\r\\n    end -= charReceived;\\r\\n  }\\r\\n\\r\\n  this.charLength = charLength;\\r\\n  charStr += buffer.toString(encoding, 0, end);\\r\\n\\r\\n  var end = charStr.length - 1;\\r\\n  var charCode = charStr.charCodeAt(end);\\r\\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\\r\\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\\r\\n    charLength += surrogateSize;\\r\\n    charReceived += surrogateSize;\\r\\n    charBuffer.copy(charBuffer, surrogateSize, 0, surrogateSize);\\r\\n    buffer.copy(charBuffer, 0, 0, surrogateSize);\\r\\n\\r\\n    this.charLength = charLength;\\r\\n    this.charReceived = charReceived;\\r\\n\\r\\n    return charStr.substring(0, end);\\r\\n  }\\r\\n\\r\\n  // or just emit the charStr\\r\\n  return charStr;\\r\\n};\\r\\n\\r\\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\\r\\n// the end of the given buffer. If so, it sets this.charLength to the byte\\r\\n// length that character, and sets this.charReceived to the number of bytes\\r\\n// that are available for this character.\\r\\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\\r\\n  var buflen = buffer.length;\\r\\n  // determine how many bytes we have to check at the end of this buffer\\r\\n  var i = (buflen >= 3) ? 3 : buflen;\\r\\n  var newlen = false;\\r\\n\\r\\n  // Figure out if one of the last i bytes of our buffer announces an\\r\\n  // incomplete char.\\r\\n  for (; i > 0; i--) {\\r\\n    var c = buffer[buflen - i];\\r\\n\\r\\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\\r\\n\\r\\n    // 110XXXXX\\r\\n    if (i === 1 && c >> 5 === 0x06) {\\r\\n      this.charLength = 2;\\r\\n      newlen = true;\\r\\n      break;\\r\\n    }\\r\\n\\r\\n    // 1110XXXX\\r\\n    if (i <= 2 && c >> 4 === 0x0E) {\\r\\n      this.charLength = 3;\\r\\n      newlen = true;\\r\\n      break;\\r\\n    }\\r\\n\\r\\n    // 11110XXX\\r\\n    if (i <= 3 && c >> 3 === 0x1E) {\\r\\n      this.charLength = 4;\\r\\n      newlen = true;\\r\\n      break;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  this.charReceived = i;\\r\\n\\r\\n  return newlen;\\r\\n};\\r\\n\\r\\nStringDecoder.prototype.end = function(buffer) {\\r\\n  var res = '';\\r\\n  if (buffer && buffer.length)\\r\\n    res = this.write(buffer);\\r\\n\\r\\n  var charReceived = this.charReceived;\\r\\n  if (charReceived) {\\r\\n    var cr = charReceived;\\r\\n    var buf = this.charBuffer;\\r\\n    var enc = this.encoding;\\r\\n    res += buf.toString(enc, 0, cr);\\r\\n  }\\r\\n\\r\\n  return res;\\r\\n};\\r\\n\\r\\nfunction passThroughWrite(buffer) {\\r\\n  return buffer.toString(this.encoding);\\r\\n}\\r\\n\\r\\nfunction utf16DetectIncompleteChar(buffer) {\\r\\n  var charReceived = this.charReceived = buffer.length % 2;\\r\\n  this.charLength = charReceived ? 2 : 0;\\r\\n  return true;\\r\\n}\\r\\n\\r\\nfunction base64DetectIncompleteChar(buffer) {\\r\\n  var charReceived = this.charReceived = buffer.length % 3;\\r\\n  this.charLength = charReceived ? 3 : 0;\\r\\n  return true;\\r\\n}\\r\\n\",\"tty\":\"'use strict';\\r\\n\\r\\nvar util = require('util');\\r\\nvar internalUtil = require('internal/util');\\r\\nvar net = require('net');\\r\\nvar TTY = process.binding('tty_wrap').TTY;\\r\\nvar isTTY = process.binding('tty_wrap').isTTY;\\r\\nvar inherits = util.inherits;\\r\\nvar errnoException = util._errnoException;\\r\\n\\r\\n\\r\\nexports.isatty = function(fd) {\\r\\n  return isTTY(fd);\\r\\n};\\r\\n\\r\\n\\r\\n// backwards-compat\\r\\nexports.setRawMode = internalUtil.deprecate(function(flag) {\\r\\n  if (!process.stdin.isTTY) {\\r\\n    throw new Error('Can\\\\'t set raw mode on non-tty');\\r\\n  }\\r\\n  process.stdin.setRawMode(flag);\\r\\n}, 'tty.setRawMode is deprecated. ' +\\r\\n   'Use process.stdin.setRawMode instead.');\\r\\n\\r\\n\\r\\nfunction ReadStream(fd, options) {\\r\\n  if (!(this instanceof ReadStream))\\r\\n    return new ReadStream(fd, options);\\r\\n\\r\\n  options = util._extend({\\r\\n    highWaterMark: 0,\\r\\n    readable: true,\\r\\n    writable: false,\\r\\n    handle: new TTY(fd, true)\\r\\n  }, options);\\r\\n\\r\\n  net.Socket.call(this, options);\\r\\n\\r\\n  this.isRaw = false;\\r\\n  this.isTTY = true;\\r\\n}\\r\\ninherits(ReadStream, net.Socket);\\r\\n\\r\\nexports.ReadStream = ReadStream;\\r\\n\\r\\nReadStream.prototype.setRawMode = function(flag) {\\r\\n  flag = !!flag;\\r\\n  this._handle.setRawMode(flag);\\r\\n  this.isRaw = flag;\\r\\n};\\r\\n\\r\\n\\r\\nfunction WriteStream(fd) {\\r\\n  if (!(this instanceof WriteStream)) return new WriteStream(fd);\\r\\n  net.Socket.call(this, {\\r\\n    handle: new TTY(fd, false),\\r\\n    readable: false,\\r\\n    writable: true\\r\\n  });\\r\\n\\r\\n  var winSize = [];\\r\\n  var err = this._handle.getWindowSize(winSize);\\r\\n  if (!err) {\\r\\n    this.columns = winSize[0];\\r\\n    this.rows = winSize[1];\\r\\n  }\\r\\n}\\r\\ninherits(WriteStream, net.Socket);\\r\\nexports.WriteStream = WriteStream;\\r\\n\\r\\n\\r\\nWriteStream.prototype.isTTY = true;\\r\\n\\r\\n\\r\\nWriteStream.prototype._refreshSize = function() {\\r\\n  var oldCols = this.columns;\\r\\n  var oldRows = this.rows;\\r\\n  var winSize = [];\\r\\n  var err = this._handle.getWindowSize(winSize);\\r\\n  if (err) {\\r\\n    this.emit('error', errnoException(err, 'getWindowSize'));\\r\\n    return;\\r\\n  }\\r\\n  var newCols = winSize[0];\\r\\n  var newRows = winSize[1];\\r\\n  if (oldCols !== newCols || oldRows !== newRows) {\\r\\n    this.columns = newCols;\\r\\n    this.rows = newRows;\\r\\n    this.emit('resize');\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\n// backwards-compat\\r\\nWriteStream.prototype.cursorTo = function(x, y) {\\r\\n  require('readline').cursorTo(this, x, y);\\r\\n};\\r\\nWriteStream.prototype.moveCursor = function(dx, dy) {\\r\\n  require('readline').moveCursor(this, dx, dy);\\r\\n};\\r\\nWriteStream.prototype.clearLine = function(dir) {\\r\\n  require('readline').clearLine(this, dir);\\r\\n};\\r\\nWriteStream.prototype.clearScreenDown = function() {\\r\\n  require('readline').clearScreenDown(this);\\r\\n};\\r\\nWriteStream.prototype.getWindowSize = function() {\\r\\n  return [this.columns, this.rows];\\r\\n};\\r\\n\",\"internal/child_process\":\"'use strict';\\n\\nvar StringDecoder = require('string_decoder').StringDecoder;\\nvar Buffer = require('buffer').Buffer;\\nvar EventEmitter = require('events');\\nvar net = require('net');\\n//FIXME: dgram\\n// var dgram = require('dgram');\\nvar util = require('util');\\nvar constants = require('constants');\\nvar assert = require('assert');\\n\\nvar Process = process.binding('process_wrap').Process;\\nvar WriteWrap = process.binding('stream_wrap').WriteWrap;\\nvar uv = process.binding('uv');\\nvar Pipe = process.binding('pipe_wrap').Pipe;\\nvar TTY = process.binding('tty_wrap').TTY;\\nvar TCP = process.binding('tcp_wrap').TCP;\\n//FIXME udp\\n// var UDP = process.binding('udp_wrap').UDP;\\nvar SocketList = require('internal/socket_list');\\n\\nvar errnoException = util._errnoException;\\nvar SocketListSend = SocketList.SocketListSend;\\nvar SocketListReceive = SocketList.SocketListReceive;\\n\\nexports.ChildProcess = ChildProcess;\\nexports.setupChannel = setupChannel;\\nexports._validateStdio = _validateStdio;\\nexports.getSocketList = getSocketList;\\n\\n// module.exports = {\\n//   ChildProcess,\\n//   setupChannel,\\n//   _validateStdio,\\n//   getSocketList\\n// };\\n\\n// this object contain function to convert TCP objects to native handle objects\\n// and back again.\\nvar handleConversion = {\\n  'net.Native': {\\n    simultaneousAccepts: true,\\n\\n    send: function(message, handle) {\\n      return handle;\\n    },\\n\\n    got: function(message, handle, emit) {\\n      emit(handle);\\n    }\\n  },\\n\\n  'net.Server': {\\n    simultaneousAccepts: true,\\n\\n    send: function(message, server) {\\n      return server._handle;\\n    },\\n\\n    got: function(message, handle, emit) {\\n      var server = new net.Server();\\n      server.listen(handle, function() {\\n        emit(server);\\n      });\\n    }\\n  },\\n\\n  'net.Socket': {\\n    send: function(message, socket) {\\n      if (!socket._handle)\\n        return;\\n\\n      // if the socket was created by net.Server\\n      if (socket.server) {\\n        // the slave should keep track of the socket\\n        message.key = socket.server._connectionKey;\\n\\n        var firstTime = !this._channel.sockets.send[message.key];\\n        var socketList = getSocketList('send', this, message.key);\\n\\n        // the server should no longer expose a .connection property\\n        // and when asked to close it should query the socket status from\\n        // the slaves\\n        if (firstTime) socket.server._setupSlave(socketList);\\n\\n        // Act like socket is detached\\n        socket.server._connections--;\\n      }\\n\\n      // remove handle from socket object, it will be closed when the socket\\n      // will be sent\\n      var handle = socket._handle;\\n      handle.onread = function() {};\\n      socket._handle = null;\\n\\n      return handle;\\n    },\\n\\n    postSend: function(handle) {\\n      // Close the Socket handle after sending it\\n      if (handle)\\n        handle.close();\\n    },\\n\\n    got: function(message, handle, emit) {\\n      var socket = new net.Socket({handle: handle});\\n      socket.readable = socket.writable = true;\\n\\n      // if the socket was created by net.Server we will track the socket\\n      if (message.key) {\\n\\n        // add socket to connections list\\n        var socketList = getSocketList('got', this, message.key);\\n        socketList.add({\\n          socket: socket\\n        });\\n      }\\n\\n      emit(socket);\\n    }\\n  },\\n\\n  'dgram.Native': {\\n    simultaneousAccepts: false,\\n\\n    send: function(message, handle) {\\n      return handle;\\n    },\\n\\n    got: function(message, handle, emit) {\\n      emit(handle);\\n    }\\n  },\\n\\n  'dgram.Socket': {\\n    simultaneousAccepts: false,\\n\\n    send: function(message, socket) {\\n      message.dgramType = socket.type;\\n\\n      return socket._handle;\\n    },\\n\\n    got: function(message, handle, emit) {\\n      var socket = new dgram.Socket(message.dgramType);\\n\\n      socket.bind(handle, function() {\\n        emit(socket);\\n      });\\n    }\\n  }\\n};\\n\\n\\nfunction ChildProcess() {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n\\n  this._closesNeeded = 1;\\n  this._closesGot = 0;\\n  this.connected = false;\\n\\n  this.signalCode = null;\\n  this.exitCode = null;\\n  this.killed = false;\\n  this.spawnfile = null;\\n\\n  this._handle = new Process();\\n  this._handle.owner = this;\\n\\n  this._handle.onexit = function(exitCode, signalCode) {\\n    //\\n    // follow 0.4.x behaviour:\\n    //\\n    // - normally terminated processes don't touch this.signalCode\\n    // - signaled processes don't touch this.exitCode\\n    //\\n    // new in 0.9.x:\\n    //\\n    // - spawn failures are reported with exitCode < 0\\n    //\\n    var syscall = self.spawnfile ? 'spawn ' + self.spawnfile : 'spawn';\\n    var err = (exitCode < 0) ? errnoException(exitCode, syscall) : null;\\n\\n    if (signalCode) {\\n      self.signalCode = signalCode;\\n    } else {\\n      self.exitCode = exitCode;\\n    }\\n\\n    if (self.stdin) {\\n      self.stdin.destroy();\\n    }\\n\\n    self._handle.close();\\n    self._handle = null;\\n\\n    if (exitCode < 0) {\\n      if (self.spawnfile)\\n        err.path = self.spawnfile;\\n\\n      err.spawnargs = self.spawnargs.slice(1);\\n      self.emit('error', err);\\n    } else {\\n      self.emit('exit', self.exitCode, self.signalCode);\\n    }\\n\\n    // if any of the stdio streams have not been touched,\\n    // then pull all the data through so that it can get the\\n    // eof and emit a 'close' event.\\n    // Do it on nextTick so that the user has one last chance\\n    // to consume the output, if for example they only want to\\n    // start reading the data once the process exits.\\n    process.nextTick(flushStdio, self);\\n\\n    maybeClose(self);\\n  };\\n}\\nutil.inherits(ChildProcess, EventEmitter);\\n\\n\\nfunction flushStdio(subprocess) {\\n  if (subprocess.stdio == null) return;\\n  subprocess.stdio.forEach(function(stream, fd, stdio) {\\n    if (!stream || !stream.readable)\\n      return;\\n    stream.resume();\\n  });\\n}\\n\\n\\nfunction createSocket(pipe, readable) {\\n  var s = new net.Socket({ handle: pipe });\\n\\n  if (readable) {\\n    s.writable = false;\\n    s.readable = true;\\n  } else {\\n    s.writable = true;\\n    s.readable = false;\\n  }\\n\\n  return s;\\n}\\n\\n\\nfunction getHandleWrapType(stream) {\\n  if (stream instanceof Pipe) return 'pipe';\\n  if (stream instanceof TTY) return 'tty';\\n  if (stream instanceof TCP) return 'tcp';\\n  if (stream instanceof UDP) return 'udp';\\n\\n  return false;\\n}\\n\\n\\nChildProcess.prototype.spawn = function(options) {\\n  var self = this,\\n      ipc,\\n      ipcFd,\\n      // If no `stdio` option was given - use default\\n      stdio = options.stdio || 'pipe';\\n\\n  stdio = _validateStdio(stdio, false);\\n\\n  ipc = stdio.ipc;\\n  ipcFd = stdio.ipcFd;\\n  stdio = options.stdio = stdio.stdio;\\n\\n  if (ipc !== undefined) {\\n    // Let child process know about opened IPC channel\\n    options.envPairs = options.envPairs || [];\\n    options.envPairs.push('NODE_CHANNEL_FD=' + ipcFd);\\n  }\\n\\n  this.spawnfile = options.file;\\n  this.spawnargs = options.args;\\n\\n  var err = this._handle.spawn(options);\\n\\n  // Run-time errors should emit an error, not throw an exception.\\n  if (err === uv.UV_EAGAIN ||\\n      err === uv.UV_EMFILE ||\\n      err === uv.UV_ENFILE ||\\n      err === uv.UV_ENOENT) {\\n    process.nextTick(onErrorNT, self, err);\\n    // There is no point in continuing when we've hit EMFILE or ENFILE\\n    // because we won't be able to set up the stdio file descriptors.\\n    // It's kind of silly that the de facto spec for ENOENT (the test suite)\\n    // mandates that stdio _is_ set up, even if there is no process on the\\n    // receiving end, but it is what it is.\\n    if (err !== uv.UV_ENOENT) return err;\\n  } else if (err) {\\n    // Close all opened fds on error\\n    stdio.forEach(function(stdio) {\\n      if (stdio.type === 'pipe') {\\n        stdio.handle.close();\\n      }\\n    });\\n\\n    this._handle.close();\\n    this._handle = null;\\n    throw errnoException(err, 'spawn');\\n  }\\n\\n  this.pid = this._handle.pid;\\n\\n  stdio.forEach(function(stdio, i) {\\n    if (stdio.type === 'ignore') return;\\n\\n    if (stdio.ipc) {\\n      self._closesNeeded++;\\n      return;\\n    }\\n\\n    if (stdio.handle) {\\n      // when i === 0 - we're dealing with stdin\\n      // (which is the only one writable pipe)\\n      stdio.socket = createSocket(self.pid !== 0 ? stdio.handle : null, i > 0);\\n\\n      if (i > 0 && self.pid !== 0) {\\n        self._closesNeeded++;\\n        stdio.socket.on('close', function() {\\n          maybeClose(self);\\n        });\\n      }\\n    }\\n  });\\n\\n  this.stdin = stdio.length >= 1 && stdio[0].socket !== undefined ?\\n      stdio[0].socket : null;\\n  this.stdout = stdio.length >= 2 && stdio[1].socket !== undefined ?\\n      stdio[1].socket : null;\\n  this.stderr = stdio.length >= 3 && stdio[2].socket !== undefined ?\\n      stdio[2].socket : null;\\n\\n  this.stdio = stdio.map(function(stdio) {\\n    return stdio.socket === undefined ? null : stdio.socket;\\n  });\\n\\n  // Add .send() method and start listening for IPC data\\n  if (ipc !== undefined) setupChannel(this, ipc);\\n\\n  return err;\\n};\\n\\n\\nfunction onErrorNT(self, err) {\\n  self._handle.onexit(err);\\n}\\n\\n\\nChildProcess.prototype.kill = function(sig) {\\n  var signal;\\n\\n  if (sig === 0) {\\n    signal = 0;\\n  } else if (!sig) {\\n    signal = constants['SIGTERM'];\\n  } else {\\n    signal = constants[sig];\\n  }\\n\\n  if (signal === undefined) {\\n    throw new Error('Unknown signal: ' + sig);\\n  }\\n\\n  if (this._handle) {\\n    var err = this._handle.kill(signal);\\n    if (err === 0) {\\n      /* Success. */\\n      this.killed = true;\\n      return true;\\n    }\\n    if (err === uv.UV_ESRCH) {\\n      /* Already dead. */\\n    } else if (err === uv.UV_EINVAL || err === uv.UV_ENOSYS) {\\n      /* The underlying platform doesn't support this signal. */\\n      throw errnoException(err, 'kill');\\n    } else {\\n      /* Other error, almost certainly EPERM. */\\n      this.emit('error', errnoException(err, 'kill'));\\n    }\\n  }\\n\\n  /* Kill didn't succeed. */\\n  return false;\\n};\\n\\n\\nChildProcess.prototype.ref = function() {\\n  if (this._handle) this._handle.ref();\\n};\\n\\n\\nChildProcess.prototype.unref = function() {\\n  if (this._handle) this._handle.unref();\\n};\\n\\n// COMO nodejs code modification\\n// modified code here from es6 to es5\\nutil.inherits(ClassExtends, EventEmitter);\\nfunction ClassExtends (channel){\\n  EventEmitter.call(this);\\n  this.channel = channel;\\n  this.refs = 0;\\n\\n  this.ref = function() {\\n    if (++this.refs === 1) {\\n      this.channel.ref();\\n    }\\n  };\\n\\n  this.unref = function() {\\n    if (--this.refs === 0) {\\n      this.channel.unref();\\n      this.emit('unref');\\n    }\\n  };\\n}\\n\\nfunction setupChannel(target, channel) {\\n  target._channel = channel;\\n  target._handleQueue = null;\\n  var control = new ClassExtends(channel);\\n  // Object.setPrototypeOf(control, EventEmitter);\\n  // console.log(control);\\n  // var control = new class extends EventEmitter {\\n  //   constructor() {\\n  //     super();\\n  //     this.channel = channel;\\n  //     this.refs = 0;\\n  //   }\\n  //   ref() {\\n  //     if (++this.refs === 1) {\\n  //       this.channel.ref();\\n  //     }\\n  //   }\\n  //   unref() {\\n  //     if (--this.refs === 0) {\\n  //       this.channel.unref();\\n  //       this.emit('unref');\\n  //     }\\n  //   }\\n  // };\\n\\n  var decoder = new StringDecoder('utf8');\\n  var jsonBuffer = '';\\n  channel.buffering = false;\\n  channel.onread = function(nread, pool, recvHandle) {\\n    // TODO(bnoordhuis) Check that nread > 0.\\n    if (pool) {\\n      jsonBuffer += decoder.write(pool);\\n\\n      var i, start = 0;\\n\\n      //Linebreak is used as a message end sign\\n      while ((i = jsonBuffer.indexOf('\\\\n', start)) >= 0) {\\n        var json = jsonBuffer.slice(start, i);\\n        var message = JSON.parse(json);\\n\\n        // There will be at most one NODE_HANDLE message in every chunk we\\n        // read because SCM_RIGHTS messages don't get coalesced. Make sure\\n        // that we deliver the handle with the right message however.\\n        if (message && message.cmd === 'NODE_HANDLE')\\n          handleMessage(target, message, recvHandle);\\n        else\\n          handleMessage(target, message, undefined);\\n\\n        start = i + 1;\\n      }\\n      jsonBuffer = jsonBuffer.slice(start);\\n      this.buffering = jsonBuffer.length !== 0;\\n\\n    } else {\\n      this.buffering = false;\\n      target.disconnect();\\n      channel.onread = nop;\\n      channel.close();\\n      target._channel = null;\\n      maybeClose(target);\\n    }\\n  };\\n\\n  // object where socket lists will live\\n  channel.sockets = { got: {}, send: {} };\\n\\n  // handlers will go through this\\n  target.on('internalMessage', function(message, handle) {\\n    // Once acknowledged - continue sending handles.\\n    if (message.cmd === 'NODE_HANDLE_ACK') {\\n      assert(Array.isArray(target._handleQueue));\\n      var queue = target._handleQueue;\\n      target._handleQueue = null;\\n\\n      queue.forEach(function(args) {\\n        target._send(args.message, args.handle, false, args.callback);\\n      });\\n\\n      // Process a pending disconnect (if any).\\n      if (!target.connected && target._channel && !target._handleQueue)\\n        target._disconnect();\\n\\n      return;\\n    }\\n\\n    if (message.cmd !== 'NODE_HANDLE') return;\\n\\n    // Acknowledge handle receival. Don't emit error events (for example if\\n    // the other side has disconnected) because this call to send() is not\\n    // initiated by the user and it shouldn't be fatal to be unable to ACK\\n    // a message.\\n    target._send({ cmd: 'NODE_HANDLE_ACK' }, null, true);\\n\\n    var obj = handleConversion[message.type];\\n\\n    // Update simultaneous accepts on Windows\\n    if (process.platform === 'win32') {\\n      handle._simultaneousAccepts = false;\\n      net._setSimultaneousAccepts(handle);\\n    }\\n\\n    // Convert handle object\\n    obj.got.call(this, message, handle, function(handle) {\\n      handleMessage(target, message.msg, handle);\\n    });\\n  });\\n\\n  target.send = function(message, handle, callback) {\\n    if (typeof handle === 'function') {\\n      callback = handle;\\n      handle = undefined;\\n    }\\n    if (this.connected) {\\n      return this._send(message, handle, false, callback);\\n    }\\n    var ex = new Error('channel closed');\\n    if (typeof callback === 'function') {\\n      process.nextTick(callback, ex);\\n    } else {\\n      this.emit('error', ex);  // FIXME(bnoordhuis) Defer to next tick.\\n    }\\n    return false;\\n  };\\n\\n  target._send = function(message, handle, swallowErrors, callback) {\\n    assert(this.connected || this._channel);\\n\\n    if (message === undefined)\\n      throw new TypeError('\\\"message\\\" argument cannot be undefined');\\n\\n    // package messages with a handle object\\n    if (handle) {\\n      // this message will be handled by an internalMessage event handler\\n      message = {\\n        cmd: 'NODE_HANDLE',\\n        type: null,\\n        msg: message\\n      };\\n\\n      if (handle instanceof net.Socket) {\\n        message.type = 'net.Socket';\\n      } else if (handle instanceof net.Server) {\\n        message.type = 'net.Server';\\n      } else if (handle instanceof TCP || handle instanceof Pipe) {\\n        message.type = 'net.Native';\\n      } else if (handle instanceof dgram.Socket) {\\n        message.type = 'dgram.Socket';\\n      } else if (handle instanceof UDP) {\\n        message.type = 'dgram.Native';\\n      } else {\\n        throw new TypeError('This handle type can\\\\'t be sent');\\n      }\\n\\n      // Queue-up message and handle if we haven't received ACK yet.\\n      if (this._handleQueue) {\\n        this._handleQueue.push({\\n          callback: callback,\\n          handle: handle,\\n          message: message.msg,\\n        });\\n        return this._handleQueue.length === 1;\\n      }\\n\\n      var obj = handleConversion[message.type];\\n\\n      // convert TCP object to native handle object\\n      handle =\\n          handleConversion[message.type].send.call(target, message, handle);\\n\\n      // If handle was sent twice, or it is impossible to get native handle\\n      // out of it - just send a text without the handle.\\n      if (!handle)\\n        message = message.msg;\\n\\n      // Update simultaneous accepts on Windows\\n      if (obj.simultaneousAccepts) {\\n        net._setSimultaneousAccepts(handle);\\n      }\\n    } else if (this._handleQueue &&\\n               !(message && message.cmd === 'NODE_HANDLE_ACK')) {\\n      // Queue request anyway to avoid out-of-order messages.\\n      this._handleQueue.push({\\n        callback: callback,\\n        handle: null,\\n        message: message,\\n      });\\n      return this._handleQueue.length === 1;\\n    }\\n\\n    var req = new WriteWrap();\\n    req.async = false;\\n\\n    var string = JSON.stringify(message) + '\\\\n';\\n    var err = channel.writeUtf8String(req, string, handle);\\n\\n    if (err === 0) {\\n      if (handle && !this._handleQueue)\\n        this._handleQueue = [];\\n      req.oncomplete = function() {\\n        if (this.async === true)\\n          control.unref();\\n        if (obj && obj.postSend)\\n          obj.postSend(handle);\\n        if (typeof callback === 'function')\\n          callback(null);\\n      };\\n      if (req.async === true) {\\n        control.ref();\\n      } else {\\n        process.nextTick(function() { req.oncomplete(); });\\n      }\\n    } else if (!swallowErrors) {\\n      var ex = errnoException(err, 'write');\\n      if (typeof callback === 'function') {\\n        process.nextTick(callback, ex);\\n      } else {\\n        this.emit('error', ex);  // FIXME(bnoordhuis) Defer to next tick.\\n      }\\n    }\\n\\n    /* If the master is > 2 read() calls behind, please stop sending. */\\n    return channel.writeQueueSize < (65536 * 2);\\n  };\\n\\n  // connected will be set to false immediately when a disconnect() is\\n  // requested, even though the channel might still be alive internally to\\n  // process queued messages. The three states are distinguished as follows:\\n  // - disconnect() never requested: _channel is not null and connected\\n  //   is true\\n  // - disconnect() requested, messages in the queue: _channel is not null\\n  //   and connected is false\\n  // - disconnect() requested, channel actually disconnected: _channel is\\n  //   null and connected is false\\n  target.connected = true;\\n\\n  target.disconnect = function() {\\n    if (!this.connected) {\\n      this.emit('error', new Error('IPC channel is already disconnected'));\\n      return;\\n    }\\n\\n    // Do not allow any new messages to be written.\\n    this.connected = false;\\n\\n    // If there are no queued messages, disconnect immediately. Otherwise,\\n    // postpone the disconnect so that it happens internally after the\\n    // queue is flushed.\\n    if (!this._handleQueue)\\n      this._disconnect();\\n  };\\n\\n  target._disconnect = function() {\\n    assert(this._channel);\\n\\n    // This marks the fact that the channel is actually disconnected.\\n    this._channel = null;\\n\\n    var fired = false;\\n    function finish() {\\n      if (fired) return;\\n      fired = true;\\n\\n      channel.close();\\n      target.emit('disconnect');\\n    }\\n\\n    // If a message is being read, then wait for it to complete.\\n    if (channel.buffering) {\\n      this.once('message', finish);\\n      this.once('internalMessage', finish);\\n\\n      return;\\n    }\\n\\n    process.nextTick(finish);\\n  };\\n\\n  channel.readStart();\\n  return control;\\n}\\n\\n\\nvar INTERNAL_PREFIX = 'NODE_';\\nfunction handleMessage(target, message, handle) {\\n  var eventName = 'message';\\n  if (message !== null &&\\n      typeof message === 'object' &&\\n      typeof message.cmd === 'string' &&\\n      message.cmd.length > INTERNAL_PREFIX.length &&\\n      message.cmd.slice(0, INTERNAL_PREFIX.length) === INTERNAL_PREFIX) {\\n    eventName = 'internalMessage';\\n  }\\n  target.emit(eventName, message, handle);\\n}\\n\\nfunction nop() { }\\n\\nfunction _validateStdio(stdio, sync) {\\n  var ipc,\\n      ipcFd;\\n\\n  // Replace shortcut with an array\\n  if (typeof stdio === 'string') {\\n    switch (stdio) {\\n      case 'ignore': stdio = ['ignore', 'ignore', 'ignore']; break;\\n      case 'pipe': stdio = ['pipe', 'pipe', 'pipe']; break;\\n      case 'inherit': stdio = [0, 1, 2]; break;\\n      default: throw new TypeError('Incorrect value of stdio option: ' + stdio);\\n    }\\n  } else if (!Array.isArray(stdio)) {\\n    throw new TypeError('Incorrect value of stdio option: ' +\\n        util.inspect(stdio));\\n  }\\n\\n  // At least 3 stdio will be created\\n  // Don't concat() a new Array() because it would be sparse, and\\n  // stdio.reduce() would skip the sparse elements of stdio.\\n  // See http://stackoverflow.com/a/5501711/3561\\n  while (stdio.length < 3) stdio.push(undefined);\\n\\n  // Translate stdio into C++-readable form\\n  // (i.e. PipeWraps or fds)\\n  stdio = stdio.reduce(function(acc, stdio, i) {\\n    function cleanup() {\\n      acc.filter(function(stdio) {\\n        return stdio.type === 'pipe' || stdio.type === 'ipc';\\n      }).forEach(function(stdio) {\\n        if (stdio.handle)\\n          stdio.handle.close();\\n      });\\n    }\\n\\n    // Defaults\\n    if (stdio === null || stdio === undefined) {\\n      stdio = i < 3 ? 'pipe' : 'ignore';\\n    }\\n\\n    if (stdio === null || stdio === 'ignore') {\\n      acc.push({type: 'ignore'});\\n    } else if (stdio === 'pipe' || typeof stdio === 'number' && stdio < 0) {\\n      var a = {\\n        type: 'pipe',\\n        readable: i === 0,\\n        writable: i !== 0\\n      };\\n\\n      if (!sync)\\n        a.handle = new Pipe();\\n\\n      acc.push(a);\\n    } else if (stdio === 'ipc') {\\n      if (sync || ipc !== undefined) {\\n        // Cleanup previously created pipes\\n        cleanup();\\n        if (!sync)\\n          throw new Error('Child process can have only one IPC pipe');\\n        else\\n          throw new Error('You cannot use IPC with synchronous forks');\\n      }\\n\\n      ipc = new Pipe(true);\\n      ipcFd = i;\\n\\n      acc.push({\\n        type: 'pipe',\\n        handle: ipc,\\n        ipc: true\\n      });\\n    } else if (stdio === 'inherit') {\\n      acc.push({\\n        type: 'inherit',\\n        fd: i\\n      });\\n    } else if (typeof stdio === 'number' || typeof stdio.fd === 'number') {\\n      acc.push({\\n        type: 'fd',\\n        fd: typeof stdio === 'number' ? stdio : stdio.fd\\n      });\\n    } else if (getHandleWrapType(stdio) || getHandleWrapType(stdio.handle) ||\\n               getHandleWrapType(stdio._handle)) {\\n      var handle = getHandleWrapType(stdio) ?\\n          stdio :\\n          getHandleWrapType(stdio.handle) ? stdio.handle : stdio._handle;\\n\\n      acc.push({\\n        type: 'wrap',\\n        wrapType: getHandleWrapType(handle),\\n        handle: handle\\n      });\\n    } else if (stdio instanceof Buffer || typeof stdio === 'string') {\\n      if (!sync) {\\n        cleanup();\\n        throw new TypeError('Asynchronous forks do not support Buffer input: ' +\\n            util.inspect(stdio));\\n      }\\n    } else {\\n      // Cleanup\\n      cleanup();\\n      throw new TypeError('Incorrect value for stdio stream: ' +\\n          util.inspect(stdio));\\n    }\\n\\n    return acc;\\n  }, []);\\n\\n  return {stdio: stdio, ipc: ipc, ipcFd: ipcFd};\\n}\\n\\n\\nfunction getSocketList(type, slave, key) {\\n  var sockets = slave._channel.sockets[type];\\n  var socketList = sockets[key];\\n  if (!socketList) {\\n    var Construct = type === 'send' ? SocketListSend : SocketListReceive;\\n    socketList = sockets[key] = new Construct(slave, key);\\n  }\\n  return socketList;\\n}\\n\\n\\nfunction maybeClose(subprocess) {\\n  subprocess._closesGot++;\\n\\n  if (subprocess._closesGot == subprocess._closesNeeded) {\\n    subprocess.emit('close', subprocess.exitCode, subprocess.signalCode);\\n  }\\n}\\n\",\"internal/socket_list\":\"'use strict';\\n\\nexports.SocketListSend = SocketListSend;\\nexports.SocketListReceive = SocketListReceive;\\n\\nvar EventEmitter = require('events');\\nvar util = require('util');\\n\\n// This object keep track of the socket there are sended\\nfunction SocketListSend(slave, key) {\\n  EventEmitter.call(this);\\n\\n  this.key = key;\\n  this.slave = slave;\\n}\\nutil.inherits(SocketListSend, EventEmitter);\\n\\nSocketListSend.prototype._request = function(msg, cmd, callback) {\\n  var self = this;\\n\\n  if (!this.slave.connected) return onclose();\\n  this.slave.send(msg);\\n\\n  function onclose() {\\n    self.slave.removeListener('internalMessage', onreply);\\n    callback(new Error('Slave closed before reply'));\\n  }\\n\\n  function onreply(msg) {\\n    if (!(msg.cmd === cmd && msg.key === self.key)) return;\\n    self.slave.removeListener('disconnect', onclose);\\n    self.slave.removeListener('internalMessage', onreply);\\n\\n    callback(null, msg);\\n  }\\n\\n  this.slave.once('disconnect', onclose);\\n  this.slave.on('internalMessage', onreply);\\n};\\n\\nSocketListSend.prototype.close = function close(callback) {\\n  this._request({\\n    cmd: 'NODE_SOCKET_NOTIFY_CLOSE',\\n    key: this.key\\n  }, 'NODE_SOCKET_ALL_CLOSED', callback);\\n};\\n\\nSocketListSend.prototype.getConnections = function getConnections(callback) {\\n  this._request({\\n    cmd: 'NODE_SOCKET_GET_COUNT',\\n    key: this.key\\n  }, 'NODE_SOCKET_COUNT', function(err, msg) {\\n    if (err) return callback(err);\\n    callback(null, msg.count);\\n  });\\n};\\n\\n// This object keep track of the socket there are received\\nfunction SocketListReceive(slave, key) {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n\\n  this.connections = 0;\\n  this.key = key;\\n  this.slave = slave;\\n\\n  function onempty() {\\n    if (!self.slave.connected) return;\\n\\n    self.slave.send({\\n      cmd: 'NODE_SOCKET_ALL_CLOSED',\\n      key: self.key\\n    });\\n  }\\n\\n  this.slave.on('internalMessage', function(msg) {\\n    if (msg.key !== self.key) return;\\n\\n    if (msg.cmd === 'NODE_SOCKET_NOTIFY_CLOSE') {\\n      // Already empty\\n      if (self.connections === 0) return onempty();\\n\\n      // Wait for sockets to get closed\\n      self.once('empty', onempty);\\n    } else if (msg.cmd === 'NODE_SOCKET_GET_COUNT') {\\n      if (!self.slave.connected) return;\\n      self.slave.send({\\n        cmd: 'NODE_SOCKET_COUNT',\\n        key: self.key,\\n        count: self.connections\\n      });\\n    }\\n  });\\n}\\nutil.inherits(SocketListReceive, EventEmitter);\\n\\nSocketListReceive.prototype.add = function(obj) {\\n  var self = this;\\n\\n  this.connections++;\\n\\n  // Notify previous owner of socket about its state change\\n  obj.socket.once('close', function() {\\n    self.connections--;\\n\\n    if (self.connections === 0) self.emit('empty');\\n  });\\n};\\n\",\"child_process\":\"'use strict';\\n\\nvar util = require('util');\\nvar internalUtil = require('internal/util');\\nvar debug = util.debuglog('child_process');\\nvar constants = require('constants');\\n\\nvar uv = process.binding('uv');\\nvar spawn_sync = require('spawn_sync');\\nvar Buffer = require('buffer').Buffer;\\nvar Pipe = process.binding('pipe_wrap').Pipe;\\nvar child_process = require('internal/child_process');\\n\\nvar errnoException = util._errnoException;\\nvar _validateStdio = child_process._validateStdio;\\nvar setupChannel = child_process.setupChannel;\\nvar ChildProcess = exports.ChildProcess = child_process.ChildProcess;\\n\\nexports.fork = function(modulePath /*, args, options*/) {\\n\\n  // Get options and args arguments.\\n  var options, args, execArgv;\\n  if (Array.isArray(arguments[1])) {\\n    args = arguments[1];\\n    options = util._extend({}, arguments[2]);\\n  } else if (arguments[1] && typeof arguments[1] !== 'object') {\\n    throw new TypeError('Incorrect value of args option');\\n  } else {\\n    args = [];\\n    options = util._extend({}, arguments[1]);\\n  }\\n\\n  // Prepare arguments for fork:\\n  execArgv = options.execArgv || process.execArgv;\\n\\n  if (execArgv === process.execArgv && process._eval != null) {\\n    var index = execArgv.lastIndexOf(process._eval);\\n    if (index > 0) {\\n      // Remove the -e switch to avoid fork bombing ourselves.\\n      execArgv = execArgv.slice();\\n      execArgv.splice(index - 1, 2);\\n    }\\n  }\\n\\n  args = execArgv.concat([modulePath], args);\\n\\n  // Leave stdin open for the IPC channel. stdout and stderr should be the\\n  // same as the parent's if silent isn't set.\\n  options.stdio = options.silent ? ['pipe', 'pipe', 'pipe', 'ipc'] :\\n      [0, 1, 2, 'ipc'];\\n\\n  options.execPath = options.execPath || process.execPath;\\n\\n  return spawn(options.execPath, args, options);\\n};\\n\\n\\nexports._forkChild = function(fd) {\\n  // set process.send()\\n  var p = new Pipe(true);\\n  p.open(fd);\\n  p.unref();\\n  var control = setupChannel(process, p);\\n  process.on('newListener', function(name) {\\n    if (name === 'message' || name === 'disconnect') control.ref();\\n  });\\n  process.on('removeListener', function(name) {\\n    if (name === 'message' || name === 'disconnect') control.unref();\\n  });\\n};\\n\\n\\nfunction normalizeExecArgs(command /*, options, callback*/) {\\n  var file, args, options, callback;\\n\\n  if (typeof arguments[1] === 'function') {\\n    options = undefined;\\n    callback = arguments[1];\\n  } else {\\n    options = arguments[1];\\n    callback = arguments[2];\\n  }\\n\\n  if (process.platform === 'win32') {\\n    file = process.env.comspec || 'cmd.exe';\\n    args = ['/s', '/c', '\\\"' + command + '\\\"'];\\n    // Make a shallow copy before patching so we don't clobber the user's\\n    // options object.\\n    options = util._extend({}, options);\\n    options.windowsVerbatimArguments = true;\\n  } else {\\n    file = '/bin/sh';\\n    args = ['-c', command];\\n  }\\n\\n  if (options && options.shell)\\n    file = options.shell;\\n\\n  return {\\n    cmd: command,\\n    file: file,\\n    args: args,\\n    options: options,\\n    callback: callback\\n  };\\n}\\n\\n\\nexports.exec = function(command /*, options, callback*/) {\\n  var opts = normalizeExecArgs.apply(null, arguments);\\n  return exports.execFile(opts.file,\\n                          opts.args,\\n                          opts.options,\\n                          opts.callback);\\n};\\n\\n\\nexports.execFile = function(file /*, args, options, callback*/) {\\n  var args = [], callback;\\n  var options = {\\n    encoding: 'utf8',\\n    timeout: 0,\\n    maxBuffer: 200 * 1024,\\n    killSignal: 'SIGTERM',\\n    cwd: null,\\n    env: null\\n  };\\n\\n  // Parse the optional positional parameters.\\n  var pos = 1;\\n  if (pos < arguments.length && Array.isArray(arguments[pos])) {\\n    args = arguments[pos++];\\n  } else if (pos < arguments.length && arguments[pos] == null) {\\n    pos++;\\n  }\\n\\n  if (pos < arguments.length && typeof arguments[pos] === 'object') {\\n    options = util._extend(options, arguments[pos++]);\\n  } else if (pos < arguments.length && arguments[pos] == null) {\\n    pos++;\\n  }\\n\\n  if (pos < arguments.length && typeof arguments[pos] === 'function') {\\n    callback = arguments[pos++];\\n  }\\n\\n  if (pos === 1 && arguments.length > 1) {\\n    throw new TypeError('Incorrect value of args option');\\n  }\\n\\n  var child = spawn(file, args, {\\n    cwd: options.cwd,\\n    env: options.env,\\n    gid: options.gid,\\n    uid: options.uid,\\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments\\n  });\\n\\n  var encoding;\\n  var _stdout;\\n  var _stderr;\\n  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {\\n    encoding = options.encoding;\\n    _stdout = '';\\n    _stderr = '';\\n  } else {\\n    _stdout = [];\\n    _stderr = [];\\n    encoding = null;\\n  }\\n  var stdoutLen = 0;\\n  var stderrLen = 0;\\n  var killed = false;\\n  var exited = false;\\n  var timeoutId;\\n\\n  var ex = null;\\n\\n  function exithandler(code, signal) {\\n    if (exited) return;\\n    exited = true;\\n\\n    if (timeoutId) {\\n      clearTimeout(timeoutId);\\n      timeoutId = null;\\n    }\\n\\n    if (!callback) return;\\n\\n    // merge chunks\\n    var stdout;\\n    var stderr;\\n    if (!encoding) {\\n      stdout = Buffer.concat(_stdout);\\n      stderr = Buffer.concat(_stderr);\\n    } else {\\n      stdout = _stdout;\\n      stderr = _stderr;\\n    }\\n\\n    if (ex) {\\n      // Will be handled later\\n    } else if (code === 0 && signal === null) {\\n      callback(null, stdout, stderr);\\n      return;\\n    }\\n\\n    var cmd = file;\\n    if (args.length !== 0)\\n      cmd += ' ' + args.join(' ');\\n\\n    if (!ex) {\\n      ex = new Error('Command failed: ' + cmd + '\\\\n' + stderr);\\n      ex.killed = child.killed || killed;\\n      ex.code = code < 0 ? uv.errname(code) : code;\\n      ex.signal = signal;\\n    }\\n\\n    ex.cmd = cmd;\\n    callback(ex, stdout, stderr);\\n  }\\n\\n  function errorhandler(e) {\\n    ex = e;\\n\\n    if (child.stdout)\\n      child.stdout.destroy();\\n\\n    if (child.stderr)\\n      child.stderr.destroy();\\n\\n    exithandler();\\n  }\\n\\n  function kill() {\\n    if (child.stdout)\\n      child.stdout.destroy();\\n\\n    if (child.stderr)\\n      child.stderr.destroy();\\n\\n    killed = true;\\n    try {\\n      child.kill(options.killSignal);\\n    } catch (e) {\\n      ex = e;\\n      exithandler();\\n    }\\n  }\\n\\n  if (options.timeout > 0) {\\n    timeoutId = setTimeout(function() {\\n      kill();\\n      timeoutId = null;\\n    }, options.timeout);\\n  }\\n\\n  if (child.stdout) {\\n    if (encoding)\\n      child.stdout.setEncoding(encoding);\\n\\n    child.stdout.addListener('data', function(chunk) {\\n      stdoutLen += chunk.length;\\n\\n      if (stdoutLen > options.maxBuffer) {\\n        ex = new Error('stdout maxBuffer exceeded');\\n        kill();\\n      } else {\\n        if (!encoding)\\n          _stdout.push(chunk);\\n        else\\n          _stdout += chunk;\\n      }\\n    });\\n  }\\n\\n  if (child.stderr) {\\n    if (encoding)\\n      child.stderr.setEncoding(encoding);\\n\\n    child.stderr.addListener('data', function(chunk) {\\n      stderrLen += chunk.length;\\n\\n      if (stderrLen > options.maxBuffer) {\\n        ex = new Error('stderr maxBuffer exceeded');\\n        kill();\\n      } else {\\n        if (!encoding)\\n          _stderr.push(chunk);\\n        else\\n          _stderr += chunk;\\n      }\\n    });\\n  }\\n\\n  child.addListener('close', exithandler);\\n  child.addListener('error', errorhandler);\\n\\n  return child;\\n};\\n\\nvar _deprecatedCustomFds = internalUtil.deprecate(function(options) {\\n  options.stdio = options.customFds.map(function(fd) {\\n    return fd === -1 ? 'pipe' : fd;\\n  });\\n}, 'child_process: options.customFds option is deprecated. ' +\\n   'Use options.stdio instead.');\\n\\nfunction _convertCustomFds(options) {\\n  if (options && options.customFds && !options.stdio) {\\n    _deprecatedCustomFds(options);\\n  }\\n}\\n\\nfunction normalizeSpawnArguments(file /*, args, options*/) {\\n  var args, options;\\n\\n  if (Array.isArray(arguments[1])) {\\n    args = arguments[1].slice(0);\\n    options = arguments[2];\\n  } else if (arguments[1] !== undefined &&\\n             (arguments[1] === null || typeof arguments[1] !== 'object')) {\\n    throw new TypeError('Incorrect value of args option');\\n  } else {\\n    args = [];\\n    options = arguments[1];\\n  }\\n\\n  if (options === undefined)\\n    options = {};\\n  else if (options === null || typeof options !== 'object')\\n    throw new TypeError('\\\"options\\\" argument must be an object');\\n\\n  options = util._extend({}, options);\\n  args.unshift(file);\\n\\n  var env = options.env || process.env;\\n  var envPairs = [];\\n\\n  for (var key in env) {\\n    envPairs.push(key + '=' + env[key]);\\n  }\\n\\n  _convertCustomFds(options);\\n\\n  return {\\n    file: file,\\n    args: args,\\n    options: options,\\n    envPairs: envPairs\\n  };\\n}\\n\\n\\nvar spawn = exports.spawn = function(/*file, args, options*/) {\\n  var opts = normalizeSpawnArguments.apply(null, arguments);\\n  var options = opts.options;\\n  var child = new ChildProcess();\\n\\n  debug('spawn', opts.args, options);\\n\\n  child.spawn({\\n    file: opts.file,\\n    args: opts.args,\\n    cwd: options.cwd,\\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments,\\n    detached: !!options.detached,\\n    envPairs: opts.envPairs,\\n    stdio: options.stdio,\\n    uid: options.uid,\\n    gid: options.gid\\n  });\\n\\n  return child;\\n};\\n\\n\\nfunction lookupSignal(signal) {\\n  if (typeof signal === 'number')\\n    return signal;\\n\\n  if (!(signal in constants))\\n    throw new Error('Unknown signal: ' + signal);\\n\\n  return constants[signal];\\n}\\n\\n\\n//node to como modification\\nfunction spawnSync(/*file, args, options*/) {\\n  var opts = normalizeSpawnArguments.apply(null, arguments);\\n\\n  var options = opts.options;\\n\\n  // var i;\\n\\n  // debug('spawnSync', opts.args, options);\\n\\n  // options.file = opts.file;\\n  // options.args = opts.args;\\n  // options.envPairs = opts.envPairs;\\n\\n  // if (options.killSignal)\\n  //   options.killSignal = lookupSignal(options.killSignal);\\n\\n  // options.stdio = _validateStdio(options.stdio || 'pipe', true).stdio;\\n\\n  // if (options.input) {\\n  //   var stdin = options.stdio[0] = util._extend({}, options.stdio[0]);\\n  //   stdin.input = options.input;\\n  // }\\n\\n  // // We may want to pass data in on any given fd, ensure it is a valid buffer\\n  // for (i = 0; i < options.stdio.length; i++) {\\n  //   var input = options.stdio[i] && options.stdio[i].input;\\n  //   if (input != null) {\\n  //     var pipe = options.stdio[i] = util._extend({}, options.stdio[i]);\\n  //     if (Buffer.isBuffer(input))\\n  //       pipe.input = input;\\n  //     else if (typeof input === 'string')\\n  //       pipe.input = new Buffer(input, options.encoding);\\n  //     else\\n  //       throw new TypeError(util.format(\\n  //           'stdio[%d] should be Buffer or string not %s',\\n  //           i,\\n  //           typeof input));\\n  //   }\\n  // }\\n\\n\\n  // var result = spawn_sync.spawn(options);\\n\\n  var result = spawn_sync.spawn.apply(null, arguments);\\n  if (result.output && options.encoding) {\\n    for (i = 0; i < result.output.length; i++) {\\n      if (!result.output[i])\\n        continue;\\n      result.output[i] = result.output[i].toString(options.encoding);\\n    }\\n  }\\n\\n  result.stdout = result.output && result.output[1];\\n  result.stderr = result.output && result.output[2];\\n\\n  // if (result.error) {\\n  //   result.error = errnoException(result.error, 'spawnSync ' + opts.file);\\n  //   result.error.path = opts.file;\\n  //   result.error.spawnargs = opts.args.slice(1);\\n  // }\\n\\n  util._extend(result, opts);\\n\\n  return result;\\n}\\nexports.spawnSync = spawnSync;\\n\\n\\nfunction checkExecSyncError(ret) {\\n  if (ret.error || ret.status !== 0) {\\n    var err = ret.error;\\n    ret.error = null;\\n\\n    if (!err) {\\n      var msg = 'Command failed: ' +\\n                (ret.cmd ? ret.cmd : ret.args.join(' ')) +\\n                (ret.stderr ? '\\\\n' + ret.stderr.toString() : '');\\n      err = new Error(msg);\\n    }\\n\\n    util._extend(err, ret);\\n    return err;\\n  }\\n\\n  return false;\\n}\\n\\n\\nfunction execFileSync(/*command, args, options*/) {\\n  var opts = normalizeSpawnArguments.apply(null, arguments);\\n  var inheritStderr = !opts.options.stdio;\\n\\n  var ret = spawnSync(opts.file, opts.args.slice(1), opts.options);\\n\\n  if (inheritStderr)\\n    process.stderr.write(ret.stderr);\\n\\n  var err = checkExecSyncError(ret);\\n\\n  if (err)\\n    throw err;\\n  else\\n    return ret.stdout;\\n}\\nexports.execFileSync = execFileSync;\\n\\n\\nfunction execSync(/*command, options*/) {\\n  var opts = normalizeExecArgs.apply(null, arguments);\\n  var inheritStderr = opts.options ? !opts.options.stdio : true;\\n\\n  var ret = spawnSync(opts.file, opts.args, opts.options);\\n  ret.cmd = opts.cmd;\\n\\n  if (inheritStderr)\\n    process.stderr.write(ret.stderr);\\n\\n  var err = checkExecSyncError(ret);\\n\\n  if (err)\\n    throw err;\\n  else\\n    return ret.stdout;\\n}\\nexports.execSync = execSync;\\n\",\"stream\":\"'use strict';\\n\\nmodule.exports = Stream;\\n\\nvar EE = require('events');\\nvar util = require('util');\\n\\nutil.inherits(Stream, EE);\\nStream.Readable = require('_stream_readable');\\nStream.Writable = require('_stream_writable');\\nStream.Duplex = require('_stream_duplex');\\nStream.Transform = require('_stream_transform');\\nStream.PassThrough = require('_stream_passthrough');\\n\\n// Backwards-compat with node 0.4.x\\nStream.Stream = Stream;\\n\\n\\n// old-style streams.  Note that the pipe method (the only relevant\\n// part of this class) is overridden in the Readable class.\\n\\nfunction Stream() {\\n  EE.call(this);\\n}\\n\\nStream.prototype.pipe = function(dest, options) {\\n  var source = this;\\n\\n  function ondata(chunk) {\\n    if (dest.writable) {\\n      if (false === dest.write(chunk) && source.pause) {\\n        source.pause();\\n      }\\n    }\\n  }\\n\\n  source.on('data', ondata);\\n\\n  function ondrain() {\\n    if (source.readable && source.resume) {\\n      source.resume();\\n    }\\n  }\\n\\n  dest.on('drain', ondrain);\\n\\n  // If the 'end' option is not supplied, dest.end() will be called when\\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\\n  if (!dest._isStdio && (!options || options.end !== false)) {\\n    source.on('end', onend);\\n    source.on('close', onclose);\\n  }\\n\\n  var didOnEnd = false;\\n  function onend() {\\n    if (didOnEnd) return;\\n    didOnEnd = true;\\n\\n    dest.end();\\n  }\\n\\n\\n  function onclose() {\\n    if (didOnEnd) return;\\n    didOnEnd = true;\\n\\n    if (typeof dest.destroy === 'function') dest.destroy();\\n  }\\n\\n  // don't leave dangling pipes when there are errors.\\n  function onerror(er) {\\n    cleanup();\\n    if (EE.listenerCount(this, 'error') === 0) {\\n      throw er; // Unhandled stream error in pipe.\\n    }\\n  }\\n\\n  source.on('error', onerror);\\n  dest.on('error', onerror);\\n\\n  // remove all the event listeners that were added.\\n  function cleanup() {\\n    source.removeListener('data', ondata);\\n    dest.removeListener('drain', ondrain);\\n\\n    source.removeListener('end', onend);\\n    source.removeListener('close', onclose);\\n\\n    source.removeListener('error', onerror);\\n    dest.removeListener('error', onerror);\\n\\n    source.removeListener('end', cleanup);\\n    source.removeListener('close', cleanup);\\n\\n    dest.removeListener('close', cleanup);\\n  }\\n\\n  source.on('end', cleanup);\\n  source.on('close', cleanup);\\n\\n  dest.on('close', cleanup);\\n\\n  dest.emit('pipe', source);\\n\\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\\n  return dest;\\n};\\n\",\"_stream_readable\":\"'use strict';\\n\\nmodule.exports = Readable;\\nReadable.ReadableState = ReadableState;\\n\\nvar EE = require('events');\\nvar Stream = require('stream');\\nvar Buffer = require('buffer').Buffer;\\nvar util = require('util');\\nvar debug = util.debuglog('stream');\\nvar StringDecoder;\\n\\nutil.inherits(Readable, Stream);\\n\\nfunction ReadableState(options, stream) {\\n  options = options || {};\\n\\n  // object stream flag. Used to make read(n) ignore n and to\\n  // make all the buffer merging and length checks go away\\n  this.objectMode = !!options.objectMode;\\n\\n  if (stream instanceof Stream.Duplex)\\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\\n\\n  // the point at which it stops calling _read() to fill the buffer\\n  // Note: 0 is a valid value, means \\\"don't call _read preemptively ever\\\"\\n  var hwm = options.highWaterMark;\\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\\n\\n  // cast to ints.\\n  this.highWaterMark = ~~this.highWaterMark;\\n\\n  this.buffer = [];\\n  this.length = 0;\\n  this.pipes = null;\\n  this.pipesCount = 0;\\n  this.flowing = null;\\n  this.ended = false;\\n  this.endEmitted = false;\\n  this.reading = false;\\n\\n  // a flag to be able to tell if the onwrite cb is called immediately,\\n  // or on a later tick.  We set this to true at first, because any\\n  // actions that shouldn't happen until \\\"later\\\" should generally also\\n  // not happen before the first write call.\\n  this.sync = true;\\n\\n  // whenever we return null, then we set a flag to say\\n  // that we're awaiting a 'readable' event emission.\\n  this.needReadable = false;\\n  this.emittedReadable = false;\\n  this.readableListening = false;\\n\\n  // Crypto is kind of old and crusty.  Historically, its default string\\n  // encoding is 'binary' so we have to make this configurable.\\n  // Everything else in the universe uses 'utf8', though.\\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\\n\\n  // when piping, we only care about 'readable' events that happen\\n  // after read()ing all the bytes and not getting any pushback.\\n  this.ranOut = false;\\n\\n  // the number of writers that are awaiting a drain event in .pipe()s\\n  this.awaitDrain = 0;\\n\\n  // if true, a maybeReadMore has been scheduled\\n  this.readingMore = false;\\n\\n  this.decoder = null;\\n  this.encoding = null;\\n  if (options.encoding) {\\n    if (!StringDecoder)\\n      StringDecoder = require('string_decoder').StringDecoder;\\n    this.decoder = new StringDecoder(options.encoding);\\n    this.encoding = options.encoding;\\n  }\\n}\\n\\nfunction Readable(options) {\\n  if (!(this instanceof Readable))\\n    return new Readable(options);\\n\\n  this._readableState = new ReadableState(options, this);\\n\\n  // legacy\\n  this.readable = true;\\n\\n  if (options && typeof options.read === 'function')\\n    this._read = options.read;\\n\\n  Stream.call(this);\\n}\\n\\n// Manually shove something into the read() buffer.\\n// This returns true if the highWaterMark has not been hit yet,\\n// similar to how Writable.write() returns true if you should\\n// write() some more.\\nReadable.prototype.push = function(chunk, encoding) {\\n  var state = this._readableState;\\n\\n  if (!state.objectMode && typeof chunk === 'string') {\\n    encoding = encoding || state.defaultEncoding;\\n    if (encoding !== state.encoding) {\\n      chunk = Buffer(chunk, encoding);\\n      encoding = '';\\n    }\\n  }\\n\\n  return readableAddChunk(this, state, chunk, encoding, false);\\n};\\n\\n// Unshift should *always* be something directly out of read()\\nReadable.prototype.unshift = function(chunk) {\\n  var state = this._readableState;\\n  return readableAddChunk(this, state, chunk, '', true);\\n};\\n\\nReadable.prototype.isPaused = function() {\\n  return this._readableState.flowing === false;\\n};\\n\\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\\n  var er = chunkInvalid(state, chunk);\\n  if (er) {\\n    stream.emit('error', er);\\n  } else if (chunk === null) {\\n    state.reading = false;\\n    onEofChunk(stream, state);\\n  } else if (state.objectMode || chunk && chunk.length > 0) {\\n    if (state.ended && !addToFront) {\\n      var e = new Error('stream.push() after EOF');\\n      stream.emit('error', e);\\n    } else if (state.endEmitted && addToFront) {\\n      var e = new Error('stream.unshift() after end event');\\n      stream.emit('error', e);\\n    } else {\\n      if (state.decoder && !addToFront && !encoding)\\n        chunk = state.decoder.write(chunk);\\n\\n      if (!addToFront)\\n        state.reading = false;\\n\\n      // if we want the data now, just emit it.\\n      if (state.flowing && state.length === 0 && !state.sync) {\\n        stream.emit('data', chunk);\\n        stream.read(0);\\n      } else {\\n        // update the buffer info.\\n        state.length += state.objectMode ? 1 : chunk.length;\\n        if (addToFront)\\n          state.buffer.unshift(chunk);\\n        else\\n          state.buffer.push(chunk);\\n\\n        if (state.needReadable)\\n          emitReadable(stream);\\n      }\\n\\n      maybeReadMore(stream, state);\\n    }\\n  } else if (!addToFront) {\\n    state.reading = false;\\n  }\\n\\n  return needMoreData(state);\\n}\\n\\n\\n// if it's past the high water mark, we can push in some more.\\n// Also, if we have no data yet, we can stand some\\n// more bytes.  This is to work around cases where hwm=0,\\n// such as the repl.  Also, if the push() triggered a\\n// readable event, and the user called read(largeNumber) such that\\n// needReadable was set, then we ought to push more, so that another\\n// 'readable' event will be triggered.\\nfunction needMoreData(state) {\\n  return !state.ended &&\\n         (state.needReadable ||\\n          state.length < state.highWaterMark ||\\n          state.length === 0);\\n}\\n\\n// backwards compatibility.\\nReadable.prototype.setEncoding = function(enc) {\\n  if (!StringDecoder)\\n    StringDecoder = require('string_decoder').StringDecoder;\\n  this._readableState.decoder = new StringDecoder(enc);\\n  this._readableState.encoding = enc;\\n  return this;\\n};\\n\\n// Don't raise the hwm > 8MB\\nvar MAX_HWM = 0x800000;\\nfunction computeNewHighWaterMark(n) {\\n  if (n >= MAX_HWM) {\\n    n = MAX_HWM;\\n  } else {\\n    // Get the next highest power of 2\\n    n--;\\n    n |= n >>> 1;\\n    n |= n >>> 2;\\n    n |= n >>> 4;\\n    n |= n >>> 8;\\n    n |= n >>> 16;\\n    n++;\\n  }\\n  return n;\\n}\\n\\nfunction howMuchToRead(n, state) {\\n  if (state.length === 0 && state.ended)\\n    return 0;\\n\\n  if (state.objectMode)\\n    return n === 0 ? 0 : 1;\\n\\n  if (n === null || isNaN(n)) {\\n    // only flow one buffer at a time\\n    if (state.flowing && state.buffer.length)\\n      return state.buffer[0].length;\\n    else\\n      return state.length;\\n  }\\n\\n  if (n <= 0)\\n    return 0;\\n\\n  // If we're asking for more than the target buffer level,\\n  // then raise the water mark.  Bump up to the next highest\\n  // power of 2, to prevent increasing it excessively in tiny\\n  // amounts.\\n  if (n > state.highWaterMark)\\n    state.highWaterMark = computeNewHighWaterMark(n);\\n\\n  // don't have that much.  return null, unless we've ended.\\n  if (n > state.length) {\\n    if (!state.ended) {\\n      state.needReadable = true;\\n      return 0;\\n    } else {\\n      return state.length;\\n    }\\n  }\\n\\n  return n;\\n}\\n\\n// you can override either this method, or the async _read(n) below.\\nReadable.prototype.read = function(n) {\\n  debug('read', n);\\n  var state = this._readableState;\\n  var nOrig = n;\\n\\n  if (typeof n !== 'number' || n > 0)\\n    state.emittedReadable = false;\\n\\n  // if we're doing read(0) to trigger a readable event, but we\\n  // already have a bunch of data in the buffer, then just trigger\\n  // the 'readable' event and move on.\\n  if (n === 0 &&\\n      state.needReadable &&\\n      (state.length >= state.highWaterMark || state.ended)) {\\n    debug('read: emitReadable', state.length, state.ended);\\n    if (state.length === 0 && state.ended)\\n      endReadable(this);\\n    else\\n      emitReadable(this);\\n    return null;\\n  }\\n\\n  n = howMuchToRead(n, state);\\n\\n  // if we've ended, and we're now clear, then finish it up.\\n  if (n === 0 && state.ended) {\\n    if (state.length === 0)\\n      endReadable(this);\\n    return null;\\n  }\\n\\n  // All the actual chunk generation logic needs to be\\n  // *below* the call to _read.  The reason is that in certain\\n  // synthetic stream cases, such as passthrough streams, _read\\n  // may be a completely synchronous operation which may change\\n  // the state of the read buffer, providing enough data when\\n  // before there was *not* enough.\\n  //\\n  // So, the steps are:\\n  // 1. Figure out what the state of things will be after we do\\n  // a read from the buffer.\\n  //\\n  // 2. If that resulting state will trigger a _read, then call _read.\\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\\n  // deeply ugly to write APIs this way, but that still doesn't mean\\n  // that the Readable class should behave improperly, as streams are\\n  // designed to be sync/async agnostic.\\n  // Take note if the _read call is sync or async (ie, if the read call\\n  // has returned yet), so that we know whether or not it's safe to emit\\n  // 'readable' etc.\\n  //\\n  // 3. Actually pull the requested chunks out of the buffer and return.\\n\\n  // if we need a readable event, then we need to do some reading.\\n  var doRead = state.needReadable;\\n  debug('need readable', doRead);\\n\\n  // if we currently have less than the highWaterMark, then also read some\\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\\n    doRead = true;\\n    debug('length less than watermark', doRead);\\n  }\\n\\n  // however, if we've ended, then there's no point, and if we're already\\n  // reading, then it's unnecessary.\\n  if (state.ended || state.reading) {\\n    doRead = false;\\n    debug('reading or ended', doRead);\\n  }\\n\\n  if (doRead) {\\n    debug('do read');\\n    state.reading = true;\\n    state.sync = true;\\n    // if the length is currently zero, then we *need* a readable event.\\n    if (state.length === 0)\\n      state.needReadable = true;\\n    // call internal read method\\n    this._read(state.highWaterMark);\\n    state.sync = false;\\n  }\\n\\n  // If _read pushed data synchronously, then `reading` will be false,\\n  // and we need to re-evaluate how much data we can return to the user.\\n  if (doRead && !state.reading)\\n    n = howMuchToRead(nOrig, state);\\n\\n  var ret;\\n  if (n > 0)\\n    ret = fromList(n, state);\\n  else\\n    ret = null;\\n\\n  if (ret === null) {\\n    state.needReadable = true;\\n    n = 0;\\n  }\\n\\n  state.length -= n;\\n\\n  // If we have nothing in the buffer, then we want to know\\n  // as soon as we *do* get something into the buffer.\\n  if (state.length === 0 && !state.ended)\\n    state.needReadable = true;\\n\\n  // If we tried to read() past the EOF, then emit end on the next tick.\\n  if (nOrig !== n && state.ended && state.length === 0)\\n    endReadable(this);\\n\\n  if (ret !== null)\\n    this.emit('data', ret);\\n\\n  return ret;\\n};\\n\\nfunction chunkInvalid(state, chunk) {\\n  var er = null;\\n  if (!(Buffer.isBuffer(chunk)) &&\\n      typeof chunk !== 'string' &&\\n      chunk !== null &&\\n      chunk !== undefined &&\\n      !state.objectMode) {\\n    er = new TypeError('Invalid non-string/buffer chunk');\\n  }\\n  return er;\\n}\\n\\n\\nfunction onEofChunk(stream, state) {\\n  if (state.ended) return;\\n  if (state.decoder) {\\n    var chunk = state.decoder.end();\\n    if (chunk && chunk.length) {\\n      state.buffer.push(chunk);\\n      state.length += state.objectMode ? 1 : chunk.length;\\n    }\\n  }\\n  state.ended = true;\\n\\n  // emit 'readable' now to make sure it gets picked up.\\n  emitReadable(stream);\\n}\\n\\n// Don't emit readable right away in sync mode, because this can trigger\\n// another read() call => stack overflow.  This way, it might trigger\\n// a nextTick recursion warning, but that's not so bad.\\nfunction emitReadable(stream) {\\n  var state = stream._readableState;\\n  state.needReadable = false;\\n  if (!state.emittedReadable) {\\n    debug('emitReadable', state.flowing);\\n    state.emittedReadable = true;\\n    if (state.sync)\\n      process.nextTick(emitReadable_, stream);\\n    else\\n      emitReadable_(stream);\\n  }\\n}\\n\\nfunction emitReadable_(stream) {\\n  debug('emit readable');\\n  stream.emit('readable');\\n  flow(stream);\\n}\\n\\n\\n// at this point, the user has presumably seen the 'readable' event,\\n// and called read() to consume some data.  that may have triggered\\n// in turn another _read(n) call, in which case reading = true if\\n// it's in progress.\\n// However, if we're not ended, or reading, and the length < hwm,\\n// then go ahead and try to read some more preemptively.\\nfunction maybeReadMore(stream, state) {\\n  if (!state.readingMore) {\\n    state.readingMore = true;\\n    process.nextTick(maybeReadMore_, stream, state);\\n  }\\n}\\n\\nfunction maybeReadMore_(stream, state) {\\n  var len = state.length;\\n  while (!state.reading && !state.flowing && !state.ended &&\\n         state.length < state.highWaterMark) {\\n    debug('maybeReadMore read 0');\\n    stream.read(0);\\n    if (len === state.length)\\n      // didn't get any data, stop spinning.\\n      break;\\n    else\\n      len = state.length;\\n  }\\n  state.readingMore = false;\\n}\\n\\n// abstract method.  to be overridden in specific implementation classes.\\n// call cb(er, data) where data is <= n in length.\\n// for virtual (non-string, non-buffer) streams, \\\"length\\\" is somewhat\\n// arbitrary, and perhaps not very meaningful.\\nReadable.prototype._read = function(n) {\\n  this.emit('error', new Error('not implemented'));\\n};\\n\\nReadable.prototype.pipe = function(dest, pipeOpts) {\\n  var src = this;\\n  var state = this._readableState;\\n\\n  switch (state.pipesCount) {\\n    case 0:\\n      state.pipes = dest;\\n      break;\\n    case 1:\\n      state.pipes = [state.pipes, dest];\\n      break;\\n    default:\\n      state.pipes.push(dest);\\n      break;\\n  }\\n  state.pipesCount += 1;\\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\\n\\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\\n              dest !== process.stdout &&\\n              dest !== process.stderr;\\n\\n  var endFn = doEnd ? onend : cleanup;\\n  if (state.endEmitted)\\n    process.nextTick(endFn);\\n  else\\n    src.once('end', endFn);\\n\\n  dest.on('unpipe', onunpipe);\\n  function onunpipe(readable) {\\n    debug('onunpipe');\\n    if (readable === src) {\\n      cleanup();\\n    }\\n  }\\n\\n  function onend() {\\n    debug('onend');\\n    dest.end();\\n  }\\n\\n  // when the dest drains, it reduces the awaitDrain counter\\n  // on the source.  This would be more elegant with a .once()\\n  // handler in flow(), but adding and removing repeatedly is\\n  // too slow.\\n  var ondrain = pipeOnDrain(src);\\n  dest.on('drain', ondrain);\\n\\n  var cleanedUp = false;\\n  function cleanup() {\\n    debug('cleanup');\\n    // cleanup event handlers once the pipe is broken\\n    dest.removeListener('close', onclose);\\n    dest.removeListener('finish', onfinish);\\n    dest.removeListener('drain', ondrain);\\n    dest.removeListener('error', onerror);\\n    dest.removeListener('unpipe', onunpipe);\\n    src.removeListener('end', onend);\\n    src.removeListener('end', cleanup);\\n    src.removeListener('data', ondata);\\n\\n    cleanedUp = true;\\n\\n    // if the reader is waiting for a drain event from this\\n    // specific writer, then it would cause it to never start\\n    // flowing again.\\n    // So, if this is awaiting a drain, then we just call it now.\\n    // If we don't know, then assume that we are waiting for one.\\n    if (state.awaitDrain &&\\n        (!dest._writableState || dest._writableState.needDrain))\\n      ondrain();\\n  }\\n\\n  src.on('data', ondata);\\n  function ondata(chunk) {\\n    debug('ondata');\\n    var ret = dest.write(chunk);\\n    if (false === ret) {\\n      // If the user unpiped during `dest.write()`, it is possible\\n      // to get stuck in a permanently paused state if that write\\n      // also returned false.\\n      if (state.pipesCount === 1 &&\\n          state.pipes[0] === dest &&\\n          src.listenerCount('data') === 1 &&\\n          !cleanedUp) {\\n        debug('false write response, pause', src._readableState.awaitDrain);\\n        src._readableState.awaitDrain++;\\n      }\\n      src.pause();\\n    }\\n  }\\n\\n  // if the dest has an error, then stop piping into it.\\n  // however, don't suppress the throwing behavior for this.\\n  function onerror(er) {\\n    debug('onerror', er);\\n    unpipe();\\n    dest.removeListener('error', onerror);\\n    if (EE.listenerCount(dest, 'error') === 0)\\n      dest.emit('error', er);\\n  }\\n  // This is a brutally ugly hack to make sure that our error handler\\n  // is attached before any userland ones.  NEVER DO THIS.\\n  if (!dest._events || !dest._events.error)\\n    dest.on('error', onerror);\\n  else if (Array.isArray(dest._events.error))\\n    dest._events.error.unshift(onerror);\\n  else\\n    dest._events.error = [onerror, dest._events.error];\\n\\n\\n  // Both close and finish should trigger unpipe, but only once.\\n  function onclose() {\\n    dest.removeListener('finish', onfinish);\\n    unpipe();\\n  }\\n  dest.once('close', onclose);\\n  function onfinish() {\\n    debug('onfinish');\\n    dest.removeListener('close', onclose);\\n    unpipe();\\n  }\\n  dest.once('finish', onfinish);\\n\\n  function unpipe() {\\n    debug('unpipe');\\n    src.unpipe(dest);\\n  }\\n\\n  // tell the dest that it's being piped to\\n  dest.emit('pipe', src);\\n\\n  // start the flow if it hasn't been started already.\\n  if (!state.flowing) {\\n    debug('pipe resume');\\n    src.resume();\\n  }\\n\\n  return dest;\\n};\\n\\nfunction pipeOnDrain(src) {\\n  return function() {\\n    var state = src._readableState;\\n    debug('pipeOnDrain', state.awaitDrain);\\n    if (state.awaitDrain)\\n      state.awaitDrain--;\\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\\n      state.flowing = true;\\n      flow(src);\\n    }\\n  };\\n}\\n\\n\\nReadable.prototype.unpipe = function(dest) {\\n  var state = this._readableState;\\n\\n  // if we're not piping anywhere, then do nothing.\\n  if (state.pipesCount === 0)\\n    return this;\\n\\n  // just one destination.  most common case.\\n  if (state.pipesCount === 1) {\\n    // passed in one, but it's not the right one.\\n    if (dest && dest !== state.pipes)\\n      return this;\\n\\n    if (!dest)\\n      dest = state.pipes;\\n\\n    // got a match.\\n    state.pipes = null;\\n    state.pipesCount = 0;\\n    state.flowing = false;\\n    if (dest)\\n      dest.emit('unpipe', this);\\n    return this;\\n  }\\n\\n  // slow case. multiple pipe destinations.\\n\\n  if (!dest) {\\n    // remove all.\\n    var dests = state.pipes;\\n    var len = state.pipesCount;\\n    state.pipes = null;\\n    state.pipesCount = 0;\\n    state.flowing = false;\\n\\n    for (var i = 0; i < len; i++)\\n      dests[i].emit('unpipe', this);\\n    return this;\\n  }\\n\\n  // try to find the right one.\\n  var i = state.pipes.indexOf(dest);\\n  if (i === -1)\\n    return this;\\n\\n  state.pipes.splice(i, 1);\\n  state.pipesCount -= 1;\\n  if (state.pipesCount === 1)\\n    state.pipes = state.pipes[0];\\n\\n  dest.emit('unpipe', this);\\n\\n  return this;\\n};\\n\\n// set up data events if they are asked for\\n// Ensure readable listeners eventually get something\\nReadable.prototype.on = function(ev, fn) {\\n  var res = Stream.prototype.on.call(this, ev, fn);\\n\\n  // If listening to data, and it has not explicitly been paused,\\n  // then call resume to start the flow of data on the next tick.\\n  if (ev === 'data' && false !== this._readableState.flowing) {\\n    this.resume();\\n  }\\n\\n  if (ev === 'readable' && this.readable) {\\n    var state = this._readableState;\\n    if (!state.readableListening) {\\n      state.readableListening = true;\\n      state.emittedReadable = false;\\n      state.needReadable = true;\\n      if (!state.reading) {\\n        process.nextTick(nReadingNextTick, this);\\n      } else if (state.length) {\\n        emitReadable(this, state);\\n      }\\n    }\\n  }\\n\\n  return res;\\n};\\nReadable.prototype.addListener = Readable.prototype.on;\\n\\nfunction nReadingNextTick(self) {\\n  debug('readable nexttick read 0');\\n  self.read(0);\\n}\\n\\n// pause() and resume() are remnants of the legacy readable stream API\\n// If the user uses them, then switch into old mode.\\nReadable.prototype.resume = function() {\\n  var state = this._readableState;\\n  if (!state.flowing) {\\n    debug('resume');\\n    state.flowing = true;\\n    resume(this, state);\\n  }\\n  return this;\\n};\\n\\nfunction resume(stream, state) {\\n  if (!state.resumeScheduled) {\\n    state.resumeScheduled = true;\\n    process.nextTick(resume_, stream, state);\\n  }\\n}\\n\\nfunction resume_(stream, state) {\\n  if (!state.reading) {\\n    debug('resume read 0');\\n    stream.read(0);\\n  }\\n\\n  state.resumeScheduled = false;\\n  stream.emit('resume');\\n  flow(stream);\\n  if (state.flowing && !state.reading)\\n    stream.read(0);\\n}\\n\\nReadable.prototype.pause = function() {\\n  debug('call pause flowing=%j', this._readableState.flowing);\\n  if (false !== this._readableState.flowing) {\\n    debug('pause');\\n    this._readableState.flowing = false;\\n    this.emit('pause');\\n  }\\n  return this;\\n};\\n\\nfunction flow(stream) {\\n  var state = stream._readableState;\\n  debug('flow', state.flowing);\\n  if (state.flowing) {\\n    do {\\n      var chunk = stream.read();\\n    } while (null !== chunk && state.flowing);\\n  }\\n}\\n\\n// wrap an old-style stream as the async data source.\\n// This is *not* part of the readable stream interface.\\n// It is an ugly unfortunate mess of history.\\nReadable.prototype.wrap = function(stream) {\\n  var state = this._readableState;\\n  var paused = false;\\n\\n  var self = this;\\n  stream.on('end', function() {\\n    debug('wrapped end');\\n    if (state.decoder && !state.ended) {\\n      var chunk = state.decoder.end();\\n      if (chunk && chunk.length)\\n        self.push(chunk);\\n    }\\n\\n    self.push(null);\\n  });\\n\\n  stream.on('data', function(chunk) {\\n    debug('wrapped data');\\n    if (state.decoder)\\n      chunk = state.decoder.write(chunk);\\n\\n    // don't skip over falsy values in objectMode\\n    if (state.objectMode && (chunk === null || chunk === undefined))\\n      return;\\n    else if (!state.objectMode && (!chunk || !chunk.length))\\n      return;\\n\\n    var ret = self.push(chunk);\\n    if (!ret) {\\n      paused = true;\\n      stream.pause();\\n    }\\n  });\\n\\n  // proxy all the other methods.\\n  // important when wrapping filters and duplexes.\\n  for (var i in stream) {\\n    if (this[i] === undefined && typeof stream[i] === 'function') {\\n      this[i] = function(method) { return function() {\\n        return stream[method].apply(stream, arguments);\\n      }; }(i);\\n    }\\n  }\\n\\n  // proxy certain important events.\\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\\n  events.forEach(function(ev) {\\n    stream.on(ev, self.emit.bind(self, ev));\\n  });\\n\\n  // when we try to consume some more bytes, simply unpause the\\n  // underlying stream.\\n  self._read = function(n) {\\n    debug('wrapped _read', n);\\n    if (paused) {\\n      paused = false;\\n      stream.resume();\\n    }\\n  };\\n\\n  return self;\\n};\\n\\n\\n// exposed for testing purposes only.\\nReadable._fromList = fromList;\\n\\n// Pluck off n bytes from an array of buffers.\\n// Length is the combined lengths of all the buffers in the list.\\nfunction fromList(n, state) {\\n  var list = state.buffer;\\n  var length = state.length;\\n  var stringMode = !!state.decoder;\\n  var objectMode = !!state.objectMode;\\n  var ret;\\n\\n  // nothing in the list, definitely empty.\\n  if (list.length === 0)\\n    return null;\\n\\n  if (length === 0)\\n    ret = null;\\n  else if (objectMode)\\n    ret = list.shift();\\n  else if (!n || n >= length) {\\n    // read it all, truncate the array.\\n    if (stringMode)\\n      ret = list.join('');\\n    else if (list.length === 1)\\n      ret = list[0];\\n    else\\n      ret = Buffer.concat(list, length);\\n    list.length = 0;\\n  } else {\\n    // read just some of it.\\n    if (n < list[0].length) {\\n      // just take a part of the first list item.\\n      // slice is the same for buffers and strings.\\n      var buf = list[0];\\n      ret = buf.slice(0, n);\\n      list[0] = buf.slice(n);\\n    } else if (n === list[0].length) {\\n      // first list is a perfect match\\n      ret = list.shift();\\n    } else {\\n      // complex case.\\n      // we have enough to cover it, but it spans past the first buffer.\\n      if (stringMode)\\n        ret = '';\\n      else\\n        ret = new Buffer(n);\\n\\n      var c = 0;\\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\\n        var buf = list[0];\\n        var cpy = Math.min(n - c, buf.length);\\n\\n        if (stringMode)\\n          ret += buf.slice(0, cpy);\\n        else\\n          buf.copy(ret, c, 0, cpy);\\n\\n        if (cpy < buf.length)\\n          list[0] = buf.slice(cpy);\\n        else\\n          list.shift();\\n\\n        c += cpy;\\n      }\\n    }\\n  }\\n\\n  return ret;\\n}\\n\\nfunction endReadable(stream) {\\n  var state = stream._readableState;\\n\\n  // If we get here before consuming all the bytes, then that is a\\n  // bug in node.  Should never happen.\\n  if (state.length > 0)\\n    throw new Error('\\\"endReadable()\\\" called on non-empty stream');\\n\\n  if (!state.endEmitted) {\\n    state.ended = true;\\n    process.nextTick(endReadableNT, state, stream);\\n  }\\n}\\n\\nfunction endReadableNT(state, stream) {\\n  // Check that we didn't get one last unshift.\\n  if (!state.endEmitted && state.length === 0) {\\n    state.endEmitted = true;\\n    stream.readable = false;\\n    stream.emit('end');\\n  }\\n}\\n\",\"_stream_writable\":\"// A bit simpler than readable streams.\\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\\n// the drain event emission and buffering.\\n\\n'use strict';\\n\\nmodule.exports = Writable;\\nWritable.WritableState = WritableState;\\n\\nvar util = require('util');\\nvar internalUtil = require('internal/util');\\nvar Stream = require('stream');\\nvar Buffer = require('buffer').Buffer;\\n\\nutil.inherits(Writable, Stream);\\n\\nfunction nop() {}\\n\\nfunction WriteReq(chunk, encoding, cb) {\\n  this.chunk = chunk;\\n  this.encoding = encoding;\\n  this.callback = cb;\\n  this.next = null;\\n}\\n\\nfunction WritableState(options, stream) {\\n  options = options || {};\\n\\n  // object stream flag to indicate whether or not this stream\\n  // contains buffers or objects.\\n  this.objectMode = !!options.objectMode;\\n\\n  if (stream instanceof Stream.Duplex)\\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\\n\\n  // the point at which write() starts returning false\\n  // Note: 0 is a valid value, means that we always return false if\\n  // the entire buffer is not flushed immediately on write()\\n  var hwm = options.highWaterMark;\\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\\n\\n  // cast to ints.\\n  this.highWaterMark = ~~this.highWaterMark;\\n\\n  this.needDrain = false;\\n  // at the start of calling end()\\n  this.ending = false;\\n  // when end() has been called, and returned\\n  this.ended = false;\\n  // when 'finish' is emitted\\n  this.finished = false;\\n\\n  // should we decode strings into buffers before passing to _write?\\n  // this is here so that some node-core streams can optimize string\\n  // handling at a lower level.\\n  var noDecode = options.decodeStrings === false;\\n  this.decodeStrings = !noDecode;\\n\\n  // Crypto is kind of old and crusty.  Historically, its default string\\n  // encoding is 'binary' so we have to make this configurable.\\n  // Everything else in the universe uses 'utf8', though.\\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\\n\\n  // not an actual buffer we keep track of, but a measurement\\n  // of how much we're waiting to get pushed to some underlying\\n  // socket or file.\\n  this.length = 0;\\n\\n  // a flag to see when we're in the middle of a write.\\n  this.writing = false;\\n\\n  // when true all writes will be buffered until .uncork() call\\n  this.corked = 0;\\n\\n  // a flag to be able to tell if the onwrite cb is called immediately,\\n  // or on a later tick.  We set this to true at first, because any\\n  // actions that shouldn't happen until \\\"later\\\" should generally also\\n  // not happen before the first write call.\\n  this.sync = true;\\n\\n  // a flag to know if we're processing previously buffered items, which\\n  // may call the _write() callback in the same tick, so that we don't\\n  // end up in an overlapped onwrite situation.\\n  this.bufferProcessing = false;\\n\\n  // the callback that's passed to _write(chunk,cb)\\n  this.onwrite = function(er) {\\n    onwrite(stream, er);\\n  };\\n\\n  // the callback that the user supplies to write(chunk,encoding,cb)\\n  this.writecb = null;\\n\\n  // the amount that is being written when _write is called.\\n  this.writelen = 0;\\n\\n  this.bufferedRequest = null;\\n  this.lastBufferedRequest = null;\\n\\n  // number of pending user-supplied write callbacks\\n  // this must be 0 before 'finish' can be emitted\\n  this.pendingcb = 0;\\n\\n  // emit prefinish if the only thing we're waiting for is _write cbs\\n  // This is relevant for synchronous Transform streams\\n  this.prefinished = false;\\n\\n  // True if the error was already emitted and should not be thrown again\\n  this.errorEmitted = false;\\n}\\n\\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\\n  var current = this.bufferedRequest;\\n  var out = [];\\n  while (current) {\\n    out.push(current);\\n    current = current.next;\\n  }\\n  return out;\\n};\\n\\nObject.defineProperty(WritableState.prototype, 'buffer', {\\n  get: internalUtil.deprecate(function() {\\n    return this.getBuffer();\\n  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +\\n     'instead.')\\n});\\n\\nfunction Writable(options) {\\n  // Writable ctor is applied to Duplexes, though they're not\\n  // instanceof Writable, they're instanceof Readable.\\n  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))\\n    return new Writable(options);\\n\\n  this._writableState = new WritableState(options, this);\\n\\n  // legacy.\\n  this.writable = true;\\n\\n  if (options) {\\n    if (typeof options.write === 'function')\\n      this._write = options.write;\\n\\n    if (typeof options.writev === 'function')\\n      this._writev = options.writev;\\n  }\\n\\n  Stream.call(this);\\n}\\n\\n// Otherwise people can pipe Writable streams, which is just wrong.\\nWritable.prototype.pipe = function() {\\n  this.emit('error', new Error('Cannot pipe, not readable'));\\n};\\n\\n\\nfunction writeAfterEnd(stream, cb) {\\n  var er = new Error('write after end');\\n  // TODO: defer error events consistently everywhere, not just the cb\\n  stream.emit('error', er);\\n  process.nextTick(cb, er);\\n}\\n\\n// If we get something that is not a buffer, string, null, or undefined,\\n// and we're not in objectMode, then that's an error.\\n// Otherwise stream chunks are all considered to be of length=1, and the\\n// watermarks determine how many objects to keep in the buffer, rather than\\n// how many bytes or characters.\\nfunction validChunk(stream, state, chunk, cb) {\\n  var valid = true;\\n\\n  if (!(Buffer.isBuffer(chunk)) &&\\n      typeof chunk !== 'string' &&\\n      chunk !== null &&\\n      chunk !== undefined &&\\n      !state.objectMode) {\\n    var er = new TypeError('Invalid non-string/buffer chunk');\\n    stream.emit('error', er);\\n    process.nextTick(cb, er);\\n    valid = false;\\n  }\\n  return valid;\\n}\\n\\nWritable.prototype.write = function(chunk, encoding, cb) {\\n  var state = this._writableState;\\n  var ret = false;\\n\\n  if (typeof encoding === 'function') {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n\\n  if (chunk instanceof Buffer)\\n    encoding = 'buffer';\\n  else if (!encoding)\\n    encoding = state.defaultEncoding;\\n\\n  if (typeof cb !== 'function')\\n    cb = nop;\\n\\n  if (state.ended)\\n    writeAfterEnd(this, cb);\\n  else if (validChunk(this, state, chunk, cb)) {\\n    state.pendingcb++;\\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\\n  }\\n\\n  return ret;\\n};\\n\\nWritable.prototype.cork = function() {\\n  var state = this._writableState;\\n\\n  state.corked++;\\n};\\n\\nWritable.prototype.uncork = function() {\\n  var state = this._writableState;\\n\\n  if (state.corked) {\\n    state.corked--;\\n\\n    if (!state.writing &&\\n        !state.corked &&\\n        !state.finished &&\\n        !state.bufferProcessing &&\\n        state.bufferedRequest)\\n      clearBuffer(this, state);\\n  }\\n};\\n\\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\\n  // node::ParseEncoding() requires lower case.\\n  if (typeof encoding === 'string')\\n    encoding = encoding.toLowerCase();\\n  if (!Buffer.isEncoding(encoding))\\n    throw new TypeError('Unknown encoding: ' + encoding);\\n  this._writableState.defaultEncoding = encoding;\\n};\\n\\nfunction decodeChunk(state, chunk, encoding) {\\n  if (!state.objectMode &&\\n      state.decodeStrings !== false &&\\n      typeof chunk === 'string') {\\n    chunk = Buffer(chunk, encoding);\\n  }\\n  return chunk;\\n}\\n\\n// if we're already writing something, then just put this\\n// in the queue, and wait our turn.  Otherwise, call _write\\n// If we return false, then we need a drain event, so set that flag.\\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\\n  chunk = decodeChunk(state, chunk, encoding);\\n\\n  if (chunk instanceof Buffer)\\n    encoding = 'buffer';\\n  var len = state.objectMode ? 1 : chunk.length;\\n\\n  state.length += len;\\n\\n  var ret = state.length < state.highWaterMark;\\n  // we must ensure that previous needDrain will not be reset to false.\\n  if (!ret)\\n    state.needDrain = true;\\n\\n  if (state.writing || state.corked) {\\n    var last = state.lastBufferedRequest;\\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\\n    if (last) {\\n      last.next = state.lastBufferedRequest;\\n    } else {\\n      state.bufferedRequest = state.lastBufferedRequest;\\n    }\\n  } else {\\n    doWrite(stream, state, false, len, chunk, encoding, cb);\\n  }\\n\\n  return ret;\\n}\\n\\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\\n  state.writelen = len;\\n  state.writecb = cb;\\n  state.writing = true;\\n  state.sync = true;\\n  if (writev)\\n    stream._writev(chunk, state.onwrite);\\n  else\\n    stream._write(chunk, encoding, state.onwrite);\\n  state.sync = false;\\n}\\n\\nfunction onwriteError(stream, state, sync, er, cb) {\\n  --state.pendingcb;\\n  if (sync)\\n    process.nextTick(cb, er);\\n  else\\n    cb(er);\\n\\n  stream._writableState.errorEmitted = true;\\n  stream.emit('error', er);\\n}\\n\\nfunction onwriteStateUpdate(state) {\\n  state.writing = false;\\n  state.writecb = null;\\n  state.length -= state.writelen;\\n  state.writelen = 0;\\n}\\n\\nfunction onwrite(stream, er) {\\n  var state = stream._writableState;\\n  var sync = state.sync;\\n  var cb = state.writecb;\\n\\n  onwriteStateUpdate(state);\\n\\n  if (er)\\n    onwriteError(stream, state, sync, er, cb);\\n  else {\\n    // Check if we're actually ready to finish, but don't emit yet\\n    var finished = needFinish(state);\\n\\n    if (!finished &&\\n        !state.corked &&\\n        !state.bufferProcessing &&\\n        state.bufferedRequest) {\\n      clearBuffer(stream, state);\\n    }\\n\\n    if (sync) {\\n      process.nextTick(afterWrite, stream, state, finished, cb);\\n    } else {\\n      afterWrite(stream, state, finished, cb);\\n    }\\n  }\\n}\\n\\nfunction afterWrite(stream, state, finished, cb) {\\n  if (!finished)\\n    onwriteDrain(stream, state);\\n  state.pendingcb--;\\n  cb();\\n  finishMaybe(stream, state);\\n}\\n\\n// Must force callback to be called on nextTick, so that we don't\\n// emit 'drain' before the write() consumer gets the 'false' return\\n// value, and has a chance to attach a 'drain' listener.\\nfunction onwriteDrain(stream, state) {\\n  if (state.length === 0 && state.needDrain) {\\n    state.needDrain = false;\\n    stream.emit('drain');\\n  }\\n}\\n\\n\\n// if there's something in the buffer waiting, then process it\\nfunction clearBuffer(stream, state) {\\n  state.bufferProcessing = true;\\n  var entry = state.bufferedRequest;\\n\\n  if (stream._writev && entry && entry.next) {\\n    // Fast case, write everything using _writev()\\n    var buffer = [];\\n    var cbs = [];\\n    while (entry) {\\n      cbs.push(entry.callback);\\n      buffer.push(entry);\\n      entry = entry.next;\\n    }\\n\\n    // count the one we are adding, as well.\\n    // TODO(isaacs) clean this up\\n    state.pendingcb++;\\n    state.lastBufferedRequest = null;\\n    doWrite(stream, state, true, state.length, buffer, '', function(err) {\\n      for (var i = 0; i < cbs.length; i++) {\\n        state.pendingcb--;\\n        cbs[i](err);\\n      }\\n    });\\n\\n    // Clear buffer\\n  } else {\\n    // Slow case, write chunks one-by-one\\n    while (entry) {\\n      var chunk = entry.chunk;\\n      var encoding = entry.encoding;\\n      var cb = entry.callback;\\n      var len = state.objectMode ? 1 : chunk.length;\\n\\n      doWrite(stream, state, false, len, chunk, encoding, cb);\\n      entry = entry.next;\\n      // if we didn't call the onwrite immediately, then\\n      // it means that we need to wait until it does.\\n      // also, that means that the chunk and cb are currently\\n      // being processed, so move the buffer counter past them.\\n      if (state.writing) {\\n        break;\\n      }\\n    }\\n\\n    if (entry === null)\\n      state.lastBufferedRequest = null;\\n  }\\n  state.bufferedRequest = entry;\\n  state.bufferProcessing = false;\\n}\\n\\nWritable.prototype._write = function(chunk, encoding, cb) {\\n  cb(new Error('not implemented'));\\n};\\n\\nWritable.prototype._writev = null;\\n\\nWritable.prototype.end = function(chunk, encoding, cb) {\\n  var state = this._writableState;\\n\\n  if (typeof chunk === 'function') {\\n    cb = chunk;\\n    chunk = null;\\n    encoding = null;\\n  } else if (typeof encoding === 'function') {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n\\n  if (chunk !== null && chunk !== undefined)\\n    this.write(chunk, encoding);\\n\\n  // .end() fully uncorks\\n  if (state.corked) {\\n    state.corked = 1;\\n    this.uncork();\\n  }\\n\\n  // ignore unnecessary end() calls.\\n  if (!state.ending && !state.finished)\\n    endWritable(this, state, cb);\\n};\\n\\n\\nfunction needFinish(state) {\\n  return (state.ending &&\\n          state.length === 0 &&\\n          state.bufferedRequest === null &&\\n          !state.finished &&\\n          !state.writing);\\n}\\n\\nfunction prefinish(stream, state) {\\n  if (!state.prefinished) {\\n    state.prefinished = true;\\n    stream.emit('prefinish');\\n  }\\n}\\n\\nfunction finishMaybe(stream, state) {\\n  var need = needFinish(state);\\n  if (need) {\\n    if (state.pendingcb === 0) {\\n      prefinish(stream, state);\\n      state.finished = true;\\n      stream.emit('finish');\\n    } else {\\n      prefinish(stream, state);\\n    }\\n  }\\n  return need;\\n}\\n\\nfunction endWritable(stream, state, cb) {\\n  state.ending = true;\\n  finishMaybe(stream, state);\\n  if (cb) {\\n    if (state.finished)\\n      process.nextTick(cb);\\n    else\\n      stream.once('finish', cb);\\n  }\\n  state.ended = true;\\n}\\n\",\"_stream_duplex\":\"// a duplex stream is just a stream that is both readable and writable.\\n// Since JS doesn't have multiple prototypal inheritance, this class\\n// prototypally inherits from Readable, and then parasitically from\\n// Writable.\\n\\n'use strict';\\n\\nmodule.exports = Duplex;\\n\\nvar util = require('util');\\nvar Readable = require('_stream_readable');\\nvar Writable = require('_stream_writable');\\n\\nutil.inherits(Duplex, Readable);\\n\\nvar keys = Object.keys(Writable.prototype);\\nfor (var v = 0; v < keys.length; v++) {\\n  var method = keys[v];\\n  if (!Duplex.prototype[method])\\n    Duplex.prototype[method] = Writable.prototype[method];\\n}\\n\\nfunction Duplex(options) {\\n  if (!(this instanceof Duplex))\\n    return new Duplex(options);\\n\\n  Readable.call(this, options);\\n  Writable.call(this, options);\\n\\n  if (options && options.readable === false)\\n    this.readable = false;\\n\\n  if (options && options.writable === false)\\n    this.writable = false;\\n\\n  this.allowHalfOpen = true;\\n  if (options && options.allowHalfOpen === false)\\n    this.allowHalfOpen = false;\\n\\n  this.once('end', onend);\\n}\\n\\n// the no-half-open enforcer\\nfunction onend() {\\n  // if we allow half-open state, or if the writable side ended,\\n  // then we're ok.\\n  if (this.allowHalfOpen || this._writableState.ended)\\n    return;\\n\\n  // no more data can be written.\\n  // But allow more writes to happen in this tick.\\n  process.nextTick(onEndNT, this);\\n}\\n\\nfunction onEndNT(self) {\\n  self.end();\\n}\\n\",\"_stream_transform\":\"// a transform stream is a readable/writable stream where you do\\n// something with the data.  Sometimes it's called a \\\"filter\\\",\\n// but that's not a great name for it, since that implies a thing where\\n// some bits pass through, and others are simply ignored.  (That would\\n// be a valid example of a transform, of course.)\\n//\\n// While the output is causally related to the input, it's not a\\n// necessarily symmetric or synchronous transformation.  For example,\\n// a zlib stream might take multiple plain-text writes(), and then\\n// emit a single compressed chunk some time in the future.\\n//\\n// Here's how this works:\\n//\\n// The Transform stream has all the aspects of the readable and writable\\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\\n// internally, and returns false if there's a lot of pending writes\\n// buffered up.  When you call read(), that calls _read(n) until\\n// there's enough pending readable data buffered up.\\n//\\n// In a transform stream, the written data is placed in a buffer.  When\\n// _read(n) is called, it transforms the queued up data, calling the\\n// buffered _write cb's as it consumes chunks.  If consuming a single\\n// written chunk would result in multiple output chunks, then the first\\n// outputted bit calls the readcb, and subsequent chunks just go into\\n// the read buffer, and will cause it to emit 'readable' if necessary.\\n//\\n// This way, back-pressure is actually determined by the reading side,\\n// since _read has to be called to start processing a new chunk.  However,\\n// a pathological inflate type of transform can cause excessive buffering\\n// here.  For example, imagine a stream where every byte of input is\\n// interpreted as an integer from 0-255, and then results in that many\\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\\n// 1kb of data being output.  In this case, you could write a very small\\n// amount of input, and end up with a very large amount of output.  In\\n// such a pathological inflating mechanism, there'd be no way to tell\\n// the system to stop doing the transform.  A single 4MB write could\\n// cause the system to run out of memory.\\n//\\n// However, even in such a pathological case, only a single written chunk\\n// would be consumed, and then the rest would wait (un-transformed) until\\n// the results of the previous transformed chunk were consumed.\\n\\n'use strict';\\n\\nmodule.exports = Transform;\\n\\nvar Duplex = require('_stream_duplex');\\nvar util = require('util');\\nutil.inherits(Transform, Duplex);\\n\\n\\nfunction TransformState(stream) {\\n  this.afterTransform = function(er, data) {\\n    return afterTransform(stream, er, data);\\n  };\\n\\n  this.needTransform = false;\\n  this.transforming = false;\\n  this.writecb = null;\\n  this.writechunk = null;\\n}\\n\\nfunction afterTransform(stream, er, data) {\\n  var ts = stream._transformState;\\n  ts.transforming = false;\\n\\n  var cb = ts.writecb;\\n\\n  if (!cb)\\n    return stream.emit('error', new Error('no writecb in Transform class'));\\n\\n  ts.writechunk = null;\\n  ts.writecb = null;\\n\\n  if (data !== null && data !== undefined)\\n    stream.push(data);\\n\\n  if (cb)\\n    cb(er);\\n\\n  var rs = stream._readableState;\\n  rs.reading = false;\\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\\n    stream._read(rs.highWaterMark);\\n  }\\n}\\n\\n\\nfunction Transform(options) {\\n  if (!(this instanceof Transform))\\n    return new Transform(options);\\n\\n  Duplex.call(this, options);\\n\\n  this._transformState = new TransformState(this);\\n\\n  // when the writable side finishes, then flush out anything remaining.\\n  var stream = this;\\n\\n  // start out asking for a readable event once data is transformed.\\n  this._readableState.needReadable = true;\\n\\n  // we have implemented the _read method, and done the other things\\n  // that Readable wants before the first _read call, so unset the\\n  // sync guard flag.\\n  this._readableState.sync = false;\\n\\n  if (options) {\\n    if (typeof options.transform === 'function')\\n      this._transform = options.transform;\\n\\n    if (typeof options.flush === 'function')\\n      this._flush = options.flush;\\n  }\\n\\n  this.once('prefinish', function() {\\n    if (typeof this._flush === 'function')\\n      this._flush(function(er) {\\n        done(stream, er);\\n      });\\n    else\\n      done(stream);\\n  });\\n}\\n\\nTransform.prototype.push = function(chunk, encoding) {\\n  this._transformState.needTransform = false;\\n  return Duplex.prototype.push.call(this, chunk, encoding);\\n};\\n\\n// This is the part where you do stuff!\\n// override this function in implementation classes.\\n// 'chunk' is an input chunk.\\n//\\n// Call `push(newChunk)` to pass along transformed output\\n// to the readable side.  You may call 'push' zero or more times.\\n//\\n// Call `cb(err)` when you are done with this chunk.  If you pass\\n// an error, then that'll put the hurt on the whole operation.  If you\\n// never call cb(), then you'll never get another chunk.\\nTransform.prototype._transform = function(chunk, encoding, cb) {\\n  throw new Error('Not implemented');\\n};\\n\\nTransform.prototype._write = function(chunk, encoding, cb) {\\n  var ts = this._transformState;\\n  ts.writecb = cb;\\n  ts.writechunk = chunk;\\n  ts.writeencoding = encoding;\\n  if (!ts.transforming) {\\n    var rs = this._readableState;\\n    if (ts.needTransform ||\\n        rs.needReadable ||\\n        rs.length < rs.highWaterMark)\\n      this._read(rs.highWaterMark);\\n  }\\n};\\n\\n// Doesn't matter what the args are here.\\n// _transform does all the work.\\n// That we got here means that the readable side wants more data.\\nTransform.prototype._read = function(n) {\\n  var ts = this._transformState;\\n\\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\\n    ts.transforming = true;\\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\\n  } else {\\n    // mark that we need a transform, so that any data that comes in\\n    // will get processed, now that we've asked for it.\\n    ts.needTransform = true;\\n  }\\n};\\n\\n\\nfunction done(stream, er) {\\n  if (er)\\n    return stream.emit('error', er);\\n\\n  // if there's nothing in the write buffer, then that means\\n  // that nothing more will ever be provided\\n  var ws = stream._writableState;\\n  var ts = stream._transformState;\\n\\n  if (ws.length)\\n    throw new Error('Calling transform done when ws.length != 0');\\n\\n  if (ts.transforming)\\n    throw new Error('Calling transform done when still transforming');\\n\\n  return stream.push(null);\\n}\\n\",\"_stream_passthrough\":\"// a passthrough stream.\\n// basically just the most minimal sort of Transform stream.\\n// Every written chunk gets output as-is.\\n\\n'use strict';\\n\\nmodule.exports = PassThrough;\\n\\nvar Transform = require('_stream_transform');\\nvar util = require('util');\\nutil.inherits(PassThrough, Transform);\\n\\nfunction PassThrough(options) {\\n  if (!(this instanceof PassThrough))\\n    return new PassThrough(options);\\n\\n  Transform.call(this, options);\\n}\\n\\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\\n  cb(null, chunk);\\n};\\n\",\"http\":\"'use strict';\\r\\n\\r\\nvar util = require('util');\\r\\nvar internalUtil = require('internal/util');\\r\\nvar EventEmitter = require('events');\\r\\n\\r\\n\\r\\nexports.IncomingMessage = require('_http_incoming').IncomingMessage;\\r\\n\\r\\n\\r\\nvar common = require('_http_common');\\r\\nexports.METHODS = common.methods.slice().sort();\\r\\n\\r\\n\\r\\nexports.OutgoingMessage = require('_http_outgoing').OutgoingMessage;\\r\\n\\r\\n\\r\\nvar server = require('_http_server');\\r\\nexports.ServerResponse = server.ServerResponse;\\r\\nexports.STATUS_CODES = server.STATUS_CODES;\\r\\n\\r\\n\\r\\nvar agent = require('_http_agent');\\r\\nvar Agent = exports.Agent = agent.Agent;\\r\\nexports.globalAgent = agent.globalAgent;\\r\\n\\r\\nvar client = require('_http_client');\\r\\nvar ClientRequest = exports.ClientRequest = client.ClientRequest;\\r\\n\\r\\nexports.request = function(options, cb) {\\r\\n  return new ClientRequest(options, cb);\\r\\n};\\r\\n\\r\\nexports.get = function(options, cb) {\\r\\n  var req = exports.request(options, cb);\\r\\n  req.end();\\r\\n  return req;\\r\\n};\\r\\n\\r\\nexports._connectionListener = server._connectionListener;\\r\\nvar Server = exports.Server = server.Server;\\r\\n\\r\\nexports.createServer = function(requestListener) {\\r\\n  return new Server(requestListener);\\r\\n};\\r\\n\\r\\n\\r\\n// Legacy Interface\\r\\n\\r\\nfunction Client(port, host) {\\r\\n  if (!(this instanceof Client)) return new Client(port, host);\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  host = host || 'localhost';\\r\\n  port = port || 80;\\r\\n  this.host = host;\\r\\n  this.port = port;\\r\\n  this.agent = new Agent({ host: host, port: port, maxSockets: 1 });\\r\\n}\\r\\nutil.inherits(Client, EventEmitter);\\r\\nClient.prototype.request = function(method, path, headers) {\\r\\n  var self = this;\\r\\n  var options = {};\\r\\n  options.host = self.host;\\r\\n  options.port = self.port;\\r\\n  if (method[0] === '/') {\\r\\n    headers = path;\\r\\n    path = method;\\r\\n    method = 'GET';\\r\\n  }\\r\\n  options.method = method;\\r\\n  options.path = path;\\r\\n  options.headers = headers;\\r\\n  options.agent = self.agent;\\r\\n  var c = new ClientRequest(options);\\r\\n  c.on('error', function(e) {\\r\\n    self.emit('error', e);\\r\\n  });\\r\\n  // The old Client interface emitted 'end' on socket end.\\r\\n  // This doesn't map to how we want things to operate in the future\\r\\n  // but it will get removed when we remove this legacy interface.\\r\\n  c.on('socket', function(s) {\\r\\n    s.on('end', function() {\\r\\n      if (self._decoder) {\\r\\n        var ret = self._decoder.end();\\r\\n        if (ret)\\r\\n          self.emit('data', ret);\\r\\n      }\\r\\n      self.emit('end');\\r\\n    });\\r\\n  });\\r\\n  return c;\\r\\n};\\r\\n\\r\\nexports.Client = internalUtil.deprecate(Client, 'http.Client is deprecated.');\\r\\n\\r\\nexports.createClient = internalUtil.deprecate(function(port, host) {\\r\\n  return new Client(port, host);\\r\\n}, 'http.createClient is deprecated. Use http.request instead.');\\r\\n\",\"_http_agent\":\"'use strict';\\r\\n\\r\\nvar net = require('net');\\r\\nvar util = require('util');\\r\\nvar EventEmitter = require('events');\\r\\nvar debug = util.debuglog('http');\\r\\n\\r\\n// New Agent code.\\r\\n\\r\\n// The largest departure from the previous implementation is that\\r\\n// an Agent instance holds connections for a variable number of host:ports.\\r\\n// Surprisingly, this is still API compatible as far as third parties are\\r\\n// concerned. The only code that really notices the difference is the\\r\\n// request object.\\r\\n\\r\\n// Another departure is that all code related to HTTP parsing is in\\r\\n// ClientRequest.onSocket(). The Agent is now *strictly*\\r\\n// concerned with managing a connection pool.\\r\\n\\r\\nfunction Agent(options) {\\r\\n  if (!(this instanceof Agent))\\r\\n    return new Agent(options);\\r\\n\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  var self = this;\\r\\n\\r\\n  self.defaultPort = 80;\\r\\n  self.protocol = 'http:';\\r\\n\\r\\n  self.options = util._extend({}, options);\\r\\n\\r\\n  // don't confuse net and make it think that we're connecting to a pipe\\r\\n  self.options.path = null;\\r\\n  self.requests = {};\\r\\n  self.sockets = {};\\r\\n  self.freeSockets = {};\\r\\n  self.keepAliveMsecs = self.options.keepAliveMsecs || 1000;\\r\\n  self.keepAlive = self.options.keepAlive || false;\\r\\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;\\r\\n  self.maxFreeSockets = self.options.maxFreeSockets || 256;\\r\\n\\r\\n  self.on('free', function(socket, options) {\\r\\n    var name = self.getName(options);\\r\\n    debug('agent.on(free)', name);\\r\\n\\r\\n    if (!socket.destroyed &&\\r\\n        self.requests[name] && self.requests[name].length) {\\r\\n      self.requests[name].shift().onSocket(socket);\\r\\n      if (self.requests[name].length === 0) {\\r\\n        // don't leak\\r\\n        delete self.requests[name];\\r\\n      }\\r\\n    } else {\\r\\n      // If there are no pending requests, then put it in\\r\\n      // the freeSockets pool, but only if we're allowed to do so.\\r\\n      var req = socket._httpMessage;\\r\\n      if (req &&\\r\\n          req.shouldKeepAlive &&\\r\\n          !socket.destroyed &&\\r\\n          self.options.keepAlive) {\\r\\n        var freeSockets = self.freeSockets[name];\\r\\n        var freeLen = freeSockets ? freeSockets.length : 0;\\r\\n        var count = freeLen;\\r\\n        if (self.sockets[name])\\r\\n          count += self.sockets[name].length;\\r\\n\\r\\n        if (count > self.maxSockets || freeLen >= self.maxFreeSockets) {\\r\\n          self.removeSocket(socket, options);\\r\\n          socket.destroy();\\r\\n        } else {\\r\\n          freeSockets = freeSockets || [];\\r\\n          self.freeSockets[name] = freeSockets;\\r\\n          socket.setKeepAlive(true, self.keepAliveMsecs);\\r\\n          socket.unref();\\r\\n          socket._httpMessage = null;\\r\\n          self.removeSocket(socket, options);\\r\\n          freeSockets.push(socket);\\r\\n        }\\r\\n      } else {\\r\\n        self.removeSocket(socket, options);\\r\\n        socket.destroy();\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n}\\r\\n\\r\\nutil.inherits(Agent, EventEmitter);\\r\\nexports.Agent = Agent;\\r\\n\\r\\nAgent.defaultMaxSockets = Infinity;\\r\\n\\r\\nAgent.prototype.createConnection = net.createConnection;\\r\\n\\r\\n// Get the key for a given set of request options\\r\\nAgent.prototype.getName = function(options) {\\r\\n  var name = options.host || 'localhost';\\r\\n\\r\\n  name += ':';\\r\\n  if (options.port)\\r\\n    name += options.port;\\r\\n\\r\\n  name += ':';\\r\\n  if (options.localAddress)\\r\\n    name += options.localAddress;\\r\\n\\r\\n  return name;\\r\\n};\\r\\n\\r\\nAgent.prototype.addRequest = function(req, options) {\\r\\n  // Legacy API: addRequest(req, host, port, path)\\r\\n  if (typeof options === 'string') {\\r\\n    options = {\\r\\n      host: options,\\r\\n      port: arguments[2],\\r\\n      path: arguments[3]\\r\\n    };\\r\\n  }\\r\\n\\r\\n  var name = this.getName(options);\\r\\n  if (!this.sockets[name]) {\\r\\n    this.sockets[name] = [];\\r\\n  }\\r\\n\\r\\n  var freeLen = this.freeSockets[name] ? this.freeSockets[name].length : 0;\\r\\n  var sockLen = freeLen + this.sockets[name].length;\\r\\n\\r\\n  if (freeLen) {\\r\\n    // we have a free socket, so use that.\\r\\n    var socket = this.freeSockets[name].shift();\\r\\n    debug('have free socket');\\r\\n\\r\\n    // don't leak\\r\\n    if (!this.freeSockets[name].length)\\r\\n      delete this.freeSockets[name];\\r\\n\\r\\n    socket.ref();\\r\\n    req.onSocket(socket);\\r\\n    this.sockets[name].push(socket);\\r\\n  } else if (sockLen < this.maxSockets) {\\r\\n    debug('call onSocket', sockLen, freeLen);\\r\\n    // If we are under maxSockets create a new one.\\r\\n    req.onSocket(this.createSocket(req, options));\\r\\n  } else {\\r\\n    debug('wait for socket');\\r\\n    // We are over limit so we'll add it to the queue.\\r\\n    if (!this.requests[name]) {\\r\\n      this.requests[name] = [];\\r\\n    }\\r\\n    this.requests[name].push(req);\\r\\n  }\\r\\n};\\r\\n\\r\\nAgent.prototype.createSocket = function(req, options) {\\r\\n  var self = this;\\r\\n  options = util._extend({}, options);\\r\\n  options = util._extend(options, self.options);\\r\\n\\r\\n  if (!options.servername) {\\r\\n    options.servername = options.host;\\r\\n    if (req) {\\r\\n      var hostHeader = req.getHeader('host');\\r\\n      if (hostHeader) {\\r\\n        options.servername = hostHeader.replace(/:.*$/, '');\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var name = self.getName(options);\\r\\n  options._agentKey = name;\\r\\n\\r\\n  debug('createConnection', name, options);\\r\\n  options.encoding = null;\\r\\n  var s = self.createConnection(options);\\r\\n  if (!self.sockets[name]) {\\r\\n    self.sockets[name] = [];\\r\\n  }\\r\\n  this.sockets[name].push(s);\\r\\n  debug('sockets', name, this.sockets[name].length);\\r\\n\\r\\n  function onFree() {\\r\\n    self.emit('free', s, options);\\r\\n  }\\r\\n  s.on('free', onFree);\\r\\n\\r\\n  function onClose(err) {\\r\\n    debug('CLIENT socket onClose');\\r\\n    // This is the only place where sockets get removed from the Agent.\\r\\n    // If you want to remove a socket from the pool, just close it.\\r\\n    // All socket errors end in a close event anyway.\\r\\n    self.removeSocket(s, options);\\r\\n  }\\r\\n  s.on('close', onClose);\\r\\n\\r\\n  function onRemove() {\\r\\n    // We need this function for cases like HTTP 'upgrade'\\r\\n    // (defined by WebSockets) where we need to remove a socket from the\\r\\n    // pool because it'll be locked up indefinitely\\r\\n    debug('CLIENT socket onRemove');\\r\\n    self.removeSocket(s, options);\\r\\n    s.removeListener('close', onClose);\\r\\n    s.removeListener('free', onFree);\\r\\n    s.removeListener('agentRemove', onRemove);\\r\\n  }\\r\\n  s.on('agentRemove', onRemove);\\r\\n  return s;\\r\\n};\\r\\n\\r\\nAgent.prototype.removeSocket = function(s, options) {\\r\\n  var name = this.getName(options);\\r\\n  debug('removeSocket', name, 'destroyed:', s.destroyed);\\r\\n  var sets = [this.sockets];\\r\\n\\r\\n  // If the socket was destroyed, remove it from the free buffers too.\\r\\n  if (s.destroyed)\\r\\n    sets.push(this.freeSockets);\\r\\n\\r\\n  for (var sk = 0; sk < sets.length; sk++) {\\r\\n    var sockets = sets[sk];\\r\\n\\r\\n    if (sockets[name]) {\\r\\n      var index = sockets[name].indexOf(s);\\r\\n      if (index !== -1) {\\r\\n        sockets[name].splice(index, 1);\\r\\n        // Don't leak\\r\\n        if (sockets[name].length === 0)\\r\\n          delete sockets[name];\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (this.requests[name] && this.requests[name].length) {\\r\\n    debug('removeSocket, have a request, make a socket');\\r\\n    var req = this.requests[name][0];\\r\\n    // If we have pending requests and a socket gets closed make a new one\\r\\n    this.createSocket(req, options).emit('free');\\r\\n  }\\r\\n};\\r\\n\\r\\nAgent.prototype.destroy = function() {\\r\\n  var sets = [this.freeSockets, this.sockets];\\r\\n  for (var s = 0; s < sets.length; s++) {\\r\\n    var set = sets[s];\\r\\n    var keys = Object.keys(set);\\r\\n    for (var v = 0; v < keys.length; v++) {\\r\\n      var setName = set[keys[v]];\\r\\n      for (var n = 0; n < setName.length; n++) {\\r\\n        setName[n].destroy();\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nexports.globalAgent = new Agent();\\r\\n\",\"_http_client\":\"'use strict';\\r\\n\\r\\nvar util = require('util');\\r\\nvar net = require('net');\\r\\nvar url = require('url');\\r\\nvar EventEmitter = require('events');\\r\\nvar HTTPParser = process.binding('http_parser').HTTPParser;\\r\\nvar assert = require('assert').ok;\\r\\nvar common = require('_http_common');\\r\\nvar httpSocketSetup = common.httpSocketSetup;\\r\\nvar parsers = common.parsers;\\r\\nvar freeParser = common.freeParser;\\r\\nvar debug = common.debug;\\r\\nvar OutgoingMessage = require('_http_outgoing').OutgoingMessage;\\r\\nvar Agent = require('_http_agent');\\r\\nvar Buffer = require('buffer').Buffer;\\r\\n\\r\\n\\r\\nfunction ClientRequest(options, cb) {\\r\\n  var self = this;\\r\\n  OutgoingMessage.call(self);\\r\\n\\r\\n  if (typeof options === 'string') {\\r\\n    options = url.parse(options);\\r\\n    if (!options.hostname) {\\r\\n      throw new Error('Unable to determine the domain name');\\r\\n    }\\r\\n  } else {\\r\\n    options = util._extend({}, options);\\r\\n  }\\r\\n\\r\\n  var agent = options.agent;\\r\\n  var defaultAgent = options._defaultAgent || Agent.globalAgent;\\r\\n  if (agent === false) {\\r\\n    agent = new defaultAgent.constructor();\\r\\n  } else if ((agent === null || agent === undefined) &&\\r\\n             !options.createConnection) {\\r\\n    agent = defaultAgent;\\r\\n  }\\r\\n  self.agent = agent;\\r\\n\\r\\n  var protocol = options.protocol || defaultAgent.protocol;\\r\\n  var expectedProtocol = defaultAgent.protocol;\\r\\n  if (self.agent && self.agent.protocol)\\r\\n    expectedProtocol = self.agent.protocol;\\r\\n\\r\\n  if (options.path && / /.test(options.path)) {\\r\\n    // The actual regex is more like /[^A-Za-z0-9\\\\-._~!$&'()*+,;=/:@]/\\r\\n    // with an additional rule for ignoring percentage-escaped characters\\r\\n    // but that's a) hard to capture in a regular expression that performs\\r\\n    // well, and b) possibly too restrictive for real-world usage. That's\\r\\n    // why it only scans for spaces because those are guaranteed to create\\r\\n    // an invalid request.\\r\\n    throw new TypeError('Request path contains unescaped characters');\\r\\n  } else if (protocol !== expectedProtocol) {\\r\\n    throw new Error('Protocol \\\"' + protocol + '\\\" not supported. ' +\\r\\n                    'Expected \\\"' + expectedProtocol + '\\\"');\\r\\n  }\\r\\n\\r\\n  var defaultPort = options.defaultPort ||\\r\\n                      self.agent && self.agent.defaultPort;\\r\\n\\r\\n  var port = options.port = options.port || defaultPort || 80;\\r\\n  var host = options.host = options.hostname || options.host || 'localhost';\\r\\n\\r\\n  if (options.setHost === undefined) {\\r\\n    var setHost = true;\\r\\n  }\\r\\n\\r\\n  self.socketPath = options.socketPath;\\r\\n\\r\\n  var method = self.method = (options.method || 'GET').toUpperCase();\\r\\n  if (!common._checkIsHttpToken(method)) {\\r\\n    throw new TypeError('Method must be a valid HTTP token');\\r\\n  }\\r\\n  self.path = options.path || '/';\\r\\n  if (cb) {\\r\\n    self.once('response', cb);\\r\\n  }\\r\\n\\r\\n  if (!Array.isArray(options.headers)) {\\r\\n    if (options.headers) {\\r\\n      var keys = Object.keys(options.headers);\\r\\n      for (var i = 0, l = keys.length; i < l; i++) {\\r\\n        var key = keys[i];\\r\\n        self.setHeader(key, options.headers[key]);\\r\\n      }\\r\\n    }\\r\\n    if (host && !this.getHeader('host') && setHost) {\\r\\n      var hostHeader = host;\\r\\n      if (port && +port !== defaultPort) {\\r\\n        hostHeader += ':' + port;\\r\\n      }\\r\\n      this.setHeader('Host', hostHeader);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (options.auth && !this.getHeader('Authorization')) {\\r\\n    //basic auth\\r\\n    this.setHeader('Authorization', 'Basic ' +\\r\\n                   new Buffer(options.auth).toString('base64'));\\r\\n  }\\r\\n\\r\\n  if (method === 'GET' ||\\r\\n      method === 'HEAD' ||\\r\\n      method === 'DELETE' ||\\r\\n      method === 'OPTIONS' ||\\r\\n      method === 'CONNECT') {\\r\\n    self.useChunkedEncodingByDefault = false;\\r\\n  } else {\\r\\n    self.useChunkedEncodingByDefault = true;\\r\\n  }\\r\\n\\r\\n  if (Array.isArray(options.headers)) {\\r\\n    self._storeHeader(self.method + ' ' + self.path + ' HTTP/1.1\\\\r\\\\n',\\r\\n                      options.headers);\\r\\n  } else if (self.getHeader('expect')) {\\r\\n    self._storeHeader(self.method + ' ' + self.path + ' HTTP/1.1\\\\r\\\\n',\\r\\n                      self._renderHeaders());\\r\\n  }\\r\\n\\r\\n  if (self.socketPath) {\\r\\n    self._last = true;\\r\\n    self.shouldKeepAlive = false;\\r\\n    var conn = self.agent.createConnection({ path: self.socketPath });\\r\\n    self.onSocket(conn);\\r\\n  } else if (self.agent) {\\r\\n    // If there is an agent we should default to Connection:keep-alive,\\r\\n    // but only if the Agent will actually reuse the connection!\\r\\n    // If it's not a keepAlive agent, and the maxSockets==Infinity, then\\r\\n    // there's never a case where this socket will actually be reused\\r\\n    if (!self.agent.keepAlive && !Number.isFinite(self.agent.maxSockets)) {\\r\\n      self._last = true;\\r\\n      self.shouldKeepAlive = false;\\r\\n    } else {\\r\\n      self._last = false;\\r\\n      self.shouldKeepAlive = true;\\r\\n    }\\r\\n    self.agent.addRequest(self, options);\\r\\n  } else {\\r\\n    // No agent, default to Connection:close.\\r\\n    self._last = true;\\r\\n    self.shouldKeepAlive = false;\\r\\n    if (options.createConnection) {\\r\\n      var conn = options.createConnection(options);\\r\\n    } else {\\r\\n      debug('CLIENT use net.createConnection', options);\\r\\n      var conn = net.createConnection(options);\\r\\n    }\\r\\n    self.onSocket(conn);\\r\\n  }\\r\\n\\r\\n  self._deferToConnect(null, null, function() {\\r\\n    self._flush();\\r\\n    self = null;\\r\\n  });\\r\\n}\\r\\n\\r\\nutil.inherits(ClientRequest, OutgoingMessage);\\r\\n\\r\\nexports.ClientRequest = ClientRequest;\\r\\n\\r\\nClientRequest.prototype.aborted = undefined;\\r\\n\\r\\nClientRequest.prototype._finish = function() {\\r\\n  DTRACE_HTTP_CLIENT_REQUEST(this, this.connection);\\r\\n  LTTNG_HTTP_CLIENT_REQUEST(this, this.connection);\\r\\n  COUNTER_HTTP_CLIENT_REQUEST();\\r\\n  OutgoingMessage.prototype._finish.call(this);\\r\\n};\\r\\n\\r\\nClientRequest.prototype._implicitHeader = function() {\\r\\n  this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\\\r\\\\n',\\r\\n                    this._renderHeaders());\\r\\n};\\r\\n\\r\\nClientRequest.prototype.abort = function() {\\r\\n  if (this.aborted === undefined) {\\r\\n    process.nextTick(emitAbortNT, this);\\r\\n  }\\r\\n  // Mark as aborting so we can avoid sending queued request data\\r\\n  // This is used as a truthy flag elsewhere. The use of Date.now is for\\r\\n  // debugging purposes only.\\r\\n  this.aborted = Date.now();\\r\\n\\r\\n  // If we're aborting, we don't care about any more response data.\\r\\n  if (this.res)\\r\\n    this.res._dump();\\r\\n  else\\r\\n    this.once('response', function(res) {\\r\\n      res._dump();\\r\\n    });\\r\\n\\r\\n  // In the event that we don't have a socket, we will pop out of\\r\\n  // the request queue through handling in onSocket.\\r\\n  if (this.socket) {\\r\\n    // in-progress\\r\\n    this.socket.destroy();\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nfunction emitAbortNT(self) {\\r\\n  self.emit('abort');\\r\\n}\\r\\n\\r\\n\\r\\nfunction createHangUpError() {\\r\\n  var error = new Error('socket hang up');\\r\\n  error.code = 'ECONNRESET';\\r\\n  return error;\\r\\n}\\r\\n\\r\\n\\r\\nfunction socketCloseListener() {\\r\\n  var socket = this;\\r\\n  var req = socket._httpMessage;\\r\\n  debug('HTTP socket close');\\r\\n\\r\\n  // Pull through final chunk, if anything is buffered.\\r\\n  // the ondata function will handle it properly, and this\\r\\n  // is a no-op if no final chunk remains.\\r\\n  socket.read();\\r\\n\\r\\n  // NOTE: It's important to get parser here, because it could be freed by\\r\\n  // the `socketOnData`.\\r\\n  var parser = socket.parser;\\r\\n  req.emit('close');\\r\\n  if (req.res && req.res.readable) {\\r\\n    // Socket closed before we emitted 'end' below.\\r\\n    req.res.emit('aborted');\\r\\n    var res = req.res;\\r\\n    res.on('end', function() {\\r\\n      res.emit('close');\\r\\n    });\\r\\n    res.push(null);\\r\\n  } else if (!req.res && !req.socket._hadError) {\\r\\n    // This socket error fired before we started to\\r\\n    // receive a response. The error needs to\\r\\n    // fire on the request.\\r\\n    req.emit('error', createHangUpError());\\r\\n    req.socket._hadError = true;\\r\\n  }\\r\\n\\r\\n  // Too bad.  That output wasn't getting written.\\r\\n  // This is pretty terrible that it doesn't raise an error.\\r\\n  // Fixed better in v0.10\\r\\n  if (req.output)\\r\\n    req.output.length = 0;\\r\\n  if (req.outputEncodings)\\r\\n    req.outputEncodings.length = 0;\\r\\n\\r\\n  if (parser) {\\r\\n    parser.finish();\\r\\n    freeParser(parser, req, socket);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction socketErrorListener(err) {\\r\\n  var socket = this;\\r\\n  var req = socket._httpMessage;\\r\\n  debug('SOCKET ERROR:', err.message, err.stack);\\r\\n\\r\\n  if (req) {\\r\\n    req.emit('error', err);\\r\\n    // For Safety. Some additional errors might fire later on\\r\\n    // and we need to make sure we don't double-fire the error event.\\r\\n    req.socket._hadError = true;\\r\\n  }\\r\\n\\r\\n  // Handle any pending data\\r\\n  socket.read();\\r\\n\\r\\n  var parser = socket.parser;\\r\\n  if (parser) {\\r\\n    parser.finish();\\r\\n    freeParser(parser, req, socket);\\r\\n  }\\r\\n\\r\\n  // Ensure that no further data will come out of the socket\\r\\n  socket.removeListener('data', socketOnData);\\r\\n  socket.removeListener('end', socketOnEnd);\\r\\n  socket.destroy();\\r\\n}\\r\\n\\r\\nfunction socketOnEnd() {\\r\\n  var socket = this;\\r\\n  var req = this._httpMessage;\\r\\n  var parser = this.parser;\\r\\n\\r\\n  if (!req.res && !req.socket._hadError) {\\r\\n    // If we don't have a response then we know that the socket\\r\\n    // ended prematurely and we need to emit an error on the request.\\r\\n    req.emit('error', createHangUpError());\\r\\n    req.socket._hadError = true;\\r\\n  }\\r\\n  if (parser) {\\r\\n    parser.finish();\\r\\n    freeParser(parser, req, socket);\\r\\n  }\\r\\n  socket.destroy();\\r\\n}\\r\\n\\r\\nfunction socketOnData(d) {\\r\\n  var socket = this;\\r\\n  var req = this._httpMessage;\\r\\n  var parser = this.parser;\\r\\n\\r\\n  assert(parser && parser.socket === socket);\\r\\n\\r\\n  var ret = parser.execute(d);\\r\\n  if (ret instanceof Error) {\\r\\n    debug('parse error');\\r\\n    freeParser(parser, req, socket);\\r\\n    socket.destroy();\\r\\n    req.emit('error', ret);\\r\\n    req.socket._hadError = true;\\r\\n  } else if (parser.incoming && parser.incoming.upgrade) {\\r\\n    // Upgrade or CONNECT\\r\\n    var bytesParsed = ret;\\r\\n    var res = parser.incoming;\\r\\n    req.res = res;\\r\\n\\r\\n    socket.removeListener('data', socketOnData);\\r\\n    socket.removeListener('end', socketOnEnd);\\r\\n    parser.finish();\\r\\n\\r\\n    var bodyHead = d.slice(bytesParsed, d.length);\\r\\n\\r\\n    var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\\r\\n    if (req.listenerCount(eventName) > 0) {\\r\\n      req.upgradeOrConnect = true;\\r\\n\\r\\n      // detach the socket\\r\\n      socket.emit('agentRemove');\\r\\n      socket.removeListener('close', socketCloseListener);\\r\\n      socket.removeListener('error', socketErrorListener);\\r\\n\\r\\n      // TODO(isaacs): Need a way to reset a stream to fresh state\\r\\n      // IE, not flowing, and not explicitly paused.\\r\\n      socket._readableState.flowing = null;\\r\\n\\r\\n      req.emit(eventName, res, socket, bodyHead);\\r\\n      req.emit('close');\\r\\n    } else {\\r\\n      // Got Upgrade header or CONNECT method, but have no handler.\\r\\n      socket.destroy();\\r\\n    }\\r\\n    freeParser(parser, req, socket);\\r\\n  } else if (parser.incoming && parser.incoming.complete &&\\r\\n             // When the status code is 100 (Continue), the server will\\r\\n             // send a final response after this client sends a request\\r\\n             // body. So, we must not free the parser.\\r\\n             parser.incoming.statusCode !== 100) {\\r\\n    socket.removeListener('data', socketOnData);\\r\\n    socket.removeListener('end', socketOnEnd);\\r\\n    freeParser(parser, req, socket);\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n// client\\r\\nfunction parserOnIncomingClient(res, shouldKeepAlive) {\\r\\n  var socket = this.socket;\\r\\n  var req = socket._httpMessage;\\r\\n\\r\\n\\r\\n  // propagate \\\"domain\\\" setting...\\r\\n  if (req.domain && !res.domain) {\\r\\n    debug('setting \\\"res.domain\\\"');\\r\\n    res.domain = req.domain;\\r\\n  }\\r\\n\\r\\n  debug('AGENT incoming response!');\\r\\n\\r\\n  if (req.res) {\\r\\n    // We already have a response object, this means the server\\r\\n    // sent a double response.\\r\\n    socket.destroy();\\r\\n    return;\\r\\n  }\\r\\n  req.res = res;\\r\\n\\r\\n  // Responses to CONNECT request is handled as Upgrade.\\r\\n  if (req.method === 'CONNECT') {\\r\\n    res.upgrade = true;\\r\\n    return true; // skip body\\r\\n  }\\r\\n\\r\\n  // Responses to HEAD requests are crazy.\\r\\n  // HEAD responses aren't allowed to have an entity-body\\r\\n  // but *can* have a content-length which actually corresponds\\r\\n  // to the content-length of the entity-body had the request\\r\\n  // been a GET.\\r\\n  var isHeadResponse = req.method === 'HEAD';\\r\\n  debug('AGENT isHeadResponse', isHeadResponse);\\r\\n\\r\\n  if (res.statusCode === 100) {\\r\\n    // restart the parser, as this is a continue message.\\r\\n    delete req.res; // Clear res so that we don't hit double-responses.\\r\\n    req.emit('continue');\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  if (req.shouldKeepAlive && !shouldKeepAlive && !req.upgradeOrConnect) {\\r\\n    // Server MUST respond with Connection:keep-alive for us to enable it.\\r\\n    // If we've been upgraded (via WebSockets) we also shouldn't try to\\r\\n    // keep the connection open.\\r\\n    req.shouldKeepAlive = false;\\r\\n  }\\r\\n\\r\\n\\r\\n  DTRACE_HTTP_CLIENT_RESPONSE(socket, req);\\r\\n  LTTNG_HTTP_CLIENT_RESPONSE(socket, req);\\r\\n  COUNTER_HTTP_CLIENT_RESPONSE();\\r\\n  req.res = res;\\r\\n  res.req = req;\\r\\n\\r\\n  // add our listener first, so that we guarantee socket cleanup\\r\\n  res.on('end', responseOnEnd);\\r\\n  var handled = req.emit('response', res);\\r\\n\\r\\n  // If the user did not listen for the 'response' event, then they\\r\\n  // can't possibly read the data, so we ._dump() it into the void\\r\\n  // so that the socket doesn't hang there in a paused state.\\r\\n  if (!handled)\\r\\n    res._dump();\\r\\n\\r\\n  return isHeadResponse;\\r\\n}\\r\\n\\r\\n// client\\r\\nfunction responseOnEnd() {\\r\\n  var res = this;\\r\\n  var req = res.req;\\r\\n  var socket = req.socket;\\r\\n\\r\\n  if (!req.shouldKeepAlive) {\\r\\n    if (socket.writable) {\\r\\n      debug('AGENT socket.destroySoon()');\\r\\n      socket.destroySoon();\\r\\n    }\\r\\n    assert(!socket.writable);\\r\\n  } else {\\r\\n    debug('AGENT socket keep-alive');\\r\\n    if (req.timeoutCb) {\\r\\n      socket.setTimeout(0, req.timeoutCb);\\r\\n      req.timeoutCb = null;\\r\\n    }\\r\\n    socket.removeListener('close', socketCloseListener);\\r\\n    socket.removeListener('error', socketErrorListener);\\r\\n    // Mark this socket as available, AFTER user-added end\\r\\n    // handlers have a chance to run.\\r\\n    process.nextTick(emitFreeNT, socket);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction emitFreeNT(socket) {\\r\\n  socket.emit('free');\\r\\n}\\r\\n\\r\\nfunction tickOnSocket(req, socket) {\\r\\n  var parser = parsers.alloc();\\r\\n  req.socket = socket;\\r\\n  req.connection = socket;\\r\\n  parser.reinitialize(HTTPParser.RESPONSE);\\r\\n  parser.socket = socket;\\r\\n  parser.incoming = null;\\r\\n  parser.outgoing = req;\\r\\n  req.parser = parser;\\r\\n\\r\\n  socket.parser = parser;\\r\\n  socket._httpMessage = req;\\r\\n\\r\\n  // Setup \\\"drain\\\" propagation.\\r\\n  httpSocketSetup(socket);\\r\\n\\r\\n  // Propagate headers limit from request object to parser\\r\\n  if (typeof req.maxHeadersCount === 'number') {\\r\\n    parser.maxHeaderPairs = req.maxHeadersCount << 1;\\r\\n  } else {\\r\\n    // Set default value because parser may be reused from FreeList\\r\\n    parser.maxHeaderPairs = 2000;\\r\\n  }\\r\\n\\r\\n  parser.onIncoming = parserOnIncomingClient;\\r\\n  socket.on('error', socketErrorListener);\\r\\n  socket.on('data', socketOnData);\\r\\n  socket.on('end', socketOnEnd);\\r\\n  socket.on('close', socketCloseListener);\\r\\n  req.emit('socket', socket);\\r\\n}\\r\\n\\r\\nClientRequest.prototype.onSocket = function(socket) {\\r\\n  process.nextTick(onSocketNT, this, socket);\\r\\n};\\r\\n\\r\\nfunction onSocketNT(req, socket) {\\r\\n  if (req.aborted) {\\r\\n    // If we were aborted while waiting for a socket, skip the whole thing.\\r\\n    socket.emit('free');\\r\\n  } else {\\r\\n    tickOnSocket(req, socket);\\r\\n  }\\r\\n}\\r\\n\\r\\nClientRequest.prototype._deferToConnect = function(method, arguments_, cb) {\\r\\n  // This function is for calls that need to happen once the socket is\\r\\n  // connected and writable. It's an important promisy thing for all the socket\\r\\n  // calls that happen either now (when a socket is assigned) or\\r\\n  // in the future (when a socket gets assigned out of the pool and is\\r\\n  // eventually writable).\\r\\n  var self = this;\\r\\n\\r\\n  function callSocketMethod() {\\r\\n    if (method)\\r\\n      self.socket[method].apply(self.socket, arguments_);\\r\\n\\r\\n    if (typeof cb === 'function')\\r\\n      cb();\\r\\n  }\\r\\n\\r\\n  var onSocket = function() {\\r\\n    if (self.socket.writable) {\\r\\n      callSocketMethod();\\r\\n    } else {\\r\\n      self.socket.once('connect', callSocketMethod);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  if (!self.socket) {\\r\\n    self.once('socket', onSocket);\\r\\n  } else {\\r\\n    onSocket();\\r\\n  }\\r\\n};\\r\\n\\r\\nClientRequest.prototype.setTimeout = function(msecs, callback) {\\r\\n  if (callback) this.once('timeout', callback);\\r\\n\\r\\n  var self = this;\\r\\n  function emitTimeout() {\\r\\n    self.emit('timeout');\\r\\n  }\\r\\n\\r\\n  if (this.socket && this.socket.writable) {\\r\\n    if (this.timeoutCb)\\r\\n      this.socket.setTimeout(0, this.timeoutCb);\\r\\n    this.timeoutCb = emitTimeout;\\r\\n    this.socket.setTimeout(msecs, emitTimeout);\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  // Set timeoutCb so that it'll get cleaned up on request end\\r\\n  this.timeoutCb = emitTimeout;\\r\\n  if (this.socket) {\\r\\n    var sock = this.socket;\\r\\n    this.socket.once('connect', function() {\\r\\n      sock.setTimeout(msecs, emitTimeout);\\r\\n    });\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  this.once('socket', function(sock) {\\r\\n    sock.setTimeout(msecs, emitTimeout);\\r\\n  });\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\nClientRequest.prototype.setNoDelay = function() {\\r\\n  this._deferToConnect('setNoDelay', arguments);\\r\\n};\\r\\nClientRequest.prototype.setSocketKeepAlive = function() {\\r\\n  this._deferToConnect('setKeepAlive', arguments);\\r\\n};\\r\\n\\r\\nClientRequest.prototype.clearTimeout = function(cb) {\\r\\n  this.setTimeout(0, cb);\\r\\n};\\r\\n\",\"_http_common\":\"'use strict';\\r\\n\\r\\nvar FreeList = require('internal/freelist').FreeList;\\r\\nvar HTTPParser = process.binding('http_parser').HTTPParser;\\r\\n\\r\\nvar incoming = require('_http_incoming');\\r\\nvar IncomingMessage = incoming.IncomingMessage;\\r\\nvar readStart = incoming.readStart;\\r\\nvar readStop = incoming.readStop;\\r\\n\\r\\nvar debug = require('util').debuglog('http');\\r\\nexports.debug = debug;\\r\\n\\r\\nexports.CRLF = '\\\\r\\\\n';\\r\\nexports.chunkExpression = /chunk/i;\\r\\nexports.continueExpression = /100-continue/i;\\r\\nexports.methods = HTTPParser.methods;\\r\\n\\r\\nvar kOnHeaders = HTTPParser.kOnHeaders | 0;\\r\\nvar kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;\\r\\nvar kOnBody = HTTPParser.kOnBody | 0;\\r\\nvar kOnMessageComplete = HTTPParser.kOnMessageComplete | 0;\\r\\n\\r\\n// Only called in the slow case where slow means\\r\\n// that the request headers were either fragmented\\r\\n// across multiple TCP packets or too large to be\\r\\n// processed in a single run. This method is also\\r\\n// called to process trailing HTTP headers.\\r\\nfunction parserOnHeaders(headers, url) {\\r\\n  // Once we exceeded headers limit - stop collecting them\\r\\n  if (this.maxHeaderPairs <= 0 ||\\r\\n      this._headers.length < this.maxHeaderPairs) {\\r\\n    this._headers = this._headers.concat(headers);\\r\\n  }\\r\\n  this._url += url;\\r\\n}\\r\\n\\r\\n// `headers` and `url` are set only if .onHeaders() has not been called for\\r\\n// this request.\\r\\n// `url` is not set for response parsers but that's not applicable here since\\r\\n// all our parsers are request parsers.\\r\\nfunction parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\r\\n                                 url, statusCode, statusMessage, upgrade,\\r\\n                                 shouldKeepAlive) {\\r\\n  var parser = this;\\r\\n\\r\\n  if (!headers) {\\r\\n    headers = parser._headers;\\r\\n    parser._headers = [];\\r\\n  }\\r\\n\\r\\n  if (!url) {\\r\\n    url = parser._url;\\r\\n    parser._url = '';\\r\\n  }\\r\\n\\r\\n  parser.incoming = new IncomingMessage(parser.socket);\\r\\n  parser.incoming.httpVersionMajor = versionMajor;\\r\\n  parser.incoming.httpVersionMinor = versionMinor;\\r\\n  parser.incoming.httpVersion = versionMajor + '.' + versionMinor;\\r\\n  parser.incoming.url = url;\\r\\n\\r\\n  var n = headers.length;\\r\\n\\r\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\r\\n  if (parser.maxHeaderPairs > 0)\\r\\n    n = Math.min(n, parser.maxHeaderPairs);\\r\\n\\r\\n  parser.incoming._addHeaderLines(headers, n);\\r\\n\\r\\n  if (typeof method === 'number') {\\r\\n    // server only\\r\\n    parser.incoming.method = HTTPParser.methods[method];\\r\\n  } else {\\r\\n    // client only\\r\\n    parser.incoming.statusCode = statusCode;\\r\\n    parser.incoming.statusMessage = statusMessage;\\r\\n  }\\r\\n\\r\\n  // The client made non-upgrade request, and server is just advertising\\r\\n  // supported protocols.\\r\\n  //\\r\\n  // See RFC7230 Section 6.7\\r\\n  //\\r\\n  // NOTE: RegExp below matches `upgrade` in `Connection: abc, upgrade, def`\\r\\n  // header.\\r\\n  if (upgrade &&\\r\\n      parser.outgoing !== null &&\\r\\n      (parser.outgoing._headers.upgrade === undefined ||\\r\\n       !/(^|\\\\W)upgrade(\\\\W|$)/i.test(parser.outgoing._headers.connection))) {\\r\\n    upgrade = false;\\r\\n  }\\r\\n\\r\\n  parser.incoming.upgrade = upgrade;\\r\\n\\r\\n  var skipBody = false; // response to HEAD or CONNECT\\r\\n\\r\\n  if (!upgrade) {\\r\\n    // For upgraded connections and CONNECT method request, we'll emit this\\r\\n    // after parser.execute so that we can capture the first part of the new\\r\\n    // protocol.\\r\\n    skipBody = parser.onIncoming(parser.incoming, shouldKeepAlive);\\r\\n  }\\r\\n\\r\\n  return skipBody;\\r\\n}\\r\\n\\r\\n// XXX This is a mess.\\r\\n// TODO: http.Parser should be a Writable emits request/response events.\\r\\nfunction parserOnBody(b, start, len) {\\r\\n  var parser = this;\\r\\n  var stream = parser.incoming;\\r\\n\\r\\n  // if the stream has already been removed, then drop it.\\r\\n  if (!stream)\\r\\n    return;\\r\\n\\r\\n  var socket = stream.socket;\\r\\n\\r\\n  // pretend this was the result of a stream._read call.\\r\\n  if (len > 0 && !stream._dumped) {\\r\\n    var slice = b.slice(start, start + len);\\r\\n    var ret = stream.push(slice);\\r\\n    if (!ret)\\r\\n      readStop(socket);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction parserOnMessageComplete() {\\r\\n  var parser = this;\\r\\n  var stream = parser.incoming;\\r\\n\\r\\n  if (stream) {\\r\\n    stream.complete = true;\\r\\n    // Emit any trailing headers.\\r\\n    var headers = parser._headers;\\r\\n    if (headers) {\\r\\n      parser.incoming._addHeaderLines(headers, headers.length);\\r\\n      parser._headers = [];\\r\\n      parser._url = '';\\r\\n    }\\r\\n\\r\\n    // For emit end event\\r\\n    stream.push(null);\\r\\n  }\\r\\n\\r\\n  // force to read the next incoming message\\r\\n  readStart(parser.socket);\\r\\n}\\r\\n\\r\\n\\r\\nvar parsers = new FreeList('parsers', 1000, function() {\\r\\n  var parser = new HTTPParser(HTTPParser.REQUEST);\\r\\n\\r\\n  parser._headers = [];\\r\\n  parser._url = '';\\r\\n  parser._consumed = false;\\r\\n\\r\\n  parser.socket = null;\\r\\n  parser.incoming = null;\\r\\n  parser.outgoing = null;\\r\\n\\r\\n  // Only called in the slow case where slow means\\r\\n  // that the request headers were either fragmented\\r\\n  // across multiple TCP packets or too large to be\\r\\n  // processed in a single run. This method is also\\r\\n  // called to process trailing HTTP headers.\\r\\n  parser[kOnHeaders] = parserOnHeaders;\\r\\n  parser[kOnHeadersComplete] = parserOnHeadersComplete;\\r\\n  parser[kOnBody] = parserOnBody;\\r\\n  parser[kOnMessageComplete] = parserOnMessageComplete;\\r\\n\\r\\n  return parser;\\r\\n});\\r\\nexports.parsers = parsers;\\r\\n\\r\\n\\r\\n// Free the parser and also break any links that it\\r\\n// might have to any other things.\\r\\n// TODO: All parser data should be attached to a\\r\\n// single object, so that it can be easily cleaned\\r\\n// up by doing `parser.data = {}`, which should\\r\\n// be done in FreeList.free.  `parsers.free(parser)`\\r\\n// should be all that is needed.\\r\\nfunction freeParser(parser, req, socket) {\\r\\n  if (parser) {\\r\\n    parser._headers = [];\\r\\n    parser.onIncoming = null;\\r\\n    if (parser._consumed)\\r\\n      parser.unconsume();\\r\\n    parser._consumed = false;\\r\\n    if (parser.socket)\\r\\n      parser.socket.parser = null;\\r\\n    parser.socket = null;\\r\\n    parser.incoming = null;\\r\\n    parser.outgoing = null;\\r\\n    if (parsers.free(parser) === false)\\r\\n      parser.close();\\r\\n    parser = null;\\r\\n  }\\r\\n  if (req) {\\r\\n    req.parser = null;\\r\\n  }\\r\\n  if (socket) {\\r\\n    socket.parser = null;\\r\\n  }\\r\\n}\\r\\nexports.freeParser = freeParser;\\r\\n\\r\\n\\r\\nfunction ondrain() {\\r\\n  if (this._httpMessage) this._httpMessage.emit('drain');\\r\\n}\\r\\n\\r\\n\\r\\nfunction httpSocketSetup(socket) {\\r\\n  socket.removeListener('drain', ondrain);\\r\\n  socket.on('drain', ondrain);\\r\\n}\\r\\nexports.httpSocketSetup = httpSocketSetup;\\r\\n\\r\\n/**\\r\\n * Verifies that the given val is a valid HTTP token\\r\\n * per the rules defined in RFC 7230\\r\\n **/\\r\\nvar token = /^[a-zA-Z0-9_!#$%&'*+.^`|~-]+$/;\\r\\nfunction checkIsHttpToken(val) {\\r\\n  return typeof val === 'string' && token.test(val);\\r\\n}\\r\\nexports._checkIsHttpToken = checkIsHttpToken;\\r\\n\",\"_http_incoming\":\"'use strict';\\r\\n\\r\\nvar util = require('util');\\r\\nvar Stream = require('stream');\\r\\n\\r\\nfunction readStart(socket) {\\r\\n  if (socket && !socket._paused && socket.readable)\\r\\n    socket.resume();\\r\\n}\\r\\nexports.readStart = readStart;\\r\\n\\r\\nfunction readStop(socket) {\\r\\n  if (socket)\\r\\n    socket.pause();\\r\\n}\\r\\nexports.readStop = readStop;\\r\\n\\r\\n\\r\\n/* Abstract base class for ServerRequest and ClientResponse. */\\r\\nfunction IncomingMessage(socket) {\\r\\n  Stream.Readable.call(this);\\r\\n\\r\\n  // XXX This implementation is kind of all over the place\\r\\n  // When the parser emits body chunks, they go in this list.\\r\\n  // _read() pulls them out, and when it finds EOF, it ends.\\r\\n\\r\\n  this.socket = socket;\\r\\n  this.connection = socket;\\r\\n\\r\\n  this.httpVersionMajor = null;\\r\\n  this.httpVersionMinor = null;\\r\\n  this.httpVersion = null;\\r\\n  this.complete = false;\\r\\n  this.headers = {};\\r\\n  this.rawHeaders = [];\\r\\n  this.trailers = {};\\r\\n  this.rawTrailers = [];\\r\\n\\r\\n  this.readable = true;\\r\\n\\r\\n  this.upgrade = null;\\r\\n\\r\\n  // request (server) only\\r\\n  this.url = '';\\r\\n  this.method = null;\\r\\n\\r\\n  // response (client) only\\r\\n  this.statusCode = null;\\r\\n  this.statusMessage = null;\\r\\n  this.client = socket;\\r\\n\\r\\n  // flag for backwards compatibility grossness.\\r\\n  this._consuming = false;\\r\\n\\r\\n  // flag for when we decide that this message cannot possibly be\\r\\n  // read by the user, so there's no point continuing to handle it.\\r\\n  this._dumped = false;\\r\\n}\\r\\nutil.inherits(IncomingMessage, Stream.Readable);\\r\\n\\r\\n\\r\\nexports.IncomingMessage = IncomingMessage;\\r\\n\\r\\n\\r\\nIncomingMessage.prototype.setTimeout = function(msecs, callback) {\\r\\n  if (callback)\\r\\n    this.on('timeout', callback);\\r\\n  this.socket.setTimeout(msecs);\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nIncomingMessage.prototype.read = function(n) {\\r\\n  this._consuming = true;\\r\\n  this.read = Stream.Readable.prototype.read;\\r\\n  return this.read(n);\\r\\n};\\r\\n\\r\\n\\r\\nIncomingMessage.prototype._read = function(n) {\\r\\n  // We actually do almost nothing here, because the parserOnBody\\r\\n  // function fills up our internal buffer directly.  However, we\\r\\n  // do need to unpause the underlying socket so that it flows.\\r\\n  if (this.socket.readable)\\r\\n    readStart(this.socket);\\r\\n};\\r\\n\\r\\n\\r\\n// It's possible that the socket will be destroyed, and removed from\\r\\n// any messages, before ever calling this.  In that case, just skip\\r\\n// it, since something else is destroying this connection anyway.\\r\\nIncomingMessage.prototype.destroy = function(error) {\\r\\n  if (this.socket)\\r\\n    this.socket.destroy(error);\\r\\n};\\r\\n\\r\\n\\r\\nIncomingMessage.prototype._addHeaderLines = function(headers, n) {\\r\\n  if (headers && headers.length) {\\r\\n    var raw, dest;\\r\\n    if (this.complete) {\\r\\n      raw = this.rawTrailers;\\r\\n      dest = this.trailers;\\r\\n    } else {\\r\\n      raw = this.rawHeaders;\\r\\n      dest = this.headers;\\r\\n    }\\r\\n\\r\\n    for (var i = 0; i < n; i += 2) {\\r\\n      var k = headers[i];\\r\\n      var v = headers[i + 1];\\r\\n      raw.push(k);\\r\\n      raw.push(v);\\r\\n      this._addHeaderLine(k, v, dest);\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\n// Add the given (field, value) pair to the message\\r\\n//\\r\\n// Per RFC2616, section 4.2 it is acceptable to join multiple instances of the\\r\\n// same header with a ', ' if the header in question supports specification of\\r\\n// multiple values this way. If not, we declare the first instance the winner\\r\\n// and drop the second. Extended header fields (those beginning with 'x-') are\\r\\n// always joined.\\r\\nIncomingMessage.prototype._addHeaderLine = function(field, value, dest) {\\r\\n  field = field.toLowerCase();\\r\\n  switch (field) {\\r\\n    // Array headers:\\r\\n    case 'set-cookie':\\r\\n      if (dest[field] !== undefined) {\\r\\n        dest[field].push(value);\\r\\n      } else {\\r\\n        dest[field] = [value];\\r\\n      }\\r\\n      break;\\r\\n\\r\\n    /* eslint-disable max-len */\\r\\n    // list is taken from:\\r\\n    // https://mxr.mozilla.org/mozilla/source/netwerk/protocol/http/src/nsHttpHeaderArray.cpp\\r\\n    /* eslint-enable max-len */\\r\\n    case 'content-type':\\r\\n    case 'content-length':\\r\\n    case 'user-agent':\\r\\n    case 'referer':\\r\\n    case 'host':\\r\\n    case 'authorization':\\r\\n    case 'proxy-authorization':\\r\\n    case 'if-modified-since':\\r\\n    case 'if-unmodified-since':\\r\\n    case 'from':\\r\\n    case 'location':\\r\\n    case 'max-forwards':\\r\\n    case 'retry-after':\\r\\n    case 'etag':\\r\\n    case 'last-modified':\\r\\n    case 'server':\\r\\n    case 'age':\\r\\n    case 'expires':\\r\\n      // drop duplicates\\r\\n      if (dest[field] === undefined)\\r\\n        dest[field] = value;\\r\\n      break;\\r\\n\\r\\n    default:\\r\\n      // make comma-separated list\\r\\n      if (dest[field] !== undefined) {\\r\\n        dest[field] += ', ' + value;\\r\\n      } else {\\r\\n        dest[field] = value;\\r\\n      }\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\n// Call this instead of resume() if we want to just\\r\\n// dump all the data to /dev/null\\r\\nIncomingMessage.prototype._dump = function() {\\r\\n  if (!this._dumped) {\\r\\n    this._dumped = true;\\r\\n    this.resume();\\r\\n  }\\r\\n};\\r\\n\",\"_http_outgoing\":\"'use strict';\\r\\n\\r\\nvar assert = require('assert').ok;\\r\\nvar Stream = require('stream');\\r\\nvar timers = require('timers');\\r\\nvar util = require('util');\\r\\nvar internalUtil = require('internal/util');\\r\\nvar Buffer = require('buffer').Buffer;\\r\\nvar common = require('_http_common');\\r\\n\\r\\nvar CRLF = common.CRLF;\\r\\nvar chunkExpression = common.chunkExpression;\\r\\nvar debug = common.debug;\\r\\n\\r\\nvar connectionExpression = /^Connection$/i;\\r\\nvar transferEncodingExpression = /^Transfer-Encoding$/i;\\r\\nvar closeExpression = /close/i;\\r\\nvar contentLengthExpression = /^Content-Length$/i;\\r\\nvar dateExpression = /^Date$/i;\\r\\nvar expectExpression = /^Expect$/i;\\r\\nvar trailerExpression = /^Trailer$/i;\\r\\n\\r\\nvar automaticHeaders = {\\r\\n  connection: true,\\r\\n  'content-length': true,\\r\\n  'transfer-encoding': true,\\r\\n  date: true\\r\\n};\\r\\n\\r\\n\\r\\nvar dateCache;\\r\\nfunction utcDate() {\\r\\n  if (!dateCache) {\\r\\n    var d = new Date();\\r\\n    dateCache = d.toUTCString();\\r\\n    timers.enroll(utcDate, 1000 - d.getMilliseconds());\\r\\n    timers._unrefActive(utcDate);\\r\\n  }\\r\\n  return dateCache;\\r\\n}\\r\\nutcDate._onTimeout = function() {\\r\\n  dateCache = undefined;\\r\\n};\\r\\n\\r\\n\\r\\nfunction OutgoingMessage() {\\r\\n  Stream.call(this);\\r\\n\\r\\n  // Queue that holds all currently pending data, until the response will be\\r\\n  // assigned to the socket (until it will its turn in the HTTP pipeline).\\r\\n  this.output = [];\\r\\n  this.outputEncodings = [];\\r\\n  this.outputCallbacks = [];\\r\\n\\r\\n  // `outputSize` is an approximate measure of how much data is queued on this\\r\\n  // response. `_onPendingData` will be invoked to update similar global\\r\\n  // per-connection counter. That counter will be used to pause/unpause the\\r\\n  // TCP socket and HTTP Parser and thus handle the backpressure.\\r\\n  this.outputSize = 0;\\r\\n\\r\\n  this.writable = true;\\r\\n\\r\\n  this._last = false;\\r\\n  this.chunkedEncoding = false;\\r\\n  this.shouldKeepAlive = true;\\r\\n  this.useChunkedEncodingByDefault = true;\\r\\n  this.sendDate = false;\\r\\n  this._removedHeader = {};\\r\\n\\r\\n  this._contentLength = null;\\r\\n  this._hasBody = true;\\r\\n  this._trailer = '';\\r\\n\\r\\n  this.finished = false;\\r\\n  this._headerSent = false;\\r\\n\\r\\n  this.socket = null;\\r\\n  this.connection = null;\\r\\n  this._header = null;\\r\\n  this._headers = null;\\r\\n  this._headerNames = {};\\r\\n\\r\\n  this._onPendingData = null;\\r\\n}\\r\\nutil.inherits(OutgoingMessage, Stream);\\r\\n\\r\\n\\r\\nexports.OutgoingMessage = OutgoingMessage;\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype.setTimeout = function(msecs, callback) {\\r\\n\\r\\n  if (callback) {\\r\\n    this.on('timeout', callback);\\r\\n  }\\r\\n\\r\\n  if (!this.socket) {\\r\\n    this.once('socket', function(socket) {\\r\\n      socket.setTimeout(msecs);\\r\\n    });\\r\\n  } else {\\r\\n    this.socket.setTimeout(msecs);\\r\\n  }\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\n// It's possible that the socket will be destroyed, and removed from\\r\\n// any messages, before ever calling this.  In that case, just skip\\r\\n// it, since something else is destroying this connection anyway.\\r\\nOutgoingMessage.prototype.destroy = function(error) {\\r\\n  if (this.socket)\\r\\n    this.socket.destroy(error);\\r\\n  else\\r\\n    this.once('socket', function(socket) {\\r\\n      socket.destroy(error);\\r\\n    });\\r\\n};\\r\\n\\r\\n\\r\\n// This abstract either writing directly to the socket or buffering it.\\r\\nOutgoingMessage.prototype._send = function(data, encoding, callback) {\\r\\n  // This is a shameful hack to get the headers and first body chunk onto\\r\\n  // the same packet. Future versions of Node are going to take care of\\r\\n  // this at a lower level and in a more general way.\\r\\n  if (!this._headerSent) {\\r\\n    if (typeof data === 'string' &&\\r\\n        encoding !== 'hex' &&\\r\\n        encoding !== 'base64') {\\r\\n      data = this._header + data;\\r\\n    } else {\\r\\n      this.output.unshift(this._header);\\r\\n      this.outputEncodings.unshift('binary');\\r\\n      this.outputCallbacks.unshift(null);\\r\\n      this.outputSize += this._header.length;\\r\\n      if (typeof this._onPendingData === 'function')\\r\\n        this._onPendingData(this._header.length);\\r\\n    }\\r\\n    this._headerSent = true;\\r\\n  }\\r\\n  return this._writeRaw(data, encoding, callback);\\r\\n};\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype._writeRaw = function(data, encoding, callback) {\\r\\n  if (typeof encoding === 'function') {\\r\\n    callback = encoding;\\r\\n    encoding = null;\\r\\n  }\\r\\n\\r\\n  var connection = this.connection;\\r\\n  if (connection &&\\r\\n      connection._httpMessage === this &&\\r\\n      connection.writable &&\\r\\n      !connection.destroyed) {\\r\\n    // There might be pending data in the this.output buffer.\\r\\n    var outputLength = this.output.length;\\r\\n    if (outputLength > 0) {\\r\\n      this._flushOutput(connection);\\r\\n    } else if (data.length === 0) {\\r\\n      if (typeof callback === 'function')\\r\\n        process.nextTick(callback);\\r\\n      return true;\\r\\n    }\\r\\n\\r\\n    // Directly write to socket.\\r\\n    return connection.write(data, encoding, callback);\\r\\n  } else if (connection && connection.destroyed) {\\r\\n    // The socket was destroyed.  If we're still trying to write to it,\\r\\n    // then we haven't gotten the 'close' event yet.\\r\\n    return false;\\r\\n  } else {\\r\\n    // buffer, as long as we're not destroyed.\\r\\n    return this._buffer(data, encoding, callback);\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype._buffer = function(data, encoding, callback) {\\r\\n  this.output.push(data);\\r\\n  this.outputEncodings.push(encoding);\\r\\n  this.outputCallbacks.push(callback);\\r\\n  this.outputSize += data.length;\\r\\n  if (typeof this._onPendingData === 'function')\\r\\n    this._onPendingData(data.length);\\r\\n  return false;\\r\\n};\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype._storeHeader = function(firstLine, headers) {\\r\\n  // firstLine in the case of request is: 'GET /index.html HTTP/1.1\\\\r\\\\n'\\r\\n  // in the case of response it is: 'HTTP/1.1 200 OK\\\\r\\\\n'\\r\\n  var state = {\\r\\n    sentConnectionHeader: false,\\r\\n    sentContentLengthHeader: false,\\r\\n    sentTransferEncodingHeader: false,\\r\\n    sentDateHeader: false,\\r\\n    sentExpect: false,\\r\\n    sentTrailer: false,\\r\\n    messageHeader: firstLine\\r\\n  };\\r\\n\\r\\n  if (headers) {\\r\\n    var keys = Object.keys(headers);\\r\\n    var isArray = Array.isArray(headers);\\r\\n    var field, value;\\r\\n\\r\\n    for (var i = 0, l = keys.length; i < l; i++) {\\r\\n      var key = keys[i];\\r\\n      if (isArray) {\\r\\n        field = headers[key][0];\\r\\n        value = headers[key][1];\\r\\n      } else {\\r\\n        field = key;\\r\\n        value = headers[key];\\r\\n      }\\r\\n\\r\\n      if (Array.isArray(value)) {\\r\\n        for (var j = 0; j < value.length; j++) {\\r\\n          storeHeader(this, state, field, value[j]);\\r\\n        }\\r\\n      } else {\\r\\n        storeHeader(this, state, field, value);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // Date header\\r\\n  if (this.sendDate === true && state.sentDateHeader === false) {\\r\\n    state.messageHeader += 'Date: ' + utcDate() + CRLF;\\r\\n  }\\r\\n\\r\\n  // Force the connection to close when the response is a 204 No Content or\\r\\n  // a 304 Not Modified and the user has set a \\\"Transfer-Encoding: chunked\\\"\\r\\n  // header.\\r\\n  //\\r\\n  // RFC 2616 mandates that 204 and 304 responses MUST NOT have a body but\\r\\n  // node.js used to send out a zero chunk anyway to accommodate clients\\r\\n  // that don't have special handling for those responses.\\r\\n  //\\r\\n  // It was pointed out that this might confuse reverse proxies to the point\\r\\n  // of creating security liabilities, so suppress the zero chunk and force\\r\\n  // the connection to close.\\r\\n  var statusCode = this.statusCode;\\r\\n  if ((statusCode === 204 || statusCode === 304) &&\\r\\n      this.chunkedEncoding === true) {\\r\\n    debug(statusCode + ' response should not use chunked encoding,' +\\r\\n          ' closing connection.');\\r\\n    this.chunkedEncoding = false;\\r\\n    this.shouldKeepAlive = false;\\r\\n  }\\r\\n\\r\\n  // keep-alive logic\\r\\n  if (this._removedHeader.connection) {\\r\\n    this._last = true;\\r\\n    this.shouldKeepAlive = false;\\r\\n  } else if (state.sentConnectionHeader === false) {\\r\\n    var shouldSendKeepAlive = this.shouldKeepAlive &&\\r\\n        (state.sentContentLengthHeader ||\\r\\n         this.useChunkedEncodingByDefault ||\\r\\n         this.agent);\\r\\n    if (shouldSendKeepAlive) {\\r\\n      state.messageHeader += 'Connection: keep-alive\\\\r\\\\n';\\r\\n    } else {\\r\\n      this._last = true;\\r\\n      state.messageHeader += 'Connection: close\\\\r\\\\n';\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (state.sentContentLengthHeader === false &&\\r\\n      state.sentTransferEncodingHeader === false) {\\r\\n    if (!this._hasBody) {\\r\\n      // Make sure we don't end the 0\\\\r\\\\n\\\\r\\\\n at the end of the message.\\r\\n      this.chunkedEncoding = false;\\r\\n    } else if (!this.useChunkedEncodingByDefault) {\\r\\n      this._last = true;\\r\\n    } else {\\r\\n      if (!state.sentTrailer &&\\r\\n          !this._removedHeader['content-length'] &&\\r\\n          typeof this._contentLength === 'number') {\\r\\n        state.messageHeader += 'Content-Length: ' + this._contentLength +\\r\\n                               '\\\\r\\\\n';\\r\\n      } else if (!this._removedHeader['transfer-encoding']) {\\r\\n        state.messageHeader += 'Transfer-Encoding: chunked\\\\r\\\\n';\\r\\n        this.chunkedEncoding = true;\\r\\n      } else {\\r\\n        // We should only be able to get here if both Content-Length and\\r\\n        // Transfer-Encoding are removed by the user.\\r\\n        // See: test/parallel/test-http-remove-header-stays-removed.js\\r\\n        debug('Both Content-Length and Transfer-Encoding are removed');\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  this._header = state.messageHeader + CRLF;\\r\\n  this._headerSent = false;\\r\\n\\r\\n  // wait until the first body chunk, or close(), is sent to flush,\\r\\n  // UNLESS we're sending Expect: 100-continue.\\r\\n  if (state.sentExpect) this._send('');\\r\\n};\\r\\n\\r\\nfunction storeHeader(self, state, field, value) {\\r\\n  if (!common._checkIsHttpToken(field)) {\\r\\n    throw new TypeError(\\r\\n      'Header name must be a valid HTTP Token [\\\"' + field + '\\\"]');\\r\\n  }\\r\\n  value = escapeHeaderValue(value);\\r\\n  state.messageHeader += field + ': ' + value + CRLF;\\r\\n\\r\\n  if (connectionExpression.test(field)) {\\r\\n    state.sentConnectionHeader = true;\\r\\n    if (closeExpression.test(value)) {\\r\\n      self._last = true;\\r\\n    } else {\\r\\n      self.shouldKeepAlive = true;\\r\\n    }\\r\\n\\r\\n  } else if (transferEncodingExpression.test(field)) {\\r\\n    state.sentTransferEncodingHeader = true;\\r\\n    if (chunkExpression.test(value)) self.chunkedEncoding = true;\\r\\n\\r\\n  } else if (contentLengthExpression.test(field)) {\\r\\n    state.sentContentLengthHeader = true;\\r\\n  } else if (dateExpression.test(field)) {\\r\\n    state.sentDateHeader = true;\\r\\n  } else if (expectExpression.test(field)) {\\r\\n    state.sentExpect = true;\\r\\n  } else if (trailerExpression.test(field)) {\\r\\n    state.sentTrailer = true;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype.setHeader = function(name, value) {\\r\\n  if (!common._checkIsHttpToken(name))\\r\\n    throw new TypeError(\\r\\n      'Header name must be a valid HTTP Token [\\\"' + name + '\\\"]');\\r\\n  if (typeof name !== 'string')\\r\\n    throw new TypeError('\\\"name\\\" should be a string in setHeader(name, value)');\\r\\n  if (value === undefined)\\r\\n    throw new Error('\\\"value\\\" required in setHeader(\\\"' + name + '\\\", value)');\\r\\n  if (this._header)\\r\\n    throw new Error('Can\\\\'t set headers after they are sent');\\r\\n\\r\\n  if (this._headers === null)\\r\\n    this._headers = {};\\r\\n\\r\\n  var key = name.toLowerCase();\\r\\n  this._headers[key] = value;\\r\\n  this._headerNames[key] = name;\\r\\n\\r\\n  if (automaticHeaders[key])\\r\\n    this._removedHeader[key] = false;\\r\\n};\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype.getHeader = function(name) {\\r\\n  if (arguments.length < 1) {\\r\\n    throw new Error('\\\"name\\\" argument is required for getHeader(name)');\\r\\n  }\\r\\n\\r\\n  if (!this._headers) return;\\r\\n\\r\\n  var key = name.toLowerCase();\\r\\n  return this._headers[key];\\r\\n};\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype.removeHeader = function(name) {\\r\\n  if (arguments.length < 1) {\\r\\n    throw new Error('\\\"name\\\" argument is required for removeHeader(name)');\\r\\n  }\\r\\n\\r\\n  if (this._header) {\\r\\n    throw new Error('Can\\\\'t remove headers after they are sent');\\r\\n  }\\r\\n\\r\\n  var key = name.toLowerCase();\\r\\n\\r\\n  if (key === 'date')\\r\\n    this.sendDate = false;\\r\\n  else if (automaticHeaders[key])\\r\\n    this._removedHeader[key] = true;\\r\\n\\r\\n  if (this._headers) {\\r\\n    delete this._headers[key];\\r\\n    delete this._headerNames[key];\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype._renderHeaders = function() {\\r\\n  if (this._header) {\\r\\n    throw new Error('Can\\\\'t render headers after they are sent to the client');\\r\\n  }\\r\\n\\r\\n  var headersMap = this._headers;\\r\\n  if (!headersMap) return {};\\r\\n\\r\\n  var headers = {};\\r\\n  var keys = Object.keys(headersMap);\\r\\n  var headerNames = this._headerNames;\\r\\n\\r\\n  for (var i = 0, l = keys.length; i < l; i++) {\\r\\n    var key = keys[i];\\r\\n    headers[headerNames[key]] = headersMap[key];\\r\\n  }\\r\\n  return headers;\\r\\n};\\r\\n\\r\\n\\r\\nObject.defineProperty(OutgoingMessage.prototype, 'headersSent', {\\r\\n  configurable: true,\\r\\n  enumerable: true,\\r\\n  get: function() { return !!this._header; }\\r\\n});\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype.write = function(chunk, encoding, callback) {\\r\\n  if (this.finished) {\\r\\n    var err = new Error('write after end');\\r\\n    process.nextTick(writeAfterEndNT, this, err, callback);\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  if (!this._header) {\\r\\n    this._implicitHeader();\\r\\n  }\\r\\n\\r\\n  if (!this._hasBody) {\\r\\n    debug('This type of response MUST NOT have a body. ' +\\r\\n          'Ignoring write() calls.');\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  if (typeof chunk !== 'string' && !(chunk instanceof Buffer)) {\\r\\n    throw new TypeError('First argument must be a string or Buffer');\\r\\n  }\\r\\n\\r\\n\\r\\n  // If we get an empty string or buffer, then just do nothing, and\\r\\n  // signal the user to keep writing.\\r\\n  if (chunk.length === 0) return true;\\r\\n\\r\\n  var len, ret;\\r\\n  if (this.chunkedEncoding) {\\r\\n    if (typeof chunk === 'string' &&\\r\\n        encoding !== 'hex' &&\\r\\n        encoding !== 'base64' &&\\r\\n        encoding !== 'binary') {\\r\\n      len = Buffer.byteLength(chunk, encoding);\\r\\n      chunk = len.toString(16) + CRLF + chunk + CRLF;\\r\\n      ret = this._send(chunk, encoding, callback);\\r\\n    } else {\\r\\n      // buffer, or a non-toString-friendly encoding\\r\\n      if (typeof chunk === 'string')\\r\\n        len = Buffer.byteLength(chunk, encoding);\\r\\n      else\\r\\n        len = chunk.length;\\r\\n\\r\\n      if (this.connection && !this.connection.corked) {\\r\\n        this.connection.cork();\\r\\n        process.nextTick(connectionCorkNT, this.connection);\\r\\n      }\\r\\n      this._send(len.toString(16), 'binary', null);\\r\\n      this._send(crlf_buf, null, null);\\r\\n      this._send(chunk, encoding, null);\\r\\n      ret = this._send(crlf_buf, null, callback);\\r\\n    }\\r\\n  } else {\\r\\n    ret = this._send(chunk, encoding, callback);\\r\\n  }\\r\\n\\r\\n  debug('write ret = ' + ret);\\r\\n  return ret;\\r\\n};\\r\\n\\r\\n\\r\\nfunction writeAfterEndNT(self, err, callback) {\\r\\n  self.emit('error', err);\\r\\n  if (callback) callback(err);\\r\\n}\\r\\n\\r\\n\\r\\nfunction connectionCorkNT(conn) {\\r\\n  if (conn)\\r\\n    conn.uncork();\\r\\n}\\r\\n\\r\\n\\r\\nfunction escapeHeaderValue(value) {\\r\\n  // Protect against response splitting. The regex test is there to\\r\\n  // minimize the performance impact in the common case.\\r\\n  return /[\\\\r\\\\n]/.test(value) ? value.replace(/[\\\\r\\\\n]+[ \\\\t]*/g, '') : value;\\r\\n}\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype.addTrailers = function(headers) {\\r\\n  this._trailer = '';\\r\\n  var keys = Object.keys(headers);\\r\\n  var isArray = Array.isArray(headers);\\r\\n  var field, value;\\r\\n  for (var i = 0, l = keys.length; i < l; i++) {\\r\\n    var key = keys[i];\\r\\n    if (isArray) {\\r\\n      field = headers[key][0];\\r\\n      value = headers[key][1];\\r\\n    } else {\\r\\n      field = key;\\r\\n      value = headers[key];\\r\\n    }\\r\\n    if (!common._checkIsHttpToken(field)) {\\r\\n      throw new TypeError(\\r\\n        'Trailer name must be a valid HTTP Token [\\\"' + field + '\\\"]');\\r\\n    }\\r\\n    this._trailer += field + ': ' + escapeHeaderValue(value) + CRLF;\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nvar crlf_buf = new Buffer('\\\\r\\\\n');\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype.end = function(data, encoding, callback) {\\r\\n  if (typeof data === 'function') {\\r\\n    callback = data;\\r\\n    data = null;\\r\\n  } else if (typeof encoding === 'function') {\\r\\n    callback = encoding;\\r\\n    encoding = null;\\r\\n  }\\r\\n\\r\\n  if (data && typeof data !== 'string' && !(data instanceof Buffer)) {\\r\\n    throw new TypeError('First argument must be a string or Buffer');\\r\\n  }\\r\\n\\r\\n  if (this.finished) {\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  var self = this;\\r\\n  function finish() {\\r\\n    self.emit('finish');\\r\\n  }\\r\\n\\r\\n  if (typeof callback === 'function')\\r\\n    this.once('finish', callback);\\r\\n\\r\\n  if (!this._header) {\\r\\n    if (data) {\\r\\n      if (typeof data === 'string')\\r\\n        this._contentLength = Buffer.byteLength(data, encoding);\\r\\n      else\\r\\n        this._contentLength = data.length;\\r\\n    } else {\\r\\n      this._contentLength = 0;\\r\\n    }\\r\\n    this._implicitHeader();\\r\\n  }\\r\\n\\r\\n  if (data && !this._hasBody) {\\r\\n    debug('This type of response MUST NOT have a body. ' +\\r\\n          'Ignoring data passed to end().');\\r\\n    data = null;\\r\\n  }\\r\\n\\r\\n  if (this.connection && data)\\r\\n    this.connection.cork();\\r\\n\\r\\n  var ret;\\r\\n  if (data) {\\r\\n    // Normal body write.\\r\\n    this.write(data, encoding);\\r\\n  }\\r\\n\\r\\n  if (this._hasBody && this.chunkedEncoding) {\\r\\n    ret = this._send('0\\\\r\\\\n' + this._trailer + '\\\\r\\\\n', 'binary', finish);\\r\\n  } else {\\r\\n    // Force a flush, HACK.\\r\\n    ret = this._send('', 'binary', finish);\\r\\n  }\\r\\n\\r\\n  if (this.connection && data)\\r\\n    this.connection.uncork();\\r\\n\\r\\n  this.finished = true;\\r\\n\\r\\n  // There is the first message on the outgoing queue, and we've sent\\r\\n  // everything to the socket.\\r\\n  debug('outgoing message end.');\\r\\n  if (this.output.length === 0 &&\\r\\n      this.connection &&\\r\\n      this.connection._httpMessage === this) {\\r\\n    this._finish();\\r\\n  }\\r\\n\\r\\n  return ret;\\r\\n};\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype._finish = function() {\\r\\n  assert(this.connection);\\r\\n  this.emit('prefinish');\\r\\n};\\r\\n\\r\\n\\r\\n// This logic is probably a bit confusing. Let me explain a bit:\\r\\n//\\r\\n// In both HTTP servers and clients it is possible to queue up several\\r\\n// outgoing messages. This is easiest to imagine in the case of a client.\\r\\n// Take the following situation:\\r\\n//\\r\\n//    req1 = client.request('GET', '/');\\r\\n//    req2 = client.request('POST', '/');\\r\\n//\\r\\n// When the user does\\r\\n//\\r\\n//   req2.write('hello world\\\\n');\\r\\n//\\r\\n// it's possible that the first request has not been completely flushed to\\r\\n// the socket yet. Thus the outgoing messages need to be prepared to queue\\r\\n// up data internally before sending it on further to the socket's queue.\\r\\n//\\r\\n// This function, outgoingFlush(), is called by both the Server and Client\\r\\n// to attempt to flush any pending messages out to the socket.\\r\\nOutgoingMessage.prototype._flush = function() {\\r\\n  var socket = this.socket;\\r\\n  var ret;\\r\\n\\r\\n  if (socket && socket.writable) {\\r\\n    // There might be remaining data in this.output; write it out\\r\\n    ret = this._flushOutput(socket);\\r\\n\\r\\n    if (this.finished) {\\r\\n      // This is a queue to the server or client to bring in the next this.\\r\\n      this._finish();\\r\\n    } else if (ret) {\\r\\n      // This is necessary to prevent https from breaking\\r\\n      this.emit('drain');\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nOutgoingMessage.prototype._flushOutput = function _flushOutput(socket) {\\r\\n  var ret;\\r\\n  var outputLength = this.output.length;\\r\\n  if (outputLength <= 0)\\r\\n    return ret;\\r\\n\\r\\n  var output = this.output;\\r\\n  var outputEncodings = this.outputEncodings;\\r\\n  var outputCallbacks = this.outputCallbacks;\\r\\n  socket.cork();\\r\\n  for (var i = 0; i < outputLength; i++) {\\r\\n    ret = socket.write(output[i], outputEncodings[i],\\r\\n                       outputCallbacks[i]);\\r\\n  }\\r\\n  socket.uncork();\\r\\n\\r\\n  this.output = [];\\r\\n  this.outputEncodings = [];\\r\\n  this.outputCallbacks = [];\\r\\n  if (typeof this._onPendingData === 'function')\\r\\n    this._onPendingData(-this.outputSize);\\r\\n  this.outputSize = 0;\\r\\n\\r\\n  return ret;\\r\\n};\\r\\n\\r\\n\\r\\nOutgoingMessage.prototype.flushHeaders = function() {\\r\\n  if (!this._header) {\\r\\n    this._implicitHeader();\\r\\n  }\\r\\n\\r\\n  // Force-flush the headers.\\r\\n  this._send('');\\r\\n};\\r\\n\\r\\nOutgoingMessage.prototype.flush = internalUtil.deprecate(function() {\\r\\n  this.flushHeaders();\\r\\n}, 'OutgoingMessage.flush is deprecated. Use flushHeaders instead.');\\r\\n\",\"_http_server\":\"'use strict';\\r\\n\\r\\nvar util = require('util');\\r\\nvar net = require('net');\\r\\nvar EventEmitter = require('events');\\r\\nvar HTTPParser = process.binding('http_parser').HTTPParser;\\r\\nvar assert = require('assert').ok;\\r\\nvar common = require('_http_common');\\r\\nvar parsers = common.parsers;\\r\\nvar freeParser = common.freeParser;\\r\\nvar debug = common.debug;\\r\\nvar CRLF = common.CRLF;\\r\\nvar continueExpression = common.continueExpression;\\r\\nvar chunkExpression = common.chunkExpression;\\r\\nvar httpSocketSetup = common.httpSocketSetup;\\r\\nvar OutgoingMessage = require('_http_outgoing').OutgoingMessage;\\r\\n\\r\\nvar STATUS_CODES = exports.STATUS_CODES = {\\r\\n  100 : 'Continue',\\r\\n  101 : 'Switching Protocols',\\r\\n  102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918\\r\\n  200 : 'OK',\\r\\n  201 : 'Created',\\r\\n  202 : 'Accepted',\\r\\n  203 : 'Non-Authoritative Information',\\r\\n  204 : 'No Content',\\r\\n  205 : 'Reset Content',\\r\\n  206 : 'Partial Content',\\r\\n  207 : 'Multi-Status',               // RFC 4918\\r\\n  208 : 'Already Reported',\\r\\n  226 : 'IM Used',\\r\\n  300 : 'Multiple Choices',\\r\\n  301 : 'Moved Permanently',\\r\\n  302 : 'Found',\\r\\n  303 : 'See Other',\\r\\n  304 : 'Not Modified',\\r\\n  305 : 'Use Proxy',\\r\\n  307 : 'Temporary Redirect',\\r\\n  308 : 'Permanent Redirect',         // RFC 7238\\r\\n  400 : 'Bad Request',\\r\\n  401 : 'Unauthorized',\\r\\n  402 : 'Payment Required',\\r\\n  403 : 'Forbidden',\\r\\n  404 : 'Not Found',\\r\\n  405 : 'Method Not Allowed',\\r\\n  406 : 'Not Acceptable',\\r\\n  407 : 'Proxy Authentication Required',\\r\\n  408 : 'Request Timeout',\\r\\n  409 : 'Conflict',\\r\\n  410 : 'Gone',\\r\\n  411 : 'Length Required',\\r\\n  412 : 'Precondition Failed',\\r\\n  413 : 'Payload Too Large',\\r\\n  414 : 'URI Too Long',\\r\\n  415 : 'Unsupported Media Type',\\r\\n  416 : 'Range Not Satisfiable',\\r\\n  417 : 'Expectation Failed',\\r\\n  418 : 'I\\\\'m a teapot',              // RFC 2324\\r\\n  421 : 'Misdirected Request',\\r\\n  422 : 'Unprocessable Entity',       // RFC 4918\\r\\n  423 : 'Locked',                     // RFC 4918\\r\\n  424 : 'Failed Dependency',          // RFC 4918\\r\\n  425 : 'Unordered Collection',       // RFC 4918\\r\\n  426 : 'Upgrade Required',           // RFC 2817\\r\\n  428 : 'Precondition Required',      // RFC 6585\\r\\n  429 : 'Too Many Requests',          // RFC 6585\\r\\n  431 : 'Request Header Fields Too Large',// RFC 6585\\r\\n  500 : 'Internal Server Error',\\r\\n  501 : 'Not Implemented',\\r\\n  502 : 'Bad Gateway',\\r\\n  503 : 'Service Unavailable',\\r\\n  504 : 'Gateway Timeout',\\r\\n  505 : 'HTTP Version Not Supported',\\r\\n  506 : 'Variant Also Negotiates',    // RFC 2295\\r\\n  507 : 'Insufficient Storage',       // RFC 4918\\r\\n  508 : 'Loop Detected',\\r\\n  509 : 'Bandwidth Limit Exceeded',\\r\\n  510 : 'Not Extended',               // RFC 2774\\r\\n  511 : 'Network Authentication Required' // RFC 6585\\r\\n};\\r\\n\\r\\nvar kOnExecute = HTTPParser.kOnExecute | 0;\\r\\n\\r\\n\\r\\nfunction ServerResponse(req) {\\r\\n  OutgoingMessage.call(this);\\r\\n\\r\\n  if (req.method === 'HEAD') this._hasBody = false;\\r\\n\\r\\n  this.sendDate = true;\\r\\n\\r\\n  if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {\\r\\n    this.useChunkedEncodingByDefault = chunkExpression.test(req.headers.te);\\r\\n    this.shouldKeepAlive = false;\\r\\n  }\\r\\n}\\r\\nutil.inherits(ServerResponse, OutgoingMessage);\\r\\n\\r\\nServerResponse.prototype._finish = function() {\\r\\n  DTRACE_HTTP_SERVER_RESPONSE(this.connection);\\r\\n  LTTNG_HTTP_SERVER_RESPONSE(this.connection);\\r\\n  COUNTER_HTTP_SERVER_RESPONSE();\\r\\n  OutgoingMessage.prototype._finish.call(this);\\r\\n};\\r\\n\\r\\n\\r\\nexports.ServerResponse = ServerResponse;\\r\\n\\r\\nServerResponse.prototype.statusCode = 200;\\r\\nServerResponse.prototype.statusMessage = undefined;\\r\\n\\r\\nfunction onServerResponseClose() {\\r\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\r\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\r\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\r\\n  // listener, onServerResponseClose is still in that copy of the listeners\\r\\n  // array. That is, in the example below, b still gets called even though\\r\\n  // it's been removed by a:\\r\\n  //\\r\\n  //   var EventEmitter = require('events');\\r\\n  //   var obj = new EventEmitter();\\r\\n  //   obj.on('event', a);\\r\\n  //   obj.on('event', b);\\r\\n  //   function a() { obj.removeListener('event', b) }\\r\\n  //   function b() { throw \\\"BAM!\\\" }\\r\\n  //   obj.emit('event');  // throws\\r\\n  //\\r\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\r\\n  // where the ServerResponse object has already been deconstructed.\\r\\n  // Fortunately, that requires only a single if check. :-)\\r\\n  if (this._httpMessage) this._httpMessage.emit('close');\\r\\n}\\r\\n\\r\\nServerResponse.prototype.assignSocket = function(socket) {\\r\\n  assert(!socket._httpMessage);\\r\\n  socket._httpMessage = this;\\r\\n  socket.on('close', onServerResponseClose);\\r\\n  this.socket = socket;\\r\\n  this.connection = socket;\\r\\n  this.emit('socket', socket);\\r\\n  this._flush();\\r\\n};\\r\\n\\r\\nServerResponse.prototype.detachSocket = function(socket) {\\r\\n  assert(socket._httpMessage === this);\\r\\n  socket.removeListener('close', onServerResponseClose);\\r\\n  socket._httpMessage = null;\\r\\n  this.socket = this.connection = null;\\r\\n};\\r\\n\\r\\nServerResponse.prototype.writeContinue = function(cb) {\\r\\n  this._writeRaw('HTTP/1.1 100 Continue' + CRLF + CRLF, 'ascii', cb);\\r\\n  this._sent100 = true;\\r\\n};\\r\\n\\r\\nServerResponse.prototype._implicitHeader = function() {\\r\\n  this.writeHead(this.statusCode);\\r\\n};\\r\\n\\r\\nServerResponse.prototype.writeHead = function(statusCode, reason, obj) {\\r\\n  var headers;\\r\\n\\r\\n  if (typeof reason === 'string') {\\r\\n    // writeHead(statusCode, reasonPhrase[, headers])\\r\\n    this.statusMessage = reason;\\r\\n  } else {\\r\\n    // writeHead(statusCode[, headers])\\r\\n    this.statusMessage =\\r\\n        this.statusMessage || STATUS_CODES[statusCode] || 'unknown';\\r\\n    obj = reason;\\r\\n  }\\r\\n  this.statusCode = statusCode;\\r\\n\\r\\n  if (this._headers) {\\r\\n    // Slow-case: when progressive API and header fields are passed.\\r\\n    if (obj) {\\r\\n      var keys = Object.keys(obj);\\r\\n      for (var i = 0; i < keys.length; i++) {\\r\\n        var k = keys[i];\\r\\n        if (k) this.setHeader(k, obj[k]);\\r\\n      }\\r\\n    }\\r\\n    // only progressive api is used\\r\\n    headers = this._renderHeaders();\\r\\n  } else {\\r\\n    // only writeHead() called\\r\\n    headers = obj;\\r\\n  }\\r\\n\\r\\n  var statusLine = 'HTTP/1.1 ' + statusCode.toString() + ' ' +\\r\\n                   this.statusMessage + CRLF;\\r\\n\\r\\n  if (statusCode === 204 || statusCode === 304 ||\\r\\n      (100 <= statusCode && statusCode <= 199)) {\\r\\n    // RFC 2616, 10.2.5:\\r\\n    // The 204 response MUST NOT include a message-body, and thus is always\\r\\n    // terminated by the first empty line after the header fields.\\r\\n    // RFC 2616, 10.3.5:\\r\\n    // The 304 response MUST NOT contain a message-body, and thus is always\\r\\n    // terminated by the first empty line after the header fields.\\r\\n    // RFC 2616, 10.1 Informational 1xx:\\r\\n    // This class of status code indicates a provisional response,\\r\\n    // consisting only of the Status-Line and optional headers, and is\\r\\n    // terminated by an empty line.\\r\\n    this._hasBody = false;\\r\\n  }\\r\\n\\r\\n  // don't keep alive connections where the client expects 100 Continue\\r\\n  // but we sent a final status; they may put extra bytes on the wire.\\r\\n  if (this._expect_continue && !this._sent100) {\\r\\n    this.shouldKeepAlive = false;\\r\\n  }\\r\\n\\r\\n  this._storeHeader(statusLine, headers);\\r\\n};\\r\\n\\r\\nServerResponse.prototype.writeHeader = function() {\\r\\n  this.writeHead.apply(this, arguments);\\r\\n};\\r\\n\\r\\n\\r\\nfunction Server(requestListener) {\\r\\n  if (!(this instanceof Server)) return new Server(requestListener);\\r\\n  net.Server.call(this, { allowHalfOpen: true });\\r\\n\\r\\n  if (requestListener) {\\r\\n    this.addListener('request', requestListener);\\r\\n  }\\r\\n\\r\\n  /* eslint-disable max-len */\\r\\n  // Similar option to this. Too lazy to write my own docs.\\r\\n  // http://www.squid-cache.org/Doc/config/half_closed_clients/\\r\\n  // http://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\\r\\n  /* eslint-enable max-len */\\r\\n  this.httpAllowHalfOpen = false;\\r\\n\\r\\n  this.addListener('connection', connectionListener);\\r\\n\\r\\n  this.addListener('clientError', function(err, conn) {\\r\\n    conn.destroy(err);\\r\\n  });\\r\\n\\r\\n  this.timeout = 2 * 60 * 1000;\\r\\n\\r\\n  this._pendingResponseData = 0;\\r\\n}\\r\\nutil.inherits(Server, net.Server);\\r\\n\\r\\n\\r\\nServer.prototype.setTimeout = function(msecs, callback) {\\r\\n  this.timeout = msecs;\\r\\n  if (callback)\\r\\n    this.on('timeout', callback);\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nexports.Server = Server;\\r\\n\\r\\n\\r\\nfunction connectionListener(socket) {\\r\\n  var self = this;\\r\\n  var outgoing = [];\\r\\n  var incoming = [];\\r\\n  var outgoingData = 0;\\r\\n\\r\\n  function updateOutgoingData(delta) {\\r\\n    // `outgoingData` is an approximate amount of bytes queued through all\\r\\n    // inactive responses. If more data than the high watermark is queued - we\\r\\n    // need to pause TCP socket/HTTP parser, and wait until the data will be\\r\\n    // sent to the client.\\r\\n    outgoingData += delta;\\r\\n    if (socket._paused && outgoingData < socket._writableState.highWaterMark)\\r\\n      return socketOnDrain();\\r\\n  }\\r\\n\\r\\n  function abortIncoming() {\\r\\n    while (incoming.length) {\\r\\n      var req = incoming.shift();\\r\\n      req.emit('aborted');\\r\\n      req.emit('close');\\r\\n    }\\r\\n    // abort socket._httpMessage ?\\r\\n  }\\r\\n\\r\\n  function serverSocketCloseListener() {\\r\\n    debug('server socket close');\\r\\n    // mark this parser as reusable\\r\\n    if (this.parser) {\\r\\n      freeParser(this.parser, null, this);\\r\\n    }\\r\\n\\r\\n    abortIncoming();\\r\\n  }\\r\\n\\r\\n  debug('SERVER new http connection');\\r\\n\\r\\n  httpSocketSetup(socket);\\r\\n\\r\\n  // If the user has added a listener to the server,\\r\\n  // request, or response, then it's their responsibility.\\r\\n  // otherwise, destroy on timeout by default\\r\\n  if (self.timeout)\\r\\n    socket.setTimeout(self.timeout);\\r\\n  socket.on('timeout', function() {\\r\\n    var req = socket.parser && socket.parser.incoming;\\r\\n    var reqTimeout = req && !req.complete && req.emit('timeout', socket);\\r\\n    var res = socket._httpMessage;\\r\\n    var resTimeout = res && res.emit('timeout', socket);\\r\\n    var serverTimeout = self.emit('timeout', socket);\\r\\n\\r\\n    if (!reqTimeout && !resTimeout && !serverTimeout)\\r\\n      socket.destroy();\\r\\n  });\\r\\n\\r\\n  var parser = parsers.alloc();\\r\\n  parser.reinitialize(HTTPParser.REQUEST);\\r\\n  parser.socket = socket;\\r\\n  socket.parser = parser;\\r\\n  parser.incoming = null;\\r\\n\\r\\n  // Propagate headers limit from server instance to parser\\r\\n  if (typeof this.maxHeadersCount === 'number') {\\r\\n    parser.maxHeaderPairs = this.maxHeadersCount << 1;\\r\\n  } else {\\r\\n    // Set default value because parser may be reused from FreeList\\r\\n    parser.maxHeaderPairs = 2000;\\r\\n  }\\r\\n\\r\\n  socket.addListener('error', socketOnError);\\r\\n  socket.addListener('close', serverSocketCloseListener);\\r\\n  parser.onIncoming = parserOnIncoming;\\r\\n  socket.on('end', socketOnEnd);\\r\\n  socket.on('data', socketOnData);\\r\\n\\r\\n  // We are consuming socket, so it won't get any actual data\\r\\n  socket.on('resume', onSocketResume);\\r\\n  socket.on('pause', onSocketPause);\\r\\n\\r\\n  socket.on('drain', socketOnDrain);\\r\\n\\r\\n  // Override on to unconsume on `data`, `readable` listeners\\r\\n  socket.on = socketOnWrap;\\r\\n\\r\\n  var external = socket._handle._externalStream;\\r\\n  if (external) {\\r\\n    parser._consumed = true;\\r\\n    parser.consume(external);\\r\\n  }\\r\\n  external = null;\\r\\n  parser[kOnExecute] = onParserExecute;\\r\\n\\r\\n  // TODO(isaacs): Move all these functions out of here\\r\\n  function socketOnError(e) {\\r\\n    self.emit('clientError', e, this);\\r\\n  }\\r\\n\\r\\n  function socketOnData(d) {\\r\\n    assert(!socket._paused);\\r\\n    debug('SERVER socketOnData %d', d.length);\\r\\n    var ret = parser.execute(d);\\r\\n\\r\\n    onParserExecuteCommon(ret, d);\\r\\n  }\\r\\n\\r\\n  function onParserExecute(ret, d) {\\r\\n    debug('SERVER socketOnParserExecute %d', ret);\\r\\n    onParserExecuteCommon(ret, undefined);\\r\\n  }\\r\\n\\r\\n  function onParserExecuteCommon(ret, d) {\\r\\n    if (ret instanceof Error) {\\r\\n      debug('parse error');\\r\\n      socket.destroy(ret);\\r\\n    } else if (parser.incoming && parser.incoming.upgrade) {\\r\\n      // Upgrade or CONNECT\\r\\n      var bytesParsed = ret;\\r\\n      var req = parser.incoming;\\r\\n      debug('SERVER upgrade or connect', req.method);\\r\\n\\r\\n      if (!d)\\r\\n        d = parser.getCurrentBuffer();\\r\\n\\r\\n      socket.removeListener('data', socketOnData);\\r\\n      socket.removeListener('end', socketOnEnd);\\r\\n      socket.removeListener('close', serverSocketCloseListener);\\r\\n      unconsume(parser, socket);\\r\\n      parser.finish();\\r\\n      freeParser(parser, req, null);\\r\\n      parser = null;\\r\\n\\r\\n      var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\\r\\n      if (EventEmitter.listenerCount(self, eventName) > 0) {\\r\\n        debug('SERVER have listener for %s', eventName);\\r\\n        var bodyHead = d.slice(bytesParsed, d.length);\\r\\n\\r\\n        // TODO(isaacs): Need a way to reset a stream to fresh state\\r\\n        // IE, not flowing, and not explicitly paused.\\r\\n        socket._readableState.flowing = null;\\r\\n        self.emit(eventName, req, socket, bodyHead);\\r\\n      } else {\\r\\n        // Got upgrade header or CONNECT method, but have no handler.\\r\\n        socket.destroy();\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (socket._paused && socket.parser) {\\r\\n      // onIncoming paused the socket, we should pause the parser as well\\r\\n      debug('pause parser');\\r\\n      socket.parser.pause();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function socketOnEnd() {\\r\\n    var socket = this;\\r\\n    var ret = parser.finish();\\r\\n\\r\\n    if (ret instanceof Error) {\\r\\n      debug('parse error');\\r\\n      socket.destroy(ret);\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    if (!self.httpAllowHalfOpen) {\\r\\n      abortIncoming();\\r\\n      if (socket.writable) socket.end();\\r\\n    } else if (outgoing.length) {\\r\\n      outgoing[outgoing.length - 1]._last = true;\\r\\n    } else if (socket._httpMessage) {\\r\\n      socket._httpMessage._last = true;\\r\\n    } else {\\r\\n      if (socket.writable) socket.end();\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n  // The following callback is issued after the headers have been read on a\\r\\n  // new message. In this callback we setup the response object and pass it\\r\\n  // to the user.\\r\\n\\r\\n  socket._paused = false;\\r\\n  function socketOnDrain() {\\r\\n    var needPause = outgoingData > socket._writableState.highWaterMark;\\r\\n\\r\\n    // If we previously paused, then start reading again.\\r\\n    if (socket._paused && !needPause) {\\r\\n      socket._paused = false;\\r\\n      if (socket.parser)\\r\\n        socket.parser.resume();\\r\\n      socket.resume();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function parserOnIncoming(req, shouldKeepAlive) {\\r\\n    incoming.push(req);\\r\\n\\r\\n    // If the writable end isn't consuming, then stop reading\\r\\n    // so that we don't become overwhelmed by a flood of\\r\\n    // pipelined requests that may never be resolved.\\r\\n    if (!socket._paused) {\\r\\n      var needPause = socket._writableState.needDrain ||\\r\\n          outgoingData >= socket._writableState.highWaterMark;\\r\\n      if (needPause) {\\r\\n        socket._paused = true;\\r\\n        // We also need to pause the parser, but don't do that until after\\r\\n        // the call to execute, because we may still be processing the last\\r\\n        // chunk.\\r\\n        socket.pause();\\r\\n      }\\r\\n    }\\r\\n\\r\\n    var res = new ServerResponse(req);\\r\\n    res._onPendingData = updateOutgoingData;\\r\\n\\r\\n    res.shouldKeepAlive = shouldKeepAlive;\\r\\n    DTRACE_HTTP_SERVER_REQUEST(req, socket);\\r\\n    LTTNG_HTTP_SERVER_REQUEST(req, socket);\\r\\n    COUNTER_HTTP_SERVER_REQUEST();\\r\\n\\r\\n    if (socket._httpMessage) {\\r\\n      // There are already pending outgoing res, append.\\r\\n      outgoing.push(res);\\r\\n    } else {\\r\\n      res.assignSocket(socket);\\r\\n    }\\r\\n\\r\\n    // When we're finished writing the response, check if this is the last\\r\\n    // respose, if so destroy the socket.\\r\\n    res.on('finish', resOnFinish);\\r\\n    function resOnFinish() {\\r\\n      // Usually the first incoming element should be our request.  it may\\r\\n      // be that in the case abortIncoming() was called that the incoming\\r\\n      // array will be empty.\\r\\n      assert(incoming.length === 0 || incoming[0] === req);\\r\\n\\r\\n      incoming.shift();\\r\\n\\r\\n      // if the user never called req.read(), and didn't pipe() or\\r\\n      // .resume() or .on('data'), then we call req._dump() so that the\\r\\n      // bytes will be pulled off the wire.\\r\\n      if (!req._consuming && !req._readableState.resumeScheduled)\\r\\n        req._dump();\\r\\n\\r\\n      res.detachSocket(socket);\\r\\n\\r\\n      if (res._last) {\\r\\n        socket.destroySoon();\\r\\n      } else {\\r\\n        // start sending the next message\\r\\n        var m = outgoing.shift();\\r\\n        if (m) {\\r\\n          m.assignSocket(socket);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (req.headers.expect !== undefined &&\\r\\n        (req.httpVersionMajor == 1 && req.httpVersionMinor == 1) &&\\r\\n        continueExpression.test(req.headers['expect'])) {\\r\\n      res._expect_continue = true;\\r\\n      if (EventEmitter.listenerCount(self, 'checkContinue') > 0) {\\r\\n        self.emit('checkContinue', req, res);\\r\\n      } else {\\r\\n        res.writeContinue();\\r\\n        self.emit('request', req, res);\\r\\n      }\\r\\n    } else {\\r\\n      self.emit('request', req, res);\\r\\n    }\\r\\n    return false; // Not a HEAD response. (Not even a response!)\\r\\n  }\\r\\n}\\r\\nexports._connectionListener = connectionListener;\\r\\n\\r\\nfunction onSocketResume() {\\r\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\r\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\r\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\r\\n  // state.\\r\\n  //\\r\\n  // We don't care about stream semantics for the consumed socket anyway.\\r\\n  if (this._paused) {\\r\\n    this.pause();\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  if (this._handle && !this._handle.reading) {\\r\\n    this._handle.reading = true;\\r\\n    this._handle.readStart();\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction onSocketPause() {\\r\\n  if (this._handle && this._handle.reading) {\\r\\n    this._handle.reading = false;\\r\\n    this._handle.readStop();\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction unconsume(parser, socket) {\\r\\n  if (socket._handle) {\\r\\n    if (parser._consumed)\\r\\n      parser.unconsume(socket._handle._externalStream);\\r\\n    parser._consumed = false;\\r\\n    socket.removeListener('pause', onSocketPause);\\r\\n    socket.removeListener('resume', onSocketResume);\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction socketOnWrap(ev, fn) {\\r\\n  var res = net.Socket.prototype.on.call(this, ev, fn);\\r\\n  if (!this.parser) {\\r\\n    this.on = net.Socket.prototype.on;\\r\\n    return res;\\r\\n  }\\r\\n\\r\\n  if (ev === 'data' || ev === 'readable')\\r\\n    unconsume(this.parser, this);\\r\\n\\r\\n  return res;\\r\\n}\\r\\n\",\"internal/freelist\":\"'use strict';\\r\\n\\r\\n// This is a free list to avoid creating so many of the same object.\\r\\nexports.FreeList = function(name, max, constructor) {\\r\\n  this.name = name;\\r\\n  this.constructor = constructor;\\r\\n  this.max = max;\\r\\n  this.list = [];\\r\\n};\\r\\n\\r\\n\\r\\nexports.FreeList.prototype.alloc = function() {\\r\\n  return this.list.length ? this.list.shift() :\\r\\n                            this.constructor.apply(this, arguments);\\r\\n};\\r\\n\\r\\n\\r\\nexports.FreeList.prototype.free = function(obj) {\\r\\n  if (this.list.length < this.max) {\\r\\n    this.list.push(obj);\\r\\n    return true;\\r\\n  }\\r\\n  return false;\\r\\n};\\r\\n\",\"timer_wrap\":\"var uv = require('uv');\\r\\n\\r\\nvar kOnTimeout = 'ontimeout';\\r\\n\\r\\nfunction Timer() {\\r\\n\\tvar handle = uv.new_timer();\\r\\n\\r\\n\\tObject.defineProperty(this, \\\"_handle\\\", {\\r\\n\\t\\tenumerable: false,\\r\\n\\t\\twritable: true\\r\\n\\t});\\r\\n\\r\\n\\tthis._handle = handle;\\r\\n\\treturn this;\\r\\n}\\r\\n\\r\\nTimer.kOnTimeout = kOnTimeout;\\r\\n\\r\\nTimer.prototype.start  = function (timeout, repeat) {\\r\\n\\tvar handle = this._handle;\\r\\n\\tuv.timer_start(handle, timeout, repeat || -1, OnTimeout.bind(this));\\r\\n};\\r\\n\\r\\nTimer.prototype.stop  = function (timeout, repeat) {\\r\\n\\tvar handle = this._handle;\\r\\n\\tuv.timer_stop(handle);\\r\\n};\\r\\n\\r\\nTimer.prototype.close = function(cb){\\r\\n\\tuv.handle_close(this._handle, cb);\\r\\n};\\r\\n\\r\\nTimer.prototype.unref = function(){\\r\\n\\tuv.unref(this._handle);\\r\\n};\\r\\n\\r\\nTimer.prototype.ref = function(){\\r\\n\\tuv.ref(this._handle);\\r\\n};\\r\\n\\r\\nTimer.now = function () {\\r\\n\\tvar now = uv.update_time();\\r\\n\\tif (uv.now){\\r\\n\\t\\treturn uv.now();\\r\\n\\t}\\r\\n\\treturn now;\\r\\n};\\r\\n\\r\\nfunction OnTimeout (handle) {\\r\\n\\tvar wrap = this;\\r\\n\\tprocess.MakeCallback(wrap, kOnTimeout);\\r\\n}\\r\\n\\r\\nmodule.exports = {\\r\\n\\tTimer : Timer,\\r\\n\\tkOnTimeout : Timer.kOnTimeout\\r\\n};\\r\\n\",\"buffer_wrap\":\"var binding = process.binding('buffer');\\r\\nvar _bufferPrototype;\\r\\n\\r\\nfunction _enc (enc){\\r\\n\\treturn binding.encodings[enc] || 3;\\r\\n}\\r\\n\\r\\nexports.setupBufferJS = function(proto, obj){\\r\\n\\t_bufferPrototype = proto;\\r\\n\\r\\n\\tproto.hexSlice     = binding.hexSlice;\\r\\n\\tproto.asciiSlice   = binding.asciiSlice;\\r\\n\\tproto.base64Slice  = binding.base64Slice;\\r\\n\\tproto.binarySlice  = binding.asciiSlice;\\r\\n\\tproto.utf8Slice    = binding.utf8Slice;\\r\\n\\tproto.ucs2Slice    = binding.ucs2Slice;\\r\\n\\r\\n\\t// proto.utf8Slice    = function(s,e){\\r\\n\\t// \\treturn NODE_BUFFER.prototype.toString.call(this, 'utf8', s, e);\\r\\n\\t// };\\r\\n\\r\\n\\tproto.hexWrite = binding.hexWrite;\\r\\n\\tproto.utf8Write = binding.utf8Write;\\r\\n\\tproto.asciiWrite = binding.asciiWrite;\\r\\n\\tproto.binaryWrite = binding.binaryWrite;\\r\\n\\tproto.base64Write = binding.base64Write;\\r\\n\\tproto.ucs2Write   = binding.ucs2Write;\\r\\n\\r\\n\\tproto.foreach = binding.foreach;\\r\\n\\tproto.copy = NODE_BUFFER.prototype.copy;\\r\\n\\r\\n\\tobj.flags = new Uint8Array(1);\\r\\n};\\r\\n\\r\\nexports.createFromString = function(string, encoding){\\r\\n\\tvar enc = _enc(encoding);\\r\\n\\tvar buf = binding.createFromString(string, enc);\\r\\n\\t// buf = new Int32Array(buf, 0, buf.byteLength);\\r\\n\\tObject.setPrototypeOf(buf, _bufferPrototype);\\r\\n\\treturn buf;\\r\\n};\\r\\n\\r\\nexports.createFromArrayBuffer = function(ab){\\r\\n\\tif(!(ab instanceof ArrayBuffer)) throw(\\\"argument is not an ArrayBuffer\\\");\\r\\n\\tvar buf = new Uint8Array(ab, 0, ab.byteLength);\\r\\n\\tObject.setPrototypeOf(buf, _bufferPrototype);\\r\\n\\treturn buf;\\r\\n};\\r\\n\\r\\nexports.fill    = binding.fill;\\r\\nexports.compare = binding.compare;\\r\\n\\r\\nexports.byteLengthUtf8 = binding.byteLengthUtf8;\\r\\nexports.create = binding.create;\\r\\nexports.kMaxLength = binding.kMaxLength;\\r\\n\",\"tcp_wrap\":\"var sock    = process.binding('socket');\\r\\nvar uv      = require('uv');\\r\\nvar errno   = require('errno');\\r\\n\\r\\nexports.TCP = TCP;\\r\\nexports.TCPConnectWrap = TCPConnectWrap;\\r\\n\\r\\nvar MakeCallback = process.MakeCallback;\\r\\n\\r\\nfunction TCPConnectWrap (){}\\r\\n\\r\\nfunction TCP (){\\r\\n\\tthis.writeQueueSize = 0;\\r\\n\\tthis._handle = new uv.TCP();\\r\\n}\\r\\n\\r\\n\\r\\nTCP.prototype.bind6 = TCP.prototype.bind = function(ip, port){\\r\\n\\tvar addr = uv.ip_address(ip, port);\\r\\n\\tif (!addr){\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\tthis.bindPort = port;\\r\\n\\tthis.bindAddress = ip;\\r\\n\\tvar err = this._handle.bind(addr, 0);\\r\\n\\treturn err;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.close = function(cb){\\r\\n\\tvar tcp = this;\\r\\n\\tprocess.nextTick(function(){\\r\\n\\t\\ttcp._handle.close(cb);\\r\\n\\t});\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.listen = function(backlog){\\r\\n\\tvar tcp = this;\\r\\n\\t//pass onConnection callback\\r\\n\\treturn this._handle.listen(backlog, function(status){\\r\\n\\t\\tif (!status){\\r\\n\\t\\t\\tclient = new TCP();\\r\\n\\t\\t\\tthis.accept(client._handle);\\r\\n\\t\\t}\\r\\n\\t\\tMakeCallback(tcp, \\\"onconnection\\\", status, client);\\r\\n\\t});\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.readStart = function(){\\r\\n\\tvar tcp = this;\\r\\n\\tthis._handle.read_start(function(err, buf){\\r\\n\\t\\tvar len;\\r\\n\\t\\tif (err){\\r\\n\\t\\t\\tlen = err > 0 ? -err : err;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\telse if (buf){\\r\\n\\t\\t\\tlen = buf.length;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// nread == 0\\r\\n\\t\\telse { return; }\\r\\n\\t\\tMakeCallback(tcp, \\\"onread\\\", len, buf);\\r\\n\\t});\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.readStop = function(){\\r\\n\\treturn this._handle.read_stop();\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.open = function(fd){\\r\\n\\treturn this._handle.open(fd);\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.setSimultaneousAccepts = function(enable) {\\r\\n\\treturn this._handle.simultaneous_accepts(enable);\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.shutdown = function(req){\\r\\n\\tvar tcp = this;\\r\\n\\tthis._handle.shutdown(function(status){\\r\\n\\t\\tMakeCallback(req, \\\"oncomplete\\\", status, tcp, req);\\r\\n\\t});\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.writeBinaryString = function(req, data){\\r\\n\\tdata = Buffer(data, \\\"binary\\\");\\r\\n\\treturn this.writeUtf8String(req, data.toString(\\\"binary\\\"));\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.writeAsciiString =\\r\\nTCP.prototype.writeBuffer =\\r\\nTCP.prototype.writeUtf8String = function(req, data){\\r\\n\\tvar tcp = this;\\r\\n\\tthis._handle.write(data, function(status){\\r\\n\\t\\ttcp.writeQueueSize = tcp._handle.write_queue_size;\\r\\n\\t\\treq.bytes = this.bytes;\\r\\n\\t\\tMakeCallback(req, \\\"oncomplete\\\", status, tcp, req, 0);\\r\\n\\t});\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.connect = function(req_wrap_obj, ip_address, port){\\r\\n\\tvar tcp = this;\\r\\n\\tvar addr = uv.ip_address(ip_address, port);\\r\\n\\tif (addr === null){\\r\\n\\t\\treturn errno.translate(process.errno);\\r\\n\\t}\\r\\n\\r\\n\\tvar err = this._handle.connect(addr, function AfterConnect (status){\\r\\n\\t\\tMakeCallback(req_wrap_obj, \\\"oncomplete\\\", errno.translate(status), tcp, req_wrap_obj, true, true);\\r\\n\\t});\\r\\n\\treturn errno.translate(err);\\r\\n};\\r\\n\\r\\n\\r\\n// TODO: use syscall!!\\r\\n// FIXME: handle errors\\r\\nTCP.prototype.getsockname = function(out){\\r\\n\\tvar addr = sock.getsockname(this._handle.fd);\\r\\n\\tvar info = sock.addr_info(addr);\\r\\n\\tout.address = this.bindAddress || info[0];\\r\\n\\tout.port    = this.bindPort    || info[1];\\r\\n\\tswitch (sock.isIP(out.address)){\\r\\n\\t\\tcase 4 : out.family = 'IPv4'; break;\\r\\n\\t\\tcase 6 : out.family = 'IPv6'; break;\\r\\n\\t\\tdefault : throw new Error('unknown family type');\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.getpeername = function(out){\\r\\n\\tvar peerinfo = this._handle.getpeername();\\r\\n\\tout.address = peerinfo[0];\\r\\n\\tout.port = peerinfo[1];\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.setKeepAlive = function(){\\r\\n\\t// throw new Error('setKeepAlive');\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.unref = function(){\\r\\n\\tthis._handle.unref();\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.ref = function(fd){\\r\\n\\tthis._handle.ref();\\r\\n\\treturn 0;\\r\\n};\\r\\n\",\"stream_wrap\":\"exports.WriteWrap = function(){};\\r\\nexports.ShutdownWrap = function(){};\\r\\n\\r\\n\",\"pipe_wrap\":\"var uv           = require('uv');\\r\\nvar MakeCallback = process.MakeCallback;\\r\\nvar syscall      = require('syscall');\\r\\nvar tcpWrap      = process.binding('tcp_wrap').TCP;\\r\\nvar errno        = require('errno');\\r\\n\\r\\n\\r\\nfunction Pipe(ipc){\\r\\n\\tthis._handle = new uv.Pipe(ipc);\\r\\n}\\r\\n\\r\\n\\r\\nPipe.prototype.close = function(cb){\\r\\n\\tvar pipe = this;\\r\\n\\tpipe._handle.close(cb);\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.readStop = function(){\\r\\n\\tthrow new Error('read stop');\\r\\n\\treturn this._handle.read_stop();\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.writeBuffer =\\r\\nPipe.prototype.writeUtf8String = function(req, data, send_handle){\\r\\n\\tvar stream = this;\\r\\n\\r\\n\\tif (send_handle){\\r\\n\\t\\tsend_handle = send_handle._handle;\\r\\n\\t}\\r\\n\\r\\n\\tthis._handle.write(data, function(status){\\r\\n\\t\\tstream.writeQueueSize = stream._handle.write_queue_size;\\r\\n\\t\\treq.bytes = this.bytes;\\r\\n\\t\\tMakeCallback(req, \\\"oncomplete\\\", status, stream, req, 0);\\r\\n\\t}, send_handle);\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.open = function(fd){\\r\\n\\treturn this._handle.open(fd);\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.unref = function(fd){\\r\\n\\tthis._handle.unref();\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.ref = function(fd){\\r\\n\\tthis._handle.ref();\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.readStart = function(){\\r\\n\\tvar pipe = this;\\r\\n\\r\\n\\tpipe._handle.read_start(function(err, buf){\\r\\n\\t\\tvar handle = pipe._handle;\\r\\n\\r\\n\\t\\t// get pending type\\r\\n\\t\\tvar type   = 'UNKNOWN_HANDLE';\\r\\n\\t\\tif (handle.type === 'NAMED_PIPE' && handle.ipc &&\\r\\n\\t\\t\\tuv.pipe_pending_count(handle) > 0){\\r\\n\\t\\t\\ttype = uv.pipe_handle_type(handle);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar nread = 0;\\r\\n\\t\\tif (err){\\r\\n\\t\\t\\tnread = err > 0 ? -err : err;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\telse if (buf){\\r\\n\\t\\t\\tnread = Buffer.byteLength(buf);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\telse { nread = 0; }\\r\\n\\r\\n\\t\\tif (nread === 0) return;\\r\\n\\r\\n\\t\\tvar pending_object;\\r\\n\\t\\tif (type !== 'UNKNOWN_HANDLE'){\\r\\n\\t\\t\\tpending_object = new tcpWrap();\\r\\n\\t\\t\\tvar ret = this.accept(pending_object._handle);\\r\\n\\t\\t\\tif (ret){\\r\\n\\t\\t\\t\\tthrow new Error(\\\"pending object error\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tMakeCallback(pipe, 'onread', nread, Buffer(buf).toString(), pending_object);\\r\\n\\t});\\r\\n};\\r\\n\\r\\nexports.Pipe = Pipe;\\r\\n\",\"fs_wrap\":\"var posix    = process.binding('posix');\\r\\nvar syscall  = require('syscall');\\r\\nvar util     = require('util');\\r\\n\\r\\nvar isWin    = process.platform == 'win32';\\r\\nvar errnoException = require('util')._errnoException;\\r\\n\\r\\nfunction _throw (errno, syscall, path){\\r\\n\\tvar error = errnoException(errno, syscall);\\r\\n\\tif (path) error.path = path.replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\/, '');\\r\\n\\treturn error;\\r\\n}\\r\\n\\r\\nexports.FSReqWrap = function(){};\\r\\n\\r\\nvar statFunction; /* global */\\r\\nexports.FSInitialize = function(fn){\\r\\n\\tstatFunction = fn;\\r\\n};\\r\\n\\r\\n\\r\\nexports.open = function(file, flags, mode, req){\\r\\n\\tvar err = null;\\r\\n\\tvar fd = posix.open(file, flags, mode);\\r\\n\\tif (fd === null){\\r\\n\\t\\terr = _throw(process.errno, 'open', file);\\r\\n\\t} else {\\r\\n\\t\\tvar closefd = isWin ? syscall.GetFdHandle(fd) : fd;\\r\\n\\t\\tif (!syscall.cloexec(closefd, 1)){\\r\\n\\t\\t    err = _throw(process.errno, 'open', file);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (req){\\r\\n\\t\\tprocess.nextTick(function(){\\r\\n\\t\\t\\treq.oncomplete(err, fd);\\r\\n\\t\\t});\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (err) throw(err);\\r\\n\\treturn fd;\\r\\n};\\r\\n\\r\\n\\r\\nexports.read = function(fd, buffer, offset, length, position, req){\\r\\n\\toffset = offset || 0;\\r\\n\\tlength = length || buffer.byteLength;\\r\\n\\r\\n\\tvar err;\\r\\n\\tvar nread = posix.read(fd, [buffer, offset], length, position);\\r\\n\\tif (nread === null){\\r\\n\\t\\terr = _throw(process.errno, 'read');\\r\\n\\t}\\r\\n\\r\\n\\tif (req){\\r\\n\\t\\tprocess.nextTick(function(){\\r\\n\\t\\t\\treq.oncomplete(err, nread);\\r\\n\\t\\t});\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (err) throw err;\\r\\n\\treturn nread;\\r\\n};\\r\\n\\r\\n\\r\\nexports.writeBuffers = function(fd, chunks, pos, req){\\r\\n\\tif (req){\\r\\n\\t\\tcb = {};\\r\\n\\t\\tcb.oncomplete = function(err, n){\\r\\n\\t\\t\\tif (err){\\r\\n\\t\\t\\t\\treq.oncomplete(err);\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar chunk = chunks.shift();\\r\\n\\t\\t\\tif (!chunk){\\r\\n\\t\\t\\t\\treq.oncomplete(err, n);\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\texports.writeBuffer(fd, chunk, 0, chunk.byteLength, pos, cb);\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tcb.oncomplete(null);\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tchunks.forEach(function(chunk){\\r\\n\\t\\texports.writeBuffer(fd, chunk, 0, chunk.byteLength, pos);\\r\\n\\t});\\r\\n};\\r\\n\\r\\n\\r\\nexports.writeBuffer = exports.writeString = function(fd, data, offset, length, position, req){\\r\\n\\tvar err;\\r\\n\\tvar buffer;\\r\\n\\r\\n\\tif (util.isBuffer(data)){\\r\\n\\t\\tbuffer = data;\\r\\n\\t\\tif (!util.isNumber(position)){\\r\\n\\t\\t\\tposition = 0;\\r\\n\\t\\t}\\r\\n\\t} else {\\r\\n\\t\\tvar args = [].slice.call(arguments);\\r\\n\\t\\tposition = args[2];\\r\\n\\t\\tif (!util.isNumber(position)){\\r\\n\\t\\t\\tposition = 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar encoding = args[3];\\r\\n\\t\\treq = args[4];\\r\\n\\r\\n\\t\\tif (!util.isString(encoding)){\\r\\n\\t\\t\\tencoding = 'utf8';\\r\\n\\t\\t\\treq = encoding;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tbuffer = Buffer(data, encoding);\\r\\n\\t\\tlength = buffer.byteLength;\\r\\n\\t\\toffset = 0;\\r\\n\\t}\\r\\n\\r\\n\\tvar nwritten = posix.writeBuffer(fd, [buffer, offset], length, position);\\r\\n\\tif (nwritten === null){\\r\\n\\t\\terr = _throw(process.errno, 'write');\\r\\n\\t}\\r\\n\\r\\n\\tif (req){\\r\\n\\t\\tprocess.nextTick(function(){\\r\\n\\t\\t\\treq.oncomplete(err, nwritten);\\r\\n\\t\\t});\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (err) throw(err);\\r\\n\\treturn nwritten;\\r\\n};\\r\\n\\r\\n\\r\\nfunction _normalizePath (args){\\r\\n\\tif (typeof args[0] === 'string'){\\r\\n\\targs[0] = args[0].replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\/, '');\\r\\n\\t}\\r\\n\\treturn args;\\r\\n}\\r\\n\\r\\n\\r\\nfunction _normalizeLinkArgs (args) {\\r\\n\\t//src => args[0]\\r\\n\\tif (!util.isString(args[0])){\\r\\n\\t\\tthrow new Error('src path must be a string');\\r\\n\\t}\\r\\n\\r\\n\\t//dest => args[1]\\r\\n\\tif (!util.isString(args[1])){\\r\\n\\t\\tthrow new Error('dest path must be a string');\\r\\n\\t}\\r\\n\\r\\n\\targs[0] = _normalizePath(args[0]);\\r\\n\\targs[1] = _normalizePath(args[1]);\\r\\n\\r\\n\\treturn args;\\r\\n}\\r\\n\\r\\n\\r\\nfunction _checkAccessArgs (args){\\r\\n\\t if (!util.isString(args[0])){\\r\\n\\t\\tthrow new Error(\\\"path must be a string\\\");\\r\\n\\t}\\r\\n\\treturn args;\\r\\n}\\r\\n\\r\\n\\r\\n[\\r\\n\\t['close', 2],\\r\\n\\t['ftruncate', 3],\\r\\n\\t['rmdir', 3],\\r\\n\\t['mkdir', 3],\\r\\n\\t['fchmod', 3],\\r\\n\\t['chmod', 3],\\r\\n\\t['unlink', 2],\\r\\n\\t['symlink', 4],\\r\\n\\t['readdir', 2],\\r\\n\\t['fsync', 2],\\r\\n\\t['link', 3, _normalizeLinkArgs],\\r\\n\\t['access', 3, _checkAccessArgs]\\r\\n].forEach(function(obj){\\r\\n\\tvar fn         = obj[0];\\r\\n\\tvar argsLength = obj[1];\\r\\n\\tvar _normalize = obj[2] || _normalizePath;\\r\\n\\r\\n\\texports[fn] = function(){\\r\\n\\t\\tvar args = [].slice.call(arguments);\\r\\n\\t\\tvar req;\\r\\n\\t\\tvar err = null;\\r\\n\\r\\n\\t\\tif (args.length === argsLength){\\r\\n\\t\\t\\treq = args.pop();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//normalize and or check arguments\\r\\n\\t\\targs = _normalize(args);\\r\\n\\r\\n\\t\\tvar ret = posix[fn].apply(null, args);\\r\\n\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\terr = _throw(process.errno, fn, args[0]);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (req){\\r\\n\\t\\t\\tprocess.nextTick(function(){\\r\\n\\t\\t\\t\\treq.oncomplete(err, ret);\\r\\n\\t\\t\\t});\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (err) throw err;\\r\\n\\t\\treturn ret;\\r\\n\\t};\\r\\n});\\r\\n\\r\\nexports.fdatasync = exports.fsync;\\r\\n\\r\\n\\r\\n//stat functions\\r\\n['lstat', 'fstat', 'stat'].forEach(function(fn){\\r\\n\\texports[fn] = function(file, req){\\r\\n\\t\\tvar err = null;\\r\\n\\t\\tvar stat;\\r\\n\\r\\n\\t\\tif (typeof file === 'string'){\\r\\n\\t\\t\\tfile = file.replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\/, '');\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar s = posix[fn](file);\\r\\n\\t\\tif (s === null){\\r\\n\\t\\t\\terr = _throw(process.errno, fn, file);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (s && !err){\\r\\n\\t\\t\\tstat = new statFunction(s.dev,\\r\\n\\t\\t\\t\\ts.mode,\\r\\n\\t\\t\\t\\ts.nlink,\\r\\n\\t\\t\\t\\ts.uid,\\r\\n\\t\\t\\t\\ts.gid,\\r\\n\\t\\t\\t\\ts.rdev,\\r\\n\\t\\t\\t\\ts.blksize,\\r\\n\\t\\t\\t\\ts.ino,\\r\\n\\t\\t\\t\\ts.size,\\r\\n\\t\\t\\t\\ts.blocks,\\r\\n\\t\\t\\t\\ts.atime * 1000, //to millisecond\\r\\n\\t\\t\\t\\ts.mtime * 1000, //to millisecond\\r\\n\\t\\t\\t\\ts.ctime * 1000, //to millisecond\\r\\n\\t\\t\\t\\ts.birthtim_msec\\r\\n\\t\\t\\t);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (req){\\r\\n\\t\\t\\tprocess.nextTick(function(){\\r\\n\\t\\t\\t\\treq.oncomplete(err, stat);\\r\\n\\t\\t\\t});\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (err) throw err;\\r\\n\\t\\treturn stat;\\r\\n\\t};\\r\\n});\\r\\n\",\"fs_event_wrap\":\"//empty file\\r\\nmodule.exports = {};\\r\\n\",\"cares_wrap\":\"var sock  = process.binding('socket');\\r\\nvar C       = require('C');\\r\\nvar syscall = require('syscall');\\r\\nvar assert  = require('assert');\\r\\nvar errno = require('errno');\\r\\n\\r\\nexports.QueryReqWrap = function(){};\\r\\nexports.GetAddrInfoReqWrap = function(){};\\r\\n\\r\\n\\r\\nexports.getaddrinfo = function(req, hostname, family, flags){\\r\\n\\r\\n\\tassert(typeof hostname === 'string');\\r\\n\\tswitch (family) {\\r\\n\\t\\tcase 0: family = syscall.AF_UNSPEC; break;\\r\\n\\t\\tcase 4: family = syscall.AF_INET;   break;\\r\\n\\t\\tcase 6: family = syscall.AF_INET6;  break;\\r\\n\\t\\tdefault: throw new Error (\\\"bad address family\\\");\\r\\n\\t}\\r\\n\\r\\n\\tvar hints = new C.Struct.addrinfo();\\r\\n\\thints.ai_family   = family;\\r\\n\\thints.ai_socktype = syscall.SOCK_STREAM;\\r\\n\\thints.ai_flags    = flags;\\r\\n\\r\\n\\tvar result = C.void();\\r\\n\\r\\n\\t// TODO in thread\\r\\n\\tvar status = syscall.getaddrinfo(hostname, null /* service */, hints, result);\\r\\n\\r\\n\\tvar addrs = [];\\r\\n\\tif (status === 0){ //success\\r\\n\\t\\tvar freePTR = result.ptr;\\r\\n\\t\\tvar info;\\r\\n\\r\\n\\t\\t// Iterate over the IPv4\\r\\n\\t\\tresult = freePTR;\\r\\n\\t\\tinfo   = new C.Struct.addrinfo(result);\\r\\n\\t\\twhile (result !== null){\\r\\n\\t\\t\\tvar info = new C.Struct.addrinfo(result);\\r\\n\\t\\t\\tresult = info.ai_next;\\r\\n\\t\\t\\tif (info.ai_family === syscall.AF_INET){\\r\\n\\t\\t\\t\\tvar addr = new C.Struct.sockaddr(info.ai_addr);\\r\\n\\t\\t\\t\\tvar a    = addr.buffer.sin_addr;\\r\\n\\t\\t\\t\\tvar ipv4 = sock.ntop(addr.pointer);\\r\\n\\t\\t\\t\\taddrs.push(ipv4);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Iterate over the IPv6\\r\\n\\t\\tresult = freePTR;\\r\\n\\t\\tinfo   = new C.Struct.addrinfo(result);\\r\\n\\t\\twhile (result !== null){\\r\\n\\t\\t\\tvar info = new C.Struct.addrinfo(result);\\r\\n\\t\\t\\tresult = info.ai_next;\\r\\n\\t\\t\\tif (info.ai_family === syscall.AF_INET6){\\r\\n\\t\\t\\t\\tvar addr = new C.Struct.sockaddr6(info.ai_addr);\\r\\n\\t\\t\\t\\tvar ipv6  = sock.ntop(addr.pointer);\\r\\n\\t\\t\\t\\taddrs.push(ipv6);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tsyscall.freeaddrinfo(freePTR);\\r\\n\\t}\\r\\n\\r\\n\\tif (status){\\r\\n\\t\\tvar errname = errno.errname(status);\\r\\n\\t\\tswitch (errname){\\r\\n\\t\\t\\tcase 'WSAHOST_NOT_FOUND' : status = 'ENOTFOUND'; break;\\r\\n\\t\\t\\tcase 'ENOENT' : status = 'ENOTFOUND'; break;\\r\\n\\t\\t\\tdefault : status = 'errno(' + status + ')';\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tprocess.MakeCallback(req, 'oncomplete', status, addrs);\\r\\n};\\r\\n\\r\\n\\r\\nexports.queryA = function(req, hostname){\\r\\n\\treturn exports.getaddrinfo(req, hostname, 4, 0);\\r\\n};\\r\\n\\r\\nexports.queryAaaa = function(req, hostname){\\r\\n\\treturn exports.getaddrinfo(req, hostname, 6, 0);\\r\\n};\\r\\n\\r\\nexports.isIP = function(ip){\\r\\n\\treturn sock.isIP(ip);\\r\\n};\\r\\n\",\"tty_wrap\":\"var uv  = require('uv');\\r\\n\\r\\nfunction TTY (fd, readable){\\r\\n\\tthis._handle = new uv.TTY(fd, readable);\\r\\n\\tthis.readStart(function(){});\\r\\n};\\r\\n\\r\\nTTY.prototype.writeAsciiString =\\r\\nTTY.prototype.writeBuffer =\\r\\nTTY.prototype.writeUtf8String = function(req, data){\\r\\n\\tthis._handle.write(data);\\r\\n};\\r\\n\\r\\nTTY.prototype.getWindowSize = function(arr){\\r\\n\\tvar winsize = this._handle.get_winsize();\\r\\n\\tif (!winsize){\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\tarr[0] = winsize.width;\\r\\n\\tarr[1] = winsize.height;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\nTTY.prototype.readStart = function(){\\r\\n\\tvar tcp = this;\\r\\n\\tthis._handle.read_start(function(err, buf){\\r\\n\\t\\tvar len;\\r\\n\\t\\tif (err){\\r\\n\\t\\t\\tlen = err > 0 ? -err : err;\\r\\n\\t\\t} else if (buf){\\r\\n\\t\\t\\tlen = buf.length;\\r\\n\\t\\t} else { len = 0; }\\r\\n\\r\\n\\t\\ttcp.onread(len, buf);\\r\\n\\t});\\r\\n};\\r\\n\\r\\nTTY.prototype.readStop = function(){\\r\\n\\treturn this._handle.read_stop();\\r\\n};\\r\\n\\r\\nTTY.prototype.setRawMode = function(mode){\\r\\n\\tthis._handle.set_mode(mode ? 1 : 0);\\r\\n};\\r\\n\\r\\nTTY.prototype.close = function(cb){\\r\\n\\tthis._handle.close();\\r\\n\\tsetTimeout(cb, 1);\\r\\n};\\r\\n\\r\\nexports.TTY = TTY;\\r\\n\\r\\nexports.guessHandleType = function(h){\\r\\n\\treturn uv.guess_handle(h);\\r\\n};\\r\\n\\r\\nexports.isTTY = function(h){\\r\\n\\treturn uv.guess_handle(h) === 'TTY';\\r\\n};\\r\\n\",\"spawn_sync\":\"var process_wrap = process.binding('process_wrap').Process;\\r\\nvar binding = process.binding('loop');\\r\\nvar loop = require('loop').main;\\r\\nvar child_process = require('child_process');\\r\\n\\r\\n\\r\\nexports.spawn = function(a,b,c){\\r\\n\\t// save main event loop as we\\r\\n\\t// are going to use it again\\r\\n\\tvar main_loop = loop._handle;\\r\\n\\tvar nextTick  = process.nextTick;\\r\\n\\r\\n\\tprocess.nextTick = function(){\\r\\n\\t\\tvar args = [].slice.call(arguments);\\r\\n\\t\\tvar callback = args.shift();\\r\\n\\t\\tcallback.apply(null, args);\\r\\n\\t};\\r\\n\\r\\n\\t// create new event loop handle\\r\\n\\t// change main loop handle to this new\\r\\n\\t// loop handle, run then, reset back the original\\r\\n\\t// loop handle\\r\\n\\tloop._handle = binding.init();\\r\\n\\r\\n\\tvar result = {\\r\\n\\t\\tstatus : 0,\\r\\n\\t\\toutput : []\\r\\n\\t};\\r\\n\\r\\n\\tvar stdout = [];\\r\\n\\tvar stderr = [];\\r\\n\\tvar status;\\r\\n\\r\\n\\ttry {\\r\\n\\t\\tvar child = child_process.spawn.apply(null, arguments);\\r\\n\\t} catch (e){\\r\\n\\t\\te.syscall = e.syscall.replace('spawn', 'spawnSync');\\r\\n\\t\\tresult.error = e;\\r\\n\\t\\tloop._handle = main_loop;\\r\\n\\t\\tprocess.nextTick = nextTick;\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\r\\n\\tchild.on('exit', function(code){\\r\\n\\t\\tresult.status = code;\\r\\n\\t});\\r\\n\\r\\n\\t// child.on('error', function(e){\\r\\n\\t// \\tresult.error = e;\\r\\n\\t// });\\r\\n\\r\\n\\tchild.stdout.on('data', function(data){\\r\\n\\t\\tstdout.push(data);\\r\\n\\t});\\r\\n\\r\\n\\tchild.stderr.on('data', function(data){\\r\\n\\t\\tstderr.push(data);\\r\\n\\t});\\r\\n\\r\\n\\tloop.run(0);\\r\\n\\r\\n\\tif (stdout.length > 0){\\r\\n\\t\\tresult.output[1] = Buffer.concat(stdout);\\r\\n\\t}\\r\\n\\r\\n\\tif (stderr.length > 0){\\r\\n\\t\\tresult.output[2] = Buffer.concat(stderr);\\r\\n\\t}\\r\\n\\r\\n\\t// reset back to main loop\\r\\n\\tloop._handle = main_loop;\\r\\n\\tprocess.nextTick = nextTick;\\r\\n\\r\\n\\treturn result;\\r\\n};\\r\\n\",\"process_wrap\":\"var uv           = require('uv');\\r\\nvar MakeCallback = process.MakeCallback;\\r\\nvar cons         = require('constants');\\r\\n\\r\\nfunction Process (){}\\r\\n\\r\\n// convert signal number to string\\r\\n// return null if not found\\r\\nfunction signum_to_string(signum){\\r\\n\\tif (signum === 0) return null;\\r\\n\\tfor (var key in cons){\\r\\n\\t\\tif (cons[key] === signum){\\r\\n\\t\\t\\treturn key;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn null;\\r\\n}\\r\\n\\r\\n\\r\\nfunction ParseStdioOptions(stdios, options){\\r\\n\\r\\n\\tvar stdioLength = stdios.length\\r\\n\\tvar stdio_container = uv.stdio_container(stdioLength);\\r\\n\\r\\n\\t// options.stdio_count = stdioLength;\\r\\n\\r\\n\\tfor (var i = 0; i < stdioLength; i++){\\r\\n\\t\\tvar stdio = stdios[i];\\r\\n\\t\\tvar type  = stdio.type;\\r\\n\\r\\n\\t\\t//ignor\\r\\n\\t\\tif (type === 'ignore'){\\r\\n\\t\\t\\tstdio_container[i].flags = uv.IGNORE;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//pipe\\r\\n\\t\\telse if (type === 'pipe'){\\r\\n\\t\\t\\tstdio_container[i].flags = uv.CREATE_PIPE | uv.STREAM_READABLE | uv.STREAM_WRITABLE;\\r\\n\\t\\t\\tstdio_container[i].stream = stdio.handle._handle;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//inherit\\r\\n\\t\\telse if (type === 'fd' || type === 'inherit') {\\r\\n\\t\\t\\tstdio_container[i].flags  = uv.INHERIT_FD;\\r\\n\\t\\t\\tstdio_container[i].fd     = stdio.fd;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\telse {\\r\\n\\t\\t\\tthrow new Error('unknown type!');\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\treturn stdio_container;\\r\\n}\\r\\n\\r\\n\\r\\nProcess.prototype.spawn = function(js_options){\\r\\n\\tvar process = this;\\r\\n\\r\\n\\tvar options   = {};\\r\\n\\toptions.flags = 0;\\r\\n\\toptions.file  = js_options.file;\\r\\n\\toptions.cwd   = js_options.cwd || null;\\r\\n\\toptions.args  = js_options.args || [];\\r\\n\\r\\n\\tif (!options.file){\\r\\n\\t\\tthrow new Error(\\\"Bad argument\\\");\\r\\n\\t}\\r\\n\\r\\n\\toptions.stdio_count = js_options.stdio.length;\\r\\n\\toptions.stdio = ParseStdioOptions(js_options.stdio);\\r\\n\\r\\n\\r\\n\\t//env pairs\\r\\n\\tvar env = js_options.envPairs;\\r\\n\\tif (!env){\\r\\n\\t\\tthrow new Error(\\\"TODO set current env block\\\");\\r\\n\\t}\\r\\n\\r\\n\\toptions.env = env;\\r\\n\\r\\n\\tif ( js_options.windowsVerbatimArguments ){\\r\\n\\t\\toptions.flags |= uv.PROCESS_WINDOWS_VERBATIM_ARGUMENTS;\\r\\n\\t}\\r\\n\\r\\n\\t// detach process\\r\\n\\tif ( js_options.detached ) {\\r\\n\\t\\toptions.flags |= uv.PROCESS_DETACHED;\\r\\n\\t}\\r\\n\\r\\n\\t// options.uid\\r\\n\\tif ( js_options.uid ) {\\r\\n\\t\\toptions.flags |= uv.PROCESS_SETUID;\\r\\n\\t\\toptions.uid    = js_options.uid;\\r\\n\\t}\\r\\n\\r\\n\\t// options.uid\\r\\n\\tif ( js_options.gid ) {\\r\\n\\t\\toptions.flags |= uv.PROCESS_SETGID;\\r\\n\\t\\toptions.gid = js_options.gid;\\r\\n\\t}\\r\\n\\r\\n\\t// on exit call back\\r\\n\\toptions.exit_cb = function(status, term_signal){\\r\\n\\t\\tvar sig = signum_to_string(term_signal);\\r\\n\\t\\tprocess.onexit(status, sig);\\r\\n\\t};\\r\\n\\r\\n\\tthis._handle = uv.spawn(options);\\r\\n\\tif (this._handle.errno){\\r\\n\\t\\treturn -this._handle.errno;\\r\\n\\t}\\r\\n\\r\\n\\tthis.pid = this._handle.pid;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.unref = function(){\\r\\n\\treturn this._handle.unref();\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.kill = function(signum){\\r\\n\\treturn this._handle.kill(signum);\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.close = function(cb){\\r\\n\\treturn this._handle.close(cb);\\r\\n};\\r\\n\\r\\nexports.Process = Process;\\r\\n\",\"uv_wrap\":\"var errno = require('errno');\\r\\n// reset uv_eof to negative value\\r\\nerrno.UV_EOF = -errno.UV_EOF;\\r\\nmodule.exports = errno;\\r\\n\",\"setup/stdio\":\"exports.createWritableStdioStream = function(fd){\\r\\n\\tvar stream;\\r\\n\\tvar tty_wrap = process.binding('tty_wrap');\\r\\n\\r\\n\\t// Note stream._type is used for test-module-load-list.js\\r\\n\\r\\n\\tswitch (tty_wrap.guessHandleType(fd)) {\\r\\n\\t  case 'TTY':\\r\\n\\t\\tvar tty = require('tty');\\r\\n\\t\\tstream = new tty.WriteStream(fd);\\r\\n\\t\\tstream._type = 'tty';\\r\\n\\t\\tbreak;\\r\\n\\r\\n\\t  case 'FILE':\\r\\n\\t\\tvar fs = require('fs');\\r\\n\\t\\tstream = new fs.SyncWriteStream(fd, { autoClose: false });\\r\\n\\t\\tstream._type = 'fs';\\r\\n\\t\\tbreak;\\r\\n\\r\\n\\t\\tcase 'PIPE':\\r\\n\\t\\tcase 'TCP':\\r\\n\\t\\tvar net = require('net');\\r\\n\\t\\tstream = new net.Socket({\\r\\n\\t\\t  fd: fd,\\r\\n\\t\\t  readable: false,\\r\\n\\t\\t  writable: true\\r\\n\\t\\t});\\r\\n\\t\\tstream._type = 'pipe';\\r\\n\\t\\tbreak;\\r\\n\\r\\n\\t  default:\\r\\n\\t\\t// Probably an error on in uv_guess_handle()\\r\\n\\t\\tthrow new Error('Implement me. Unknown stream file type!');\\r\\n\\t}\\r\\n\\r\\n\\t// For supporting legacy API we put the FD here.\\r\\n\\tstream.fd = fd;\\r\\n\\r\\n\\tstream._isStdio = true;\\r\\n\\r\\n\\treturn stream;\\r\\n};\\r\\n\\r\\nexports.createReadableStdioStream = function(fd){\\r\\n\\tvar tty_wrap = process.binding('tty_wrap');\\r\\n\\r\\n\\tswitch (tty_wrap.guessHandleType(fd)) {\\r\\n\\tcase 'TTY':\\r\\n\\t\\tvar tty = require('tty');\\r\\n\\t\\tstdin = new tty.ReadStream(fd, {\\r\\n\\t\\t\\thighWaterMark: 0,\\r\\n\\t\\t\\treadable: true,\\r\\n\\t\\t\\twritable: false\\r\\n\\t\\t});\\r\\n\\t\\tbreak;\\r\\n\\r\\n\\tcase 'FILE':\\r\\n\\t\\tvar fs = require('fs');\\r\\n\\t\\tstdin = new fs.ReadStream(null, { fd: fd, autoClose: false });\\r\\n\\t\\tbreak;\\r\\n\\r\\n\\tcase 'PIPE':\\r\\n\\tcase 'TCP':\\r\\n\\t\\tvar net = require('net');\\r\\n\\t\\t// It could be that process has been started with an IPC channel\\r\\n\\t\\t// sitting on fd=0, in such case the pipe for this fd is already\\r\\n\\t\\t// present and creating a new one will lead to the assertion failure\\r\\n\\t\\t// in libuv.\\r\\n\\t\\tif (process._channel && process._channel.fd === fd) {\\r\\n\\t\\t\\tstdin = new net.Socket({\\r\\n\\t\\t\\t\\thandle: process._channel,\\r\\n\\t\\t\\t\\treadable: true,\\r\\n\\t\\t\\t\\twritable: false\\r\\n\\t\\t\\t});\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tstdin = new net.Socket({\\r\\n\\t\\t\\t\\tfd: fd,\\r\\n\\t\\t\\t\\treadable: true,\\r\\n\\t\\t\\t\\twritable: false\\r\\n\\t\\t\\t});\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Make sure the stdin can't be `.end()`-ed\\r\\n\\t\\tstdin._writableState.ended = true;\\r\\n\\t\\tbreak;\\r\\n\\r\\n\\tdefault:\\r\\n\\t  // Probably an error on in uv_guess_handle()\\r\\n\\t  throw new Error('Implement me. Unknown stdin file type!');\\r\\n\\t}\\r\\n\\r\\n\\t// For supporting legacy API we put the FD here.\\r\\n\\tstdin.fd = fd;\\r\\n\\r\\n\\t// stdin starts out life in a paused state, but node doesn't\\r\\n\\t// know yet.  Explicitly to readStop() it to put it in the\\r\\n\\t// not-reading state.\\r\\n\\tif (stdin._handle && stdin._handle.readStop) {\\r\\n\\t\\tstdin._handle.reading = false;\\r\\n\\t\\tstdin._readableState.reading = false;\\r\\n\\t\\tstdin._handle.readStop();\\r\\n\\t}\\r\\n\\r\\n\\t// if the user calls stdin.pause(), then we need to stop reading\\r\\n\\t// immediately, so that the process can close down.\\r\\n\\tstdin.on('pause', function() {\\r\\n\\t\\tif (!stdin._handle)\\r\\n\\t\\t\\treturn;\\r\\n\\t\\tstdin._readableState.reading = false;\\r\\n\\t\\tstdin._handle.reading = false;\\r\\n\\t\\tstdin._handle.readStop();\\r\\n\\t});\\r\\n\\r\\n\\treturn stdin;\\r\\n};\\r\\n\"}"
