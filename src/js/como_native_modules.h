"{\"fileMap\":{\"main\":\"js/main.js\",\"loop\":\"js/loop.js\",\"struct\":\"js/struct.js\",\"C\":\"js/C.js\",\"syscall\":\"js/syscall/index.js\",\"syscall/linux\":\"js/syscall/linux.js\",\"syscall/windows\":\"js/syscall/windows.js\",\"sockets\":\"js/socket.js\",\"module\":\"js/module.js\",\"http_parser\":\"js/http-parser.js\",\"socket\":\"js/socket.js\",\"errno\":\"js/errno.js\",\"os\":\"js/os.js\",\"uv\":\"js/uv/index.js\",\"uv/stream\":\"js/uv/stream.js\",\"uv/tcp\":\"js/uv/tcp.js\",\"uv/pipe\":\"js/uv/pipe.js\",\"uv/process\":\"js/uv/process.js\",\"uv/process/windows\":\"js/uv/process/windows.js\",\"uv/process/unix\":\"js/uv/process/unix.js\",\"uv/tty\":\"js/uv/tty.js\",\"internal/util\":\"js/node/internal/util.js\",\"internal/linkedlist\":\"js/node/internal/linkedlist.js\",\"buffer\":\"js/node/buffer.js\",\"util\":\"js/node/util.js\",\"path\":\"js/node/path.js\",\"fs\":\"js/node/fs.js\",\"url\":\"js/node/url.js\",\"readline\":\"js/node/readline.js\",\"querystring\":\"js/node/querystring.js\",\"assert\":\"js/node/assert.js\",\"console\":\"js/node/console.js\",\"constants\":\"js/node/constants.js\",\"events\":\"js/node/events.js\",\"timers\":\"js/node/timers.js\",\"net\":\"js/node/net.js\",\"dns\":\"js/node/dns.js\",\"cluster\":\"js/node/cluster.js\",\"string_decoder\":\"js/node/string_decoder.js\",\"tty\":\"js/node/tty.js\",\"internal/child_process\":\"js/node/internal/child_process.js\",\"internal/socket_list\":\"js/node/internal/socket_list.js\",\"child_process\":\"js/node/child_process.js\",\"stream\":\"js/node/stream.js\",\"_stream_readable\":\"js/node/stream/_stream_readable.js\",\"_stream_writable\":\"js/node/stream/_stream_writable.js\",\"_stream_duplex\":\"js/node/stream/_stream_duplex.js\",\"_stream_transform\":\"js/node/stream/_stream_transform.js\",\"_stream_passthrough\":\"js/node/stream/_stream_passthrough.js\",\"timer_wrap\":\"js/node_wrap/timer_wrap.js\",\"buffer_wrap\":\"js/node_wrap/buffer_wrap.js\",\"handle_wrap\":\"js/node_wrap/handle_wrap.js\",\"tcp_wrap\":\"js/node_wrap/tcp_wrap.js\",\"stream_wrap\":\"js/node_wrap/stream_wrap.js\",\"pipe_wrap\":\"js/node_wrap/pipe_wrap.js\",\"fs_wrap\":\"js/node_wrap/fs_wrap.js\",\"fs_event_wrap\":\"js/node_wrap/fs_event_wrap.js\",\"cares_wrap\":\"js/node_wrap/cares_wrap.js\",\"tty_wrap\":\"js/node_wrap/tty_wrap.js\",\"spawn_sync\":\"js/node_wrap/spawn_sync.js\",\"process_wrap\":\"js/node_wrap/process_wrap.js\",\"uv_wrap\":\"js/node_wrap/uv.js\"},\"loop\":\"var loop = process.binding('loop');\\r\\nvar main_loop = process.main_loop;\\r\\n\\r\\nexports.POLLOUT = loop.POLLOUT;\\r\\nexports.POLLIN  = loop.POLLIN;\\r\\nexports.POLLERR = loop.POLLERR;\\r\\nexports.POLLHUP = loop.POLLHUP;\\r\\n\\r\\n/* IO HANDLE */\\r\\nfunction IOHandle (cb){\\r\\n\\tthis.cb = cb;\\r\\n\\tthis._handle = loop.handle_init(process.main_loop, cb);\\r\\n}\\r\\n\\r\\nIOHandle.prototype.close = function(cb){\\r\\n\\tloop.handle_close(this._handle, cb);\\r\\n};\\r\\n\\r\\nIOHandle.prototype.start = function(fd, events){\\r\\n\\tloop.io_start(this._handle, fd, events);\\r\\n};\\r\\n\\r\\nIOHandle.prototype.active = function(events){\\r\\n\\treturn loop.io_active(this._handle, events);\\r\\n};\\r\\n\\r\\nIOHandle.prototype.stop = function(events){\\r\\n\\tloop.io_stop(this._handle, events);\\r\\n};\\r\\n\\r\\nIOHandle.prototype.handle_stop = function(){\\r\\n\\tloop.handle_stop(this._handle);\\r\\n};\\r\\n\\r\\nIOHandle.prototype.unref = function(){\\r\\n\\tloop.handle_unref(this._handle);\\r\\n};\\r\\n\\r\\nIOHandle.prototype.ref = function(){\\r\\n\\tloop.handle_ref(this._handle);\\r\\n};\\r\\n\\r\\nexports.io = function(cb){\\r\\n\\treturn new IOHandle(cb);\\r\\n};\\r\\n\\r\\nexports.init = function(){\\r\\n\\treturn loop.init();\\r\\n};\\r\\n\\r\\nexports.setTimeout = setTimeout;\\r\\nexports.setInterval = setInterval;\\r\\nexports.clearInterval = clearInterval;\\r\\nexports.clearTimeout = clearTimeout;\\r\\n\",\"struct\":\"'use strict';\\r\\n// =======================================================================\\r\\n//\\tstruct = require('struct');\\r\\n//\\tstruct.create({\\r\\n//\\t\\tname : 'string',\\r\\n//\\t\\tid   : 'int32'\\r\\n//\\t});\\r\\n//\\r\\n//\\tvar st = new struct();\\r\\n//\\tst.name = \\\"joe\\\";\\r\\n//\\tst.id = 1;\\r\\n//=========================================================================\\r\\n\\r\\nmodule.exports = structs;\\r\\n\\r\\nvar binding    = process.binding('buffer');\\r\\nvar syscall    = process.binding('syscall');\\r\\nvar dataTypes  = exports.data = process.binding('types').data;\\r\\n\\r\\nvar namedStructs = {};\\r\\n\\r\\nvar LE = (function() {\\r\\n\\tvar buffer = new ArrayBuffer(2);\\r\\n\\tnew DataView(buffer).setInt16(0, 256, true /* littleEndian */);\\r\\n\\treturn new Int16Array(buffer)[0] === 256; // Int16Array uses the platform's endianness.\\r\\n})();\\r\\n\\r\\n\\r\\n// a map that return setters and getter functions\\r\\n// for each data type\\r\\nvar structSettersGetters = {\\r\\n\\t'int8' : {\\r\\n\\t\\tget : function(offset, length){\\r\\n\\t\\t\\treturn this.view.getInt8(offset, LE);\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, newVal){\\r\\n\\t\\t\\tthis.view.setInt8(offset, newVal, LE);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t'uint8' : {\\r\\n\\t\\tget : function(offset, length){\\r\\n\\t\\t\\treturn this.view.getUint8(offset, LE);\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, newVal){\\r\\n\\t\\t\\tthis.view.setUint8(offset, newVal, LE);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t'int16' : {\\r\\n\\t\\tget : function(offset, length){\\r\\n\\t\\t\\treturn this.view.getInt16(offset, LE);\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, newVal){\\r\\n\\t\\t\\tthis.view.setInt16(offset, newVal, LE);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t'uint16' : {\\r\\n\\t\\tget : function(offset){\\r\\n\\t\\t\\treturn this.view.getUint16(offset, LE);\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, newVal){\\r\\n\\t\\t\\tthis.view.setUint16(offset, newVal, LE);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t'int32' : {\\r\\n\\t\\tget : function(offset, length){\\r\\n\\t\\t\\treturn this.view.getInt32(offset, LE);\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, newVal){\\r\\n\\t\\t\\tthis.view.setInt32(offset, newVal, LE);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t'uint32' : {\\r\\n\\t\\tget : function(offset){\\r\\n\\t\\t\\treturn this.view.getUint32(offset, LE);\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, newVal){\\r\\n\\t\\t\\tthis.view.setUint32(offset, newVal, LE);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t'int64' : {\\r\\n\\t\\tget : function(offset){\\r\\n\\t\\t\\treturn this.view.getUint32(offset, LE);\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, newVal){\\r\\n\\t\\t\\tthis.view.setUint32(offset, newVal, LE);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t'uint64' : {\\r\\n\\t\\tget : function(offset){\\r\\n\\t\\t\\treturn this.view.getUint32(offset, LE);\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, newVal){\\r\\n\\t\\t\\tthis.view.setUint32(offset, newVal, LE);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t'uintptr' : {\\r\\n\\t\\tget : function(offset){\\r\\n\\t\\t\\treturn this.view.getUint32(offset, LE);\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, newVal){\\r\\n\\t\\t\\tthis.view.setUint32(offset, newVal, LE);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t'Buffer' : {\\r\\n\\t\\tget : function(offset, length){\\r\\n\\t\\t\\treturn new Buffer(this.buffer).slice(offset, offset+length);\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, newVal){\\r\\n\\t\\t\\tbinding.utf8Write.call(this.buffer, newVal, offset, length);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t'Pointer' : {\\r\\n\\t\\tget : function(offset, length, obj){\\r\\n\\t\\t\\treturn obj;\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, newVal){\\r\\n\\t\\t\\tsyscall.pointerToBuffer(this.buffer, newVal.buffer, offset);\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t'Struct' : {\\r\\n\\t\\tget : function(offset, length, obj){\\r\\n\\t\\t\\tfor (var i = 0; i < length; i++){\\r\\n\\t\\t\\t\\tobj.buffer[i] = this.buffer[offset++];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn obj;\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, obj, newVal){\\r\\n\\t\\t\\tthrow new Error(\\\"cant't set values\\\");\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\r\\n\\t'*' : {\\r\\n\\t\\tget : function(offset, length, obj){\\r\\n\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tset : function(offset, length, obj, newVal){\\r\\n\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\n// Struct internal constructor object\\r\\n// you need to use struct.create\\r\\nfunction Struct(obj){\\r\\n\\r\\n\\tvar buffer;\\r\\n\\tthis.size = 0;\\r\\n\\tvar constructPointer = [];\\r\\n\\r\\n\\tfor (var key in obj){\\r\\n\\t\\tvar offset = this.size;\\r\\n\\r\\n\\t\\tvar val = obj[key];\\r\\n\\t\\tvar length = null;\\r\\n\\t\\tvar type;\\r\\n\\r\\n\\t\\t// we can pass a pointer to another struct\\r\\n\\t\\tif (val instanceof Struct){\\r\\n\\t\\t\\tlength = dataTypes.uintptr;\\r\\n\\t\\t\\ttype   = 'Pointer';\\r\\n\\t\\t\\tconstructPointer.push([key, val]);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// when passing a number we mean\\r\\n\\t\\t// a buffer to be allocated\\r\\n\\t\\telse if (typeof val === 'number'){\\r\\n\\t\\t\\tlength = val;\\r\\n\\t\\t\\ttype = 'Buffer';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\telse if (val === '*'){\\r\\n\\t\\t\\tlength = dataTypes.intptr;\\r\\n\\t\\t\\ttype = 'Buffer';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\telse if (val instanceof Buffer){\\r\\n\\t\\t\\tlength = val.byteLength;\\r\\n\\t\\t\\ttype = 'Buffer';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// string or null\\r\\n\\t\\telse {\\r\\n\\t\\t\\tif (val === null) val = 'NULL';\\r\\n\\r\\n\\t\\t\\tlength = dataTypes[val];\\r\\n\\r\\n\\t\\t\\tif (typeof length !== 'undefined'){\\r\\n\\t\\t\\t\\ttype = val;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tvar str = namedStructs[val];\\r\\n\\r\\n\\t\\t\\t\\t//nothing match this struct field!\\r\\n\\t\\t\\t\\tif (!str) throw new Error(\\\"unknown struct type \\\" + val);\\r\\n\\r\\n\\t\\t\\t\\ttype   = 'Struct';\\r\\n\\t\\t\\t\\tval    = new str();\\r\\n\\t\\t\\t\\tlength = val.size;\\r\\n\\t\\t\\t\\t// val.buffer = Buffer(8);\\r\\n\\t\\t\\t\\t//after constructing our buffer we need to point\\r\\n\\t\\t\\t\\t//to this new created struct,\\r\\n\\t\\t\\t\\t// constructPointer.push([key, val]);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// else {\\r\\n\\t\\t\\t// \\tvar str = namedStructs[val];\\r\\n\\t\\t\\t// \\tif (!str){\\r\\n\\t\\t\\t// \\t\\tthrow new Error(\\\"unknown struct type \\\" + val);\\r\\n\\t\\t\\t// \\t}\\r\\n\\r\\n\\t\\t\\t// \\ttype   = 'Pointer';\\r\\n\\t\\t\\t// \\tval    = new str();\\r\\n\\t\\t\\t// \\tlength = 4;\\r\\n\\t\\t\\t// \\t// val.buffer = Buffer(8);\\r\\n\\t\\t\\t// \\t//after constructing our buffer we need to point\\r\\n\\t\\t\\t// \\t//to this new created struct,\\r\\n\\t\\t\\t// \\tconstructPointer.push([key, val]);\\r\\n\\t\\t\\t// }\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.size += length;\\r\\n\\r\\n\\t\\tif (type === 'Struct'){\\r\\n\\t\\t\\tObject.defineProperty(this, key, {\\r\\n\\t\\t\\t\\tget: structSettersGetters[type].get.bind(this, offset, length, val),\\r\\n\\t\\t\\t\\tset: structSettersGetters[type].set.bind(this, offset, length, val),\\r\\n\\t\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\t\\tconfigurable: true\\r\\n\\t\\t\\t});\\r\\n\\t\\t}else {\\r\\n\\t\\t\\tif (!structSettersGetters[type]){\\r\\n\\t\\t\\t\\tthrow new Error(\\\"unknown struct type \\\" + type);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tObject.defineProperty(this, key, {\\r\\n\\t\\t\\t\\tget: structSettersGetters[type].get.bind(this, offset, length, val),\\r\\n\\t\\t\\t\\tset: structSettersGetters[type].set.bind(this, offset, length),\\r\\n\\t\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\t\\tconfigurable: true\\r\\n\\t\\t\\t});\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tthis.buffer = new Uint8Array(this.size);\\r\\n\\tthis.view   = new DataView(this.buffer);\\r\\n\\tthis.reset  = function(){\\r\\n\\t\\tthis.buffer.fill('\\\\0');\\r\\n\\t};\\r\\n\\r\\n\\tfor (var i = 0; i < constructPointer.length; i++){\\r\\n\\t\\tvar str = constructPointer[i];\\r\\n\\t\\t//will be handled by structSettersGetters.Pointer.set\\r\\n\\t\\tthis[str[0]] = str[1];\\r\\n\\t}\\r\\n\\r\\n\\tObject.setPrototypeOf(this.buffer, this);\\r\\n\\treturn this.buffer;\\r\\n}\\r\\n\\r\\n// struct.create\\r\\n// create a c like struct from javascript\\r\\n// supported data types can be viewd with struct.data and\\r\\n// an instace/name of another struct\\r\\nfunction structs(name){\\r\\n\\tif (!namedStructs[name]){\\r\\n\\t\\tthrow new Error('unknown struct name ' + name);\\r\\n\\t}\\r\\n\\treturn namedStructs[name];\\r\\n};\\r\\n\\r\\nstructs.create = function (name, obj){\\r\\n\\r\\n\\t//name is optionsal\\r\\n\\tif (typeof name !== 'string'){\\r\\n\\t\\tobj = name;\\r\\n\\t\\tname = undefined;\\r\\n\\t}\\r\\n\\r\\n\\tvar struct;\\r\\n\\tvar st = function NewStruct(buf){\\r\\n\\t\\tif (this instanceof NewStruct){\\r\\n\\t\\t\\treturn new Struct(obj, buf);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!struct){\\r\\n\\t\\t\\tstruct = new Struct(obj, buf);\\r\\n\\t\\t}\\r\\n\\t\\treturn struct;\\r\\n\\t};\\r\\n\\r\\n\\tif (name) namedStructs[name] = st;\\r\\n\\treturn st;\\r\\n};\\r\\n\\r\\n\\r\\nfunction TypeStruct (s){\\r\\n\\tthis.view = new DataView(s);\\r\\n\\tthis.size = function(){\\r\\n\\t\\treturn this.view.byteLength;\\r\\n\\t};\\r\\n}\\r\\n\\r\\n\\r\\nstructs.uint32 = function(n){\\r\\n\\tn = n || 1;\\r\\n\\tvar s = new Uint32Array(n);\\r\\n\\tvar t = new TypeStruct(s);\\r\\n\\tt.get = function(){ return this.view.getUint32(0, LE) };\\r\\n\\tt.set = function(v){ return this.view.setUint32(0, v, LE) };\\r\\n\\tObject.setPrototypeOf(s, t);\\r\\n\\treturn s;\\r\\n};\\r\\n\\r\\n\\r\\nstructs.int32 = function(n){\\r\\n\\tn = n || 1;\\r\\n\\tvar s = new Int32Array(n);\\r\\n\\tvar t = new TypeStruct(s);\\r\\n\\tt.get = function(){ return this.view.getInt32(0, LE) };\\r\\n\\tt.set = function(v){ return this.view.setInt32(0, v, LE) };\\r\\n\\tObject.setPrototypeOf(s, t);\\r\\n\\treturn s;\\r\\n};\\r\\n\\r\\nif (dataTypes.int === 2){\\r\\n\\tstructs.int = function(n){\\r\\n\\t\\tn = n || 1;\\r\\n\\t\\tvar s = new Int32Array(n);\\r\\n\\t\\tvar t = new TypeStruct(s);\\r\\n\\t\\tt.get = function(n){ n = n || 0; return this.view.getInt16(n * 2, LE) };\\r\\n\\t\\tt.set = function(v, n){ n = n || 0; return this.view.setInt16(n * 2, v, LE) };\\r\\n\\t\\tObject.setPrototypeOf(s, t);\\r\\n\\t\\treturn s;\\r\\n\\t};\\r\\n} else {\\r\\n\\tstructs.int = function(n){\\r\\n\\t\\tn = n || 1;\\r\\n\\t\\tvar s = new Int32Array(n);\\r\\n\\t\\tvar t = new TypeStruct(s);\\r\\n\\t\\tt.get = function(n){ n = n || 0; return this.view.getInt32(n * 4, LE) };\\r\\n\\t\\tt.set = function(v, n){ n = n || 0; return this.view.setInt32(n * 4, v, LE) };\\r\\n\\t\\tObject.setPrototypeOf(s, t);\\r\\n\\t\\treturn s;\\r\\n\\t};\\r\\n}\\r\\n\\r\\nmodule.exports = structs;\\r\\n\",\"C\":\"var binding = process.binding('C');\\r\\nmodule.exports = binding;\\r\\n\",\"syscall\":\"var binding = process.binding('syscall');\\r\\nvar errno   = require('errno');\\r\\nvar C       = require('C');\\r\\n\\r\\nvar _LoadedLib = {};\\r\\nvar littleEndian = (function() {\\r\\n\\tvar buffer = new ArrayBuffer(2);\\r\\n\\tnew DataView(buffer).setInt16(0, 256, true /* littleEndian */);\\r\\n\\treturn new Int16Array(buffer)[0] === 256; // Int16Array uses the platform's endianness.\\r\\n})();\\r\\n\\r\\nvar rr     = new Buffer(8);\\r\\nvar retVal = new DataView(rr, 0);\\r\\n\\r\\n// syscall.LoadLibrary Constructor\\r\\n// see expoprts.LoadLibrary\\r\\nfunction NewLoadLibrary (h){\\r\\n\\tthis._handle = h;\\r\\n\\tthis.procs = {};\\r\\n\\r\\n\\t// return a function (name) from proc address\\r\\n\\t// if errval passed, the return value will check against\\r\\n\\t// this errval and if matched the function will return null\\r\\n\\t// and set process.errno to the last error\\r\\n\\tthis.GetProcAddress = function(name, errval){\\r\\n\\t\\tvar fn = binding.GetProcAddress(h, name);\\r\\n\\t\\tif (fn === null){\\r\\n\\t\\t\\tthrow new Error(\\\"unknown proc name \\\" + name);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//return cached function\\r\\n\\t\\tvar proc = this.procs[name];\\r\\n\\t\\tif (proc) return proc;\\r\\n\\r\\n\\t\\tthis.procs[name] = function (){\\r\\n\\t\\t\\tvar args = [].slice.call(arguments);\\r\\n\\t\\t\\targs.unshift(retVal);\\r\\n\\t\\t\\targs.unshift(fn);\\r\\n\\t\\t\\tbinding.syscall.apply(null, args);\\r\\n\\t\\t\\tvar r = retVal.getInt32(0, littleEndian);\\r\\n\\t\\t\\tif (typeof errval !== 'undefined'){\\r\\n\\t\\t\\t\\tif (r === errval){\\r\\n\\t\\t\\t\\t\\tprocess.errno = exports.GetLastError() || errno.EINVAL;\\r\\n\\t\\t\\t\\t\\treturn null;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn r;\\r\\n\\t\\t};\\r\\n\\t\\treturn this.procs[name];\\r\\n\\t};\\r\\n}\\r\\n\\r\\n// load WINAPI Library\\r\\n// var lib = syscall.LoadLibrary('kernel32');\\r\\n// var ReadFile = lib.GetProcAddress('ReadFile');\\r\\n// ReadFile( ..args.. );\\r\\nexports.LoadLibrary = function (lib){\\r\\n\\tif (_LoadedLib[lib]) {\\r\\n\\t\\treturn _LoadedLib[lib];\\r\\n\\t}\\r\\n\\r\\n\\tvar handle = binding.LoadLibrary(lib);\\r\\n\\tif (handle === null){\\r\\n\\t\\tthrow new Error(\\\"unknown library name \\\" + lib);\\r\\n\\t}\\r\\n\\r\\n\\t_LoadedLib[lib] = new NewLoadLibrary(handle);\\r\\n\\treturn _LoadedLib[lib];\\r\\n};\\r\\n\\r\\n\\r\\nvar platform = process.platform;\\r\\n\\r\\nif (platform === 'win32'){\\r\\n\\trequire('syscall/windows')(module);\\r\\n} else {\\r\\n\\trequire('syscall/linux')(module);\\r\\n}\\r\\n\\r\\n\\r\\nfunction IPv4(a1, a2, a3, a4){\\r\\n\\treturn [a1, a2, a3, a4].join(':');\\r\\n}\\r\\n\\r\\n// return an array of ip4/ip6 addresses for a given hostname\\r\\n//===========================================================\\r\\n  exports.LookupIP = function(name) {\\r\\n//===========================================================\\r\\n\\tvar hints = new C.addrinfo();\\r\\n\\tvar syscall = require('sockets');\\r\\n\\t//set hints\\r\\n\\thints.ai_family(syscall.AF_UNSPEC);\\r\\n\\thints.ai_socktype(syscall.SOCK_STREAM);\\r\\n\\thints.ai_protocol(syscall.IPPROTO_IP);\\r\\n\\r\\n\\tvar result = new Buffer(4);\\r\\n\\t// name = UTF16PtrFromString(name);\\r\\n\\r\\n\\tvar e = exports.getaddrinfo(name, null, hints, result);\\r\\n\\tif (e !== 0){\\r\\n\\t\\tthrow new Error(e);\\r\\n\\t}\\r\\n\\r\\n\\t// if e != nil {\\r\\n\\t// \\treturn nil, &DNSError{Err: os.NewSyscallError(\\\"getaddrinfow\\\", e).Error(), Name: name}\\r\\n\\t// }\\r\\n\\r\\n\\t// get pointer address stored in result buffer\\r\\n\\tvar freePTR = C.pointer(result);\\r\\n\\tresult = freePTR;\\r\\n\\tvar addrs = [];\\r\\n\\r\\n\\tvar info = new C.addrinfo(result);\\r\\n\\twhile (result !== null){\\r\\n\\t\\tvar info = new C.addrinfo(result);\\r\\n\\t\\tresult = info.ai_next();\\r\\n\\r\\n\\t\\tswitch (info.ai_family()){\\r\\n\\t\\t\\tcase syscall.AF_INET : {\\r\\n\\t\\t\\t\\tvar addr = new C.sockaddr(info.ai_addr());\\r\\n\\t\\t\\t\\tvar a    = addr.sin_addr.buffer;\\r\\n\\t\\t\\t\\taddrs.push(IPv4(a[0], a[1], a[2], a[3]));\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tcase syscall.AF_INET6 : {\\r\\n\\t\\t\\t\\tthrow new Error('inet6 : not implemented');\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\texports.freeaddrinfo(freePTR);\\r\\n\\treturn addrs;\\r\\n};\\r\\n\",\"syscall/linux\":\"module.exports = (function(platform){\\r\\n\\tvar sys     = process.binding('syscall');\\r\\n\\r\\n\\tvar types   = process.binding('types');\\r\\n\\tvar struct  = require('struct');\\r\\n\\tvar assert  = require('assert');\\r\\n\\tvar errno   = require('errno');\\r\\n\\r\\n\\texports = platform.exports;\\r\\n\\texports.SYS = sys;\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t  var Timespec                                   // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.Timespec\\r\\n\\t= struct.create('Timespec', {\\r\\n\\t\\tSec  : 'int32',\\r\\n\\t\\tNsec : 'int32'\\r\\n\\t});\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar Stat_t                                   // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.Stat_t\\r\\n\\t= struct.create('Stat_t', {\\r\\n\\t\\tDev       : 'uint64',\\r\\n\\t\\tX__pad1   : 'uint16',\\r\\n\\t\\tPad_cgo_0 : 2, //2 bytes buffer padding\\r\\n\\t\\tX__st_ino : 'uint32',\\r\\n\\t\\tMode      : 'uint32',\\r\\n\\t\\tNlink     : 'uint32',\\r\\n\\t\\tUid       : 'uint32',\\r\\n\\t\\tGid       : 'uint32',\\r\\n\\t\\tRdev      : 'uint64',\\r\\n\\t\\tX__pad2   : 'uint16',\\r\\n\\t\\tPad_cgo_1 : 2, //2 bytes buffer padding\\r\\n\\t\\tSize      : 'int64',\\r\\n\\t\\tBlksize   : 'int32',\\r\\n\\t\\tBlocks    : 'int64',\\r\\n\\t\\tAtim      : 'Timespec',\\r\\n\\t\\tMtim      : 'Timespec',\\r\\n\\t\\tCtim      : 'Timespec',\\r\\n\\t\\tIno       : 'uint64'\\r\\n\\t});\\r\\n\\r\\n\\tvar libc = exports.LoadLibrary(null);\\r\\n\\r\\n\\tvar kill  = libc.GetProcAddress('kill', -1, 2);\\r\\n\\tvar fcntl = libc.GetProcAddress('fcntl', -1);\\r\\n\\tvar fork = libc.GetProcAddress('fork', -1, 0);\\r\\n\\tvar dup2 = libc.GetProcAddress('dup2', -1, 2);\\r\\n\\tvar chdir = libc.GetProcAddress('chdir', -1, 1);\\r\\n\\tvar setgroups = libc.GetProcAddress('setgroups', -1, 2);\\r\\n\\tvar execlp = libc.GetProcAddress('execlp', -1, 3);\\r\\n\\tvar wait = libc.GetProcAddress('wait', -1, 1);\\r\\n\\tvar waitpid = libc.GetProcAddress('waitpid', -1, 3);\\r\\n    var setenv  = libc.GetProcAddress('setenv', -1, 3);\\r\\n    var putenv  = libc.GetProcAddress('putenv', -1, 1);\\r\\n    var recvmsg  = libc.GetProcAddress('recvmsg', -1, 3);\\r\\n    var setsid  = libc.GetProcAddress('setsid', -1, 0);\\r\\n    var open  = libc.GetProcAddress('open', -1, 3);\\r\\n    var getuid = libc.GetProcAddress('getuid', -1, 0);\\r\\n    var setuid = libc.GetProcAddress('setuid', -1, 1);\\r\\n    var getaddrinfo   = libc.GetProcAddress('getaddrinfo');\\r\\n\\r\\n\\tvar pipe2;\\r\\n\\ttry {\\r\\n\\t\\tpipe2 = libc.GetProcAddress('pipe2', -1, 2);\\r\\n\\t} catch (e){}\\r\\n\\r\\n\\tvar pipe = libc.GetProcAddress('pipe', -1, 1);\\r\\n\\r\\n\\t// direct exported functions\\r\\n\\t//===========================================================\\r\\n\\t  exports.GetLastError = sys.GetLastError;\\r\\n\\t  exports.kill  = sys.kill;\\r\\n\\t  exports.fcntl = fcntl;\\r\\n\\t  exports.fork  = fork;\\r\\n\\t  exports.dup2  = dup2;\\r\\n\\t  exports.chdir  = chdir;\\r\\n\\t  exports.setgroups  = setgroups;\\r\\n\\t  exports.execlp = execlp;\\r\\n\\t  exports.waitpid = waitpid;\\r\\n\\t  exports.putenv = putenv;\\r\\n\\t  exports.recvmsg = recvmsg;\\r\\n\\t  exports.setsid = setsid;\\r\\n\\t  exports.setuid = setuid;\\r\\n\\t  exports.getuid = getuid;\\r\\n\\t  exports.getaddrinfo = getaddrinfo;\\r\\n\\t//===========================================================\\r\\n\\r\\n\\t// cloexec\\r\\n\\t//===========================================================\\r\\n\\t  exports.cloexec = function(fd, set){\\r\\n\\t//===========================================================\\r\\n\\t\\tvar flags = 0;\\r\\n\\t\\tvar ret = fcntl(fd, sys.F_GETFD);\\r\\n\\t\\tif (ret === null) return null;\\r\\n\\r\\n\\t\\t// if cloexec flag already set do nothing\\r\\n\\t\\tif (!!(ret & sys.FD_CLOEXEC) == !!set) {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (set) {\\r\\n\\t\\t\\tflags = ret | sys.FD_CLOEXEC;\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tflags = ret & ~sys.FD_CLOEXEC;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tret = fcntl(fd, sys.F_SETFD, flags);\\r\\n\\t\\tif (ret === null) return null;\\r\\n\\t\\treturn 1;\\r\\n\\t};\\r\\n\\r\\n\\t// return a pair of pipes, null on error\\r\\n\\t//===========================================================\\r\\n\\t  var pairs = struct.int(2);\\r\\n\\t  exports.pipe = function(){\\r\\n\\t//===========================================================\\r\\n\\t\\tif (pipe(pairs) === null) return null;\\r\\n\\t\\treturn [pairs.get(0), pairs.get(1)];\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tif (pipe2){\\r\\n\\t\\t// exports pipe2 function if supported\\r\\n\\t\\t//===========================================================\\r\\n\\t\\t  exports.pipe2 = function(flags){\\r\\n\\t\\t//===========================================================\\r\\n\\t\\t\\tif (pipe2(pairs, flags || 0) === null) return null;\\r\\n\\t\\t\\treturn [pairs.get(0), pairs.get(1)];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// process check status\\r\\n\\t//===========================================================\\r\\n\\t  exports.WTERMSIG    = function(s) { return (s & 0x7f) }\\r\\n\\t  exports.WEXITSTATUS = function(s) { return ((s) & 0xff00) >> 8 }\\r\\n\\t  exports.WIFEXITED   = function(s)  { return !exports.WTERMSIG(s) }\\r\\n\\t  exports.WIFSIGNALED = function(s) { return (( s & 0xffff) -1) < 0xff }\\r\\n\\t//===========================================================\\r\\n\\r\\n\\r\\n\\t// set environment variable\\r\\n\\t//===========================================================\\r\\n\\t  exports.Setenv = function(name, val){\\r\\n\\t//===========================================================\\r\\n\\t\\treturn setenv(name, val, 1);\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\texports.Open = function(file, access, perm){\\r\\n\\t\\treturn open(file, access, perm || 0);\\r\\n\\t}\\r\\n});\\r\\n\",\"syscall/windows\":\"module.exports = (function(platform){\\r\\n\\tvar binding = process.binding('syscall');\\r\\n\\tvar struct  = require('struct');\\r\\n\\tvar assert  = require('assert');\\r\\n\\tvar errno   = require('errno');\\r\\n\\tvar C       = require('C');\\r\\n\\tvar sock    = require('sockets');\\r\\n\\t// var utf16   = require('../go/unicode/utf16');\\r\\n\\r\\n\\tvar syscall = exports = platform.exports;\\r\\n\\r\\n\\t{\\t// Invented values to support what package os expects.\\r\\n\\t\\tvar O_RDONLY   = exports.O_RDONLY   = 0x00000;\\r\\n\\t\\tvar O_WRONLY   = exports.O_WRONLY   = 0x00001;\\r\\n\\t\\tvar O_RDWR     = exports.O_RDWR     = 0x00002;\\r\\n\\t\\tvar O_CREAT    = exports.O_CREAT    = 0x00040;\\r\\n\\t\\tvar O_EXCL     = exports.O_EXCL     = 0x00080;\\r\\n\\t\\tvar O_NOCTTY   = exports.O_NOCTTY   = 0x00100;\\r\\n\\t\\tvar O_TRUNC    = exports.O_TRUNC    = 0x00200;\\r\\n\\t\\tvar O_NONBLOCK = exports.O_NONBLOCK = 0x00800;\\r\\n\\t\\tvar O_APPEND   = exports.O_APPEND   = 0x00400;\\r\\n\\t\\tvar O_SYNC     = exports.O_SYNC     = 0x01000;\\r\\n\\t\\tvar O_ASYNC    = exports.O_ASYNC    = 0x02000;\\r\\n\\t\\tvar O_CLOEXEC  = exports.O_CLOEXEC  = 0x80000;\\r\\n\\t}\\r\\n\\r\\n\\t{\\r\\n\\t\\tGENERIC_READ    = 0x80000000\\r\\n\\t\\tGENERIC_WRITE   = 0x40000000\\r\\n\\t\\tGENERIC_EXECUTE = 0x20000000\\r\\n\\t\\tGENERIC_ALL     = 0x10000000\\r\\n\\r\\n\\t\\tFILE_LIST_DIRECTORY   = 0x00000001\\r\\n\\t\\tFILE_APPEND_DATA      = 0x00000004\\r\\n\\t\\tFILE_WRITE_ATTRIBUTES = 0x00000100\\r\\n\\r\\n\\t\\tFILE_SHARE_READ              = 0x00000001\\r\\n\\t\\tFILE_SHARE_WRITE             = 0x00000002\\r\\n\\t\\tFILE_SHARE_DELETE            = 0x00000004\\r\\n\\t\\tFILE_ATTRIBUTE_READONLY      = 0x00000001\\r\\n\\t\\tFILE_ATTRIBUTE_HIDDEN        = 0x00000002\\r\\n\\t\\tFILE_ATTRIBUTE_SYSTEM        = 0x00000004\\r\\n\\t\\tFILE_ATTRIBUTE_DIRECTORY     = 0x00000010\\r\\n\\t\\tFILE_ATTRIBUTE_ARCHIVE       = 0x00000020\\r\\n\\t\\tFILE_ATTRIBUTE_NORMAL        = 0x00000080\\r\\n\\t\\tFILE_ATTRIBUTE_REPARSE_POINT = 0x00000400\\r\\n\\r\\n\\t\\tINVALID_FILE_ATTRIBUTES = 0xffffffff\\r\\n\\r\\n\\t\\tCREATE_NEW        = 1\\r\\n\\t\\tCREATE_ALWAYS     = 2\\r\\n\\t\\tOPEN_EXISTING     = 3\\r\\n\\t\\tOPEN_ALWAYS       = 4\\r\\n\\t\\tTRUNCATE_EXISTING = 5\\r\\n\\r\\n\\t\\tFILE_FLAG_OPEN_REPARSE_POINT = 0x00200000\\r\\n\\t\\tFILE_FLAG_BACKUP_SEMANTICS   = 0x02000000\\r\\n\\t\\tFILE_FLAG_OVERLAPPED         = 0x40000000\\r\\n\\r\\n\\t\\texports.HANDLE_FLAG_INHERIT    = 0x00000001\\r\\n\\t\\texports.STARTF_USESTDHANDLES   = 0x00000100\\r\\n\\t\\texports.STARTF_USESHOWWINDOW   = 0x00000001\\r\\n\\t\\texports.DUPLICATE_CLOSE_SOURCE = 0x00000001\\r\\n\\t\\texports.DUPLICATE_SAME_ACCESS  = 0x00000002\\r\\n\\r\\n\\t\\tSTD_INPUT_HANDLE  = -10\\r\\n\\t\\tSTD_OUTPUT_HANDLE = -11\\r\\n\\t\\tSTD_ERROR_HANDLE  = -12\\r\\n\\r\\n\\t\\tFILE_BEGIN   = 0\\r\\n\\t\\tFILE_CURRENT = 1\\r\\n\\t\\tFILE_END     = 2\\r\\n\\r\\n\\t\\tLANG_ENGLISH       = 0x09\\r\\n\\t\\tSUBLANG_ENGLISH_US = 0x01\\r\\n\\r\\n\\t\\tFORMAT_MESSAGE_ALLOCATE_BUFFER = 256\\r\\n\\t\\tFORMAT_MESSAGE_IGNORE_INSERTS  = 512\\r\\n\\t\\tFORMAT_MESSAGE_FROM_STRING     = 1024\\r\\n\\t\\tFORMAT_MESSAGE_FROM_HMODULE    = 2048\\r\\n\\t\\tFORMAT_MESSAGE_FROM_SYSTEM     = 4096\\r\\n\\t\\tFORMAT_MESSAGE_ARGUMENT_ARRAY  = 8192\\r\\n\\t\\tFORMAT_MESSAGE_MAX_WIDTH_MASK  = 255\\r\\n\\r\\n\\t\\tMAX_PATH      = 260\\r\\n\\t\\tMAX_LONG_PATH = 32768\\r\\n\\r\\n\\t\\tMAX_COMPUTERNAME_LENGTH = 15\\r\\n\\r\\n\\t\\tTIME_ZONE_ID_UNKNOWN  = 0\\r\\n\\t\\tTIME_ZONE_ID_STANDARD = 1\\r\\n\\r\\n\\t\\tTIME_ZONE_ID_DAYLIGHT = 2\\r\\n\\t\\tIGNORE                = 0\\r\\n\\t\\tINFINITE              = 0xffffffff\\r\\n\\r\\n\\t\\tWAIT_TIMEOUT   = 258\\r\\n\\t\\tWAIT_ABANDONED = 0x00000080\\r\\n\\t\\tWAIT_OBJECT_0  = 0x00000000\\r\\n\\t\\tWAIT_FAILED    = 0xFFFFFFFF\\r\\n\\r\\n\\t\\tCREATE_NEW_PROCESS_GROUP   = 0x00000200\\r\\n\\t\\tCREATE_UNICODE_ENVIRONMENT = 0x00000400\\r\\n\\r\\n\\t\\texports.PROCESS_TERMINATE         = 1\\r\\n\\t\\texports.PROCESS_QUERY_INFORMATION = 0x00000400\\r\\n\\t\\texports.SYNCHRONIZE               = 0x00100000\\r\\n\\r\\n\\t\\tPAGE_READONLY          = 0x02\\r\\n\\t\\tPAGE_READWRITE         = 0x04\\r\\n\\t\\tPAGE_WRITECOPY         = 0x08\\r\\n\\t\\tPAGE_EXECUTE_READ      = 0x20\\r\\n\\t\\tPAGE_EXECUTE_READWRITE = 0x40\\r\\n\\t\\tPAGE_EXECUTE_WRITECOPY = 0x80\\r\\n\\r\\n\\t\\tFILE_MAP_COPY    = 0x01\\r\\n\\t\\tFILE_MAP_WRITE   = 0x02\\r\\n\\t\\tFILE_MAP_READ    = 0x04\\r\\n\\t\\tFILE_MAP_EXECUTE = 0x20\\r\\n\\r\\n\\t\\tCTRL_C_EVENT     = 0\\r\\n\\t\\tCTRL_BREAK_EVENT = 1\\r\\n\\t}\\r\\n\\r\\n\\t{\\t//File types\\r\\n\\t\\tFILE_TYPE_CHAR    = 0x0002\\r\\n\\t\\tFILE_TYPE_DISK    = 0x0001\\r\\n\\t\\tFILE_TYPE_PIPE    = 0x0003\\r\\n\\t\\tFILE_TYPE_REMOTE  = 0x8000\\r\\n\\t\\tFILE_TYPE_UNKNOWN = 0x0000\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t{\\t// ShowWindow constants\\r\\n\\t\\t// winuser.h\\r\\n\\t\\texports.SW_HIDE            = 0\\r\\n\\t\\tSW_NORMAL          = 1\\r\\n\\t\\tSW_SHOWNORMAL      = 1\\r\\n\\t\\texports.SW_SHOWMINIMIZED   = 2\\r\\n\\t\\tSW_SHOWMAXIMIZED   = 3\\r\\n\\t\\tSW_MAXIMIZE        = 3\\r\\n\\t\\tSW_SHOWNOACTIVATE  = 4\\r\\n\\t\\tSW_SHOW            = 5\\r\\n\\t\\tSW_MINIMIZE        = 6\\r\\n\\t\\tSW_SHOWMINNOACTIVE = 7\\r\\n\\t\\tSW_SHOWNA          = 8\\r\\n\\t\\tSW_RESTORE         = 9\\r\\n\\t\\texports.SW_SHOWDEFAULT     = 10\\r\\n\\t\\tSW_FORCEMINIMIZE   = 11\\r\\n\\t}\\r\\n\\r\\n\\tvar DWORD  = 'uint32';\\r\\n\\tvar HANDLE = 'uintptr';\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar Overlapped                               // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.Overlapped\\r\\n\\t= struct.create('Overlapped', {\\r\\n\\t\\tInternal     : 'uintptr',\\r\\n\\t\\tInternalHigh : 'uintptr',\\r\\n\\t\\tOffset       : 'uint32',\\r\\n\\t\\tOffsetHigh   : 'uint32',\\r\\n\\t\\tHEvent       : HANDLE\\r\\n\\t});\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar Filetime                                 // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.Filetime\\r\\n\\t= struct.create('Filetime', {\\r\\n\\t\\tLowDateTime  : DWORD,\\r\\n\\t\\tHighDateTime : DWORD\\r\\n\\t});\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar ByHandleFileInformation                  // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.ByHandleFileInformation\\r\\n\\t= struct.create('ByHandleFileInformation', {\\r\\n\\t\\tFileAttributes      : DWORD,\\r\\n\\t\\tCreationTime        : 'Filetime',\\r\\n\\t\\tLastAccessTime      : 'Filetime',\\r\\n\\t\\tLastWriteTime       : 'Filetime',\\r\\n\\t\\tVolumeSerialNumber  : DWORD,\\r\\n\\t\\tFileSizeHigh        : DWORD,\\r\\n\\t\\tFileSizeLow         : DWORD,\\r\\n\\t\\tNumberOfLinks       : DWORD,\\r\\n\\t\\tFileIndexHigh       : DWORD,\\r\\n\\t\\tFileIndexLow        : DWORD\\r\\n\\t});\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar Win32FileAttributeData                   // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.Win32FileAttributeData\\r\\n\\t= struct.create('Win32FileAttributeData', {\\r\\n\\t\\tFileAttributes : 'uint32',\\r\\n\\t\\tCreationTime   : 'Filetime',\\r\\n\\t\\tLastAccessTime : 'Filetime',\\r\\n\\t\\tLastWriteTime  : 'Filetime',\\r\\n\\t\\tFileSizeHigh   : 'uint32',\\r\\n\\t\\tFileSizeLow    : 'uint32'\\r\\n\\t});\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar SecurityAttributes                       // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.SecurityAttributes\\r\\n\\t= struct.create ('SecurityAttributes', {\\r\\n\\t\\tLength             : 'uint32',\\r\\n\\t\\tSecurityDescriptor : 'uintptr',\\r\\n\\t\\tInheritHandle      : 'uint32'\\r\\n\\t});\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar StartupInfo                              // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.StartupInfo\\r\\n\\t= struct.create('StartupInfo', {\\r\\n\\t\\tCb            : 'uint32',\\r\\n\\t\\tReserved1     : '*',\\r\\n\\t\\tDesktop       : '*',\\r\\n\\t\\tTitle         : '*',\\r\\n\\t\\tX             : 'uint32',\\r\\n\\t\\tY             : 'uint32',\\r\\n\\t\\tXSize         : 'uint32',\\r\\n\\t\\tYSize         : 'uint32',\\r\\n\\t\\tXCountChars   : 'uint32',\\r\\n\\t\\tYCountChars   : 'uint32',\\r\\n\\t\\tFillAttribute : 'uint32',\\r\\n\\t\\tFlags         : 'uint32',\\r\\n\\t\\tShowWindow    : 'uint16',\\r\\n\\t\\tReserved2     : 'uint16',\\r\\n\\t\\tReserved3     : '*',\\r\\n\\t\\tStdInput      : HANDLE,\\r\\n\\t\\tStdOutput     : HANDLE,\\r\\n\\t\\tStdError      : HANDLE\\r\\n\\t});\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t\\tvar ProcessInformation                       // STRUCT //\\r\\n\\t//===========================================================\\r\\n\\t= exports.ProcessInformation\\r\\n\\t= struct.create('ProcessInformation', {\\r\\n\\t\\tProcess   : HANDLE,\\r\\n\\t\\tThread    : HANDLE,\\r\\n\\t\\tProcessId : 'uint32',\\r\\n\\t\\tThreadId  : 'uint32'\\r\\n\\t});\\r\\n\\r\\n\\t//kernel32 library\\r\\n\\tvar kernel       = exports.LoadLibrary('kernel32');\\r\\n\\tvar ws2          = exports.LoadLibrary('Ws2_32');\\r\\n\\texports.WSADuplicateSocket = ws2.GetProcAddress('WSADuplicateSocketW', -1, 3);\\r\\n\\texports.WSASocket = ws2.GetProcAddress('WSASocketW');\\r\\n\\texports.WSAGetLastError = ws2.GetProcAddress('WSAGetLastError');\\r\\n\\r\\n\\texports.getaddrinfo   = ws2.GetProcAddress('getaddrinfo', null, 4);\\r\\n\\texports.freeaddrinfo  = ws2.GetProcAddress('freeaddrinfo');\\r\\n\\r\\n\\tGetLastError     = kernel.GetProcAddress('GetLastError');\\r\\n\\r\\n\\t// functions with failure value of -1.\\r\\n\\tvar GetStdHandle = kernel.GetProcAddress('GetStdHandle', -1);\\r\\n\\tvar CreateFile   = kernel.GetProcAddress('CreateFileW', -1);\\r\\n\\r\\n\\tvar ReadFile      = kernel.GetProcAddress('ReadFile', 0);\\r\\n\\tvar WriteFile     = kernel.GetProcAddress('WriteFile', 0);\\r\\n\\tvar GetTempPath   = kernel.GetProcAddress('GetTempPathW');\\r\\n\\tvar WriteConsole  = kernel.GetProcAddress('WriteConsoleW');\\r\\n\\tvar GetFileType   = kernel.GetProcAddress('GetFileType', 0);\\r\\n\\r\\n\\tvar SetHandleInformation = kernel.GetProcAddress('SetHandleInformation', 0);\\r\\n\\tvar GetFileInformationByHandle = kernel.GetProcAddress('GetFileInformationByHandle', 0);\\r\\n\\tvar DuplicateHandle = kernel.GetProcAddress('DuplicateHandle', 0);\\r\\n\\tvar GetCurrentProcess = kernel.GetProcAddress('GetCurrentProcess');\\r\\n\\tvar GetCurrentProcessId = kernel.GetProcAddress('GetCurrentProcessId');\\r\\n\\r\\n\\tvar OpenProcess    = kernel.GetProcAddress('OpenProcess', 0);\\r\\n\\tvar TerminateProcess   = kernel.GetProcAddress('TerminateProcess', 0, 2);\\r\\n\\tvar CreateProcess    = kernel.GetProcAddress('CreateProcessW', 0);\\r\\n\\tvar CloseHandle    = kernel.GetProcAddress('CloseHandle', 0);\\r\\n\\tvar GetExitCodeProcess = kernel.GetProcAddress('GetExitCodeProcess', 0);\\r\\n\\tvar GetCurrentDirectory =  kernel.GetProcAddress('GetCurrentDirectoryW', 0);\\r\\n\\tvar GetEnvironmentVariable =  kernel.GetProcAddress('GetEnvironmentVariableW', 0);\\r\\n\\tvar CreatePipe = kernel.GetProcAddress('CreatePipe', 0);\\r\\n\\r\\n\\t// exported raw syscall functions\\r\\n\\t//===========================================================\\r\\n\\t  exports.GetLastError = GetLastError;\\r\\n\\t  exports.CloseOnExec = CloseOnExec;\\r\\n\\t  exports.DuplicateHandle = DuplicateHandle;\\r\\n\\t  exports.GetCurrentProcess = GetCurrentProcess;\\r\\n\\t  exports.GetCurrentProcessId = GetCurrentProcessId;\\r\\n\\r\\n\\t  exports.OpenProcess     = OpenProcess;\\r\\n\\t  exports.TerminateProcess  = TerminateProcess;\\r\\n\\t  exports.CreateProcess     = CreateProcess;\\r\\n\\t  exports.CloseHandle = CloseHandle;\\r\\n\\t  exports.GetExitCodeProcess = GetExitCodeProcess;\\r\\n\\r\\n\\t  exports.GetFdHandle = binding.GetFdHandle;\\r\\n\\t  exports.GetHandleFd = binding.GetHandleFd;\\r\\n\\r\\n\\t  exports.UTF16PtrFromString = UTF16PtrFromString;\\r\\n\\r\\n\\t  exports.WriteFile = WriteFile;\\r\\n\\t  exports.GetFileInformationByHandle = GetFileInformationByHandle;\\r\\n\\t//===========================================================\\r\\n\\r\\n\\r\\n\\t// STDIO handles\\r\\n\\t//===========================================================\\r\\n\\t  exports.Stdin  = getStdHandle(STD_INPUT_HANDLE);\\r\\n\\t  exports.Stdout = getStdHandle(STD_OUTPUT_HANDLE);\\r\\n\\t  exports.Stderr = getStdHandle(STD_ERROR_HANDLE);\\r\\n\\t//===========================================================\\r\\n\\r\\n\\r\\n\\tfunction _kill(handle, signum){\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\texports.kill = function(pid, signum) {\\r\\n\\r\\n\\t\\tvar process_handle = OpenProcess(\\r\\n\\t\\t\\tPROCESS_TERMINATE | PROCESS_QUERY_INFORMATION,\\r\\n\\t\\t\\t0, pid\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\tif (process_handle === null) {\\r\\n\\t\\t\\terr = process.errno;\\r\\n\\t\\t\\tif (err == errno.ERROR_INVALID_PARAMETER) {\\r\\n\\t\\t\\t\\treturn errno.ESRCH;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn uv_translate_sys_error(err);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\terr = _kill(process_handle, signum);\\r\\n\\t\\tCloseHandle(process_handle);\\r\\n\\t\\treturn err;  /* err is already translated. */\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\tfunction CloseOnExec(fd) {\\r\\n\\t\\treturn SetHandleInformation(fd, exports.HANDLE_FLAG_INHERIT, 0);\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tfunction getStdHandle(h){\\r\\n\\t\\tvar r = GetStdHandle(h);\\r\\n\\t\\tif (r === null) return null;\\r\\n\\t\\tCloseOnExec(r);\\r\\n\\t\\treturn r;\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tfunction UTF16PtrFromString (s){\\r\\n\\t\\ts = s + '\\\\0'; //nul terminated string\\r\\n\\t\\treturn new Buffer(s, 'ucs2');\\r\\n\\t\\t// return utf16.Encode(rune(s + \\\"\\\\x00\\\"));\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t// SetFilePointer return value is not as other win32 functions\\r\\n\\t// on failure it returns INVALID_SET_FILE_POINTER  0xffffffff\\r\\n\\t// we could define this error as GetProcAddress 2nd argument\\r\\n\\t// but for clarification we created a whole function\\r\\n\\tvar _SetFilePointer  = kernel.GetProcAddress('SetFilePointer');\\r\\n\\tfunction SetFilePointer(handle, lowoffset, highoffsetptr, whence) {\\r\\n\\t\\tvar newlowoffset = _SetFilePointer(handle, lowoffset, highoffsetptr, whence);\\r\\n\\t\\tif (newlowoffset === 0xffffffff) {\\r\\n\\t\\t\\tprocess.errno = GetLastError() || errno.EINVAL;\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\t\\treturn newlowoffset;\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t// returns a utf16 buffer to the current working directory\\r\\n\\t//===========================================================\\r\\n\\t  exports.GetCurrentDirectory = function() {\\r\\n\\t//===========================================================\\r\\n\\r\\n\\t\\t// first need get the current directory length\\r\\n\\t\\tvar buf_length = GetCurrentDirectory(0, null);\\r\\n\\t\\tif (!buf_length) return null;\\r\\n\\r\\n\\t\\tvar buf = new Buffer(buf_length * 2);\\r\\n\\r\\n\\t\\tvar ret = GetCurrentDirectory(buf.byteLength, buf);\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\tthrow new Error(process.errno);\\r\\n\\t\\t}\\r\\n\\t\\treturn buf;\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// returns string value of environment variable (v)\\r\\n\\t//===========================================================\\r\\n\\t  exports.Getenv = function(v) {\\r\\n\\t//===========================================================\\r\\n\\t\\tvar vUTF16 = UTF16PtrFromString(v);\\r\\n\\r\\n\\t\\tvar n = 200;\\r\\n\\r\\n\\t\\t// we first try with small buffer\\r\\n\\t\\t// if the return value exceeds our initial\\r\\n\\t\\t// buffer length we go through the loop\\r\\n\\t\\t// again and allocate a new buffer with the\\r\\n\\t\\t// exact length of charcters returned\\r\\n\\t\\twhile (1){\\r\\n\\t\\t\\tvar buf = new Buffer(n);\\r\\n\\t\\t\\tvar len = buf.byteLength;\\r\\n\\r\\n\\t\\t\\tn = GetEnvironmentVariable(vUTF16, buf, len);\\r\\n\\t\\t\\tif (n === null){\\r\\n\\t\\t\\t\\tif (process.errno === errno.ERROR_ENVVAR_NOT_FOUND){\\r\\n\\t\\t\\t\\t\\treturn \\\"\\\";\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tthrow new Error(process.errno);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (n <= len){\\r\\n\\t\\t\\t\\treturn buf.toString('ucs2').slice(0, n);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tn *= 2;\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// enable disable file handle inheritance\\r\\n\\t// in new created child processes\\r\\n\\t//===========================================================\\r\\n\\t  exports.cloexec = function(fd, close){\\r\\n\\t//===========================================================\\r\\n\\t\\tvar n = close ? 0 : 1;\\r\\n\\t\\treturn SetHandleInformation(fd, exports.HANDLE_FLAG_INHERIT, n);\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// open file with mode and permission\\r\\n\\t// on success returns file handle opened\\r\\n\\t// on error returns null and set process.errno\\r\\n\\t// with the last syscall error\\r\\n\\t//===========================================================\\r\\n\\t  exports.Open = function(path, mode, perm) {\\r\\n\\t//===========================================================\\r\\n\\t\\tassert(typeof path === 'string', \\\"path must be a string\\\");\\r\\n\\r\\n\\t\\tif (path.length === 0) {\\r\\n\\t\\t\\tprocess.errno = ERROR_FILE_NOT_FOUND;\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar pathp = UTF16PtrFromString(path);\\r\\n\\t\\tif (pathp == null) { //return null as this already set errno\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar access = 0;\\r\\n\\t\\tswitch (mode & (O_RDONLY | O_WRONLY | O_RDWR)) {\\r\\n\\t\\t\\tcase O_RDONLY:\\r\\n\\t\\t\\t\\taccess = GENERIC_READ; break;\\r\\n\\t\\t\\tcase O_WRONLY:\\r\\n\\t\\t\\t\\taccess = GENERIC_WRITE; break;\\r\\n\\t\\t\\tcase O_RDWR:\\r\\n\\t\\t\\t\\taccess = GENERIC_READ | GENERIC_WRITE; break;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( (mode & O_CREAT) != 0 ) {\\r\\n\\t\\t\\taccess |= GENERIC_WRITE;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif ( (mode & O_APPEND) != 0 ) {\\r\\n\\t\\t\\taccess &= ~GENERIC_WRITE;\\r\\n\\t\\t\\taccess |= FILE_APPEND_DATA;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar sharemode = FILE_SHARE_READ | FILE_SHARE_WRITE;\\r\\n\\t\\tvar sa = SecurityAttributes();\\r\\n\\r\\n\\t\\t//if no O_CLOEXEC flag make this handle inheritable\\r\\n\\t\\tif ( (mode & O_CLOEXEC) == 0 ) {\\r\\n\\t\\t\\t// sa = makeInheritSa();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar createmode = 0;\\r\\n\\r\\n\\t\\t{\\t/*  file creation mode */\\r\\n\\t\\t\\tif ((mode & (O_CREAT | O_EXCL)) === (O_CREAT | O_EXCL)) {\\r\\n\\t\\t\\t\\tcreatemode = CREATE_NEW;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\telse if ((mode & (O_CREAT|O_TRUNC)) == (O_CREAT | O_TRUNC)){\\r\\n\\t\\t\\t\\tcreatemode = CREATE_ALWAYS;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\telse if ( (mode & O_CREAT) == O_CREAT ) {\\r\\n\\t\\t\\t\\tcreatemode = OPEN_ALWAYS;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\telse if ((mode & O_TRUNC) == O_TRUNC){\\r\\n\\t\\t\\t\\tcreatemode = TRUNCATE_EXISTING;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\tcreatemode = OPEN_EXISTING;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar h = CreateFile(pathp, access, sharemode, sa, createmode, FILE_ATTRIBUTE_NORMAL, 0);\\r\\n\\t\\treturn h;\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// Read file (fd) into buffer (b)\\r\\n\\t// on success returns number of read bytes\\r\\n\\t// on error returns null and set process.errno\\r\\n\\t// to the last syscall error\\r\\n\\t//===========================================================\\r\\n\\t  var rDone = struct.uint32();\\r\\n\\t  exports.Read = function(fd, b) {\\r\\n\\t//===========================================================\\r\\n\\t\\tvar e = ReadFile(fd, b, b.byteLength, rDone, null);\\r\\n\\t\\tif (e === null) return e;\\r\\n\\t\\treturn rDone.get();\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// Write data from buffer (b) into file fd\\r\\n\\t// return null on failure and number of written data\\r\\n\\t// on success\\r\\n\\t//===========================================================\\r\\n\\t  var wDone = struct.uint32();\\r\\n\\t  exports.Write = function(fd, b) {\\r\\n\\t//===========================================================\\r\\n\\t\\tvar e = WriteFile(fd, b, b.byteLength, wDone, null);\\r\\n\\t\\tif (e === null) return null;\\r\\n\\t\\treturn wDone.get();\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t  exports.Seek = function(fd, offset, whence) {\\r\\n\\t//===========================================================\\r\\n\\t\\tvar w = 0;\\r\\n\\t\\tswitch (whence) {\\r\\n\\t\\t\\tcase 0:\\r\\n\\t\\t\\t\\tw = FILE_BEGIN; break;\\r\\n\\t\\t\\tcase 1:\\r\\n\\t\\t\\t\\tw = FILE_CURRENT; break;\\r\\n\\t\\t\\tcase 2:\\r\\n\\t\\t\\t\\tw = FILE_END; break;\\r\\n\\t\\t\\tdeafult: throw new Error('unknown file seek whence');\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar hi = struct.int32(1);\\r\\n\\t\\thi.set( offset.RShift(32) ); // offset >> 32\\r\\n\\r\\n\\t\\tvar lo = offset;\\r\\n\\t\\t// use GetFileType to check pipe, pipe can't do seek\\r\\n\\t\\tvar ft = GetFileType(fd);\\r\\n\\t\\tif (ft == FILE_TYPE_PIPE) {\\r\\n\\t\\t\\tprocess.errno = errno.EPIPE;\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar rlo = SetFilePointer(fd, lo, hi, w);\\r\\n\\t\\tif (rlo === null) return null;\\r\\n\\r\\n\\t\\t//(hi << 32) + rlo\\r\\n\\t\\treturn ( hi.get().LShift(32) ) + rlo;\\r\\n\\t};\\r\\n});\\r\\n\",\"sockets\":\"\\\"use strict\\\";\\r\\n\\r\\nvar socket = process.binding('socket');\\r\\n\\r\\nvar SOCK_STREAM = socket.SOCK_STREAM;\\r\\nvar AF_INET     = socket.AF_INET;\\r\\n\\r\\nsocket.ipAddress = socket.pton;\\r\\n\\r\\n// Object.defineProperty(socket, 'hasIPv6', {\\r\\n// \\tget : function (){\\r\\n// \\t\\tif (typeof this.IPV6 !== 'undefined')\\r\\n// \\t\\t\\treturn this.IPV6;\\r\\n\\r\\n// \\t\\tvar s = this.socket(this.AF_INET6, this.SOCK_STREAM, 0);\\r\\n// \\t\\tif (s === null){\\r\\n// \\t\\t\\tthis.IPV6 = false;\\r\\n// \\t\\t} else {\\r\\n// \\t\\t\\tthis.IPV6 = true;\\r\\n// \\t\\t\\tthis.close(s);\\r\\n// \\t\\t}\\r\\n\\r\\n// \\t\\treturn this.IPV6;\\r\\n// \\t}\\r\\n// });\\r\\n\\r\\n\\r\\nsocket.winsocketpair = function(n){\\r\\n\\treturn socket.socketpair(n);\\r\\n\\r\\n\\tvar proto = socket.getprotobyname('tcp');\\r\\n\\t// for (1..5) {\\r\\n\\t// \\tcarp \\\"winsocketpair failed: $!, retrying\\\" unless $_ == 1;\\r\\n\\tvar port = 5000;\\r\\n\\twhile (1){\\r\\n\\t\\tvar listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto );\\r\\n\\t\\tvar server = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto );\\r\\n\\t\\tvar client = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto );\\r\\n\\r\\n\\t\\tsocket.nonblock(client, 0);\\r\\n\\r\\n\\t\\tvar addr = socket.pton4(socket.INADDR_LOOPBACK, port++);\\r\\n\\r\\n\\t\\tif (socket.bind( listener, addr ) === null){\\r\\n\\t\\t\\tif (process.errno === 10048 || process.errno === 98){\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthrow new Error(\\\"bind error \\\" + process.errno);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (socket.listen( listener, 1 ) === null){\\r\\n\\t\\t\\tthrow new Error(\\\"listen error \\\" + process.errno);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\taddr = socket.getsockname( listener );\\r\\n\\t\\tif (addr === null) throw new Error('get sock name ' + process.errno);\\r\\n\\r\\n\\t\\tvar ret = 0;\\r\\n\\t\\tdo {\\r\\n\\t\\t\\tret = socket.connect(client, addr);\\r\\n\\t\\t} while(ret === null & process.errno === 10035);\\r\\n\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\tthrow new Error(\\\"connect error \\\" + process.errno);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar peer = socket.accept( listener );\\r\\n\\t\\tif (peer === null){\\r\\n\\t\\t\\tthrow new Error('accept error ' + process.errno);\\r\\n\\t\\t\\t//continue\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tsocket.nonblock(client, 1);\\r\\n\\t\\treturn [peer, client];\\r\\n\\t}\\r\\n};\\r\\n\\r\\nmodule.exports = socket;\\r\\n\",\"module\":\"'use strict';\\r\\n\\r\\nvar modulePaths = [], cache = {}, path;\\r\\nvar NativeModule = require('native_module');\\r\\n\\r\\nexports.require = function(id,parent){\\r\\n\\tif (NativeModule.exists(id)) {\\r\\n\\t\\treturn NativeModule.require(id);\\r\\n\\t}\\r\\n\\r\\n\\tvar module = new Module(id,parent);\\r\\n\\treturn module.load();\\r\\n};\\r\\n\\r\\nfunction Module(id,parent){\\r\\n\\tthis.id = id;\\r\\n\\tthis.exports = {};\\r\\n\\tthis.parent = parent || null;\\r\\n\\tif (parent && parent.children) {\\r\\n\\t\\tparent.children.push(this);\\r\\n\\t}\\r\\n\\r\\n\\tthis.filename = null;\\r\\n\\tthis.loaded = false;\\r\\n\\tthis.children = [];\\r\\n\\tthis.paths = modulePaths.slice(0);\\r\\n}\\r\\n\\r\\nModule.prototype.resolve = function(){\\r\\n\\r\\n\\tvar self = this;\\r\\n\\tvar request = this.id;\\r\\n\\tpath = path || require('path');\\r\\n\\r\\n\\tvar basename = path.basename(request),\\r\\n\\text = path.extname(basename);\\r\\n\\r\\n\\tvar start = request.substring(0, 1)\\r\\n\\t  , searchpath\\r\\n\\t  , searchPaths = [];\\r\\n\\r\\n\\tif (start === '.' || start === '/') {\\r\\n\\t\\t//relative\\r\\n\\t\\tsearchPaths = [request];\\r\\n\\t} else {\\r\\n\\t\\tif (this.parent){\\r\\n\\t\\t\\tsearchPaths = constructPaths(this.parent.dirname,request);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tsearchPaths = [request];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t//will return matched extension\\r\\n\\tthis.tryFiles(searchPaths,ext);\\r\\n\\r\\n\\tif (!this.parent){\\r\\n\\t\\tprocess.mainModule = this;\\r\\n\\t\\tthis.id = '.';\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nModule.prototype._compile = function(content,filename){\\r\\n\\tvar self = this, dirname = self.dirname;\\r\\n\\r\\n\\tfunction require (id){\\r\\n\\t\\treturn exports.require(id,self);\\r\\n\\t}\\r\\n\\r\\n\\trequire.extensions = Module._extensions;\\r\\n\\trequire.main = process.mainModule;\\r\\n\\r\\n\\tvar args = [self.exports, require, self, filename, dirname];\\r\\n\\tvar wrap = NativeModule.wrap(content);\\r\\n\\r\\n\\tvar fn = process.eval(wrap, filename);\\r\\n\\tfn.apply(self.exports, args);\\r\\n};\\r\\n\\r\\n\\r\\nModule.prototype.load = function(){\\r\\n\\tvar self = this;\\r\\n\\tself.resolve();\\r\\n\\r\\n\\tvar filename = self.filename\\r\\n\\t  , dirname = self.dirname\\r\\n\\t  , parent = self.parent;\\r\\n\\r\\n\\tpath = path || require('path');\\r\\n\\r\\n\\r\\n\\tif (cache[filename]){\\r\\n\\t\\treturn cache[filename].exports;\\r\\n\\t}\\r\\n\\r\\n\\tcache[filename] = self;\\r\\n\\r\\n\\tvar extension = path.extname(filename) || '.js';\\r\\n\\tif (Module._extensions[extension]) {\\r\\n\\t\\tModule._extensions[extension](self,filename);\\r\\n\\t}\\r\\n\\r\\n\\treturn self.exports;\\r\\n};\\r\\n\\r\\n\\r\\nfunction constructPaths (parent,req){\\r\\n\\tpath = path || require('path');\\r\\n\\r\\n\\tvar sep = path.sep\\r\\n\\t  , paths = parent.split(sep)\\r\\n\\t  , b = [];\\r\\n\\r\\n\\tfor (var i = paths.length; i > 0; i--){\\r\\n\\t\\tvar cpath = paths.slice(0,i);\\r\\n\\t\\tb.push(cpath.join(sep) + sep + 'modules' + sep + req);\\r\\n\\t}\\r\\n\\treturn b;\\r\\n}\\r\\n\\r\\n\\r\\nModule.prototype.tryFiles = function(paths,ext){\\r\\n\\r\\n\\tvar extinsions = ext ?\\r\\n\\t\\t[''] :\\r\\n\\t\\t['','.js','.como', '.json','/index.js','/index.json'];\\r\\n\\r\\n\\tpath = path || require('path');\\r\\n\\tvar binding = process;\\r\\n\\r\\n\\tfor(var x = 0; x < extinsions.length; x++){\\r\\n\\t\\tvar extend = extinsions[x];\\r\\n\\t\\tfor (var i = 0; i < paths.length; i++){\\r\\n\\t\\t\\tvar tryFile = path.resolve(this.parent ? this.parent.dirname :\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   process.cwd(), paths[i] + extend);\\r\\n\\r\\n\\t\\t\\tif (binding.isFile(tryFile)){\\r\\n\\t\\t\\t\\tthis.id = this.filename = tryFile;\\r\\n\\t\\t\\t\\tthis.dirname = path.dirname(tryFile);\\r\\n\\t\\t\\t\\treturn ext ? ext : extend;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tvar e = new Error('Cant Find Module ' + this.id );\\r\\n\\treturn process.reportError(e);\\r\\n};\\r\\n\\r\\n\\r\\nModule._initPaths = function() {\\r\\n\\tvar isWindows = process.platform === 'win32';\\r\\n\\tpath = path || require('path');\\r\\n\\r\\n\\tif (isWindows) {\\r\\n\\t\\tvar homeDir = process.env.USERPROFILE;\\r\\n\\t} else {\\r\\n\\t\\tvar homeDir = process.env.HOME;\\r\\n\\t}\\r\\n\\r\\n\\tvar paths = [path.resolve(process.execPath, '..', '..', 'lib', 'como')];\\r\\n\\r\\n\\tif (homeDir) {\\r\\n\\t\\tpaths.unshift(path.resolve(homeDir, '.como_libraries'));\\r\\n\\t\\tpaths.unshift(path.resolve(homeDir, '.como_modules'));\\r\\n\\t}\\r\\n\\r\\n\\tif (process.env['COMO_PATH']) {\\r\\n\\t\\tvar splitter = isWindows ? ';' : ':';\\r\\n\\t\\tpaths = process.env['COMO_PATH'].split(splitter).concat(paths);\\r\\n\\t}\\r\\n\\r\\n\\tmodulePaths = paths;\\r\\n\\t// clone as a read-only copy, for introspection.\\r\\n\\tModule.globalPaths = modulePaths.slice(0);\\r\\n};\\r\\n\\r\\n\\r\\nModule._extensions = {};\\r\\nModule._extensions['.js'] = function(module, filename) {\\r\\n\\tvar content = process.readFile(filename);\\r\\n\\tmodule._compile(content,filename);\\r\\n};\\r\\n\\r\\n\\r\\nModule._extensions['.dll']  =\\r\\nModule._extensions['.so']   =\\r\\nModule._extensions['.como'] = function(module, filename) {\\r\\n\\tvar require = function (id) {\\r\\n\\t\\treturn exports.require(id, module);\\r\\n\\t};\\r\\n\\tvar t = process.dlOpen(filename, require);\\r\\n\\tmodule.exports = t;\\r\\n};\\r\\n\\r\\n\\r\\n/* for perl module */\\r\\nModule._extensions['.pl'] = function(module, filename) {\\r\\n\\tif (module.parent){\\r\\n\\t\\tmodule.parent.children = [];\\r\\n\\t}\\r\\n\\tvar ret = process.perl.require(module, filename);\\r\\n\\tmodule.exports = ret;\\r\\n};\\r\\n\\r\\nModule._initPaths();\\r\\n\",\"http_parser\":\"/**\\r\\n* @module http-parser\\r\\n* @author Mamod A. Mehyar\\r\\n* @license MIT\\r\\n******************************************************************************/\\r\\n\\\"use strict\\\";\\r\\n\\r\\nvar parser = process.binding('http-parser');\\r\\nvar assert = require('assert');\\r\\n\\r\\n/** @constructor\\r\\n  * @alias module:http-parser\\r\\n  * @param type {Constant} http parsing type [ <b>parser.REQUEST</b> |\\r\\n  * <b>parser.RESPONSE</b> | <b>parser.BOTH</b> ]\\r\\n  *\\r\\n  * @example\\r\\n  * var parser = require('http-parser');\\r\\n  * var p = new parser(parser.RESPONSE);\\r\\n  *\\r\\n  * var HTTPResponse = \\\"POST /example HTTP/1.1\\\\r\\\\n\\\"  +\\r\\n  *                    \\\"Host: example.com\\\\r\\\\n\\\"       +\\r\\n  *                    \\\"Content-Type: text/html\\\\r\\\\n\\\" +\\r\\n  *                    \\\"Content-Length: 2\\\\r\\\\n\\\\r\\\\n\\\"   +\\r\\n  *                    \\\"Hi\\\";\\r\\n  *\\r\\n  * var nread = p.parse(HTTPResponse);\\r\\n  * console.log(p.method);  // log method type\\r\\n  * console.log(p.path);    // log response path\\r\\n  * console.log(p.headers); // log response headers\\r\\n  * p.on_status = function(val){\\r\\n  *     console.log(val);\\r\\n  * };\\r\\n  *\\r\\n  * @returns {Object} an http parser object\\r\\n  *\\r\\n******************************************************************************/\\r\\nfunction HTTPParser (type){\\r\\n\\ttype = type || parser.HTTP_BOTH;\\r\\n\\tthis.headers = {};\\r\\n\\tthis._headers = [];\\r\\n\\tthis._headerFields = [];\\r\\n\\tthis._headerValues = [];\\r\\n\\r\\n\\tthis.body = '';\\r\\n\\tthis.url = '';\\r\\n\\tvar pointer = parser.init(type, this);\\r\\n\\tthis.pointer = pointer;\\r\\n\\tthis.type = type;\\r\\n\\tif (pointer === null) {\\r\\n\\t\\tthrow new Error(\\\"out of memory while creating new Http parser\\\");\\r\\n\\t}\\r\\n\\treturn this;\\r\\n}\\r\\n\\r\\n/** parse http strings, on error return an instance of Error object,\\r\\n  * other wise number of bytes parsed so far will be returned\\r\\n  *\\r\\n  * @function\\r\\n  * @param type {String} http string (either a response or request string)\\r\\n  *\\r\\n  * @returns {Number} number of parsed bytes\\r\\n  *\\r\\n******************************************************************************/\\r\\nHTTPParser.prototype.execute = HTTPParser.prototype.parse = function (str, len){\\r\\n\\tstr = String(str); //make sure it's a string\\r\\n\\tlen = len || str.length;\\r\\n\\tvar nparsed = parser.parse(this.pointer, str, len);\\r\\n\\tif (nparsed !== len) {\\r\\n\\t\\t//error parsing\\r\\n\\t\\t//TODO : handle error\\r\\n\\t}\\r\\n\\r\\n\\treturn nparsed;\\r\\n};\\r\\n\\r\\n/** Reinitialize parser type so you can use it on different http headers\\r\\n  * [response / request] without a need to reconstruct a new http-parser\\r\\n  * object\\r\\n  *\\r\\n  * @function\\r\\n  * @param type {Constant} http parsing type [ <b>parser.REQUEST</b> |\\r\\n  * <b>parser.RESPONSE</b> | <b>parser.BOTH</b> ]\\r\\n  *\\r\\n  * @example\\r\\n  * var p = new parser(parser.RESPONSE);\\r\\n  * //do some response header parsing ...\\r\\n  * p.reinitialize(parser.REQUEST);\\r\\n  * //do some request headers parsing ...\\r\\n  *\\r\\n******************************************************************************/\\r\\nHTTPParser.prototype.reinitialize = function (type){\\r\\n\\tassert(type == parser.HTTP_REQUEST ||\\r\\n\\t\\t   type == parser.HTTP_RESPONSE);\\r\\n\\r\\n\\tthis._headers = null;\\r\\n\\tthis._headers = [];\\r\\n\\tthis._headerFields = [];\\r\\n\\tthis._headerValues = [];\\r\\n\\r\\n\\tthis.headers = {};\\r\\n\\tthis.url = '';\\r\\n\\tthis.type = type;\\r\\n\\tparser.reinitialize(this.pointer, type);\\r\\n};\\r\\n\\r\\n\\r\\n/** Will be called every time the parser parses header field name\\r\\n  * and should be followed by on_header_value callback\\r\\n  *\\r\\n  * @ignore\\r\\n  * @function on_header_field\\r\\n  * @param value {String} header field name\\r\\n  *\\r\\n  * @returns {Number} [1|0] return 1 to continue parsing, 0 to stop the parser\\r\\n  *\\r\\n******************************************************************************/\\r\\nvar headersNum = 0;\\r\\nvar lastHeaderfield = '';\\r\\nvar headersDirection = 'field'\\r\\nHTTPParser.prototype.on_header_field = function (value){\\r\\n\\tlastHeaderfield = lastHeaderfield + value;\\r\\n};\\r\\n\\r\\n/** Will be called every time the parser parses header field name\\r\\n  * and should be followed by on_header_value callback\\r\\n  *\\r\\n  * @ignore\\r\\n  * @function on_header_value\\r\\n  * @param value {String} header field name\\r\\n  *\\r\\n  * @returns {Number} [1|0] return 1 to continue parsing, 0 to stop the parser\\r\\n  *\\r\\n******************************************************************************/\\r\\nvar lastHeaderValue = '';\\r\\nHTTPParser.prototype.on_header_value = function (value){\\r\\n\\tif (lastHeaderfield !== ''){\\r\\n\\t\\tthis._headers.push(lastHeaderfield);\\r\\n\\t\\theadersNum = this._headers.length;\\r\\n\\t\\tlastHeaderValue = lastHeaderfield;\\r\\n\\t\\tthis.headers[lastHeaderfield] = '';\\r\\n\\t\\tlastHeaderfield = '';\\r\\n\\t\\tthis._headers[headersNum] = '';\\r\\n\\t}\\r\\n\\tthis.headers[lastHeaderValue] += value;\\r\\n\\tthis._headers[headersNum] += value;\\r\\n};\\r\\n\\r\\nHTTPParser.prototype.on_url = function (value){\\r\\n\\tthis.url = this.url + value;\\r\\n};\\r\\n\\r\\nHTTPParser.prototype.on_status           = function (){};\\r\\nHTTPParser.prototype.on_body             = function (val){ this.body += val };\\r\\nHTTPParser.prototype.on_message_begin    = function (){};\\r\\n\\r\\nHTTPParser.prototype.on_headers_complete = function (){\\r\\n\\tvar cb = this.cb;\\r\\n\\tif (cb){\\r\\n\\t\\tvar message_info = {};\\r\\n\\t\\tmessage_info.headers = this._headers;\\r\\n\\r\\n\\t\\tif (this.type === parser.HTTP_REQUEST) {\\r\\n\\t\\t\\tmessage_info.url = this.url;\\r\\n\\t\\t\\tmessage_info.method = this.method();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// STATUS\\r\\n\\t\\tif (this.type === parser.HTTP_RESPONSE) {\\r\\n\\t\\t\\tmessage_info.status_code = this.status_code;\\r\\n\\t\\t\\tmessage_info.status_message = this.status_message;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// VERSION\\r\\n\\t\\tmessage_info.versionMajor = this.versionMajor();\\r\\n\\t\\tmessage_info.versionMinor = this.versionMinor();\\r\\n\\t\\tmessage_info.shouldKeepAlive = this.shouldKeepAlive();\\r\\n\\t\\tmessage_info.upgrade = this.upgrade();\\r\\n\\r\\n\\t\\tcb.call(this, message_info);\\r\\n\\r\\n\\t\\t//reset\\r\\n\\t\\tthis._headers.length = 0;\\r\\n\\t\\tthis.headers = {};\\r\\n\\t\\tthis.url = '';\\r\\n\\t}\\r\\n};\\r\\n\\r\\nHTTPParser.prototype.on_message_complete = function (){};\\r\\n\\r\\nHTTPParser.prototype.shouldKeepAlive = function (){\\r\\n\\treturn parser.http_should_keep_alive(this.pointer);\\r\\n};\\r\\n\\r\\nHTTPParser.prototype.upgrade = function (){\\r\\n\\treturn parser.http_upgrade(this.pointer);\\r\\n};\\r\\n\\r\\nHTTPParser.prototype.versionMinor = function (){\\r\\n\\treturn parser.http_minor(this.pointer);\\r\\n};\\r\\n\\r\\nHTTPParser.prototype.versionMajor = function (){\\r\\n\\treturn parser.http_major(this.pointer);\\r\\n};\\r\\n\\r\\nHTTPParser.prototype.method = function (){\\r\\n\\treturn parser.http_method(this.pointer);\\r\\n};\\r\\n\\r\\nHTTPParser.prototype.finish = function (){\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\nHTTPParser.prototype.destroy = function (){\\r\\n\\tparser.destroy(this.pointer);\\r\\n};\\r\\n\\r\\n/** @constant REQUEST  */ HTTPParser.REQUEST  = parser.HTTP_REQUEST;\\r\\n/** @constant RESPONSE */ HTTPParser.RESPONSE = parser.HTTP_RESPONSE;\\r\\n/** @constant BOTH     */ HTTPParser.BOTH     = parser.HTTP_BOTH;\\r\\n\\r\\n//compatable with node\\r\\nHTTPParser.methods = [\\r\\n\\t'DELETE',\\r\\n\\t'GET',\\r\\n\\t'HEAD',\\r\\n\\t'POST',\\r\\n\\t'PUT'\\r\\n];\\r\\n\\r\\nHTTPParser.kOnHeaders = 0;\\r\\nHTTPParser.kOnHeadersComplete = 'onHeadersComplete';\\r\\nHTTPParser.kOnBody = 2;\\r\\nHTTPParser.kOnMessageComplete = 3;\\r\\n\\r\\nHTTPParser.HTTPParser = HTTPParser;\\r\\n\\r\\nmodule.exports = HTTPParser;\\r\\n\",\"socket\":\"\\\"use strict\\\";\\r\\n\\r\\nvar socket = process.binding('socket');\\r\\n\\r\\nvar SOCK_STREAM = socket.SOCK_STREAM;\\r\\nvar AF_INET     = socket.AF_INET;\\r\\n\\r\\nsocket.ipAddress = socket.pton;\\r\\n\\r\\n// Object.defineProperty(socket, 'hasIPv6', {\\r\\n// \\tget : function (){\\r\\n// \\t\\tif (typeof this.IPV6 !== 'undefined')\\r\\n// \\t\\t\\treturn this.IPV6;\\r\\n\\r\\n// \\t\\tvar s = this.socket(this.AF_INET6, this.SOCK_STREAM, 0);\\r\\n// \\t\\tif (s === null){\\r\\n// \\t\\t\\tthis.IPV6 = false;\\r\\n// \\t\\t} else {\\r\\n// \\t\\t\\tthis.IPV6 = true;\\r\\n// \\t\\t\\tthis.close(s);\\r\\n// \\t\\t}\\r\\n\\r\\n// \\t\\treturn this.IPV6;\\r\\n// \\t}\\r\\n// });\\r\\n\\r\\n\\r\\nsocket.winsocketpair = function(n){\\r\\n\\treturn socket.socketpair(n);\\r\\n\\r\\n\\tvar proto = socket.getprotobyname('tcp');\\r\\n\\t// for (1..5) {\\r\\n\\t// \\tcarp \\\"winsocketpair failed: $!, retrying\\\" unless $_ == 1;\\r\\n\\tvar port = 5000;\\r\\n\\twhile (1){\\r\\n\\t\\tvar listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto );\\r\\n\\t\\tvar server = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto );\\r\\n\\t\\tvar client = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto );\\r\\n\\r\\n\\t\\tsocket.nonblock(client, 0);\\r\\n\\r\\n\\t\\tvar addr = socket.pton4(socket.INADDR_LOOPBACK, port++);\\r\\n\\r\\n\\t\\tif (socket.bind( listener, addr ) === null){\\r\\n\\t\\t\\tif (process.errno === 10048 || process.errno === 98){\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthrow new Error(\\\"bind error \\\" + process.errno);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (socket.listen( listener, 1 ) === null){\\r\\n\\t\\t\\tthrow new Error(\\\"listen error \\\" + process.errno);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\taddr = socket.getsockname( listener );\\r\\n\\t\\tif (addr === null) throw new Error('get sock name ' + process.errno);\\r\\n\\r\\n\\t\\tvar ret = 0;\\r\\n\\t\\tdo {\\r\\n\\t\\t\\tret = socket.connect(client, addr);\\r\\n\\t\\t} while(ret === null & process.errno === 10035);\\r\\n\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\tthrow new Error(\\\"connect error \\\" + process.errno);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar peer = socket.accept( listener );\\r\\n\\t\\tif (peer === null){\\r\\n\\t\\t\\tthrow new Error('accept error ' + process.errno);\\r\\n\\t\\t\\t//continue\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tsocket.nonblock(client, 1);\\r\\n\\t\\treturn [peer, client];\\r\\n\\t}\\r\\n};\\r\\n\\r\\nmodule.exports = socket;\\r\\n\",\"errno\":\"var errno = process.binding('errno');\\r\\nvar _toString = errno.toString;\\r\\n\\r\\nerrno.toString = function(errno){\\r\\n\\tif (errno < 0) errno = -errno;\\r\\n\\treturn _toString(errno);\\r\\n};\\r\\n\\r\\n// windows specific errors\\r\\nerrno.ERROR_ENVVAR_NOT_FOUND        = 203;\\r\\nerrno.ERROR_INVALID_PARAMETER       = 87;\\r\\nerrno.ERROR_ACCESS_DENIED           = 5;\\r\\n\\r\\nmodule.exports = errno;\\r\\n\",\"os\":\"var isWindows = process.platform === 'win32';\\r\\n\\r\\nexports.EOL = isWindows ? '\\\\r\\\\n' : '\\\\n';\\r\\n\\r\\nvar trailingSlashRe = isWindows ? /[^:]\\\\\\\\$/ : /.\\\\/$/;\\r\\n\\r\\nexports.tmpdir = function() {\\r\\n\\tvar path;\\r\\n\\tif (isWindows) {\\r\\n\\t\\tpath = process.env.TEMP ||\\r\\n\\t\\t  process.env.TMP ||\\r\\n\\t\\t  (process.env.SystemRoot || process.env.windir) + '\\\\\\\\temp';\\r\\n\\r\\n\\t} else {\\r\\n\\t\\tpath = process.env.TMPDIR ||\\r\\n\\t\\t  process.env.TMP ||\\r\\n\\t\\t  process.env.TEMP ||\\r\\n\\t\\t  '/tmp';\\r\\n\\t}\\r\\n\\r\\n\\tif (trailingSlashRe.test(path)) {\\r\\n\\t\\tpath = path.slice(0, -1);\\r\\n\\t}\\r\\n\\treturn path;\\r\\n};\\r\\n\",\"uv\":\"var sock     = require('socket');\\r\\nvar posix    = process.binding('posix');\\r\\nvar errno    = require('errno');\\r\\nvar assert   = require('assert');\\r\\nvar syscall  = require('syscall');\\r\\nvar SYS      = syscall.SYS;\\r\\n\\r\\nvar struct   = require('struct');\\r\\nvar constant  = require('constants');\\r\\n\\r\\nvar isWin   = process.platform === 'win32';\\r\\n\\r\\nexports.CLOSING              = 0x01;    /* uv_close() called but not finished. */\\r\\nexports.CLOSED               = 0x02;    /* close(2) finished. */\\r\\nexports.STREAM_READING       = 0x04;    /* uv_read_start() called. */\\r\\nexports.STREAM_SHUTTING      = 0x08;    /* uv_shutdown() called but not complete. */\\r\\nexports.STREAM_SHUT          = 0x10;    /* Write side closed. */\\r\\nexports.STREAM_READABLE      = 0x20;    /* The stream is readable */\\r\\nexports.STREAM_WRITABLE      = 0x40;    /* The stream is writable */\\r\\nexports.STREAM_BLOCKING      = 0x80;    /* Synchronous writes. */\\r\\nexports.STREAM_READ_PARTIAL  = 0x100;   /* read(2) read less than requested. */\\r\\nexports.STREAM_READ_EOF      = 0x200;   /* read(2) read EOF. */\\r\\nexports.TCP_NODELAY          = 0x400;   /* Disable Nagle. */\\r\\nexports.TCP_KEEPALIVE        = 0x800;   /* Turn on keep-alive. */\\r\\nexports.TCP_SINGLE_ACCEPT    = 0x1000;  /* Only accept() when idle. */\\r\\nexports.HANDLE_IPV6          = 0x10000; /* Handle is bound to a IPv6 socket. */\\r\\n\\r\\nexports.TCP_IPV6ONLY         = 1;\\r\\n\\r\\nexports.IGNORE               = 0x00;\\r\\nexports.CREATE_PIPE          = 0x01;\\r\\nexports.INHERIT_FD           = 0x02;\\r\\nexports.INHERIT_STREAM       = 0x04;\\r\\nexports.PROCESS_SETUID       = (1 << 0);\\r\\nexports.PROCESS_SETGID       = (1 << 1);\\r\\nexports.PROCESS_DETACHED     = (1 << 3);\\r\\nexports.PROCESS_WINDOWS_HIDE = (1 << 4);\\r\\nexports.PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2);\\r\\n\\r\\nexports.EOF = errno.EOF;\\r\\n\\r\\nexports.isWin = isWin;\\r\\n\\r\\n// create a socket with (domain, type, protocol) options\\r\\n// the created socket will be set to nonblocking mode\\r\\n// and mark as un inheritable, cloexec = 1\\r\\n//===========================================================\\r\\n  exports.socket = function(domain, type, protocol) {\\r\\n//===========================================================\\r\\n\\tvar sockfd, err;\\r\\n\\r\\n\\tif (sock.SOCK_NONBLOCK && sock.SOCK_CLOEXEC) {\\r\\n\\t\\tsockfd = sock.socket(domain, type | sock.SOCK_NONBLOCK | sock.SOCK_CLOEXEC, protocol);\\r\\n\\t\\tif (sockfd !== null) return sockfd;\\r\\n\\r\\n\\t\\t// if EINVAL error returned this may indicate\\r\\n\\t\\t// that SOCK_NONBLOCK or SOCK_CLOEXEC are\\r\\n\\t\\t// not supported, we give it another shot\\r\\n\\t\\t// by doing a seperate call by creating a\\r\\n\\t\\t// socket then set it's blocking and cloexec flags\\r\\n\\t\\tif (process.errno !== errno.EINVAL) return;\\r\\n\\t}\\r\\n\\r\\n\\tsockfd = sock.socket(domain, type, protocol);\\r\\n\\tif (sockfd === null) return;\\r\\n\\r\\n\\tif (!sock.nonblock(sockfd, 1)){\\r\\n\\t\\tsock.close(sockfd);\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (!syscall.cloexec(sockfd, 1)){\\r\\n\\t\\tsock.close(sockfd);\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (sock.SO_NOSIGPIPE){\\r\\n\\t\\tsock.setsockopt(sockfd, sock.SOL_SOCKET, sock.SO_NOSIGPIPE, 1);\\r\\n\\t}\\r\\n\\r\\n\\treturn sockfd;\\r\\n};\\r\\n\\r\\n\\r\\n// return an ip4 packed addrerss\\r\\n//===========================================================\\r\\n  exports.ip4_addr = exports.ip4_address = function(ip, port){\\r\\n//===========================================================\\r\\n\\treturn sock.pton4(ip, port);\\r\\n};\\r\\n\\r\\n\\r\\n// return an ip4 packed addrerss\\r\\n//===========================================================\\r\\n  exports.ip6_addr = exports.ip6_address = function(ip, port){\\r\\n//===========================================================\\r\\n\\treturn sock.pton6(ip, port);\\r\\n};\\r\\n\\r\\n\\r\\n// either ip6 or ip4 address\\r\\n//===========================================================\\r\\n  exports.ip_address = exports.ip_addr = function(ip, port){\\r\\n//===========================================================\\r\\n\\treturn sock.pton(ip, port);\\r\\n};\\r\\n\\r\\n\\r\\n//===========================================================\\r\\n  exports.make_socketpair = function(fds, flags) {\\r\\n//===========================================================\\r\\n\\tvar pairs = sock.winsocketpair(1);\\r\\n\\r\\n\\tif (!pairs) return process.errno;\\r\\n\\tfds[0] = pairs[0];\\r\\n\\tfds[1] = pairs[1];\\r\\n\\r\\n\\tsyscall.cloexec(fds[0], 1);\\r\\n\\tsyscall.cloexec(fds[1], 1);\\r\\n\\r\\n\\tif (flags & 1) {\\r\\n\\t\\tsock.nonblock(fds[0], 1);\\r\\n\\t\\tsock.nonblock(fds[1], 1);\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n//===========================================================\\r\\n  exports.make_pipe = function(fds, flags) {\\r\\n//===========================================================\\r\\n\\tvar pairs;\\r\\n\\tif (syscall.pipe2){\\r\\n\\t\\tpairs = syscall.pipe2(SYS.O_CLOEXEC);\\r\\n\\t\\tif (!pairs) return process.errno;\\r\\n\\t\\tfds[0] = pairs[0];\\r\\n\\t\\tfds[1] = pairs[1];\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\tvar pairs = syscall.pipe();\\r\\n\\r\\n\\tif (!pairs) return process.errno;\\r\\n\\tfds[0] = pairs[0];\\r\\n\\tfds[1] = pairs[1];\\r\\n\\r\\n\\tsyscall.cloexec(fds[0], 1);\\r\\n\\tsyscall.cloexec(fds[1], 1);\\r\\n\\r\\n\\tif (flags & 1) {\\r\\n\\t\\tsock.nonblock(fds[0], 1);\\r\\n\\t\\tsock.nonblock(fds[1], 1);\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\n// make fd/file handle (h) inheritable accross new\\r\\n// created child processes\\r\\n//===========================================================\\r\\n  exports.make_inheritable = function(h){\\r\\n//===========================================================\\r\\n\\tif (!syscall.cloexec(h, 0)){\\r\\n\\t\\tthrow new Error(\\\"can't inherit handle\\\");\\r\\n\\t}\\r\\n\\r\\n\\treturn h;\\r\\n};\\r\\n\\r\\n// generates an array container for stdio options\\r\\n//===========================================================\\r\\n  exports.stdio_container = function(count){\\r\\n//===========================================================\\r\\n\\tvar stdio = [];\\r\\n\\tfor (var i = 0; i < count; i++){\\r\\n\\t\\tstdio[i] = {\\r\\n\\t\\t\\tflags  : exports.IGNORE,\\r\\n\\t\\t\\tstream : null,\\r\\n\\t\\t\\tfd     : null\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\treturn stdio;\\r\\n};\\r\\n\\r\\n// returns win32 os handle for the\\r\\n// passed file descriptor\\r\\n//===========================================================\\r\\n  exports.get_fd_handle = function(fd){\\r\\n//===========================================================\\r\\n\\tvar handle = syscall.GetFdHandle(fd);\\r\\n\\tif (handle === null){\\r\\n\\t\\tthrow new Error(\\\"can't get os handle for fd : \\\" + fd);\\r\\n\\t}\\r\\n\\r\\n\\treturn handle;\\r\\n};\\r\\n\\r\\n\\r\\n// win32 return exit code of the running process (h)\\r\\n// exit code 259 indicates that the process still running\\r\\n//===========================================================\\r\\n  var exitCode = new struct.int32();\\r\\n  exports.get_exit_code = function(h){\\r\\n//===========================================================\\r\\n\\tif (syscall.GetExitCodeProcess(h, exitCode) === null){\\r\\n\\t\\tthrow new Error(\\\"GetExitCodeProcess error \\\" + process.errno);\\r\\n\\t}\\r\\n\\treturn exitCode.get();\\r\\n};\\r\\n\\r\\n\\r\\n// close fd/handle\\r\\n//===========================================================\\r\\n  var _close = isWin ? syscall.CloseHandle : posix.close;\\r\\n  exports.close = function(fd) {\\r\\n//===========================================================\\r\\n\\t/* Catch uninitialized io_watcher.fd bugs. */\\r\\n\\tassert(fd > -1, \\\"uv.close fd uninitialized\\\");\\r\\n\\r\\n\\t// FIXME: win test against stdio handles\\r\\n\\t/* Catch stdio close bugs. */\\r\\n\\tassert(fd > 2, \\\"uv.close stdio file\\\");\\r\\n\\r\\n\\tvar saved_errno = process.errno;\\r\\n\\tvar rc = _close(fd);\\r\\n\\r\\n\\tif (rc === null) {\\r\\n\\t\\trc = process.errno;\\r\\n\\t\\tif (rc == errno.EINTR) rc = errno.EINPROGRESS;  /* For platform/libc consistency. */\\r\\n\\t\\tprocess.errno = saved_errno;\\r\\n\\t}\\r\\n\\r\\n\\treturn rc;\\r\\n};\\r\\n\\r\\n\\r\\n//===========================================================\\r\\n  var _write = isWin ? sock.send : sock.write;\\r\\n  exports.write = function(fd, buf, len, flag){\\r\\n//===========================================================\\r\\n\\treturn _write(fd, buf, len);\\r\\n};\\r\\n\\r\\n\\r\\n//===========================================================\\r\\n  var _read  = isWin ? sock.recv : sock.read;\\r\\n  exports.read = function(fd, len){\\r\\n//===========================================================\\r\\n\\treturn _read(fd, len);\\r\\n};\\r\\n\\r\\n\\r\\n// return number of pending handles\\r\\n//===========================================================\\r\\n  exports.pipe_pending_count = function(handle) {\\r\\n//===========================================================\\r\\n\\tif (!handle.ipc) return 0;\\r\\n\\r\\n\\tif (handle.accepted_fd === -1){\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\tif ( handle.queued_fds.length === 0 ){\\r\\n\\t\\treturn 1;\\r\\n\\t}\\r\\n\\r\\n\\treturn handle.queued_fds.length;\\r\\n};\\r\\n\\r\\n\\r\\nvar STILL_ACTIVE = 259;\\r\\nvar Win32kill = exports.Win32kill = function(process_handle, signum){\\r\\n\\tvar status = new struct.int32();\\r\\n\\tswitch (signum) {\\r\\n\\t\\tcase constant.SIGTERM:\\r\\n\\t\\tcase constant.SIGKILL:\\r\\n\\t\\tcase constant.SIGINT: {\\r\\n\\t\\t\\t/* Unconditionally terminate the process. On Windows, killed processes */\\r\\n\\t\\t\\t/* normally return 1. */\\r\\n\\t\\t\\tvar err;\\r\\n\\r\\n\\t\\t\\tif (syscall.TerminateProcess(process_handle, 1)) return 0;\\r\\n\\r\\n\\t\\t\\t/* If the process already exited before TerminateProcess was called, */\\r\\n\\t\\t\\t/* TerminateProcess will fail with ERROR_ACCESS_DENIED. */\\r\\n\\t\\t\\terr = syscall.GetLastError();\\r\\n\\t\\t\\tif (err == errno.ERROR_ACCESS_DENIED &&\\r\\n\\t\\t\\t\\t\\tsyscall.GetExitCodeProcess(process_handle, status) &&\\r\\n\\t\\t\\t\\t\\tstatus.get() !== STILL_ACTIVE) {\\r\\n\\t\\t\\t\\treturn errno.ESRCH;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn errno.translate(err);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase 0: {\\r\\n\\t\\t\\t/* Health check: is the process still alive? */\\r\\n\\r\\n\\t\\t\\tif (syscall.GetExitCodeProcess(process_handle, status) === null) {\\r\\n\\t\\t\\t\\treturn errno.translate(process.errno);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (status.get() !== STILL_ACTIVE) {\\r\\n\\t\\t\\t\\treturn errno.ESRCH;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdefault: {\\r\\n\\t\\t\\t/* Unsupported signal. */\\r\\n\\t\\t\\treturn errno.ENOSYS;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nif (isWin){\\r\\n\\t// kill process (pid) with signal (signum)\\r\\n\\t//===========================================================\\r\\n\\t  exports.kill = function(pid, signum) {\\r\\n\\t//===========================================================\\r\\n\\t\\tvar process_handle = syscall.OpenProcess(\\r\\n\\t\\t\\tsyscall.PROCESS_TERMINATE | syscall.PROCESS_QUERY_INFORMATION,\\r\\n\\t\\t\\t0, pid\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\tif (process_handle === null) {\\r\\n\\t\\t\\terr = process.errno;\\r\\n\\t\\t\\tif (err == errno.ERROR_INVALID_PARAMETER) {\\r\\n\\t\\t\\t\\treturn errno.ESRCH;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn errno.translate(err);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\terr = Win32kill(process_handle, signum);\\r\\n\\t\\tsyscall.CloseHandle(process_handle);\\r\\n\\t\\treturn err;  /* err is already translated. */\\r\\n\\t};\\r\\n} else {\\r\\n\\t// kill process (pid) with signal (signum)\\r\\n\\t//===========================================================\\r\\n\\t  exports.kill = function(pid, signum) {\\r\\n\\t//===========================================================\\r\\n\\t\\tif (syscall.kill(pid, signum) === null){\\r\\n\\t\\t\\treturn process.errno;\\r\\n\\t\\t}\\r\\n\\t\\treturn 0;\\r\\n\\t};\\r\\n}\\r\\n\\r\\n// returns pipe handle type\\r\\n// TCP, NAMED_PIPE, UNKNOWN\\r\\n//===========================================================\\r\\n  exports.pipe_handle_type = function(handle){\\r\\n//===========================================================\\r\\n\\tif (!handle.ipc) {\\r\\n\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t}\\r\\n\\r\\n\\tif (handle.accepted_fd === -1) {\\r\\n\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t}\\r\\n\\r\\n\\telse {\\r\\n\\t\\tvar fd = handle.accepted_fd;\\r\\n\\t\\tvar sockaddr = sock.getsockname(fd);\\r\\n\\r\\n\\t\\tif (sockaddr === null) {\\r\\n\\t\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar type = sock.getsockopt(fd, sock.SOL_SOCKET, sock.SO_TYPE);\\r\\n\\t\\tif (type === null) {\\r\\n\\t\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar family = sock.family(sockaddr);\\r\\n\\t\\tif (family === null) {\\r\\n\\t\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (type === sock.SOCK_STREAM) {\\r\\n\\t\\t\\tif (family === sock.AF_UNIX) {\\r\\n\\t\\t\\t\\treturn 'NAMED_PIPE';\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse if (family === sock.AF_INET || family === sock.AF_INET6 ){\\r\\n\\t\\t\\t\\treturn 'TCP';\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (type === sock.SOCK_DGRAM &&\\r\\n\\t\\t\\t(family === sock.AF_INET || family === sock.AF_INET6)) {\\r\\n\\t\\t\\treturn 'UDP';\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn 'UNKNOWN_HANDLE';\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\n// windows recvmsg & sendmsg emulation\\r\\n// this should be moved to a seperate platform\\r\\n// file ** TODO\\r\\nvar protobuf = struct.create({\\r\\n\\tstart  : 'uint16',\\r\\n\\ttarget : 'uint32',\\r\\n\\tpid    : 'uint32',\\r\\n\\thandle : 'uint32',\\r\\n\\tpad    :  1024 * 6,\\r\\n\\tend    : 'uint16'\\r\\n});\\r\\n\\r\\n\\r\\nif (isWin){\\r\\n\\t// win32 duplicate handle with same access flags\\r\\n\\t//===========================================================\\r\\n\\t  var pseudo_id = syscall.GetCurrentProcess();\\r\\n\\t  exports.duplicate_handle = function(h){\\r\\n\\t//===========================================================\\r\\n\\t\\tvar dupHandle = new struct.int32();\\r\\n\\r\\n\\t\\tvar ret = syscall.DuplicateHandle( pseudo_id, h, pseudo_id, dupHandle, 0, 1,\\r\\n\\t\\t\\tsyscall.DUPLICATE_SAME_ACCESS);\\r\\n\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\tthrow new Error(\\\"can't duplicate handle\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn dupHandle.get();\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t// win32 sendmsg\\r\\n\\t//===========================================================\\r\\n\\t  var dupHandle = new struct.int32();\\r\\n\\t  exports.sendmsg = function(fd, buf, len, fd_to_send, pid, flag){\\r\\n\\t//===========================================================\\r\\n\\t\\tvar protoBuf = new protobuf();\\r\\n\\r\\n\\t\\tvar ret = syscall.DuplicateHandle(\\r\\n\\t\\t\\t-1,\\r\\n\\t\\t\\tfd_to_send,\\r\\n\\t\\t\\t-1,\\r\\n\\t\\t\\tdupHandle, 0, 0,\\r\\n\\t\\t\\tsyscall.DUPLICATE_SAME_ACCESS);\\r\\n\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\tthrow new Error(\\\"can't duplicate\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tprotoBuf.target = pid;\\r\\n\\t\\tprotoBuf.pid = process.pid;\\r\\n\\t\\tprotoBuf.handle = dupHandle.get();\\r\\n\\r\\n\\t\\t// special message\\r\\n\\t\\tprotoBuf.start = 123;\\r\\n\\t\\tprotoBuf.end   = 456;\\r\\n\\r\\n\\t\\t// first send both processid and duplicated handle\\r\\n\\t\\tif (_write(fd, protoBuf, protoBuf.size, flag) !== protoBuf.size){\\r\\n\\t\\t\\tthrow new Error(\\\"error sending handle\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn _write(fd, buf, len, flag);\\r\\n\\t};\\r\\n\\r\\n\\r\\n\\t//===========================================================\\r\\n\\t  var PROCESS_DUP_HANDLE = 0x0040;\\r\\n\\t  exports.recvmsg = function(fd, len, fds){\\r\\n\\t//===========================================================\\r\\n\\t\\tvar protoBuf = new protobuf();\\r\\n\\t\\tvar n = sock.readIntoBuffer(fd, protoBuf, 0);\\r\\n\\t\\tif (n === null) return null;\\r\\n\\r\\n\\t\\t//this is not protocol buffer\\r\\n\\t\\tif (n !== protoBuf.size){\\r\\n\\t\\t\\treturn Buffer(protoBuf).slice(0, n).toString();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// maybe protocol buffer\\r\\n\\t\\tif (protoBuf.start === 123 && protoBuf.end === 456){\\r\\n\\t\\t\\t// print('gottt protocol buffer');\\r\\n\\t\\t\\t// get source process handle\\r\\n\\t\\t\\tvar source = syscall.OpenProcess(PROCESS_DUP_HANDLE, 0, protoBuf.pid);\\r\\n\\t\\t\\tif (source === null){\\r\\n\\t\\t\\t\\tthrow new Error(\\\"can't open process\\\");\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar ret = syscall.DuplicateHandle(\\r\\n\\t\\t\\t\\tsource,\\r\\n\\t\\t\\t\\tprotoBuf.handle,\\r\\n\\t\\t\\t\\t-1,\\r\\n\\t\\t\\t\\tdupHandle, 0, 0,\\r\\n\\t\\t\\t\\tsyscall.DUPLICATE_SAME_ACCESS | syscall.DUPLICATE_CLOSE_SOURCE\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\tif (ret === null){\\r\\n\\t\\t\\t\\tthrow new Error(\\\"can't duplicate\\\");\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfds.push(dupHandle.get());\\r\\n\\t\\t}\\r\\n\\t\\telse { // it's just a normal data sent to socket\\r\\n\\t\\t\\treturn Buffer(protoBuf, 0, n).toString();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn _read(fd, len);\\r\\n\\t};\\r\\n} else {\\r\\n\\t// linux sendmsg\\r\\n\\t//===========================================================\\r\\n\\t  exports.sendmsg = function(fd, buf, len, fd_to_send, pid, flag){\\r\\n\\t//===========================================================\\r\\n\\t\\t//send fd\\r\\n\\t\\tif (sock.sendfd(fd, fd_to_send) === null){\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\t\\treturn _write(fd, buf, len, flag);\\r\\n\\t};\\r\\n\\r\\n\\t// linux recvmsg\\r\\n\\t//===========================================================\\r\\n\\t  exports.recvmsg = function(fd, len, fds){\\r\\n\\t//===========================================================\\r\\n\\t\\t//get fd\\r\\n\\t\\tvar pfd = struct.int();\\r\\n\\t\\tpfd.set(-1);\\r\\n\\r\\n\\t\\tvar buf = Buffer(len);\\r\\n\\t\\tvar ret = sock.recvfd(fd, buf, pfd);\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\treturn null;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar nfd = pfd.get();\\r\\n\\t\\tif (nfd !== -1){\\r\\n\\t\\t\\texports.cloexec(nfd, 1);\\r\\n\\t\\t\\tfds.push(nfd);\\r\\n\\t\\t\\tif (ret === 1 && buf[0] === 0){\\r\\n\\t\\t\\t\\treturn exports.recvmsg(fd, len, fds);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn buf.slice(0, ret).toString();\\r\\n\\t};\\r\\n}\\r\\n\\r\\nexports.cloexec  = syscall.cloexec;\\r\\nexports.nonblock = sock.nonblock;\\r\\n\\r\\nexports.O_RDWR  = posix.O_RDWR;\\r\\nexports.open    = posix.open;\\r\\n\\r\\n\\r\\n//===========================================================\\r\\n  exports.TCP    = require('uv/tcp');\\r\\n  exports.Pipe   = require('uv/pipe');\\r\\n  exports.Stream = require('uv/stream');\\r\\n  //exports.TTY    = require('uv/tty');\\r\\n//===========================================================\\r\\n\\r\\n//===========================================================\\r\\n  var uvProcess  = require('uv/process');\\r\\n  exports.spawn  = function(options){\\r\\n//===========================================================\\r\\n\\treturn new uvProcess(options);\\r\\n};\\r\\n\",\"uv/stream\":\"var sock   = require('socket');\\r\\nvar loop   = require('loop');\\r\\nvar errno  = require('errno');\\r\\nvar uv     = require('uv');\\r\\nvar assert = require('assert');\\r\\n\\r\\nvar POLLERR   = loop.POLLERR;\\r\\nvar POLLIN    = loop.POLLIN;\\r\\nvar POLLOUT   = loop.POLLOUT;\\r\\n\\r\\nvar POLLREAD  = POLLIN | POLLERR;\\r\\nvar POLLWRITE = POLLOUT | POLLERR;\\r\\n\\r\\nvar _shutting_mask = ( uv.STREAM_SHUT | uv.STREAM_SHUTTING | uv.CLOSED | uv.CLOSING);\\r\\n\\r\\nvar MAXREAD   =  80 * 1024;\\r\\nvar SEND_FLAG = sock.MSG_NOSIGNAL ? sock.MSG_NOSIGNAL : 0;\\r\\n\\r\\nfunction _accept (self){\\r\\n\\tvar sockfd = self.fd;\\r\\n\\twhile (1) {\\r\\n\\t\\tvar peerfd = sock.accept(sockfd);\\r\\n\\t\\tif (peerfd === null){\\r\\n\\t\\t\\tif (process.errno === errno.EINTR){\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//TODO cloexec\\r\\n\\t\\tif (!sock.nonblock(peerfd, 1)){\\r\\n\\t\\t\\tthrow new Error(\\\"can't set nonblocking peerfd \\\" + peerfd);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn peerfd;\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nfunction Stream (type){\\r\\n\\tthis.type = type;\\r\\n\\tthis.accepted_fd = -1;\\r\\n\\tthis.fd  = -1;\\r\\n\\tthis.flags = 0;\\r\\n\\r\\n\\tthis.queued_fds      = [];\\r\\n\\tthis.pending_queue   = [];\\r\\n\\tthis.write_queue     = [];\\r\\n\\tthis.write_completed = [];\\r\\n\\r\\n\\tthis.write_queue_size = 0;\\r\\n\\r\\n\\tvar self = this;\\r\\n\\tthis.io_watcher = loop.io(function(h, events){\\r\\n\\t\\tself.stream_io(events);\\r\\n\\t});\\r\\n}\\r\\n\\r\\n\\r\\nStream.prototype.server_io = function(events){\\r\\n\\r\\n\\tassert(events === POLLIN);\\r\\n\\tassert(!(this.flags & uv.CLOSING));\\r\\n\\r\\n\\tprocess.errno = 0;\\r\\n\\twhile (this.fd !== -1){\\r\\n\\t\\tassert(this.accepted_fd === -1);\\r\\n\\t\\tvar ret = _accept(this);\\r\\n\\t\\tif (!ret){\\r\\n\\t\\t\\tvar err = process.errno;\\r\\n\\t\\t\\tif (err === errno.EAGAIN || err === errno.EWOULDBLOCK) {\\r\\n\\t\\t\\t\\treturn; //not an error\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (err === errno.ECONNABORTED){\\r\\n\\t\\t\\t\\tcontinue; //nothing to do\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (err === errno.EMFILE || err === errno.ENFILE) {\\r\\n\\t\\t\\t\\tthrow new Error(\\\"EMFILE Error\\\");\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tthis.connection_cb(err);\\r\\n\\t\\t\\tcontinue;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.accepted_fd = ret;\\r\\n\\t\\tthis.connection_cb(0);\\r\\n\\t\\tif (this.accepted_fd != -1) {\\r\\n\\t\\t\\tthis.io_watcher.stop(POLLIN);\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nfunction __stream_recv_cmsg (stream, fds) {\\r\\n\\r\\n\\tfor (var i = 0; i < fds.length; i++){\\r\\n\\t\\tvar fd = fds[i];\\r\\n\\t\\tif (stream.accepted_fd !== -1){\\r\\n\\t\\t\\tstream.queued_fds.push(fd);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tuv.nonblock(fd, 1);\\r\\n\\t\\t\\tstream.accepted_fd = fd;\\r\\n\\t\\t\\tstream.flags |= uv.STREAM_READABLE | uv.STREAM_WRITABLE;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n    return 1;\\r\\n}\\r\\n\\r\\n\\r\\nfunction _read (stream){\\r\\n\\tvar buf;\\r\\n\\tvar err = 0;\\r\\n\\tvar is_ipc;\\r\\n\\r\\n\\tstream.flags &= ~uv.STREAM_READ_PARTIAL;\\r\\n\\r\\n\\t/* Prevent loop starvation when the data comes in as fast as (or faster than)\\r\\n\\t * we can read it. XXX Need to rearm fd if we switch to edge-triggered I/O.\\r\\n\\t*/\\r\\n\\r\\n\\tvar count = 24;\\r\\n\\r\\n\\tvar is_ipc = stream.type === \\\"NAMED_PIPE\\\" && stream.ipc;\\r\\n\\r\\n\\t/* XXX: Maybe instead of having UV_STREAM_READING we just test if\\r\\n\\t * tcp->read_cb is NULL or not?\\r\\n\\t*/\\r\\n\\r\\n\\tvar fds = [];\\r\\n\\tvar fd = stream.fd;\\r\\n\\twhile (stream.read_cb\\r\\n\\t\\t  && (stream.flags & uv.STREAM_READING)\\r\\n\\t\\t  && (count-- > 0)) {\\r\\n\\r\\n\\t\\tassert(fd >= 0);\\r\\n\\r\\n\\t\\tif (!is_ipc) {\\r\\n\\t\\t\\tbuf = uv.read(fd, MAXREAD);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tbuf = uv.recvmsg(fd, MAXREAD, fds);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar error = process.errno;\\r\\n\\t\\tif (buf === null) {\\r\\n\\t\\t\\tif (error === errno.EOF){\\r\\n\\t\\t\\t\\tstream.stream_eof(\\\"\\\");\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t/* Error */\\r\\n\\t\\t\\tif (error === errno.EAGAIN || error === errno.EWOULDBLOCK) {\\r\\n\\t\\t\\t\\t/* Wait for the next one. */\\r\\n\\t\\t\\t\\tif (stream.flags & uv.STREAM_READING) {\\r\\n\\t\\t\\t\\t\\tstream.io_watcher.start(stream.fd, POLLIN);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tstream.read_cb(0, \\\"\\\");\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t/* Error. User should call uv_close(). */\\r\\n\\t\\t\\t\\tstream.read_cb(error, \\\"\\\");\\r\\n\\t\\t\\t\\tif (stream.flags & uv.STREAM_READING) {\\r\\n\\t\\t\\t\\t\\tstream.flags &= ~uv.STREAM_READING;\\r\\n\\t\\t\\t\\t\\tstream.io_watcher.stop(POLLIN);\\r\\n\\t\\t\\t\\t\\tif (!stream.io_watcher.active(POLLOUT)){\\r\\n\\t\\t\\t\\t\\t\\tstream.io_watcher.handle_stop();\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t/* Successful read */\\r\\n\\t\\t\\tif (is_ipc) {\\r\\n\\t\\t\\t\\t__stream_recv_cmsg(stream, fds);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstream.read_cb(0, buf);\\r\\n\\r\\n\\t\\t\\t/* Return if we didn't fill the buffer, there is no more data to read. */\\r\\n\\t\\t\\tif (buf.length < MAXREAD) {\\r\\n\\t\\t\\t\\tstream.flags |= uv.STREAM_READ_PARTIAL;\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nfunction _write_req_finish (req) {\\r\\n\\tvar stream = req.handle;\\r\\n\\treq.call(req, req.error);\\r\\n\\t// stream.write_completed.push(req);\\r\\n\\t// stream.io_feed();\\r\\n}\\r\\n\\r\\n\\r\\nfunction _write(stream) {\\r\\n\\tvar req = stream.write_queue[0];\\r\\n\\tif (!req){ return }\\r\\n\\r\\n\\tvar buffer = req.buf;\\r\\n\\tvar length = req.len;\\r\\n\\tvar nbufs = 0;\\r\\n\\tvar n;\\r\\n\\r\\n\\t//TODO check if array\\r\\n\\tif (Array.isArray(buffer)){\\r\\n\\t\\t//this is an array of buffers to write\\r\\n\\t\\tnbufs = buffer.length;\\r\\n\\t}\\r\\n\\r\\n\\t// writev\\r\\n\\tif (nbufs > 0){\\r\\n\\t\\tthrow new Error(\\\"writev\\\");\\r\\n\\t}\\r\\n\\r\\n\\t// sendmsg\\r\\n\\telse if (req.send_handle) {\\r\\n\\t\\tvar fd_to_send = req.send_handle.fd;\\r\\n\\t\\tvar pid        = stream.ipc_pid;\\r\\n\\t\\tn = uv.sendmsg(stream.fd, buffer, length, fd_to_send, pid, SEND_FLAG);\\r\\n\\t}\\r\\n\\r\\n\\telse { // single write\\r\\n\\t\\tn = uv.write(stream.fd, buffer, length, SEND_FLAG);\\r\\n\\t}\\r\\n\\r\\n\\t// null indicates an error\\r\\n\\tif (n === null){\\r\\n\\t\\t// anything other than EWOULDBLOCK & EAGAIN\\r\\n\\t\\t// should be treated as an error\\r\\n\\t\\tvar error = process.errno;\\r\\n\\t\\tif ( error != errno.EAGAIN && error != errno.EWOULDBLOCK) {\\r\\n\\t\\t\\treq.error = -error;\\r\\n\\t\\t\\t_write_req_finish(req);\\r\\n\\t\\t\\tstream.io_watcher.stop(POLLOUT);\\r\\n\\t\\t\\tif (!stream.io_watcher.active(POLLIN)){\\r\\n\\t\\t\\t\\tstream.io_watcher.handle_stop();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\telse {\\r\\n\\t\\treq.bytes += n;\\r\\n\\t\\tstream.write_queue_size -= n;\\r\\n\\r\\n\\t\\tif (n === length){\\r\\n\\t\\t\\tstream.write_queue.shift();\\r\\n\\t\\t\\t_write_req_finish(req);\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\telse if (n > 0) {\\r\\n\\t\\t\\treq.buf = Buffer(buffer).slice(n, length).toString();\\r\\n\\t\\t\\treq.len = length - n;\\r\\n\\t\\t\\tstream.write_queue[0] = req;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nStream.prototype.stream_io = function(events){\\r\\n\\r\\n\\tif (events === POLLERR){\\r\\n\\t\\tthis.maybe_error = 1;\\r\\n\\t}\\r\\n\\r\\n\\tassert(!(this.flags & uv.CLOSING));\\r\\n\\r\\n\\tif (this.connect_req) {\\r\\n\\t\\tthis.stream_connect();\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tvar fd = this.fd;\\r\\n\\tif ( events & (POLLIN | POLLERR) ){\\r\\n\\t\\t_read(this);\\r\\n\\t}\\r\\n\\r\\n\\tif (this.fd === -1) return;  /* read_cb closed stream. */\\r\\n\\r\\n\\tvar flag = this.flags;\\r\\n\\tif ( (events & POLLERR) &&\\r\\n\\t  (flag & uv.STREAM_READING) &&\\r\\n\\t  (flag & uv.STREAM_READ_PARTIAL) &&\\r\\n\\t  !(flag & uv.STREAM_READ_EOF)) {\\r\\n\\r\\n\\t\\tthis.stream_eof(\\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\tif (this.fd === -1) return;  /* read_cb closed stream. */\\r\\n\\r\\n\\tif (events & (POLLOUT | POLLERR)) {\\r\\n\\t\\t_write(this);\\r\\n\\r\\n\\t\\t//uv_write_callbacks\\r\\n\\t\\twhile (1){\\r\\n\\t\\t\\tvar req = this.write_completed.shift();\\r\\n\\t\\t\\tif (!req) break;\\r\\n\\t\\t\\treq.call(req, req.error);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tthis.write_completed = [];\\r\\n\\t\\tthis.write_completed.length = 0;\\r\\n\\r\\n\\t\\t//uv_drain\\r\\n\\t\\tif (!this.write_queue.length){\\r\\n\\t\\t\\tthis.write_queue.length = 0;\\r\\n\\t\\t\\tthis.io_watcher.stop(POLLOUT);\\r\\n\\t\\t\\tvar flag = this.flags;\\r\\n\\t\\t\\tif ((flag & uv.STREAM_SHUTTING) && !(flag & uv.CLOSING) && !(flag & uv.STREAM_SHUT)) {\\r\\n\\t\\t\\t\\tthis.flags &= ~uv.STREAM_SHUTTING;\\r\\n\\r\\n\\t\\t\\t\\tvar error = 0;\\r\\n\\t\\t\\t\\tif (!sock.shutdown(this.fd, sock.SHUT_WR)){\\r\\n\\t\\t\\t\\t\\terror = process.errno;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tthis.flags |= uv.STREAM_SHUT;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (this.shutdown_cb){\\r\\n\\t\\t\\t\\t\\tthis.shutdown_cb(error);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.stream_eof = function(buf){\\r\\n\\tthis.flags |= uv.STREAM_READ_EOF;\\r\\n\\tthis.io_watcher.stop(POLLIN);\\r\\n\\tif (!this.io_watcher.active(POLLOUT)){\\r\\n\\t\\tthis.io_watcher.handle_stop();\\r\\n\\t}\\r\\n\\r\\n\\tthis.read_cb(errno.EOF, buf);\\r\\n\\tthis.flags &= ~uv.STREAM_READING;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.shutdown = function(cb){\\r\\n\\r\\n\\tif (this.flags & _shutting_mask){\\r\\n\\t\\treturn errno.ENOTCONN;\\r\\n\\t}\\r\\n\\r\\n\\tthis.shutdown_cb = cb;\\r\\n\\tthis.flags |= uv.STREAM_SHUTTING;\\r\\n\\r\\n\\tif (!this.io_watcher.active(POLLOUT)){\\r\\n\\t\\tthis.io_watcher.start(this.fd, POLLWRITE);\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.close = function(cb){\\r\\n\\tthis.flags |= uv.CLOSING;\\r\\n\\tthis.read_stop();\\r\\n\\tthis.io_watcher.close(cb);\\r\\n\\r\\n\\tif (this.fd !== -1){\\r\\n\\t\\tsock.close(this.fd);\\r\\n\\t\\tthis.fd = -1;\\r\\n\\t}\\r\\n\\r\\n\\tif (this.accepted_fd !== -1){\\r\\n\\t\\tsock.close(this.accepted_fd);\\r\\n\\t\\tthis.accepted_fd = -1;\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.read_stop = function(cb){\\r\\n\\tif (!(this.flags & uv.STREAM_READING)) return 0;\\r\\n\\r\\n\\tthis.flags &= ~uv.STREAM_READING;\\r\\n\\tthis.io_watcher.stop(POLLIN);\\r\\n\\tif (!this.io_watcher.active(POLLOUT)){\\r\\n\\t\\tthis.io_watcher.handle_stop();\\r\\n\\t}\\r\\n\\r\\n\\tthis.read_cb = null;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.stream_open = function(fd, flags){\\r\\n\\tif (!(this.fd === -1 || this.fd === fd)){\\r\\n\\t\\treturn errno.EBUSY;\\r\\n\\t}\\r\\n\\r\\n\\tthis.flags |= flags;\\r\\n\\r\\n\\tif (this.type === \\\"TCP\\\") {\\r\\n\\t\\t// if ((this.flags & uv.TCP_NODELAY) && uv__tcp_nodelay(fd, 1)){\\r\\n\\t\\t//     return process.errno;\\r\\n\\t\\t// }\\r\\n\\r\\n\\t\\t/* TODO Use delay the user passed in. */\\r\\n\\t\\t// if ((this.flags & uv.TCP_KEEPALIVE) && uv__tcp_keepalive(fd, 1, 60)) {\\r\\n\\t\\t//     return process.errno;\\r\\n\\t\\t// }\\r\\n\\t}\\r\\n\\r\\n\\tthis.fd = fd;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\n//override in uv/tcp.js\\r\\nStream.prototype.connect = function(ip, port, cb){\\r\\n\\treturn errno.EINVAL;\\r\\n};\\r\\n\\r\\n\\r\\n//override in tcp.js & uv/ipc.js\\r\\nStream.prototype.listen = function(backlog, cb){\\r\\n\\treturn errno.EINVAL;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.accept = function(client){\\r\\n\\tif (this.accepted_fd === -1) return errno.EINVAL;\\r\\n\\r\\n\\tvar ret = client.stream_open(this.accepted_fd, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n\\tif (ret){\\r\\n\\t\\tthrow new Error(\\\"stream open error\\\");\\r\\n\\t}\\r\\n\\r\\n\\tthis.accepted_fd = -1;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.read_start = function(cb){\\r\\n\\r\\n\\tif (this.flags & uv.CLOSING) return errno.EINVAL;\\r\\n\\r\\n\\tif (cb) this.read_cb = cb.bind(this);\\r\\n\\r\\n\\tthis.flags |= uv.STREAM_READING;\\r\\n\\r\\n\\t//TODO try to read immediately\\r\\n\\tassert(this.fd !== -1);\\r\\n\\tthis.io_watcher.start(this.fd, POLLREAD);\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.dowrite = function(){\\r\\n\\tvar self = this;\\r\\n\\tvar sockfd = self.fd;\\r\\n\\tassert(sockfd > 0);\\r\\n\\r\\n\\tvar req = this.write_queue[0];\\r\\n\\tif (!req){\\r\\n\\t\\tself.write_queue.length = 0;\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tvar buf    = req.buf;\\r\\n\\tvar length = req.len;\\r\\n\\r\\n\\r\\n\\tvar n = sock.send(sockfd, buf, length, SEND_FLAG);\\r\\n\\tif (n === null){\\r\\n\\t\\t//do nothing just yet\\r\\n\\t\\t//queue it for the event loop\\r\\n\\t} else {\\r\\n\\t\\tself.write_queue_size -= n;\\r\\n\\t\\tif (n === length){\\r\\n\\t\\t\\tself.write_queue.shift();\\r\\n\\t\\t\\treq.call(self, 0, n);\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t} else if (n > 0) {\\r\\n\\t\\t\\treq.buf = Buffer(buf).slice(n, length).toString();\\r\\n\\t\\t\\treq.len = length - n;\\r\\n\\t\\t\\tself.write_queue[0] = req;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (!self.io_watcher.active(POLLOUT)){\\r\\n\\t\\tself.io_watcher.start(sockfd, POLLWRITE);\\r\\n\\t}\\r\\n\\treturn n;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.write = function(buf, cb, send_handle){\\r\\n\\tvar self = this;\\r\\n\\tvar sockfd = self.fd;\\r\\n\\tassert(sockfd > 0);\\r\\n\\r\\n\\tif (Array.isArray(buf)){\\r\\n\\t\\tvar last = buf.pop();\\r\\n\\t\\tbuf.forEach(function(b){\\r\\n\\t\\t\\tself.write(b);\\r\\n\\t\\t});\\r\\n\\r\\n\\t\\treturn self.write(last, cb);\\r\\n\\t}\\r\\n\\r\\n\\tvar empty_queue = self.write_queue_size === 0;\\r\\n\\tvar length = Buffer.byteLength(buf);\\r\\n\\tself.write_queue_size += length;\\r\\n\\r\\n\\tvar req    = cb || function (){};\\r\\n\\treq.buf    = buf;\\r\\n\\treq.send_handle = send_handle;\\r\\n\\treq.len    = length;\\r\\n\\treq.handle = self;\\r\\n\\treq.write_index = 0;\\r\\n\\treq.bytes = 0;\\r\\n\\treq.error = 0;\\r\\n\\r\\n\\tself.write_queue.push(req);\\r\\n\\r\\n\\tif (self.connect_req) {\\r\\n\\t\\t//still connecting\\r\\n\\t}\\r\\n\\telse if (empty_queue){\\r\\n\\t\\t_write(self);\\r\\n\\t}\\r\\n\\telse {\\r\\n\\t\\tself.io_watcher.start(sockfd, POLLWRITE);\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.stream_connect = function(){\\r\\n\\r\\n\\tassert(this.type == \\\"TCP\\\" || this.type == \\\"NAMED_PIPE\\\");\\r\\n\\r\\n\\tvar error = 0;\\r\\n\\tif (this.delayed_error) {\\r\\n\\t\\t/* To smooth over the differences between unixes errors that\\r\\n\\t\\t * were reported synchronously on the first connect can be delayed\\r\\n\\t\\t * until the next tick--which is now.\\r\\n\\t\\t */\\r\\n\\t\\terror = this.delayed_error;\\r\\n\\t\\tthis.delayed_error = 0;\\r\\n\\t} else {\\r\\n\\t\\t/* Normal situation: we need to get the socket error from the kernel. */\\r\\n\\t\\tassert(this.fd >= 0);\\r\\n\\t\\terror = sock.getsockopt(this.fd, sock.SOL_SOCKET, sock.SO_ERROR);\\r\\n\\t}\\r\\n\\r\\n\\tif (error === errno.EINPROGRESS) {\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tthis.connect_req = null;\\r\\n\\r\\n\\tif (error || this.write_queue.length === 0) {\\r\\n\\t\\tthis.io_watcher.stop(POLLOUT);\\r\\n\\t}\\r\\n\\r\\n\\tif (this.connect_req_cb) {\\r\\n\\t\\tvar cb = this.connect_req_cb;\\r\\n\\t\\t// this.connect_req_cb = null;\\r\\n\\t\\tcb(error);\\r\\n\\t}\\r\\n\\r\\n\\tif (this.fd === -1){\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (error) {\\r\\n\\t\\t// throw new Error(\\\"flush write & connect error \\\" + error);\\r\\n\\t\\t// uv__stream_flush_write_queue(stream, -ECANCELED);\\r\\n\\t\\t// uv__write_callbacks(stream);\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nStream.prototype.io_feed = function(){\\r\\n\\tvar stream = this;\\r\\n\\tvar io = this.io_watcher;\\r\\n\\tsetTimeout(function(){\\r\\n\\t\\tstream.stream_io(POLLOUT);\\r\\n\\t}, 1);\\r\\n};\\r\\n\\r\\n\\r\\nmodule.exports = Stream;\\r\\n\",\"uv/tcp\":\"var util   = require(\\\"util\\\");\\r\\nvar stream = require('uv/stream');\\r\\nvar sock   = require('socket');\\r\\nvar errno  = require('errno');\\r\\nvar loop   = require('loop');\\r\\nvar uv     = require('uv');\\r\\nvar assert = require('assert');\\r\\n\\r\\nvar isWin  = process.platform === \\\"win32\\\";\\r\\n\\r\\nutil.inherits(TCP, stream);\\r\\nfunction TCP (){\\r\\n\\tstream.call(this, 'TCP');\\r\\n}\\r\\n\\r\\n\\r\\nTCP.prototype.open = function(s){\\r\\n\\tif (!sock.nonblock(s, 1)){\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\treturn this.stream_open(s, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.maybe_new_socket = function(domain, flags){\\r\\n\\tif (domain == sock.AF_UNSPEC || this.fd !== -1) {\\r\\n\\t\\tthis.flags |= flags;\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\tvar fd = uv.socket(domain, sock.SOCK_STREAM, 0);\\r\\n\\tif (!fd) return process.errno;\\r\\n\\r\\n\\tthis.stream_open(fd, flags);\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.simultaneous_accepts = function(enable){\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.bind = function(addr, flags) {\\r\\n\\r\\n\\tvar family = sock.family(addr);\\r\\n\\r\\n\\t/* Cannot set IPv6-only mode on non-IPv6 socket. */\\r\\n\\tif ((flags & uv.TCP_IPV6ONLY) && family !== uv.AF_INET6) {\\r\\n\\t\\treturn errno.EINVAL;\\r\\n\\t}\\r\\n\\r\\n\\tvar err = this.maybe_new_socket(family, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n\\r\\n\\tif (err) return err;\\r\\n\\r\\n\\tif (!sock.setsockopt(this.fd, sock.SOL_SOCKET, sock.SO_REUSEADDR, 1)) {\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\tprocess.errno = 0;\\r\\n\\tif (!sock.bind(this.fd, addr) && process.errno !== errno.EADDRINUSE) {\\r\\n\\t\\tif (process.errno === errno.EAFNOSUPPORT) {\\r\\n\\t\\t\\t/* OSX, other BSDs and SunoS fail with EAFNOSUPPORT when binding a\\r\\n\\t\\t\\t* socket created with AF_INET to an AF_INET6 address or vice versa. */\\r\\n\\t\\t\\treturn errno.EINVAL;\\r\\n\\t\\t}\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\tthis.delayed_error = process.errno;\\r\\n\\r\\n\\tif (family === sock.AF_INET6) {\\r\\n\\t\\tthis.flags |= uv.HANDLE_IPV6;\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.listen = function(backlog, cb){\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tif (this.delayed_error) {\\r\\n\\t\\treturn this.delayed_error;\\r\\n\\t}\\r\\n\\r\\n\\tthis.maybe_new_socket(sock.AF_INET, uv.STREAM_READABLE);\\r\\n\\r\\n\\tif (!sock.listen(this.fd, backlog)){\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\tthis.connection_cb = cb.bind(this);\\r\\n\\r\\n\\t//FIXME: io_watcher still here\\r\\n\\t//we need to free resources\\r\\n\\tthis.handle = loop.io(function(h, events){\\r\\n\\t\\tself.server_io(events);\\r\\n\\t});\\r\\n\\r\\n\\tthis.handle.start(this.fd, loop.POLLIN);\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.connect = function(addr, cb){\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tif (this.connect_req){\\r\\n\\t\\treturn errno.EALREADY;\\r\\n\\t}\\r\\n\\r\\n\\tvar family = sock.family(addr);\\r\\n\\r\\n\\tvar err = this.maybe_new_socket(family, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n\\tif (err) return err;\\r\\n\\r\\n\\tthis.delayed_error = 0;\\r\\n\\tthis.connect_req    = 1;\\r\\n\\tif (cb) this.connect_req_cb = cb.bind(this);\\r\\n\\r\\n\\tself.io_watcher.start(self.fd, loop.POLLOUT);\\r\\n\\tsock.connect(this.fd, addr);\\r\\n\\r\\n\\tif (this.delayed_error) {\\r\\n\\t\\tthis.io_feed();\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.connect = function(addr, cb){\\r\\n\\r\\n\\tif (this.connect_req){\\r\\n\\t\\treturn errno.EALREADY;  /* FIXME(bnoordhuis) -EINVAL or maybe -EBUSY. */\\r\\n\\t}\\r\\n\\r\\n\\tvar family = sock.family(addr);\\r\\n\\r\\n\\tvar err = this.maybe_new_socket(family, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n\\tif (err) return err;\\r\\n\\r\\n\\tthis.delayed_error = 0;\\r\\n\\r\\n\\tdo {\\r\\n\\t\\tr = sock.connect(this.fd, addr);\\r\\n\\t\\tif (isWin && r === null) sock.can_read(this.fd, 1);\\r\\n\\t} while (\\r\\n\\t\\tr === null && (process.errno === errno.EINTR ||\\r\\n\\t\\tisWin && process.errno === errno.EWOULDBLOCK)\\r\\n\\t);\\r\\n\\r\\n\\tvar error = process.errno;\\r\\n\\tif (r === null) {\\r\\n\\t\\tif (error === errno.EINPROGRESS || (isWin && error === 10056)) {\\r\\n\\t\\t\\t// this.delayed_error = error;\\r\\n\\t\\t\\t/* not an error */\\r\\n\\t\\t} else if (error === errno.ECONNREFUSED || error === 10037) {\\r\\n\\t\\t\\t/* If we get a ECONNREFUSED wait until the next tick to report the\\r\\n\\t\\t\\t * error. Solaris wants to report immediately--other unixes want to\\r\\n\\t\\t\\t * wait.\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tthis.delayed_error = errno.ECONNREFUSED;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn error;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tthis.connect_req    = 1;\\r\\n\\tif (cb) this.connect_req_cb = cb.bind(this);\\r\\n\\r\\n\\tthis.io_watcher.start(this.fd, loop.POLLOUT);\\r\\n\\r\\n\\tif (this.delayed_error) {\\r\\n\\t\\tthis.io_feed();\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\nmodule.exports = TCP;\\r\\n\",\"uv/pipe\":\"var util   = require(\\\"util\\\");\\r\\nvar stream = require('uv/stream');\\r\\nvar sock   = require('socket');\\r\\nvar errno  = require('errno');\\r\\nvar loop   = require('loop');\\r\\nvar uv     = require('uv');\\r\\nvar assert = require('assert');\\r\\n\\r\\nvar isWin  = process.platform === 'win32';\\r\\n\\r\\nvar pipe_map = {};\\r\\n\\r\\nutil.inherits(Pipe, stream);\\r\\nfunction Pipe (ipc){\\r\\n\\tstream.call(this, 'NAMED_PIPE');\\r\\n\\tthis.shutdown_req = null;\\r\\n\\tthis.connect_req = null;\\r\\n\\tthis.pipe_fname = null;\\r\\n\\tthis.ipc = ipc;\\r\\n}\\r\\n\\r\\n\\r\\nPipe.prototype.open = function(fd){\\r\\n\\tif (!sock.nonblock(fd, 1)){\\r\\n\\t\\tthrow new Error(process.errno);\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\treturn this.stream_open(fd, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.listen = function(backlog, cb){\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tif (this.fd === -1) return errno.EINVAL;\\r\\n\\r\\n\\tif (!sock.listen(this.fd, backlog)){\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\t// we already have io_watcher active with\\r\\n\\t// stream_io, clean this up and activate again\\r\\n\\t// on server_io cb\\r\\n\\tthis.io_watcher.close();\\r\\n\\tthis.io_watcher = null;\\r\\n\\r\\n\\tthis.connection_cb = cb;\\r\\n\\tthis.io_watcher = loop.io(function(h, events){\\r\\n\\t\\tself.server_io(events);\\r\\n\\t});\\r\\n\\r\\n\\tthis.io_watcher.start(this.fd, loop.POLLIN);\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.bind = function(pipe_fname) {\\r\\n\\r\\n\\tvar sockfd;\\r\\n\\r\\n\\t/* Already bound? */\\r\\n\\tif (this.fd >= 0) {\\r\\n\\t\\treturn errno.EINVAL;\\r\\n\\t}\\r\\n\\r\\n\\t//we are emulatiing AF_UNIX\\r\\n\\tif (isWin){\\r\\n\\t\\tsockfd = uv.socket(sock.AF_INET, sock.SOCK_STREAM, 0);\\r\\n\\t} else {\\r\\n\\t\\tsockfd = uv.socket(sock.AF_UNIX, sock.SOCK_STREAM, 0);\\r\\n\\t}\\r\\n\\r\\n\\tif (!sockfd) return process.errno;\\r\\n\\r\\n\\tvar addr = sock.pton(\\\"127.0.0.1\\\", 8000);\\r\\n\\tif (addr === null){\\r\\n\\t\\tthrow new Error(\\\"addr error \\\" + process.errno);\\r\\n\\t}\\r\\n\\r\\n\\tpipe_map[pipe_fname] = addr;\\r\\n\\r\\n\\t// memset(&saddr, 0, sizeof saddr);\\r\\n\\t// strncpy(saddr.sun_path, pipe_fname, sizeof(saddr.sun_path) - 1);\\r\\n\\t// saddr.sun_path[sizeof(saddr.sun_path) - 1] = '\\\\0';\\r\\n\\t// saddr.sun_family = AF_UNIX;\\r\\n\\r\\n\\tif (!sock.bind(sockfd, addr)) {\\r\\n\\t\\tuv.close(sockfd);\\r\\n\\t\\t/* Convert ENOENT to EACCES for compatibility with Windows. */\\r\\n\\t\\tif (process.errno == errno.ENOENT) return errno.EACCES;\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\t/* Success. */\\r\\n\\tthis.pipe_fname = pipe_fname; /* Is a strdup'ed copy. */\\r\\n\\tthis.fd = sockfd;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.connect = function(name, cb) {\\r\\n\\r\\n\\tvar new_sock = (this.fd === -1);\\r\\n\\r\\n\\tif (new_sock) {\\r\\n\\t\\tif (isWin){\\r\\n\\t\\t\\tnewSock = uv.socket(sock.AF_INET, sock.SOCK_STREAM, 0);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tnewSock = uv.socket(sock.AF_UNIX, sock.SOCK_STREAM, 0);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (!newSock) return this.connect_error();\\r\\n\\t\\tthis.fd = newSock;\\r\\n\\t}\\r\\n\\r\\n\\t// memset(&saddr, 0, sizeof saddr);\\r\\n\\t// strncpy(saddr.sun_path, name, sizeof(saddr.sun_path) - 1);\\r\\n\\t// saddr.sun_path[sizeof(saddr.sun_path) - 1] = '\\\\0';\\r\\n\\t// saddr.sun_family = AF_UNIX;\\r\\n\\r\\n\\tvar addr = pipe_map[name];\\r\\n\\tvar err = 0;\\r\\n\\tvar r;\\r\\n\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tthis.connect_req   = 1;\\r\\n\\tif (cb) this.connect_req_cb = cb.bind(this);\\r\\n\\r\\n\\tif (new_sock) {\\r\\n\\t\\terr = this.stream_open(this.fd, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n\\t}\\r\\n\\r\\n\\tself.io_watcher.start(self.fd, loop.POLLIN | loop.POLLOUT | loop.POLLERR);\\r\\n\\tsock.connect(this.fd, addr);\\r\\n\\r\\n\\tthis.delayed_error = err;\\r\\n\\r\\n\\t// do {\\r\\n\\t//     r = sock.connect(this.fd, addr);\\r\\n\\t// } while ( r === null && process.errno === errno.EINTR);\\r\\n\\r\\n\\r\\n\\r\\n\\t// if (!r && (process.errno !== errno.EINPROGRESS)) {\\r\\n\\t//     err = process.errno;\\r\\n\\t// } else {\\r\\n\\t//     if (new_sock) {\\r\\n\\t//         err = this.stream_open(this.fd, uv.STREAM_READABLE | uv.STREAM_WRITABLE);\\r\\n\\t//     }\\r\\n\\r\\n\\t//     if (err == 0) {\\r\\n\\t//         this.io_watcher.start(loop.POLLIN | loop.POLLOUT);\\r\\n\\t//     }\\r\\n\\t// }\\r\\n\\r\\n\\t// this.delayed_error = err;\\r\\n\\t// this.connect_req   = 1;\\r\\n\\t// if (cb) this.connect_req_cb = cb.bind(this);\\r\\n\\r\\n\\t// /* Force callback to run on next tick in case of error. */\\r\\n\\t// if (err) this.io_feed();\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\nmodule.exports = Pipe;\\r\\n\",\"uv/process\":\"var isWin = process.platform === 'win32';\\r\\nmodule.exports = isWin ? require('uv/process/windows') :\\r\\n                         require('uv/process/unix');\\r\\n\",\"uv/process/windows\":\"var assert   = require('assert');\\r\\nvar uv       = require('uv');\\r\\nvar errno    = require('errno');\\r\\nvar syscall  = require('syscall');\\r\\nvar timers   = require('timers');\\r\\n\\r\\nvar DETACHED_PROCESS           = 0x00000008;\\r\\nvar CREATE_NEW_PROCESS_GROUP   = 0x00000200;\\r\\nvar CREATE_UNICODE_ENVIRONMENT = 0x00000400;\\r\\nvar CREATE_NO_WINDOW           = 0x08000000;\\r\\n\\r\\nvar READ_PIPE  = 0;\\r\\nvar WRITE_PIPE = 1;\\r\\n\\r\\n// TODO child_watcher ref\\r\\n\\r\\nfunction Process (options) {\\r\\n\\r\\n\\tthis.exit_signal = 0;\\r\\n\\r\\n\\toptions = options || {};\\r\\n\\tassert(options.file, \\\"options.file required\\\");\\r\\n\\r\\n\\tassert(!(options.flags & ~(\\r\\n\\t\\tuv.PROCESS_DETACHED |\\r\\n\\t\\tuv.PROCESS_SETGID |\\r\\n\\t\\tuv.PROCESS_SETUID |\\r\\n\\t\\tuv.PROCESS_WINDOWS_HIDE |\\r\\n\\t\\tuv.PROCESS_WINDOWS_VERBATIM_ARGUMENTS\\r\\n\\t)));\\r\\n\\r\\n\\tvar stdio_count = options.stdio_count;\\r\\n\\tif (stdio_count < 3) stdio_count = 3;\\r\\n\\r\\n\\tvar err = errno.ENOMEM;\\r\\n\\r\\n\\tvar pipes = [];\\r\\n\\r\\n\\tfor (var i = 0; i < stdio_count; i++) {\\r\\n\\t\\tpipes[i]    = [];\\r\\n\\t\\tpipes[i][0] = -1;\\r\\n\\t\\tpipes[i][1] = -1;\\r\\n\\t}\\r\\n\\r\\n\\tfor (var i = 0; i < options.stdio_count; i++) {\\r\\n\\t\\terr = this.init_stdio(options.stdio[i], pipes[i], i);\\r\\n\\t\\tif (err) throw new Error(\\\"STDIO initiate error \\\" + err);\\r\\n\\t}\\r\\n\\r\\n\\tthis.status = 0;\\r\\n\\tthis.pid = 0;\\r\\n\\tthis.exit_cb = options.exit_cb;\\r\\n\\r\\n\\t// on error returns null and set process.errno\\r\\n\\t// on success returns an object hold process\\r\\n\\t// handle and process id\\r\\n\\tvar ret = this.child_init(options, stdio_count, pipes);\\r\\n\\tthis.pipes = pipes;\\r\\n\\r\\n\\tif (ret === null) {\\r\\n\\t\\terr = process.errno;\\r\\n\\t\\tthis.errno = errno.translate(process.errno);\\r\\n\\t} else {\\r\\n\\t\\tthis.process_handle = ret.process || -1;\\r\\n\\t\\tthis.pid = ret.process_id || 0;\\r\\n\\t}\\r\\n\\r\\n\\tfor (var i = 0; i < options.stdio_count; i++) {\\r\\n\\t\\t// set process id for all stream pipes\\r\\n\\t\\t// we need to use this with msgrecv function\\r\\n\\t\\tvar stream = options.stdio[i].stream;\\r\\n\\t\\tif (stream){\\r\\n\\t\\t\\tif (stream.type === 'NAMED_PIPE' || stream.type){\\r\\n\\t\\t\\t\\toptions.stdio[i].stream.ipc_pid = this.pid;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\terr = this.open_stream(options.stdio[i], pipes[i], i === 0);\\r\\n\\t\\tif (err === 0) continue;\\r\\n\\r\\n\\t\\twhile (i--) {\\r\\n\\t\\t\\tthis.close_stream(options.stdio[i]);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// Only activate this handle if exec() happened\\r\\n\\t// successfully, we are hacky here as we are using\\r\\n\\t// a timer loop to check for process status\\r\\n\\tif ( !err && this.pid ) {\\r\\n\\t\\tvar self = this;\\r\\n\\t\\tvar process_handle = this.process_handle;\\r\\n\\t\\tself.child_watcher = setInterval(function(){\\r\\n\\t\\t\\tvar exitcode = uv.get_exit_code(process_handle);\\r\\n\\r\\n\\t\\t\\t// 259 indicates that the\\r\\n\\t\\t\\t// process still running\\r\\n\\t\\t\\tif (exitcode === 259){\\r\\n\\t\\t\\t\\treturn; /* do nothing we need to check again */\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// stop child status watcher\\r\\n\\t\\t\\tclearInterval(this);\\r\\n\\t\\t\\tself.child_watcher = null;\\r\\n\\r\\n\\t\\t\\t// close process handle\\r\\n\\t\\t\\tassert(syscall.CloseHandle(self.process_handle) !== null);\\r\\n\\r\\n\\t\\t\\tif (self.exit_cb) self.exit_cb.call(self, exitcode, self.exit_signal);\\r\\n\\r\\n\\t\\t\\tfor (var fd = 0; fd < pipes.length; fd++) {\\r\\n\\t\\t\\t\\tif (pipes[fd][0] > -1){\\r\\n\\t\\t\\t\\t\\tuv.close(pipes[fd][0]);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}, 1);\\r\\n\\t} else {\\r\\n\\t\\tfor (var fd = 0; fd < pipes.length; fd++) {\\r\\n\\t\\t\\tif (pipes[fd][0] > -1){\\r\\n\\t\\t\\t\\tuv.close(pipes[fd][0]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (err) {\\r\\n\\t\\tthis.errno = errno.translate(err);\\r\\n\\t}\\r\\n\\treturn this;\\r\\n}\\r\\n\\r\\n\\r\\nProcess.prototype.unref = function(){\\r\\n\\tif (this.child_watcher){\\r\\n\\t\\tthis.child_watcher.unref();\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.open_stream = function (container, pipefds, writable) {\\r\\n\\r\\n\\tif (!(container.flags & uv.CREATE_PIPE) || pipefds[0] < 0) {\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\tvar flags = 0;\\r\\n\\r\\n\\tif (container.stream.type === 'NAMED_PIPE' && container.stream.ipc ) {\\r\\n\\t\\tflags = uv.STREAM_READABLE | uv.STREAM_WRITABLE;\\r\\n\\t}\\r\\n\\r\\n\\telse if (writable) {\\r\\n\\t\\tflags = uv.STREAM_WRITABLE;\\r\\n\\t}\\r\\n\\r\\n\\telse {\\r\\n\\t\\tflags = uv.STREAM_READABLE;\\r\\n\\t}\\r\\n\\r\\n\\treturn container.stream.stream_open(pipefds[1], flags);\\r\\n};\\r\\n\\r\\n\\r\\n// constructs a utf16 buffer of environment\\r\\n// variables block, windows require each env to be\\r\\n// seperated with 1 nul and ends with 2 nul charachters\\r\\nfunction make_env_block(env){\\r\\n\\tif (!env){\\r\\n\\t\\treturn null;\\r\\n\\t}\\r\\n\\r\\n\\tvar envBlock = process.env;\\r\\n\\r\\n\\t//extend\\r\\n\\tfor (var key in envBlock){\\r\\n\\t\\tenv.unshift(key + '=' + envBlock[key]);\\r\\n\\t}\\r\\n\\r\\n\\tvar len = env.length;\\r\\n\\r\\n\\tvar n = \\\"\\\";\\r\\n\\tfor (var i = 0; i < len; i++){\\r\\n\\t\\tn += env[i] + '\\\\0';\\r\\n\\t}\\r\\n\\tn += '\\\\0\\\\0';\\r\\n\\treturn new Buffer(n, 'ucs2');\\r\\n}\\r\\n\\r\\n\\r\\nfunction join_arguments (args, verbatim){\\r\\n\\tif (!verbatim){\\r\\n\\t\\tfor (var i = 0; i < args.length; i++){\\r\\n\\t\\t\\tvar arg = args[i];\\r\\n\\t\\t\\tif (/\\\\s/g.test(arg)){\\r\\n\\t\\t\\t\\targ.replace(/\\\"/g, '\\\\\\\"');\\r\\n\\t\\t\\t\\targ = '\\\"' + arg + '\\\"'\\r\\n\\t\\t\\t\\targs[i] = arg;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\targs = args.join(' ');\\r\\n\\treturn syscall.UTF16PtrFromString(args);\\r\\n}\\r\\n\\r\\n\\r\\nProcess.prototype.child_init = function(options, stdio_count, pipes) {\\r\\n\\r\\n\\tvar process_flags = CREATE_UNICODE_ENVIRONMENT;\\r\\n\\tif (options.flags & uv.PROCESS_DETACHED) {\\r\\n\\t\\tprocess_flags |= DETACHED_PROCESS | CREATE_NEW_PROCESS_GROUP;\\r\\n\\t}\\r\\n\\r\\n\\t//initiate stdio handles\\r\\n\\tvar stdioHandles = [-1, -1, -1];\\r\\n\\r\\n\\tfor (var fd = 0; fd < stdio_count; fd++) {\\r\\n\\t\\tvar use_handle   = pipes[fd][2];\\r\\n\\t\\tif (use_handle > -1) {\\r\\n\\t\\t\\tif (fd <= 2) {\\r\\n\\t\\t\\t\\tstdioHandles[fd] = use_handle;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t// store shared handles?\\r\\n\\t\\t\\t\\toptions.env = options.env || [];\\r\\n\\t\\t\\t\\toptions.env.push(\\\"COMO_FD_\\\"+fd+'='+use_handle);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// working directory\\r\\n\\tvar cwd = null\\r\\n\\tif (options.cwd) {\\r\\n\\t\\tcwd = syscall.UTF16PtrFromString(options.cwd);\\r\\n\\t} else {\\r\\n\\t\\tcwd = syscall.GetCurrentDirectory();\\r\\n\\t\\tif (!cwd) return null;\\r\\n\\t}\\r\\n\\r\\n\\t// var path = syscall.Getenv('PATH');\\r\\n\\r\\n\\t//custom env block\\r\\n\\tvar env = null;\\r\\n\\tif (options.env) {\\r\\n\\t\\tenv = make_env_block(options.env);\\r\\n\\t}\\r\\n\\r\\n\\t// CreateProcess syscall\\r\\n\\tvar info    = new syscall.ProcessInformation();\\r\\n\\tvar startup = new syscall.StartupInfo();\\r\\n\\r\\n\\tstartup.Cb = startup.size;\\r\\n\\tstartup.Flags = (syscall.STARTF_USESTDHANDLES | syscall.STARTF_USESHOWWINDOW);\\r\\n\\tstartup.StdInput  = stdioHandles[0];\\r\\n\\tstartup.StdOutput = stdioHandles[1];\\r\\n\\tstartup.StdError  = stdioHandles[2];\\r\\n\\r\\n\\tif (options.flags & uv.PROCESS_WINDOWS_HIDE) {\\r\\n\\t\\t/* Use SW_HIDE to avoid any potential process window. */\\r\\n\\t\\tstartup.ShowWindow = syscall.SW_HIDE;\\r\\n\\t} else {\\r\\n\\t\\tstartup.wShowWindow = syscall.SW_SHOWDEFAULT;\\r\\n\\t}\\r\\n\\r\\n\\tvar program = null;\\r\\n\\tvar arguments = join_arguments(options.args,\\r\\n\\t\\toptions.flags & uv.PROCESS_WINDOWS_VERBATIM_ARGUMENTS);\\r\\n\\r\\n\\t// syscall CreateProcess\\r\\n\\t// on failure returns null and set\\r\\n\\t// process.errno to last error\\r\\n\\tvar ret = syscall.CreateProcess(\\r\\n\\t\\tprogram,      // programs path\\r\\n\\t\\targuments,    // utf16 buffer of all args\\r\\n\\t\\tnull,\\r\\n\\t\\tnull,\\r\\n\\t\\t1,\\r\\n\\t\\tprocess_flags,\\r\\n\\t\\tenv,          // utf16 env block\\r\\n\\t\\tcwd,          // child working director\\r\\n\\t\\tstartup,      // startup info\\r\\n\\t\\tinfo          // new created process info\\r\\n\\t);\\r\\n\\r\\n\\t// duplicated handles passed to the child\\r\\n\\t// we can close them now\\r\\n\\tfor (var fd = 0; fd < pipes.length; fd++) {\\r\\n\\t\\tif (pipes[fd][2] !== -1){\\r\\n\\t\\t\\tuv.close(pipes[fd][2]);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (ret === null) return null;\\r\\n\\r\\n\\tassert(syscall.CloseHandle(info.Thread) !== null);\\r\\n\\r\\n\\treturn {\\r\\n\\t\\tprocess: info.Process,\\r\\n\\t\\tprocess_id : info.ProcessId\\r\\n\\t};\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.init_stdio = function (container, fds, i) {\\r\\n\\tvar STDIO_MASK = uv.IGNORE | uv.CREATE_PIPE | uv.INHERIT_FD | uv.INHERIT_STREAM;\\r\\n\\r\\n\\t// initiated fd to invalid handle\\r\\n\\t// ignore by default\\r\\n\\tif (i <= 2) fds[2] = -1;\\r\\n\\r\\n\\tif (!container) return 0;\\r\\n\\tswitch (container.flags & STDIO_MASK){\\r\\n\\t\\tcase uv.IGNORE : {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase uv.CREATE_PIPE : {\\r\\n\\t\\t\\tassert(container.stream.type === 'NAMED_PIPE');\\r\\n\\r\\n\\t\\t\\tif (uv.make_socketpair(fds, 0)) throw new Error(\\\"Error creating socketpair\\\");\\r\\n\\t\\t\\tvar fh = fds[0];\\r\\n\\t\\t\\tvar inherit_handle = -1;\\r\\n\\t\\t\\tif (i > 2) {\\r\\n\\t\\t\\t\\tinherit_handle = uv.make_inheritable(fh);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tinherit_handle = uv.duplicate_handle(fh);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfds[2] = inherit_handle;\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase uv.INHERIT_FD :\\r\\n\\t\\tcase uv.INHERIT_STREAM : {\\r\\n\\t\\t\\tif (container.flags & uv.INHERIT_FD) {\\r\\n\\t\\t\\t\\tfd = container.fd;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tfd = container.stream.fd;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (typeof fd === 'undefined' || fd == -1){\\r\\n\\t\\t\\t\\treturn errno.EINVAL;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t//duplicate fd to handle\\r\\n\\t\\t\\tvar handle = uv.get_fd_handle(fd);\\r\\n\\t\\t\\tif (handle === null) return process.errno;\\r\\n\\t\\t\\tvar dupHandle = uv.duplicate_handle(handle);\\r\\n\\t\\t\\tfds[2] = dupHandle;\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdefault : {\\r\\n\\t\\t\\tthrow new Error(\\\"unknown stdio type\\\");\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.kill = function(signum){\\r\\n\\tvar process = this;\\r\\n\\tvar err;\\r\\n\\r\\n\\tif (process.process_handle == -1) {\\r\\n\\t\\treturn errno.EINVAL;\\r\\n\\t}\\r\\n\\r\\n\\terr = uv.Win32kill(process.process_handle, signum);\\r\\n\\tif (err) return err;  /* err is already translated. */\\r\\n\\tprocess.exit_signal = signum;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.close = function(cb){\\r\\n\\tvar self = this;\\r\\n\\r\\n\\t// clean opened pipes\\r\\n\\tvar pipes = this.pipes || [];\\r\\n\\tfor (var fd = 0; fd < pipes.length; fd++) {\\r\\n\\t\\tif (pipes[fd][0] > -1){\\r\\n\\t\\t\\tuv.close(pipes[fd][0]);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// only close if process handle is there\\r\\n\\tif (this.process_handle){\\r\\n\\t\\tuv.close(this.process_handle);\\r\\n\\t}\\r\\n\\r\\n\\t//clear child watcher interval\\r\\n\\tif (this.child_watcher){\\r\\n\\t\\tclearInterval(this.child_watcher);\\r\\n\\t}\\r\\n};\\r\\n\\r\\nmodule.exports = Process;\\r\\n\",\"uv/process/unix\":\"var assert   = require('assert');\\r\\nvar uv       = require('uv');\\r\\nvar errno    = require('errno');\\r\\nvar syscall  = require('syscall');\\r\\nvar SYS      = syscall.SYS;\\r\\nvar timers   = require('timers');\\r\\nvar struct   = require('struct');\\r\\n\\r\\nvar DETACHED_PROCESS           = 0x00000008;\\r\\nvar CREATE_NEW_PROCESS_GROUP   = 0x00000200;\\r\\nvar CREATE_UNICODE_ENVIRONMENT = 0x00000400;\\r\\nvar CREATE_NO_WINDOW           = 0x08000000;\\r\\n\\r\\nvar READ_PIPE  = 0;\\r\\nvar WRITE_PIPE = 1;\\r\\n\\r\\nfunction _exit(n){\\r\\n\\tprocess.reallyExit(n);\\r\\n}\\r\\n\\r\\nfunction init_stdio (container, fds) {\\r\\n\\tvar mask = uv.IGNORE | uv.CREATE_PIPE | uv.INHERIT_FD | uv.INHERIT_STREAM;\\r\\n\\tvar fd;\\r\\n\\r\\n\\tswitch( container.flags & mask ){\\r\\n\\t\\tcase uv.IGNORE : {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase uv.CREATE_PIPE : {\\r\\n\\t\\t\\tassert(container.stream.type === 'NAMED_PIPE');\\r\\n\\t\\t\\tif (uv.make_socketpair(fds, 0)) throw new Error(\\\"Error creating socketpair\\\");\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcase uv.INHERIT_FD :\\r\\n\\t\\tcase uv.INHERIT_STREAM : {\\r\\n\\t\\t\\tif (container.flags & uv.INHERIT_FD) {\\r\\n\\t\\t\\t\\tfd = container.fd;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tfd = container.stream.fd;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (typeof fd === 'undefined' || fd == -1){\\r\\n\\t\\t\\t\\treturn errno.EINVAL;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfds[1] = fd;\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdefault : {\\r\\n\\t\\t\\tthrow new Error(\\\"unknown stdio type\\\");\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfunction write_int (fd, val){\\r\\n\\tval = \\\"\\\" + val; //stringify\\r\\n\\tvar n;\\r\\n\\tdo {\\r\\n\\t\\tn = uv.write(fd, val, val.length);\\r\\n\\t} while (n === null && process.errno === errno.EINVAL);\\r\\n\\r\\n\\tif (n === null && process.errno === errno.EPIPE){\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nvar jargs;\\r\\nfunction make_args_block (args){\\r\\n\\tfor (var i = 0; i < args.length; i++){\\r\\n\\t\\targs[i] = args[i] + '\\\\0';\\r\\n\\t}\\r\\n\\tjargs = Buffer(args.join(''));\\r\\n\\treturn jargs;\\r\\n}\\r\\n\\r\\nfunction child_init (options, stdio_count, pipes, error_fd){\\r\\n\\r\\n\\tvar fd, use_fd, close_fd;\\r\\n\\r\\n\\tif (options.flags & uv.PROCESS_DETACHED) {\\r\\n\\t\\tsyscall.setsid();\\r\\n\\t}\\r\\n\\r\\n\\t/* First duplicate low numbered fds, since it's not safe to duplicate them,\\r\\n\\t * they could get replaced. Example: swapping stdout and stderr; without\\r\\n\\t * this fd 2 (stderr) would be duplicated into fd 1, thus making both\\r\\n\\t * stdout and stderr go to the same fd, which was not the intention. */\\r\\n\\tfor (fd = 0; fd < stdio_count; fd++) {\\r\\n\\t\\tuse_fd = pipes[fd][1];\\r\\n\\t\\tif (use_fd < 0 || use_fd >= fd) continue;\\r\\n\\r\\n\\t\\tpipes[fd][1] = syscall.fcntl(use_fd, SYS.F_DUPFD, stdio_count);\\r\\n\\t\\tif (pipes[fd][1] === null) {\\r\\n\\t\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t\\t\\t_exit(127);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfor (fd = 0; fd < stdio_count; fd++) {\\r\\n\\r\\n\\t\\tclose_fd = pipes[fd][0];\\r\\n\\t\\tuse_fd   = pipes[fd][1];\\r\\n\\r\\n\\t\\tif (use_fd < 0) {\\r\\n\\t\\t\\tif (fd >= 3) {\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\t// redirect stdin, stdout and stderr to /dev/null even if\\r\\n\\t\\t\\t\\t// uv.IGNORE is set\\r\\n\\t\\t\\t\\tuse_fd = syscall.Open(\\\"/dev/null\\\", fd == 0 ? SYS.O_RDONLY : SYS.O_RDWR);\\r\\n\\t\\t\\t\\tclose_fd = use_fd;\\r\\n\\r\\n\\t\\t\\t\\tif (use_fd === null) {\\r\\n\\t\\t\\t\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t\\t\\t\\t\\t_exit(127);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (fd === use_fd) {\\r\\n\\t\\t\\tuv.cloexec(use_fd, 0);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tfd = syscall.dup2(use_fd, fd);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (fd === null) {\\r\\n\\t\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t\\t\\t_exit(127);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (fd <= 2) {\\r\\n\\t\\t\\tuv.nonblock(fd, 0);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (close_fd >= stdio_count) {\\r\\n\\t\\t\\tuv.close(close_fd);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfor (fd = 0; fd < stdio_count; fd++) {\\r\\n\\t\\tuse_fd = pipes[fd][1];\\r\\n\\t\\tif (use_fd >= stdio_count) {\\r\\n\\t\\t\\tuv.close(use_fd);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (options.cwd) {\\r\\n\\t\\tvar ret = syscall.chdir(options.cwd);\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t\\t\\t_exit(127);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (options.flags & (uv.PROCESS_SETUID | uv.PROCESS_SETGID)) {\\r\\n\\t\\t/* When dropping privileges from root, the `setgroups` call will\\r\\n\\t\\t * remove any extraneous groups. If we don't call this, then\\r\\n\\t\\t * even though our uid has dropped, we may still have groups\\r\\n\\t\\t * that enable us to do super-user things. This will fail if we\\r\\n\\t\\t * aren't root, so don't bother checking the return value, this\\r\\n\\t\\t * is just done as an optimistic privilege dropping function.\\r\\n\\t\\t */\\r\\n\\t\\tvar olderrno = process.errno;\\r\\n\\t\\tsyscall.setgroups(0, null);\\r\\n\\t\\tprocess.errno = olderrno;\\r\\n\\t}\\r\\n\\r\\n\\tif ((options.flags & uv.PROCESS_SETGID) && syscall.setgid(options.gid) === null) {\\r\\n\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t\\t_exit(127);\\r\\n\\t}\\r\\n\\r\\n\\tif ((options.flags & uv.PROCESS_SETUID) && syscall.setuid(options.uid) === null) {\\r\\n\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t\\t_exit(127);\\r\\n\\t}\\r\\n\\r\\n\\tif (options.env) {\\r\\n\\t\\tset_env_block(options.env);\\r\\n\\t}\\r\\n\\r\\n\\tvar args = options.args.slice(0);\\r\\n\\targs.unshift(options.file);\\r\\n\\r\\n\\t// make sure to convert everything to strings\\r\\n\\tfor (var i = 0; i < args.length; i++){\\r\\n\\t\\targs[i] = String(args[i]);\\r\\n\\t}\\r\\n\\targs.push(null);\\r\\n\\r\\n\\tif (syscall.execlp.apply(null, args) === null){\\r\\n\\t\\twrite_int(error_fd, process.errno);\\r\\n\\t}\\r\\n\\r\\n\\t// write_int(error_fd, options.cwd);\\r\\n\\t// var n = write_int(error_fd, \\\"done\\\");\\r\\n\\t// // console.log(n);\\r\\n\\t// console.log(process.errno);\\r\\n\\t// console.log('done');\\r\\n}\\r\\n\\r\\n// TODO child_watcher ref\\r\\n\\r\\nfunction Process (options) {\\r\\n\\tvar self = this;\\r\\n\\tthis.exit_signal = 0;\\r\\n\\r\\n\\toptions = options || {};\\r\\n\\tassert(options.file, \\\"options.file required\\\");\\r\\n\\r\\n\\tassert(!(options.flags & ~(\\r\\n\\t\\tuv.PROCESS_DETACHED |\\r\\n\\t\\tuv.PROCESS_SETGID |\\r\\n\\t\\tuv.PROCESS_SETUID |\\r\\n\\t\\tuv.PROCESS_WINDOWS_HIDE |\\r\\n\\t\\tuv.PROCESS_WINDOWS_VERBATIM_ARGUMENTS\\r\\n\\t)));\\r\\n\\r\\n\\tvar stdio_count = options.stdio_count;\\r\\n\\tif (stdio_count < 3) stdio_count = 3;\\r\\n\\r\\n\\tvar err = errno.ENOMEM;\\r\\n\\r\\n\\tvar pipes = [];\\r\\n\\tvar signal_pipe = [ -1, -1 ];\\r\\n\\r\\n\\tfor (var i = 0; i < stdio_count; i++) {\\r\\n\\t\\tpipes[i]    = [];\\r\\n\\t\\tpipes[i][0] = -1;\\r\\n\\t\\tpipes[i][1] = -1;\\r\\n\\t}\\r\\n\\r\\n\\tfor (var i = 0; i < options.stdio_count; i++) {\\r\\n\\t\\terr = init_stdio(options.stdio[i], pipes[i], i);\\r\\n\\t\\tif (err) throw new Error(\\\"STDIO initiate error \\\" + err);\\r\\n\\t}\\r\\n\\r\\n\\t// initiate child parent signal pipes\\r\\n\\tif (uv.make_pipe(signal_pipe, 0)) throw new Error(\\\"Error creating signal pipe\\\");\\r\\n\\r\\n\\t/* Acquire write lock to prevent opening new fds in worker threads */\\r\\n\\t// uv_rwlock_wrlock(&loop->cloexec_lock);\\r\\n\\r\\n\\tvar pid = syscall.fork();\\r\\n\\tif (pid === null){\\r\\n\\t\\tthrow new Error(\\\"can't fork\\\");\\r\\n\\t}\\r\\n\\r\\n\\t// child process\\r\\n\\tif (pid === 0){\\r\\n\\t\\tchild_init(options, stdio_count, pipes, signal_pipe[1]);\\r\\n\\t\\tprocess.reallyExit(0);\\r\\n\\t}\\r\\n\\r\\n\\t/* Release lock in parent process */\\r\\n\\t// uv_rwlock_wrunlock(&loop->cloexec_lock);\\r\\n\\tuv.close(signal_pipe[1]);\\r\\n\\r\\n\\t// waitpid status\\r\\n\\tvar status = struct.int();\\r\\n\\tvar r;\\r\\n\\tvar spawn_error = 0;\\r\\n\\r\\n\\tdo {\\r\\n\\t\\tr = uv.read(signal_pipe[0], 1024);\\r\\n\\t} while (r === null && process.errno === errno.EINTR);\\r\\n\\r\\n\\tif (r === null && process.errno === errno.EOF){\\r\\n\\t\\t/* okay, EOF - do nothing */\\r\\n\\t}\\r\\n\\telse if (r) {\\r\\n\\t\\tdo {\\r\\n\\t\\t\\terr = syscall.waitpid(pid, status, 0);  //okay, read errorno\\r\\n\\t\\t} while (err === null && process.errno == errno.EINTR);\\r\\n\\t\\tassert(err == pid);\\r\\n\\t\\tspawn_error = Number(r);\\r\\n\\t}\\r\\n\\telse if (r === null && process.errno === errno.EPIPE) {\\r\\n\\t\\t// do\\r\\n\\t\\t// \\terr = waitpid(pid, &status, 0); /* okay, got EPIPE */\\r\\n\\t\\t// while (err == -1 && errno == EINTR);\\r\\n\\t\\t// assert(err == pid);\\r\\n\\t}\\r\\n\\telse {\\r\\n\\t\\tthrow new Error('spawn error ' + process.errno);\\r\\n\\t}\\r\\n\\r\\n\\tuv.close(signal_pipe[0]);\\r\\n\\r\\n\\tthis.pipes = pipes;\\r\\n\\tfor (var i = 0; i < options.stdio_count; i++) {\\r\\n\\t\\terr = this.open_stream(options.stdio[i], pipes[i], i === 0);\\r\\n\\t\\tif (err === 0) continue;\\r\\n\\r\\n\\t\\twhile (i--) {\\r\\n\\t\\t\\tthis.close_stream(options.stdio[i]);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tthis.pid = pid;\\r\\n\\tthis.exit_cb = options.exit_cb;\\r\\n\\r\\n\\tif (!spawn_error){\\r\\n\\t\\tthis.child_watcher = setInterval(function(){\\r\\n\\t\\t\\tvar t = syscall.waitpid(pid, status, SYS.WNOHANG);\\r\\n\\t\\t\\tif (t === pid){\\r\\n\\t\\t\\t\\tvar s = status.get();\\r\\n\\t\\t\\t\\tvar exitcode = 0;\\r\\n\\t\\t\\t\\tvar termsignal = 0;\\r\\n\\r\\n\\t\\t\\t\\tif (syscall.WIFEXITED(s)){\\r\\n\\t\\t\\t\\t\\texitcode = syscall.WEXITSTATUS(s);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\ttermsignal = syscall.WTERMSIG(s);\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (self.exit_signal){\\r\\n\\t\\t\\t\\t\\ttermsignal = self.exit_signal;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tclearInterval(this);\\r\\n\\t\\t\\t\\tself.child_watcher = null;\\r\\n\\r\\n\\t\\t\\t\\tif (self.exit_cb) self.exit_cb.call(self, exitcode, termsignal);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}, 1);\\r\\n\\t}\\r\\n\\r\\n\\tif (spawn_error) {\\r\\n\\t\\tthis.errno = errno.translate(spawn_error);\\r\\n\\t}\\r\\n\\treturn this;\\r\\n}\\r\\n\\r\\n\\r\\nProcess.prototype.unref = function(){\\r\\n\\tif (this.child_watcher){\\r\\n\\t\\tthis.child_watcher.unref();\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.open_stream = function (container, pipefds, writable) {\\r\\n\\tvar flags = 0;\\r\\n\\r\\n\\tif (!(container.flags & uv.CREATE_PIPE) || pipefds[0] < 0) {\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\tif (uv.close(pipefds[1]) === null){\\r\\n\\t\\tthrow new Error('closing pipe fd ' + pipefds[1]);\\r\\n\\t}\\r\\n\\r\\n\\tpipefds[1] = -1;\\r\\n\\tuv.nonblock(pipefds[0], 1);\\r\\n\\r\\n\\tif (container.stream.type === 'NAMED_PIPE' && container.stream.ipc ) {\\r\\n\\t\\tflags = uv.STREAM_READABLE | uv.STREAM_WRITABLE;\\r\\n\\t}\\r\\n\\r\\n\\telse if (writable) {\\r\\n\\t\\tflags = uv.STREAM_WRITABLE;\\r\\n\\t}\\r\\n\\r\\n\\telse {\\r\\n\\t\\tflags = uv.STREAM_READABLE;\\r\\n\\t}\\r\\n\\r\\n\\treturn container.stream.stream_open(pipefds[0], flags);\\r\\n};\\r\\n\\r\\n\\r\\n// constructs a utf16 buffer of environment\\r\\n// variables block, windows require each env to be\\r\\n// seperated with 1 nul and ends with 2 nul charachters\\r\\nfunction set_env_block(env){\\r\\n\\tif (!env){\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tvar envBlock = process.env;\\r\\n\\r\\n\\t//extend\\r\\n\\tfor (var key in envBlock){\\r\\n\\t\\tenv.unshift(key + '=' + envBlock[key]);\\r\\n\\t}\\r\\n\\r\\n\\tvar len = env.length;\\r\\n\\r\\n\\tvar n = \\\"\\\";\\r\\n\\tfor (var i = 0; i < len; i++){\\r\\n\\t\\tassert(syscall.putenv(env[i]) !== null);\\r\\n\\t}\\r\\n\\treturn;\\r\\n}\\r\\n\\r\\n\\r\\nProcess.prototype.kill = function(signum){\\r\\n\\tvar process = this;\\r\\n\\tvar err;\\r\\n\\r\\n\\tif (process.process_handle == -1) {\\r\\n\\t\\treturn errno.EINVAL;\\r\\n\\t}\\r\\n\\r\\n\\terr = uv.kill(process.pid, signum);\\r\\n\\tif (err) return err;  /* err is already translated. */\\r\\n\\tprocess.exit_signal = signum;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.close = function(cb){\\r\\n\\tvar self = this;\\r\\n\\t//clear child watcher interval\\r\\n\\tif (this.child_watcher){\\r\\n\\t\\tclearInterval(this.child_watcher);\\r\\n\\t}\\r\\n};\\r\\n\\r\\nmodule.exports = Process;\\r\\n\",\"uv/tty\":\"var util     = require(\\\"util\\\");\\r\\nvar stream   = require('uv/stream');\\r\\nvar sock     = require('socket');\\r\\nvar tty      = process.binding('tty');\\r\\nvar errno    = require('errno');\\r\\nvar uv       = require('uv');\\r\\nvar threads  = process.binding('threads');\\r\\nvar posix    = process.binding('posix');\\r\\n\\r\\nutil.inherits(TTY, stream);\\r\\nfunction TTY (){\\r\\n\\tstream.call(this, 'TTY');\\r\\n\\tif (uv.isWin) winTTY.apply(this, arguments);\\r\\n\\telse nixTTY.apply(this, arguments);\\r\\n}\\r\\n\\r\\n//windows tty emulation through threads\\r\\nvar winTTY = function (fd, readable){\\r\\n\\r\\n\\tvar sockets = this.pipes = sock.socketpair();\\r\\n\\tvar self = this;\\r\\n\\r\\n\\tthis._fd = fd;\\r\\n\\tsock.nonblock(sockets[0], 1);\\r\\n\\r\\n\\tif (readable){\\r\\n\\t\\tvar thread = threads.create(function(options){\\r\\n\\t\\t\\tvar posix   = process.bindings['posix']();\\r\\n\\t\\t\\tvar sock    = process.bindings['socket']();\\r\\n\\t\\t\\tvar threads = process.bindings['threads']();\\r\\n\\t\\t\\tvar tty     = process.bindings['tty']();\\r\\n\\t\\t\\tvar io      = process.bindings['io']();\\r\\n\\t\\t\\tvar line = '';\\r\\n\\r\\n\\t\\t\\tvar sockfd   = options.sockfd;\\r\\n\\t\\t\\tvar fd       = options.fd;\\r\\n\\r\\n\\t\\t\\t//let parent thread notify us if this is\\r\\n\\t\\t\\t//started in raw mode read\\r\\n\\t\\t\\tvar can_read = io.can_read(sockfd, 100);\\r\\n\\t\\t\\t//consume socket buffer\\r\\n\\t\\t\\tif (can_read) sock.recv(sockfd, 1, 0);\\r\\n\\r\\n\\t\\t\\twhile (1){\\r\\n\\t\\t\\t\\ttry {\\r\\n\\t\\t\\t\\t\\tif (can_read){\\r\\n\\t\\t\\t\\t\\t\\tvar ch   = tty.read(fd);\\r\\n\\t\\t\\t\\t\\t\\tif (ch < 0){\\r\\n\\t\\t\\t\\t\\t\\t\\tline = '\\\\u001b';\\r\\n\\t\\t\\t\\t\\t\\t\\tswitch(ch) {\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase tty.KEY_DOWN  : line += '[B'; break;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase tty.KEY_UP    : line += '[A'; break;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase tty.KEY_RIGHT : line += '[C'; break;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcase tty.KEY_LEFT  : line += '[D'; break;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdefault : throw(\\\"unknown key type\\\");\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\t\\t//TODO UTF8 encoding\\r\\n\\t\\t\\t\\t\\t\\t\\tline     = Duktape.Buffer(1);\\r\\n\\t\\t\\t\\t\\t\\t\\tline[0]  = ch;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tvar str = posix.read(fd, 1);\\r\\n\\t\\t\\t\\t\\t\\tline += str;\\r\\n\\t\\t\\t\\t\\t\\tif (str != '\\\\n') continue;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tthreads.lock();\\r\\n\\t\\t\\t\\t\\tsock.send(sockfd, line, -1);\\r\\n\\t\\t\\t\\t\\tthreads.unlock();\\r\\n\\t\\t\\t\\t\\tline = '';\\r\\n\\t\\t\\t\\t} catch(e){\\r\\n\\t\\t\\t\\t\\tprint(e);\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}, {\\r\\n\\t\\t\\tsockfd : sockets[0],\\r\\n\\t\\t\\tfd : fd\\r\\n\\t\\t});\\r\\n\\t} else {\\r\\n\\t\\tsetTimeout(function(){\\r\\n\\t\\t\\tvar tcp = this.ttyTCP = new uv.TCP();\\r\\n\\t\\t\\ttcp.stream_open(sockets[0]);\\r\\n\\t\\t\\ttcp.read_start(function(e, buf){\\r\\n\\t\\t\\t\\tif (e) throw new Error(e);\\r\\n\\t\\t\\t\\tthreads.lock();\\r\\n\\t\\t\\t\\ttty.write(fd, buf);\\r\\n\\t\\t\\t\\tthreads.unlock();\\r\\n\\t\\t\\t});\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\tthis.stream_open(sockets[1], readable ? uv.STREAM_READABLE : uv.STREAM_WRITABLE);\\r\\n}\\r\\n\\r\\nvar nixTTY = function(fd, readable){\\r\\n\\tvar tty = this;\\r\\n\\tvar type = \\\"TTY\\\";\\r\\n\\t// var type = uv.guess_handle(fd);\\r\\n\\t// if (type == uv.FILE || type == uv.UNKNOWN_HANDLE) return errno.EINVAL;\\r\\n\\r\\n\\tvar flags = 0;\\r\\n\\tvar newfd;\\r\\n\\r\\n\\tvar skip = function(f){\\r\\n\\t\\ttty._fd = f;\\r\\n\\t\\tstream.call(tty, 'TTY');\\r\\n\\t\\tif (readable) flags |= uv.STREAM_READABLE;\\r\\n\\t\\telse flags |= uv.STREAM_WRITABLE;\\r\\n\\r\\n\\t\\tif (!(flags & uv.STREAM_BLOCKING)) uv.nonblock(f, 1);\\r\\n\\r\\n\\t\\ttty.stream_open(f, flags);\\r\\n\\t\\treturn tty;\\r\\n\\t};\\r\\n\\r\\n\\tif (type === \\\"TTY\\\") {\\r\\n\\t\\tnewfd = uv.open(\\\"/dev/tty\\\", uv.O_RDWR);\\r\\n\\t\\tif (newfd === null || !uv.cloexec(newfd, 1)){\\r\\n\\t\\t\\tif (readable) flags |= uv.STREAM_BLOCKING;\\r\\n\\t\\t\\treturn skip(fd);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar r = posix.dup2(newfd, fd);\\r\\n\\t\\tif (r === null && process.errno !== errno.EINVAL){\\r\\n\\t\\t\\tuv.close(newfd);\\r\\n\\t\\t\\treturn process.errno;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tuv.cloexec(newfd, 1);\\r\\n\\t\\treturn skip(newfd);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nTTY.prototype.set_mode = function(mode){\\r\\n\\tthis.rawmode = mode;\\r\\n\\tif (mode){\\r\\n\\t\\t//on windows notify thread\\r\\n\\t\\t//that this is a raw mode read\\r\\n\\t\\tif (uv.isWin) sock.send(this.fd, \\\"1\\\", 1);\\r\\n\\r\\n\\t\\tif (!tty.setRawMode(this._fd)){\\r\\n\\t\\t\\treturn process.errno;\\r\\n\\t\\t}\\r\\n\\t} else {\\r\\n\\t\\ttty.disableRawMode(this._fd);\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n}\\r\\n\\r\\nmodule.exports = TTY;\\r\\n\",\"internal/util\":\"'use strict';\\r\\n\\r\\nvar prefix = '(node) ';\\r\\n\\r\\n// All the internal deprecations have to use this function only, as this will\\r\\n// prepend the prefix to the actual message.\\r\\nexports.deprecate = function(fn, msg) {\\r\\n  return exports._deprecate(fn, prefix + msg);\\r\\n};\\r\\n\\r\\n// All the internal deprecations have to use this function only, as this will\\r\\n// prepend the prefix to the actual message.\\r\\nexports.printDeprecationMessage = function(msg, warned) {\\r\\n  return exports._printDeprecationMessage(prefix + msg, warned);\\r\\n};\\r\\n\\r\\nexports._printDeprecationMessage = function(msg, warned) {\\r\\n  if (process.noDeprecation)\\r\\n    return true;\\r\\n\\r\\n  if (warned)\\r\\n    return warned;\\r\\n\\r\\n  if (process.throwDeprecation)\\r\\n    throw new Error(msg);\\r\\n  else if (process.traceDeprecation)\\r\\n    console.trace(msg.startsWith(prefix) ? msg.replace(prefix, '') : msg);\\r\\n  else\\r\\n    console.error(msg);\\r\\n\\r\\n  return true;\\r\\n};\\r\\n\\r\\n// Mark that a method should not be used.\\r\\n// Returns a modified function which warns once by default.\\r\\n// If --no-deprecation is set, then it is a no-op.\\r\\nexports._deprecate = function(fn, msg) {\\r\\n  // Allow for deprecating things in the process of starting up.\\r\\n  if (global.process === undefined) {\\r\\n    return function() {\\r\\n      return exports._deprecate(fn, msg).apply(this, arguments);\\r\\n    };\\r\\n  }\\r\\n\\r\\n  if (process.noDeprecation === true) {\\r\\n    return fn;\\r\\n  }\\r\\n\\r\\n  var warned = false;\\r\\n  function deprecated() {\\r\\n    warned = exports._printDeprecationMessage(msg, warned);\\r\\n    return fn.apply(this, arguments);\\r\\n  }\\r\\n\\r\\n  return deprecated;\\r\\n};\\r\\n\",\"internal/linkedlist\":\"'use strict';\\r\\n\\r\\nfunction init(list) {\\r\\n  list._idleNext = list;\\r\\n  list._idlePrev = list;\\r\\n}\\r\\nexports.init = init;\\r\\n\\r\\n\\r\\n// show the most idle item\\r\\nfunction peek(list) {\\r\\n  if (list._idlePrev == list) return null;\\r\\n  return list._idlePrev;\\r\\n}\\r\\nexports.peek = peek;\\r\\n\\r\\n\\r\\n// remove the most idle item from the list\\r\\nfunction shift(list) {\\r\\n  var first = list._idlePrev;\\r\\n  remove(first);\\r\\n  return first;\\r\\n}\\r\\nexports.shift = shift;\\r\\n\\r\\n\\r\\n// remove a item from its list\\r\\nfunction remove(item) {\\r\\n  if (item._idleNext) {\\r\\n    item._idleNext._idlePrev = item._idlePrev;\\r\\n  }\\r\\n\\r\\n  if (item._idlePrev) {\\r\\n    item._idlePrev._idleNext = item._idleNext;\\r\\n  }\\r\\n\\r\\n  item._idleNext = null;\\r\\n  item._idlePrev = null;\\r\\n}\\r\\nexports.remove = remove;\\r\\n\\r\\n\\r\\n// remove a item from its list and place at the end.\\r\\nfunction append(list, item) {\\r\\n  remove(item);\\r\\n  item._idleNext = list._idleNext;\\r\\n  list._idleNext._idlePrev = item;\\r\\n  item._idlePrev = list;\\r\\n  list._idleNext = item;\\r\\n}\\r\\nexports.append = append;\\r\\n\\r\\n\\r\\nfunction isEmpty(list) {\\r\\n  return list._idleNext === list;\\r\\n}\\r\\nexports.isEmpty = isEmpty;\\r\\n\",\"buffer\":\"/* eslint-disable require-buffer */\\r\\n'use strict';\\r\\nexports.Buffer = Buffer;\\r\\nvar binding = process.binding('buffer_wrap');\\r\\n\\r\\nvar internalUtil = require('internal/util');\\r\\nvar bindingObj = {};\\r\\n\\r\\nexports.Buffer = Buffer;\\r\\nexports.SlowBuffer = SlowBuffer;\\r\\nexports.INSPECT_MAX_BYTES = 50;\\r\\nexports.kMaxLength = binding.kMaxLength;\\r\\n\\r\\nBuffer.poolSize = 8 * 1024;\\r\\nvar poolSize, poolOffset, allocPool;\\r\\n\\r\\nbinding.setupBufferJS(Buffer.prototype, bindingObj);\\r\\nvar flags = bindingObj.flags;\\r\\nvar kNoZeroFill = 0;\\r\\n\\r\\n\\r\\nfunction createPool() {\\r\\n\\tpoolSize = Buffer.poolSize;\\r\\n\\tif (poolSize > 0)\\r\\n\\t\\tflags[kNoZeroFill] = 1;\\r\\n\\tallocPool = new Uint8Array(poolSize);\\r\\n\\tObject.setPrototypeOf(allocPool, Buffer.prototype);\\r\\n\\tpoolOffset = 0;\\r\\n}\\r\\ncreatePool();\\r\\n\\r\\nfunction alignPool() {\\r\\n\\t// Ensure aligned slices\\r\\n\\tif (poolOffset & 0x7) {\\r\\n\\t\\tpoolOffset |= 0x7;\\r\\n\\t\\tpoolOffset++;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfunction Buffer(arg, encoding) {\\r\\n\\t// Common case.\\r\\n\\tif (typeof arg === 'number') {\\r\\n\\t\\t// If less than zero, or NaN.\\r\\n\\t\\tif (arg < 0 || arg !== arg)\\r\\n\\t\\t\\targ = 0;\\r\\n\\r\\n\\t\\tvar t = new Uint8Array(arg);\\r\\n\\t\\tObject.setPrototypeOf(t, Buffer.prototype);\\r\\n\\t\\treturn t;\\r\\n\\t}\\r\\n\\r\\n\\t// Slightly less common case.\\r\\n\\tif (typeof arg === 'string') {\\r\\n\\t\\treturn binding.createFromString(arg, encoding);\\r\\n\\t}\\r\\n\\r\\n\\t// Unusual.\\r\\n\\treturn fromObject(arg);\\r\\n}\\r\\n\\r\\n// function Buffer(arg, encoding) {\\r\\n//   // Common case.\\r\\n//   if (typeof arg === 'number') {\\r\\n//     // If less than zero, or NaN.\\r\\n//     if (arg < 0 || arg !== arg)\\r\\n//       arg = 0;\\r\\n//     return allocate(arg);\\r\\n//   }\\r\\n\\r\\n//   // Slightly less common case.\\r\\n//   if (typeof arg === 'string') {\\r\\n//     return fromString(arg, encoding);\\r\\n//   }\\r\\n\\r\\n//   // Unusual.\\r\\n//   return fromObject(arg);\\r\\n// }\\r\\n\\r\\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\\r\\nObject.setPrototypeOf(Buffer, Uint8Array);\\r\\n\\r\\n\\r\\nfunction SlowBuffer(length) {\\r\\n\\tif (+length != length)\\r\\n\\t\\tlength = 0;\\r\\n\\tif (length > 0)\\r\\n\\t\\tflags[kNoZeroFill] = 1;\\r\\n\\tvar ui8 = new Uint8Array(+length);\\r\\n\\tObject.setPrototypeOf(ui8, Buffer.prototype);\\r\\n\\treturn ui8;\\r\\n}\\r\\n\\r\\nObject.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);\\r\\nObject.setPrototypeOf(SlowBuffer, Uint8Array);\\r\\n\\r\\n\\r\\nfunction allocate(size) {\\r\\n\\tif (size === 0) {\\r\\n\\t\\tvar ui8 = new Uint8Array(size);\\r\\n\\t\\tObject.setPrototypeOf(ui8, Buffer.prototype);\\r\\n\\t\\treturn ui8;\\r\\n\\t}\\r\\n\\tif (size < (Buffer.poolSize >>> 1)) {\\r\\n\\t\\tif (size > (poolSize - poolOffset))\\r\\n\\t\\t\\tcreatePool();\\r\\n\\t\\tvar b = allocPool.slice(poolOffset, poolOffset + size);\\r\\n\\t\\tpoolOffset += size;\\r\\n\\t\\talignPool();\\r\\n\\t\\treturn b;\\r\\n\\t} else {\\r\\n\\t\\t// Even though this is checked above, the conditional is a safety net and\\r\\n\\t\\t// sanity check to prevent any subsequent typed array allocation from not\\r\\n\\t\\t// being zero filled.\\r\\n\\t\\tif (size > 0)\\r\\n\\t\\t\\tflags[kNoZeroFill] = 1;\\r\\n\\t\\tvar ui8 = new Uint8Array(size);\\r\\n\\t\\tObject.setPrototypeOf(ui8, Buffer.prototype);\\r\\n\\t\\treturn ui8;\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nfunction fromString(string, encoding) {\\r\\n\\tif (typeof encoding !== 'string' || encoding === '')\\r\\n\\t\\tencoding = 'utf8';\\r\\n\\r\\n\\tvar length = byteLength(string, encoding);\\r\\n\\tif (length >= (Buffer.poolSize >>> 1))\\r\\n\\t\\treturn binding.createFromString(string, encoding);\\r\\n\\r\\n\\tif (length > (poolSize - poolOffset))\\r\\n\\t\\tcreatePool();\\r\\n\\tvar actual = allocPool.write(string, poolOffset, encoding);\\r\\n\\tvar b = allocPool.slice(poolOffset, poolOffset + actual);\\r\\n\\tpoolOffset += actual;\\r\\n\\talignPool();\\r\\n\\treturn b;\\r\\n}\\r\\n\\r\\n\\r\\nfunction fromObject(obj) {\\r\\n\\tif (obj instanceof Buffer) {\\r\\n\\t\\tvar b = allocate(obj.length);\\r\\n\\t\\tobj.copy(b, 0, 0, obj.length);\\r\\n\\t\\treturn b;\\r\\n\\t}\\r\\n\\r\\n\\tif (Array.isArray(obj)) {\\r\\n\\t\\tvar length = obj.length;\\r\\n\\t\\tvar b = allocate(length);\\r\\n\\t\\tfor (var i = 0; i < length; i++)\\r\\n\\t\\t\\tb[i] = obj[i] & 255;\\r\\n\\t\\treturn b;\\r\\n\\t}\\r\\n\\r\\n\\tif (obj == null) {\\r\\n\\t\\tthrow new TypeError('Must start with number, buffer, array or string');\\r\\n\\t}\\r\\n\\r\\n\\tif (obj instanceof ArrayBuffer) {\\r\\n\\t\\treturn binding.createFromArrayBuffer(obj);\\r\\n\\t}\\r\\n\\r\\n\\tif (obj.buffer instanceof ArrayBuffer || obj.length) {\\r\\n\\t\\tvar length;\\r\\n\\t\\tif (typeof obj.length !== 'number' || obj.length !== obj.length)\\r\\n\\t\\t\\tlength = 0;\\r\\n\\t\\telse\\r\\n\\t\\t\\tlength = obj.length;\\r\\n\\t\\tvar b = allocate(length);\\r\\n\\t\\tfor (var i = 0; i < length; i++) {\\r\\n\\t\\t\\tb[i] = obj[i] & 255;\\r\\n\\t\\t}\\r\\n\\t\\treturn b;\\r\\n\\t}\\r\\n\\r\\n\\tif (obj.type === 'Buffer' && Array.isArray(obj.data)) {\\r\\n\\t\\tvar array = obj.data;\\r\\n\\t\\tvar b = allocate(array.length);\\r\\n\\t\\tfor (var i = 0; i < array.length; i++)\\r\\n\\t\\t\\tb[i] = array[i] & 255;\\r\\n\\t\\treturn b;\\r\\n\\t}\\r\\n\\r\\n\\tthrow new TypeError('Must start with number, buffer, array or string');\\r\\n}\\r\\n\\r\\n\\r\\n// Static methods\\r\\n\\r\\nBuffer.isBuffer = function isBuffer(b) {\\r\\n\\treturn b instanceof Buffer;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.compare = function compare(a, b) {\\r\\n\\tif (!(a instanceof Buffer) ||\\r\\n\\t\\t\\t!(b instanceof Buffer)) {\\r\\n\\t\\tthrow new TypeError('Arguments must be Buffers');\\r\\n\\t}\\r\\n\\r\\n\\tif (a === b) {\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\treturn binding.compare(a, b);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.isEncoding = function(encoding) {\\r\\n\\tvar loweredCase = false;\\r\\n\\tfor (;;) {\\r\\n\\t\\tswitch (encoding) {\\r\\n\\t\\t\\tcase 'hex':\\r\\n\\t\\t\\tcase 'utf8':\\r\\n\\t\\t\\tcase 'utf-8':\\r\\n\\t\\t\\tcase 'ascii':\\r\\n\\t\\t\\tcase 'binary':\\r\\n\\t\\t\\tcase 'base64':\\r\\n\\t\\t\\tcase 'ucs2':\\r\\n\\t\\t\\tcase 'ucs-2':\\r\\n\\t\\t\\tcase 'utf16le':\\r\\n\\t\\t\\tcase 'utf-16le':\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tif (loweredCase)\\r\\n\\t\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t\\tencoding = ('' + encoding).toLowerCase();\\r\\n\\t\\t\\t\\tloweredCase = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.concat = function(list, length) {\\r\\n\\tif (!Array.isArray(list))\\r\\n\\t\\tthrow new TypeError('\\\"list\\\" argument must be an Array of Buffers');\\r\\n\\r\\n\\tif (list.length === 0)\\r\\n\\t\\treturn new Buffer(0);\\r\\n\\r\\n\\tif (length === undefined) {\\r\\n\\t\\tlength = 0;\\r\\n\\t\\tfor (var i = 0; i < list.length; i++)\\r\\n\\t\\t\\tlength += list[i].length;\\r\\n\\t} else {\\r\\n\\t\\tlength = length >>> 0;\\r\\n\\t}\\r\\n\\r\\n\\tvar buffer = new Buffer(length);\\r\\n\\tvar pos = 0;\\r\\n\\tfor (var i = 0; i < list.length; i++) {\\r\\n\\t\\tvar buf = list[i];\\r\\n\\t\\tbuf.copy(buffer, pos);\\r\\n\\t\\tpos += buf.length;\\r\\n\\t}\\r\\n\\r\\n\\treturn buffer;\\r\\n};\\r\\n\\r\\n\\r\\nfunction base64ByteLength(str, bytes) {\\r\\n\\t// Handle padding\\r\\n\\tif (str.charCodeAt(bytes - 1) === 0x3D)\\r\\n\\t\\tbytes--;\\r\\n\\tif (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D)\\r\\n\\t\\tbytes--;\\r\\n\\r\\n\\t// Base64 ratio: 3/4\\r\\n\\treturn (bytes * 3) >>> 2;\\r\\n}\\r\\n\\r\\n\\r\\nfunction byteLength(string, encoding) {\\r\\n\\tif (typeof string !== 'string')\\r\\n\\t\\tstring = '' + string;\\r\\n\\r\\n\\tvar len = string.length;\\r\\n\\tif (len === 0)\\r\\n\\t\\treturn 0;\\r\\n\\r\\n\\t// Use a for loop to avoid recursion\\r\\n\\tvar loweredCase = false;\\r\\n\\tfor (;;) {\\r\\n\\t\\tswitch (encoding) {\\r\\n\\t\\t\\tcase 'ascii':\\r\\n\\t\\t\\tcase 'binary':\\r\\n\\t\\t\\t\\treturn len;\\r\\n\\r\\n\\t\\t\\tcase 'utf8':\\r\\n\\t\\t\\tcase 'utf-8':\\r\\n\\t\\t\\tcase undefined:\\r\\n\\t\\t\\t\\treturn binding.byteLengthUtf8(string);\\r\\n\\r\\n\\t\\t\\tcase 'ucs2':\\r\\n\\t\\t\\tcase 'ucs-2':\\r\\n\\t\\t\\tcase 'utf16le':\\r\\n\\t\\t\\tcase 'utf-16le':\\r\\n\\t\\t\\t\\treturn len * 2;\\r\\n\\r\\n\\t\\t\\tcase 'hex':\\r\\n\\t\\t\\t\\treturn len >>> 1;\\r\\n\\r\\n\\t\\t\\tcase 'base64':\\r\\n\\t\\t\\t\\treturn base64ByteLength(string, len);\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\t// The C++ binding defaulted to UTF8, we should too.\\r\\n\\t\\t\\t\\tif (loweredCase)\\r\\n\\t\\t\\t\\t\\treturn binding.byteLengthUtf8(string);\\r\\n\\r\\n\\t\\t\\t\\tencoding = ('' + encoding).toLowerCase();\\r\\n\\t\\t\\t\\tloweredCase = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nBuffer.byteLength = byteLength;\\r\\n\\r\\n\\r\\n// For backwards compatibility.\\r\\nObject.defineProperty(Buffer.prototype, 'parent', {\\r\\n\\tenumerable: true,\\r\\n\\tget: function() {\\r\\n\\t\\tif (!(this instanceof Buffer))\\r\\n\\t\\t\\treturn undefined;\\r\\n\\t\\tif (this.byteLength === 0 ||\\r\\n\\t\\t\\t\\tthis.byteLength === this.buffer.byteLength) {\\r\\n\\t\\t\\treturn undefined;\\r\\n\\t\\t}\\r\\n\\t\\treturn this.buffer;\\r\\n\\t}\\r\\n});\\r\\nObject.defineProperty(Buffer.prototype, 'offset', {\\r\\n\\tenumerable: true,\\r\\n\\tget: function() {\\r\\n\\t\\tif (!(this instanceof Buffer))\\r\\n\\t\\t\\treturn undefined;\\r\\n\\t\\treturn this.byteOffset;\\r\\n\\t}\\r\\n});\\r\\n\\r\\n\\r\\nfunction slowToString(encoding, start, end) {\\r\\n\\tvar loweredCase = false;\\r\\n\\r\\n\\t// No need to verify that \\\"this.length <= MAX_UINT32\\\" since it's a read-only\\r\\n\\t// property of a typed array.\\r\\n\\r\\n\\t// This behaves neither like String nor Uint8Array in that we set start/end\\r\\n\\t// to their upper/lower bounds if the value passed is out of range.\\r\\n\\t// undefined is handled specially as per ECMA-262 6th Edition,\\r\\n\\t// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\\r\\n\\tif (start === undefined || start < 0)\\r\\n\\t\\tstart = 0;\\r\\n\\t// Return early if start > this.length. Done here to prevent potential uint32\\r\\n\\t// coercion fail below.\\r\\n\\tif (start > this.length)\\r\\n\\t\\treturn '';\\r\\n\\r\\n\\tif (end === undefined || end > this.length)\\r\\n\\t\\tend = this.length;\\r\\n\\r\\n\\tif (end <= 0)\\r\\n\\t\\treturn '';\\r\\n\\r\\n\\t// Force coersion to uint32. This will also coerce falsey/NaN values to 0.\\r\\n\\tend >>>= 0;\\r\\n\\tstart >>>= 0;\\r\\n\\r\\n\\tif (end <= start)\\r\\n\\t\\treturn '';\\r\\n\\r\\n\\tif (!encoding) encoding = 'utf8';\\r\\n\\r\\n\\twhile (true) {\\r\\n\\t\\tswitch (encoding) {\\r\\n\\t\\t\\tcase 'hex':\\r\\n\\t\\t\\t\\treturn this.hexSlice(start, end);\\r\\n\\r\\n\\t\\t\\tcase 'utf8':\\r\\n\\t\\t\\tcase 'utf-8':\\r\\n\\t\\t\\t\\treturn this.utf8Slice(start, end);\\r\\n\\r\\n\\t\\t\\tcase 'ascii':\\r\\n\\t\\t\\t\\treturn this.asciiSlice(start, end);\\r\\n\\r\\n\\t\\t\\tcase 'binary':\\r\\n\\t\\t\\t\\treturn this.binarySlice(start, end);\\r\\n\\r\\n\\t\\t\\tcase 'base64':\\r\\n\\t\\t\\t\\treturn this.base64Slice(start, end);\\r\\n\\r\\n\\t\\t\\tcase 'ucs2':\\r\\n\\t\\t\\tcase 'ucs-2':\\r\\n\\t\\t\\tcase 'utf16le':\\r\\n\\t\\t\\tcase 'utf-16le':\\r\\n\\t\\t\\t\\treturn this.ucs2Slice(start, end);\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tif (loweredCase)\\r\\n\\t\\t\\t\\t\\tthrow new TypeError('Unknown encoding: ' + encoding);\\r\\n\\t\\t\\t\\tencoding = (encoding + '').toLowerCase();\\r\\n\\t\\t\\t\\tloweredCase = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\r\\nBuffer.prototype.toString = function() {\\r\\n\\tif (arguments.length === 0) {\\r\\n\\t\\tvar result = this.utf8Slice(0, this.length);\\r\\n\\t} else {\\r\\n\\t\\tvar result = slowToString.apply(this, arguments);\\r\\n\\t}\\r\\n\\tif (result === undefined)\\r\\n\\t\\tthrow new Error('\\\"toString()\\\" failed');\\r\\n\\treturn result;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.equals = function equals(b) {\\r\\n\\tif (!(b instanceof Buffer))\\r\\n\\t\\tthrow new TypeError('Argument must be a Buffer');\\r\\n\\r\\n\\tif (this === b)\\r\\n\\t\\treturn true;\\r\\n\\r\\n\\treturn binding.compare(this, b) === 0;\\r\\n};\\r\\n\\r\\n\\r\\n// Inspect\\r\\nBuffer.prototype.inspect = function inspect() {\\r\\n\\tvar str = '';\\r\\n\\tvar max = exports.INSPECT_MAX_BYTES;\\r\\n\\tif (this.length > 0) {\\r\\n\\t\\tstr = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\\r\\n\\t\\tif (this.length > max)\\r\\n\\t\\t\\tstr += ' ... ';\\r\\n\\t}\\r\\n\\treturn '<' + this.constructor.name + ' ' + str + '>';\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.compare = function compare(b) {\\r\\n\\tif (!(b instanceof Buffer))\\r\\n\\t\\tthrow new TypeError('Argument must be a Buffer');\\r\\n\\r\\n\\tif (this === b)\\r\\n\\t\\treturn 0;\\r\\n\\r\\n\\treturn binding.compare(this, b);\\r\\n};\\r\\n\\r\\nfunction slowIndexOf(buffer, val, byteOffset, encoding) {\\r\\n\\tvar loweredCase = false;\\r\\n\\tfor (;;) {\\r\\n\\t\\tswitch (encoding) {\\r\\n\\t\\t\\tcase 'utf8':\\r\\n\\t\\t\\tcase 'utf-8':\\r\\n\\t\\t\\tcase 'ucs2':\\r\\n\\t\\t\\tcase 'ucs-2':\\r\\n\\t\\t\\tcase 'utf16le':\\r\\n\\t\\t\\tcase 'utf-16le':\\r\\n\\t\\t\\tcase 'binary':\\r\\n\\t\\t\\t\\treturn binding.indexOfString(buffer, val, byteOffset, encoding);\\r\\n\\r\\n\\t\\t\\tcase 'base64':\\r\\n\\t\\t\\tcase 'ascii':\\r\\n\\t\\t\\tcase 'hex':\\r\\n\\t\\t\\t\\treturn binding.indexOfBuffer(\\r\\n\\t\\t\\t\\t\\t\\tbuffer, Buffer(val, encoding), byteOffset, encoding);\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tif (loweredCase) {\\r\\n\\t\\t\\t\\t\\tthrow new TypeError('Unknown encoding: ' + encoding);\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tencoding = ('' + encoding).toLowerCase();\\r\\n\\t\\t\\t\\tloweredCase = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\\r\\n\\tif (byteOffset > 0x7fffffff)\\r\\n\\t\\tbyteOffset = 0x7fffffff;\\r\\n\\telse if (byteOffset < -0x80000000)\\r\\n\\t\\tbyteOffset = -0x80000000;\\r\\n\\tbyteOffset >>= 0;\\r\\n\\r\\n\\tif (typeof val === 'string') {\\r\\n\\t\\tif (encoding === undefined) {\\r\\n\\t\\t\\treturn binding.indexOfString(this, val, byteOffset, encoding);\\r\\n\\t\\t}\\r\\n\\t\\treturn slowIndexOf(this, val, byteOffset, encoding);\\r\\n\\t} else if (val instanceof Buffer) {\\r\\n\\t\\treturn binding.indexOfBuffer(this, val, byteOffset, encoding);\\r\\n\\t} else if (typeof val === 'number') {\\r\\n\\t\\treturn binding.indexOfNumber(this, val, byteOffset);\\r\\n\\t}\\r\\n\\r\\n\\tthrow new TypeError('\\\"val\\\" argument must be string, number or Buffer');\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\\r\\n\\treturn this.indexOf(val, byteOffset, encoding) !== -1;\\r\\n};\\r\\n\\r\\n//FIXME: fast implementation\\r\\nif (typeof NODE_BUFFER === 'undefined'){\\r\\n\\tBuffer.prototype.fill = NODE_BUFFER.prototype.fill;\\r\\n} else {\\r\\n\\tBuffer.prototype.fill = function fill(val, start, end) {\\r\\n\\t\\tstart = start >> 0;\\r\\n\\t\\tend = (end === undefined) ? this.length : end >> 0;\\r\\n\\r\\n\\t\\tif (start < 0 || end > this.length)\\r\\n\\t\\t\\tthrow new RangeError('Out of range index');\\r\\n\\t\\tif (end <= start)\\r\\n\\t\\t\\treturn this;\\r\\n\\r\\n\\t\\tif (typeof val !== 'string') {\\r\\n\\t\\t\\tval = val >>> 0;\\r\\n\\t\\t} else if (val.length === 1) {\\r\\n\\t\\t\\tvar code = val.charCodeAt(0);\\r\\n\\t\\t\\tif (code < 256)\\r\\n\\t\\t\\t\\tval = code;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tbinding.fill(this, val, start, end);\\r\\n\\r\\n\\t\\treturn this;\\r\\n\\t};\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n// XXX remove in v0.13\\r\\nBuffer.prototype.get = internalUtil.deprecate(function get(offset) {\\r\\n\\toffset = ~~offset;\\r\\n\\tif (offset < 0 || offset >= this.length)\\r\\n\\t\\tthrow new RangeError('Index out of range');\\r\\n\\treturn this[offset];\\r\\n}, 'Buffer.get is deprecated. Use array indexes instead.');\\r\\n\\r\\n\\r\\n// XXX remove in v0.13\\r\\nBuffer.prototype.set = internalUtil.deprecate(function set(offset, v) {\\r\\n\\toffset = ~~offset;\\r\\n\\tif (offset < 0 || offset >= this.length)\\r\\n\\t\\tthrow new RangeError('Index out of range');\\r\\n\\treturn this[offset] = v;\\r\\n}, 'Buffer.set is deprecated. Use array indexes instead.');\\r\\n\\r\\n\\r\\n// TODO(trevnorris): fix these checks to follow new standard\\r\\n// write(string, offset = 0, length = buffer.length, encoding = 'utf8')\\r\\nvar writeWarned = false;\\r\\nvar writeMsg = 'Buffer.write(string, encoding, offset, length) is ' +\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t 'deprecated. Use write(string[, offset[, length]]' +\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t '[, encoding]) instead.';\\r\\nBuffer.prototype.write = function(string, offset, length, encoding) {\\r\\n\\t// Buffer#write(string);\\r\\n\\tif (offset === undefined) {\\r\\n\\t\\tencoding = 'utf8';\\r\\n\\t\\tlength = this.length;\\r\\n\\t\\toffset = 0;\\r\\n\\r\\n\\t// Buffer#write(string, encoding)\\r\\n\\t} else if (length === undefined && typeof offset === 'string') {\\r\\n\\t\\tencoding = offset;\\r\\n\\t\\tlength = this.length;\\r\\n\\t\\toffset = 0;\\r\\n\\r\\n\\t// Buffer#write(string, offset[, length][, encoding])\\r\\n\\t} else if (isFinite(offset)) {\\r\\n\\t\\toffset = offset >>> 0;\\r\\n\\t\\tif (isFinite(length)) {\\r\\n\\t\\t\\tlength = length >>> 0;\\r\\n\\t\\t\\tif (encoding === undefined)\\r\\n\\t\\t\\t\\tencoding = 'utf8';\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tencoding = length;\\r\\n\\t\\t\\tlength = undefined;\\r\\n\\t\\t}\\r\\n\\r\\n\\t// XXX legacy write(string, encoding, offset, length) - remove in v0.13\\r\\n\\t} else {\\r\\n\\t\\twriteWarned = internalUtil.printDeprecationMessage(writeMsg, writeWarned);\\r\\n\\t\\tvar swap = encoding;\\r\\n\\t\\tencoding = offset;\\r\\n\\t\\toffset = length >>> 0;\\r\\n\\t\\tlength = swap;\\r\\n\\t}\\r\\n\\r\\n\\tvar remaining = this.length - offset;\\r\\n\\tif (length === undefined || length > remaining)\\r\\n\\t\\tlength = remaining;\\r\\n\\r\\n\\tif (string.length > 0 && (length < 0 || offset < 0))\\r\\n\\t\\tthrow new RangeError('Attempt to write outside buffer bounds');\\r\\n\\r\\n\\tif (!encoding)\\r\\n\\t\\tencoding = 'utf8';\\r\\n\\r\\n\\tvar loweredCase = false;\\r\\n\\tfor (;;) {\\r\\n\\t\\tswitch (encoding) {\\r\\n\\t\\t\\tcase 'hex':\\r\\n\\t\\t\\t\\treturn this.hexWrite(string, offset, length);\\r\\n\\r\\n\\t\\t\\tcase 'utf8':\\r\\n\\t\\t\\tcase 'utf-8':\\r\\n\\t\\t\\t\\treturn this.utf8Write(string, offset, length);\\r\\n\\r\\n\\t\\t\\tcase 'ascii':\\r\\n\\t\\t\\t\\treturn this.asciiWrite(string, offset, length);\\r\\n\\r\\n\\t\\t\\tcase 'binary':\\r\\n\\t\\t\\t\\treturn this.binaryWrite(string, offset, length);\\r\\n\\r\\n\\t\\t\\tcase 'base64':\\r\\n\\t\\t\\t\\t// Warning: maxLength not taken into account in base64Write\\r\\n\\t\\t\\t\\treturn this.base64Write(string, offset, length);\\r\\n\\r\\n\\t\\t\\tcase 'ucs2':\\r\\n\\t\\t\\tcase 'ucs-2':\\r\\n\\t\\t\\tcase 'utf16le':\\r\\n\\t\\t\\tcase 'utf-16le':\\r\\n\\t\\t\\t\\treturn this.ucs2Write(string, offset, length);\\r\\n\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tif (loweredCase)\\r\\n\\t\\t\\t\\t\\tthrow new TypeError('Unknown encoding: ' + encoding);\\r\\n\\t\\t\\t\\tencoding = ('' + encoding).toLowerCase();\\r\\n\\t\\t\\t\\tloweredCase = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.toJSON = function() {\\r\\n\\treturn {\\r\\n\\t\\ttype: 'Buffer',\\r\\n\\t\\tdata: Array.prototype.slice.call(this, 0)\\r\\n\\t};\\r\\n};\\r\\n\\r\\n\\r\\n// TODO(trevnorris): currently works like Array.prototype.slice(), which\\r\\n// doesn't follow the new standard for throwing on out of range indexes.\\r\\nBuffer.prototype.slice = function slice(start, end) {\\r\\n\\tvar buffer = this.subarray(start, end);\\r\\n\\tObject.setPrototypeOf(buffer, Buffer.prototype);\\r\\n\\treturn buffer;\\r\\n};\\r\\n\\r\\n\\r\\nfunction checkOffset(offset, ext, length) {\\r\\n\\tif (offset + ext > length)\\r\\n\\t\\tthrow new RangeError('Index out of range');\\r\\n}\\r\\n\\r\\n\\r\\nBuffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tbyteLength = byteLength >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, byteLength, this.length);\\r\\n\\r\\n\\tvar val = this[offset];\\r\\n\\tvar mul = 1;\\r\\n\\tvar i = 0;\\r\\n\\twhile (++i < byteLength && (mul *= 0x100))\\r\\n\\t\\tval += this[offset + i] * mul;\\r\\n\\r\\n\\treturn val;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tbyteLength = byteLength >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, byteLength, this.length);\\r\\n\\r\\n\\tvar val = this[offset + --byteLength];\\r\\n\\tvar mul = 1;\\r\\n\\twhile (byteLength > 0 && (mul *= 0x100))\\r\\n\\t\\tval += this[offset + --byteLength] * mul;\\r\\n\\r\\n\\treturn val;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 1, this.length);\\r\\n\\treturn this[offset];\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 2, this.length);\\r\\n\\treturn this[offset] | (this[offset + 1] << 8);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 2, this.length);\\r\\n\\treturn (this[offset] << 8) | this[offset + 1];\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 4, this.length);\\r\\n\\r\\n\\treturn ((this[offset]) |\\r\\n\\t\\t\\t(this[offset + 1] << 8) |\\r\\n\\t\\t\\t(this[offset + 2] << 16)) +\\r\\n\\t\\t\\t(this[offset + 3] * 0x1000000);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 4, this.length);\\r\\n\\r\\n\\treturn (this[offset] * 0x1000000) +\\r\\n\\t\\t\\t((this[offset + 1] << 16) |\\r\\n\\t\\t\\t(this[offset + 2] << 8) |\\r\\n\\t\\t\\tthis[offset + 3]);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readIntLE = function(offset, byteLength, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tbyteLength = byteLength >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, byteLength, this.length);\\r\\n\\r\\n\\tvar val = this[offset];\\r\\n\\tvar mul = 1;\\r\\n\\tvar i = 0;\\r\\n\\twhile (++i < byteLength && (mul *= 0x100))\\r\\n\\t\\tval += this[offset + i] * mul;\\r\\n\\tmul *= 0x80;\\r\\n\\r\\n\\tif (val >= mul)\\r\\n\\t\\tval -= Math.pow(2, 8 * byteLength);\\r\\n\\r\\n\\treturn val;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readIntBE = function(offset, byteLength, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tbyteLength = byteLength >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, byteLength, this.length);\\r\\n\\r\\n\\tvar i = byteLength;\\r\\n\\tvar mul = 1;\\r\\n\\tvar val = this[offset + --i];\\r\\n\\twhile (i > 0 && (mul *= 0x100))\\r\\n\\t\\tval += this[offset + --i] * mul;\\r\\n\\tmul *= 0x80;\\r\\n\\r\\n\\tif (val >= mul)\\r\\n\\t\\tval -= Math.pow(2, 8 * byteLength);\\r\\n\\r\\n\\treturn val;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readInt8 = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 1, this.length);\\r\\n\\tvar val = this[offset];\\r\\n\\treturn !(val & 0x80) ? val : (0xff - val + 1) * -1;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 2, this.length);\\r\\n\\tvar val = this[offset] | (this[offset + 1] << 8);\\r\\n\\treturn (val & 0x8000) ? val | 0xFFFF0000 : val;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 2, this.length);\\r\\n\\tvar val = this[offset + 1] | (this[offset] << 8);\\r\\n\\treturn (val & 0x8000) ? val | 0xFFFF0000 : val;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 4, this.length);\\r\\n\\r\\n\\treturn (this[offset]) |\\r\\n\\t\\t\\t(this[offset + 1] << 8) |\\r\\n\\t\\t\\t(this[offset + 2] << 16) |\\r\\n\\t\\t\\t(this[offset + 3] << 24);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 4, this.length);\\r\\n\\r\\n\\treturn (this[offset] << 24) |\\r\\n\\t\\t\\t(this[offset + 1] << 16) |\\r\\n\\t\\t\\t(this[offset + 2] << 8) |\\r\\n\\t\\t\\t(this[offset + 3]);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 4, this.length);\\r\\n\\treturn binding.readFloatLE(this, offset);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 4, this.length);\\r\\n\\treturn binding.readFloatBE(this, offset);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 8, this.length);\\r\\n\\treturn binding.readDoubleLE(this, offset);\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckOffset(offset, 8, this.length);\\r\\n\\treturn binding.readDoubleBE(this, offset);\\r\\n};\\r\\n\\r\\n\\r\\nfunction checkInt(buffer, value, offset, ext, max, min) {\\r\\n\\tif (!(buffer instanceof Buffer))\\r\\n\\t\\tthrow new TypeError('\\\"buffer\\\" argument must be a Buffer instance');\\r\\n\\tif (value > max || value < min)\\r\\n\\t\\tthrow new TypeError('\\\"value\\\" argument is out of bounds');\\r\\n\\tif (offset + ext > buffer.length)\\r\\n\\t\\tthrow new RangeError('Index out of range');\\r\\n}\\r\\n\\r\\n\\r\\nBuffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tbyteLength = byteLength >>> 0;\\r\\n\\tif (!noAssert) {\\r\\n\\t\\tvar maxBytes = Math.pow(2, 8 * byteLength) - 1;\\r\\n\\t\\tcheckInt(this, value, offset, byteLength, maxBytes, 0);\\r\\n\\t}\\r\\n\\r\\n\\tvar mul = 1;\\r\\n\\tvar i = 0;\\r\\n\\tthis[offset] = value;\\r\\n\\twhile (++i < byteLength && (mul *= 0x100))\\r\\n\\t\\tthis[offset + i] = (value / mul) >>> 0;\\r\\n\\r\\n\\treturn offset + byteLength;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tbyteLength = byteLength >>> 0;\\r\\n\\tif (!noAssert) {\\r\\n\\t\\tvar maxBytes = Math.pow(2, 8 * byteLength) - 1;\\r\\n\\t\\tcheckInt(this, value, offset, byteLength, maxBytes, 0);\\r\\n\\t}\\r\\n\\r\\n\\tvar i = byteLength - 1;\\r\\n\\tvar mul = 1;\\r\\n\\tthis[offset + i] = value;\\r\\n\\twhile (--i >= 0 && (mul *= 0x100))\\r\\n\\t\\tthis[offset + i] = (value / mul) >>> 0;\\r\\n\\r\\n\\treturn offset + byteLength;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 1, 0xff, 0);\\r\\n\\tthis[offset] = value;\\r\\n\\treturn offset + 1;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 2, 0xffff, 0);\\r\\n\\tthis[offset] = value;\\r\\n\\tthis[offset + 1] = (value >>> 8);\\r\\n\\treturn offset + 2;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 2, 0xffff, 0);\\r\\n\\tthis[offset] = (value >>> 8);\\r\\n\\tthis[offset + 1] = value;\\r\\n\\treturn offset + 2;\\r\\n};\\r\\n\\r\\nif (typeof NODE_BUFFER !== 'undefined'){\\r\\n\\tBuffer.prototype.writeUInt32LE = NODE_BUFFER.prototype.writeUInt32LE;\\r\\n} else {\\r\\n\\tBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\\r\\n\\t\\tvalue = +value;\\r\\n\\t\\toffset = offset >>> 0;\\r\\n\\t\\tif (!noAssert)\\r\\n\\t\\t\\tcheckInt(this, value, offset, 4, 0xffffffff, 0);\\r\\n\\t\\tthis[offset + 3] = (value >>> 24);\\r\\n\\t\\tthis[offset + 2] = (value >>> 16);\\r\\n\\t\\tthis[offset + 1] = (value >>> 8);\\r\\n\\t\\tthis[offset] = value;\\r\\n\\t\\treturn offset + 4;\\r\\n\\t};\\r\\n}\\r\\n\\r\\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 4, 0xffffffff, 0);\\r\\n\\tthis[offset] = (value >>> 24);\\r\\n\\tthis[offset + 1] = (value >>> 16);\\r\\n\\tthis[offset + 2] = (value >>> 8);\\r\\n\\tthis[offset + 3] = value;\\r\\n\\treturn offset + 4;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert) {\\r\\n\\t\\tcheckInt(this,\\r\\n\\t\\t\\t\\t\\t\\t value,\\r\\n\\t\\t\\t\\t\\t\\t offset,\\r\\n\\t\\t\\t\\t\\t\\t byteLength,\\r\\n\\t\\t\\t\\t\\t\\t Math.pow(2, 8 * byteLength - 1) - 1,\\r\\n\\t\\t\\t\\t\\t\\t -Math.pow(2, 8 * byteLength - 1));\\r\\n\\t}\\r\\n\\r\\n\\tvar i = 0;\\r\\n\\tvar mul = 1;\\r\\n\\tvar sub = 0;\\r\\n\\tthis[offset] = value;\\r\\n\\twhile (++i < byteLength && (mul *= 0x100)) {\\r\\n\\t\\tif (value < 0 && sub === 0 && this[offset + i - 1] !== 0)\\r\\n\\t\\t\\tsub = 1;\\r\\n\\t\\tthis[offset + i] = ((value / mul) >> 0) - sub;\\r\\n\\t}\\r\\n\\r\\n\\treturn offset + byteLength;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert) {\\r\\n\\t\\tcheckInt(this,\\r\\n\\t\\t\\t\\t\\t\\t value,\\r\\n\\t\\t\\t\\t\\t\\t offset,\\r\\n\\t\\t\\t\\t\\t\\t byteLength,\\r\\n\\t\\t\\t\\t\\t\\t Math.pow(2, 8 * byteLength - 1) - 1,\\r\\n\\t\\t\\t\\t\\t\\t -Math.pow(2, 8 * byteLength - 1));\\r\\n\\t}\\r\\n\\r\\n\\tvar i = byteLength - 1;\\r\\n\\tvar mul = 1;\\r\\n\\tvar sub = 0;\\r\\n\\tthis[offset + i] = value;\\r\\n\\twhile (--i >= 0 && (mul *= 0x100)) {\\r\\n\\t\\tif (value < 0 && sub === 0 && this[offset + i + 1] !== 0)\\r\\n\\t\\t\\tsub = 1;\\r\\n\\t\\tthis[offset + i] = ((value / mul) >> 0) - sub;\\r\\n\\t}\\r\\n\\r\\n\\treturn offset + byteLength;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 1, 0x7f, -0x80);\\r\\n\\tthis[offset] = value;\\r\\n\\treturn offset + 1;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 2, 0x7fff, -0x8000);\\r\\n\\tthis[offset] = value;\\r\\n\\tthis[offset + 1] = (value >>> 8);\\r\\n\\treturn offset + 2;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 2, 0x7fff, -0x8000);\\r\\n\\tthis[offset] = (value >>> 8);\\r\\n\\tthis[offset + 1] = value;\\r\\n\\treturn offset + 2;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\\r\\n\\tthis[offset] = value;\\r\\n\\tthis[offset + 1] = (value >>> 8);\\r\\n\\tthis[offset + 2] = (value >>> 16);\\r\\n\\tthis[offset + 3] = (value >>> 24);\\r\\n\\treturn offset + 4;\\r\\n};\\r\\n\\r\\n\\r\\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\\r\\n\\tvalue = +value;\\r\\n\\toffset = offset >>> 0;\\r\\n\\tif (!noAssert)\\r\\n\\t\\tcheckInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\\r\\n\\tthis[offset] = (value >>> 24);\\r\\n\\tthis[offset + 1] = (value >>> 16);\\r\\n\\tthis[offset + 2] = (value >>> 8);\\r\\n\\tthis[offset + 3] = value;\\r\\n\\treturn offset + 4;\\r\\n};\\r\\n\\r\\nif (typeof NODE_BUFFER !== 'undefined'){\\r\\n\\tBuffer.prototype.writeFloatLE = NODE_BUFFER.prototype.writeFloatLE;\\r\\n} else {\\r\\n\\tBuffer.prototype.writeFloatLE = function writeFloatLE(val, offset, noAssert) {\\r\\n\\t\\tval = +val;\\r\\n\\t\\toffset = offset >>> 0;\\r\\n\\t\\tif (!noAssert)\\r\\n\\t\\t\\tbinding.writeFloatLE(this, val, offset);\\r\\n\\t\\telse\\r\\n\\t\\t\\tbinding.writeFloatLE(this, val, offset, true);\\r\\n\\t\\treturn offset + 4;\\r\\n\\t};\\r\\n}\\r\\n\\r\\nif (typeof NODE_BUFFER !== 'undefined'){\\r\\n\\tBuffer.prototype.writeFloatBE = NODE_BUFFER.prototype.writeFloatBE;\\r\\n} else {\\r\\n\\tBuffer.prototype.writeFloatBE = function writeFloatBE(val, offset, noAssert) {\\r\\n\\t\\tval = +val;\\r\\n\\t\\toffset = offset >>> 0;\\r\\n\\t\\tif (!noAssert)\\r\\n\\t\\t\\tbinding.writeFloatBE(this, val, offset);\\r\\n\\t\\telse\\r\\n\\t\\t\\tbinding.writeFloatBE(this, val, offset, true);\\r\\n\\t\\treturn offset + 4;\\r\\n\\t};\\r\\n}\\r\\n\\r\\nif (typeof NODE_BUFFER !== 'undefined'){\\r\\n\\tBuffer.prototype.writeDoubleLE = NODE_BUFFER.prototype.writeDoubleLE;\\r\\n} else {\\r\\n\\tBuffer.prototype.writeDoubleLE = function writeDoubleLE(val, offset, noAssert) {\\r\\n\\t\\tval = +val;\\r\\n\\t\\toffset = offset >>> 0;\\r\\n\\t\\tif (!noAssert)\\r\\n\\t\\t\\tbinding.writeDoubleLE(this, val, offset);\\r\\n\\t\\telse\\r\\n\\t\\t\\tbinding.writeDoubleLE(this, val, offset, true);\\r\\n\\t\\treturn offset + 8;\\r\\n\\t};\\r\\n}\\r\\n\\r\\nif (typeof NODE_BUFFER !== 'undefined'){\\r\\n\\tBuffer.prototype.writeDoubleBE = NODE_BUFFER.prototype.writeDoubleBE;\\r\\n} else {\\r\\n\\tBuffer.prototype.writeDoubleBE = function writeDoubleBE(val, offset, noAssert) {\\r\\n\\t\\tval = +val;\\r\\n\\t\\toffset = offset >>> 0;\\r\\n\\t\\tif (!noAssert)\\r\\n\\t\\t\\tbinding.writeDoubleBE(this, val, offset);\\r\\n\\t\\telse\\r\\n\\t\\t\\tbinding.writeDoubleBE(this, val, offset, true);\\r\\n\\t\\treturn offset + 8;\\r\\n\\t};\\r\\n}\\r\\n\",\"util\":\"//// Copyright Joyent, Inc. and other Node contributors.\\r\\n////\\r\\n//// Permission is hereby granted, free of charge, to any person obtaining a\\r\\n//// copy of this software and associated documentation files (the\\r\\n//// \\\"Software\\\"), to deal in the Software without restriction, including\\r\\n//// without limitation the rights to use, copy, modify, merge, publish,\\r\\n//// distribute, sublicense, and/or sell copies of the Software, and to permit\\r\\n//// persons to whom the Software is furnished to do so, subject to the\\r\\n//// following conditions:\\r\\n////\\r\\n//// The above copyright notice and this permission notice shall be included\\r\\n//// in all copies or substantial portions of the Software.\\r\\n////\\r\\n//// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\r\\n//// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\r\\n//// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\r\\n//// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\r\\n//// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\r\\n//// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\r\\n//// USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\nexports._exceptionWithHostPort = function(err,\\r\\n                                          syscall,\\r\\n                                          address,\\r\\n                                          port,\\r\\n                                          additional) {\\r\\n  var details;\\r\\n  if (port && port > 0) {\\r\\n    details = address + ':' + port;\\r\\n  } else {\\r\\n    details = address;\\r\\n  }\\r\\n\\r\\n  if (additional) {\\r\\n    details += ' - Local (' + additional + ')';\\r\\n  }\\r\\n  var ex = exports._errnoException(err, syscall, details);\\r\\n  ex.address = address;\\r\\n  if (port) {\\r\\n    ex.port = port;\\r\\n  }\\r\\n  return ex;\\r\\n};\\r\\n\\r\\nvar formatRegExp = /%[sdj%]/g;\\r\\nexports.format = function(f) {\\r\\n  if (!isString(f)) {\\r\\n    var objects = [];\\r\\n    for (var i = 0; i < arguments.length; i++) {\\r\\n      objects.push(inspect(arguments[i]));\\r\\n    }\\r\\n    return objects.join(' ');\\r\\n  }\\r\\n\\r\\n  var i = 1;\\r\\n  var args = arguments;\\r\\n  var len = args.length;\\r\\n  var str = String(f).replace(formatRegExp, function(x) {\\r\\n    if (x === '%%') return '%';\\r\\n    if (i >= len) return x;\\r\\n    switch (x) {\\r\\n      case '%s': return String(args[i++]);\\r\\n      case '%d': return Number(args[i++]);\\r\\n      case '%j':\\r\\n        try {\\r\\n          return JSON.stringify(args[i++]);\\r\\n        } catch (_) {\\r\\n          return '[Circular]';\\r\\n        }\\r\\n      default:\\r\\n        return x;\\r\\n    }\\r\\n  });\\r\\n  for (var x = args[i]; i < len; x = args[++i]) {\\r\\n    if (isNull(x) || !isObject(x)) {\\r\\n      str += ' ' + x;\\r\\n    } else {\\r\\n      str += ' ' + inspect(x);\\r\\n    }\\r\\n  }\\r\\n  return str;\\r\\n};\\r\\n\\r\\n// Mark that a method should not be used.\\r\\n// Returns a modified function which warns once by default.\\r\\n// If --no-deprecation is set, then it is a no-op.\\r\\nexports.deprecate = function(fn, msg) {\\r\\n  // Allow for deprecating things in the process of starting up.\\r\\n  if (isUndefined(global.process)) {\\r\\n    return function() {\\r\\n      return exports.deprecate(fn, msg).apply(this, arguments);\\r\\n    };\\r\\n  }\\r\\n\\r\\n  if (process.noDeprecation === true) {\\r\\n    return fn;\\r\\n  }\\r\\n\\r\\n  var warned = false;\\r\\n  function deprecated() {\\r\\n    if (!warned) {\\r\\n      if (process.throwDeprecation) {\\r\\n        throw new Error(msg);\\r\\n      } else if (process.traceDeprecation) {\\r\\n        console.trace(msg);\\r\\n      } else {\\r\\n        console.error(msg);\\r\\n      }\\r\\n      warned = true;\\r\\n    }\\r\\n    return fn.apply(this, arguments);\\r\\n  }\\r\\n\\r\\n  return deprecated;\\r\\n};\\r\\n\\r\\n\\r\\nvar debugs = {};\\r\\nvar debugEnviron;\\r\\nexports.debuglog = function(set) {\\r\\n  if (isUndefined(debugEnviron))\\r\\n    debugEnviron = process.env.NODE_DEBUG || '';\\r\\n  set = set.toUpperCase();\\r\\n  if (!debugs[set]) {\\r\\n    if (new RegExp('\\\\\\\\b' + set + '\\\\\\\\b', 'i').test(debugEnviron)) {\\r\\n      var pid = process.pid;\\r\\n      debugs[set] = function() {\\r\\n        var msg = exports.format.apply(exports, arguments);\\r\\n        console.error('%s %d: %s', set, pid, msg);\\r\\n      };\\r\\n    } else {\\r\\n      debugs[set] = function() {};\\r\\n    }\\r\\n  }\\r\\n  return debugs[set];\\r\\n};\\r\\n\\r\\n/**\\r\\n * Echos the value of a value. Trys to print the value out\\r\\n * in the best way possible given the different types.\\r\\n *\\r\\n * @param {Object} obj The object to print out.\\r\\n * @param {Object} opts Optional options object that alters the output.\\r\\n */\\r\\n/* legacy: obj, showHidden, depth, colors*/\\r\\nfunction inspect(obj, opts) {\\r\\n  // default options\\r\\n  var ctx = {\\r\\n    seen: [],\\r\\n    stylize: stylizeNoColor\\r\\n  };\\r\\n  // legacy...\\r\\n  if (arguments.length >= 3) ctx.depth = arguments[2];\\r\\n  if (arguments.length >= 4) ctx.colors = arguments[3];\\r\\n  if (isBoolean(opts)) {\\r\\n    // legacy...\\r\\n    ctx.showHidden = opts;\\r\\n  } else if (opts) {\\r\\n    // got an \\\"options\\\" object\\r\\n    exports._extend(ctx, opts);\\r\\n  }\\r\\n  // set default options\\r\\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\\r\\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\\r\\n  if (isUndefined(ctx.colors)) ctx.colors = false;\\r\\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\\r\\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\\r\\n  return formatValue(ctx, obj, ctx.depth);\\r\\n}\\r\\nexports.inspect = inspect;\\r\\n\\r\\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\\r\\ninspect.colors = {\\r\\n  'bold' : [1, 22],\\r\\n  'italic' : [3, 23],\\r\\n  'underline' : [4, 24],\\r\\n  'inverse' : [7, 27],\\r\\n  'white' : [37, 39],\\r\\n  'grey' : [90, 39],\\r\\n  'black' : [30, 39],\\r\\n  'blue' : [34, 39],\\r\\n  'cyan' : [36, 39],\\r\\n  'green' : [32, 39],\\r\\n  'magenta' : [35, 39],\\r\\n  'red' : [31, 39],\\r\\n  'yellow' : [33, 39]\\r\\n};\\r\\n\\r\\n// Don't use 'blue' not visible on cmd.exe\\r\\ninspect.styles = {\\r\\n  'special': 'cyan',\\r\\n  'number': 'yellow',\\r\\n  'boolean': 'yellow',\\r\\n  'undefined': 'grey',\\r\\n  'null': 'bold',\\r\\n  'string': 'green',\\r\\n  'date': 'magenta',\\r\\n  // \\\"name\\\": intentionally not styling\\r\\n  'regexp': 'red'\\r\\n};\\r\\n\\r\\n\\r\\nfunction stylizeWithColor(str, styleType) {\\r\\n  var style = inspect.styles[styleType];\\r\\n\\r\\n  if (style) {\\r\\n    return '\\\\u001b[' + inspect.colors[style][0] + 'm' + str +\\r\\n           '\\\\u001b[' + inspect.colors[style][1] + 'm';\\r\\n  } else {\\r\\n    return str;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nfunction stylizeNoColor(str, styleType) {\\r\\n  return str;\\r\\n}\\r\\n\\r\\n\\r\\nfunction arrayToHash(array) {\\r\\n  var hash = {};\\r\\n\\r\\n  array.forEach(function(val, idx) {\\r\\n    hash[val] = true;\\r\\n  });\\r\\n\\r\\n  return hash;\\r\\n}\\r\\n\\r\\n\\r\\nfunction formatValue(ctx, value, recurseTimes) {\\r\\n  // Provide a hook for user-specified inspect functions.\\r\\n  // Check that value is an object with an inspect function on it\\r\\n  if (ctx.customInspect &&\\r\\n      value &&\\r\\n      isFunction(value.inspect) &&\\r\\n      // Filter out the util module, it's inspect function is special\\r\\n      value.inspect !== exports.inspect &&\\r\\n      // Also filter out any prototype objects using the circular check.\\r\\n      !(value.constructor && value.constructor.prototype === value)) {\\r\\n    var ret = value.inspect(recurseTimes, ctx);\\r\\n    if (!isString(ret)) {\\r\\n      ret = formatValue(ctx, ret, recurseTimes);\\r\\n    }\\r\\n    return ret;\\r\\n  }\\r\\n\\r\\n  // Primitive types cannot have properties\\r\\n  var primitive = formatPrimitive(ctx, value);\\r\\n  if (primitive) {\\r\\n    return primitive;\\r\\n  }\\r\\n\\r\\n  // Look up the keys of the object.\\r\\n  var keys = Object.keys(value);\\r\\n  var visibleKeys = arrayToHash(keys);\\r\\n\\r\\n  if (ctx.showHidden) {\\r\\n    keys = Object.getOwnPropertyNames(value);\\r\\n  }\\r\\n\\r\\n  // This could be a boxed primitive (new String(), etc.), check valueOf()\\r\\n  // NOTE: Avoid calling `valueOf` on `Date` instance because it will return\\r\\n  // a number which, when object has some additional user-stored `keys`,\\r\\n  // will be printed out.\\r\\n  var formatted;\\r\\n  var raw = value;\\r\\n  try {\\r\\n    // the .valueOf() call can fail for a multitude of reasons\\r\\n    if (!isDate(value))\\r\\n      raw = value.valueOf();\\r\\n  } catch (e) {\\r\\n    // ignore...\\r\\n  }\\r\\n\\r\\n  if (isString(raw)) {\\r\\n    // for boxed Strings, we have to remove the 0-n indexed entries,\\r\\n    // since they just noisey up the output and are redundant\\r\\n    keys = keys.filter(function(key) {\\r\\n      return !(key >= 0 && key < raw.length);\\r\\n    });\\r\\n  }\\r\\n\\r\\n  // Some type of object without properties can be shortcutted.\\r\\n  if (keys.length === 0) {\\r\\n    if (isFunction(value)) {\\r\\n      var name = value.name ? ': ' + value.name : '';\\r\\n      return ctx.stylize('[Function' + name + ']', 'special');\\r\\n    }\\r\\n    if (isRegExp(value)) {\\r\\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\\r\\n    }\\r\\n    if (isDate(value)) {\\r\\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\\r\\n    }\\r\\n    if (isError(value)) {\\r\\n      return formatError(value);\\r\\n    }\\r\\n    // now check the `raw` value to handle boxed primitives\\r\\n    if (isString(raw)) {\\r\\n      formatted = formatPrimitiveNoColor(ctx, raw);\\r\\n      return ctx.stylize('[String: ' + formatted + ']', 'string');\\r\\n    }\\r\\n    if (isNumber(raw)) {\\r\\n      formatted = formatPrimitiveNoColor(ctx, raw);\\r\\n      return ctx.stylize('[Number: ' + formatted + ']', 'number');\\r\\n    }\\r\\n    if (isBoolean(raw)) {\\r\\n      formatted = formatPrimitiveNoColor(ctx, raw);\\r\\n      return ctx.stylize('[Boolean: ' + formatted + ']', 'boolean');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var base = '', array = false, braces = ['{', '}'];\\r\\n\\r\\n  // Make Array say that they are Array\\r\\n  if (isArray(value)) {\\r\\n    array = true;\\r\\n    braces = ['[', ']'];\\r\\n  }\\r\\n\\r\\n  // Make functions say that they are functions\\r\\n  if (isFunction(value)) {\\r\\n    var n = value.name ? ': ' + value.name : '';\\r\\n    base = ' [Function' + n + ']';\\r\\n  }\\r\\n\\r\\n  // Make RegExps say that they are RegExps\\r\\n  if (isRegExp(value)) {\\r\\n    base = ' ' + RegExp.prototype.toString.call(value);\\r\\n  }\\r\\n\\r\\n  // Make dates with properties first say the date\\r\\n  if (isDate(value)) {\\r\\n    base = ' ' + Date.prototype.toUTCString.call(value);\\r\\n  }\\r\\n\\r\\n  // Make error with message first say the error\\r\\n  if (isError(value)) {\\r\\n    base = ' ' + formatError(value);\\r\\n  }\\r\\n\\r\\n  // Make boxed primitive Strings look like such\\r\\n  if (isString(raw)) {\\r\\n    formatted = formatPrimitiveNoColor(ctx, raw);\\r\\n    base = ' ' + '[String: ' + formatted + ']';\\r\\n  }\\r\\n\\r\\n  // Make boxed primitive Numbers look like such\\r\\n  if (isNumber(raw)) {\\r\\n    formatted = formatPrimitiveNoColor(ctx, raw);\\r\\n    base = ' ' + '[Number: ' + formatted + ']';\\r\\n  }\\r\\n\\r\\n  // Make boxed primitive Booleans look like such\\r\\n  if (isBoolean(raw)) {\\r\\n    formatted = formatPrimitiveNoColor(ctx, raw);\\r\\n    base = ' ' + '[Boolean: ' + formatted + ']';\\r\\n  }\\r\\n\\r\\n  if (keys.length === 0 && (!array || value.length === 0)) {\\r\\n    return braces[0] + base + braces[1];\\r\\n  }\\r\\n\\r\\n  if (recurseTimes < 0) {\\r\\n    if (isRegExp(value)) {\\r\\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\\r\\n    } else {\\r\\n      return ctx.stylize('[Object]', 'special');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  ctx.seen.push(value);\\r\\n\\r\\n  var output;\\r\\n  if (array) {\\r\\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\\r\\n  } else {\\r\\n    output = keys.map(function(key) {\\r\\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\\r\\n    });\\r\\n  }\\r\\n\\r\\n  ctx.seen.pop();\\r\\n\\r\\n  return reduceToSingleString(output, base, braces);\\r\\n}\\r\\n\\r\\n\\r\\nfunction formatPrimitive(ctx, value) {\\r\\n  if (isUndefined(value))\\r\\n    return ctx.stylize('undefined', 'undefined');\\r\\n  if (isString(value)) {\\r\\n    var simple = '\\\\'' + JSON.stringify(value).replace(/^\\\"|\\\"$/g, '')\\r\\n                                             .replace(/'/g, \\\"\\\\\\\\'\\\")\\r\\n                                             .replace(/\\\\\\\\\\\"/g, '\\\"') + '\\\\'';\\r\\n    return ctx.stylize(simple, 'string');\\r\\n  }\\r\\n  if (isNumber(value)) {\\r\\n    // Format -0 as '-0'. Strict equality won't distinguish 0 from -0,\\r\\n    // so instead we use the fact that 1 / -0 < 0 whereas 1 / 0 > 0 .\\r\\n    if (value === 0 && 1 / value < 0)\\r\\n      return ctx.stylize('-0', 'number');\\r\\n    return ctx.stylize('' + value, 'number');\\r\\n  }\\r\\n  if (isBoolean(value))\\r\\n    return ctx.stylize('' + value, 'boolean');\\r\\n  // For some reason typeof null is \\\"object\\\", so special case here.\\r\\n  if (isNull(value))\\r\\n    return ctx.stylize('null', 'null');\\r\\n\\r\\n  if (typeof value !== 'object' && typeof value !== 'function')\\r\\n    return ctx.stylize('[Pointer: ' + value + ']', 'string');\\r\\n}\\r\\n\\r\\n\\r\\nfunction formatPrimitiveNoColor(ctx, value) {\\r\\n  var stylize = ctx.stylize;\\r\\n  ctx.stylize = stylizeNoColor;\\r\\n  var str = formatPrimitive(ctx, value);\\r\\n  ctx.stylize = stylize;\\r\\n  return str;\\r\\n}\\r\\n\\r\\n\\r\\nfunction formatError(value) {\\r\\n  return '[' + Error.prototype.toString.call(value) + ']';\\r\\n}\\r\\n\\r\\n\\r\\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\\r\\n  var output = [];\\r\\n  for (var i = 0, l = value.length; i < l; ++i) {\\r\\n    if (hasOwnProperty(value, String(i))) {\\r\\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\\r\\n          String(i), true));\\r\\n    } else {\\r\\n      output.push('');\\r\\n    }\\r\\n  }\\r\\n  keys.forEach(function(key) {\\r\\n    if (!key.match(/^\\\\d+$/)) {\\r\\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\\r\\n          key, true));\\r\\n    }\\r\\n  });\\r\\n  return output;\\r\\n}\\r\\n\\r\\n\\r\\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\\r\\n  var name, str, desc;\\r\\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\\r\\n  if (desc.get) {\\r\\n    if (desc.set) {\\r\\n      str = ctx.stylize('[Getter/Setter]', 'special');\\r\\n    } else {\\r\\n      str = ctx.stylize('[Getter]', 'special');\\r\\n    }\\r\\n  } else {\\r\\n    if (desc.set) {\\r\\n      str = ctx.stylize('[Setter]', 'special');\\r\\n    }\\r\\n  }\\r\\n  if (!hasOwnProperty(visibleKeys, key)) {\\r\\n    name = '[' + key + ']';\\r\\n  }\\r\\n  if (!str) {\\r\\n    if (ctx.seen.indexOf(desc.value) < 0) {\\r\\n      if (isNull(recurseTimes)) {\\r\\n        str = formatValue(ctx, desc.value, null);\\r\\n      } else {\\r\\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\\r\\n      }\\r\\n      if (str.indexOf('\\\\n') > -1) {\\r\\n        if (array) {\\r\\n          str = str.split('\\\\n').map(function(line) {\\r\\n            return '  ' + line;\\r\\n          }).join('\\\\n').substr(2);\\r\\n        } else {\\r\\n          str = '\\\\n' + str.split('\\\\n').map(function(line) {\\r\\n            return '   ' + line;\\r\\n          }).join('\\\\n');\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      str = ctx.stylize('[Circular]', 'special');\\r\\n    }\\r\\n  }\\r\\n  if (isUndefined(name)) {\\r\\n    if (array && key.match(/^\\\\d+$/)) {\\r\\n      return str;\\r\\n    }\\r\\n    name = JSON.stringify('' + key);\\r\\n    if (name.match(/^\\\"([a-zA-Z_][a-zA-Z_0-9]*)\\\"$/)) {\\r\\n      name = name.substr(1, name.length - 2);\\r\\n      name = ctx.stylize(name, 'name');\\r\\n    } else {\\r\\n      name = name.replace(/'/g, \\\"\\\\\\\\'\\\")\\r\\n                 .replace(/\\\\\\\\\\\"/g, '\\\"')\\r\\n                 .replace(/(^\\\"|\\\"$)/g, \\\"'\\\")\\r\\n                 .replace(/\\\\\\\\\\\\\\\\/g, '\\\\\\\\');\\r\\n      name = ctx.stylize(name, 'string');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return name + ': ' + str;\\r\\n}\\r\\n\\r\\n\\r\\nfunction reduceToSingleString(output, base, braces) {\\r\\n  var length = output.reduce(function(prev, cur) {\\r\\n    return prev + cur.replace(/\\\\u001b\\\\[\\\\d\\\\d?m/g, '').length + 1;\\r\\n  }, 0);\\r\\n\\r\\n  if (length > 60) {\\r\\n    return braces[0] +\\r\\n           (base === '' ? '' : base + '\\\\n ') +\\r\\n           ' ' +\\r\\n           output.join(',\\\\n  ') +\\r\\n           ' ' +\\r\\n           braces[1];\\r\\n  }\\r\\n\\r\\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\\r\\n}\\r\\n\\r\\n\\r\\n// NOTE: These type checking functions intentionally don't use `instanceof`\\r\\n// because it is fragile and can be easily faked with `Object.create()`.\\r\\nvar isArray = exports.isArray = Array.isArray;\\r\\n\\r\\nfunction isBoolean(arg) {\\r\\n  return typeof arg === 'boolean';\\r\\n}\\r\\nexports.isBoolean = isBoolean;\\r\\n\\r\\nfunction isNull(arg) {\\r\\n  return arg === null;\\r\\n}\\r\\nexports.isNull = isNull;\\r\\n\\r\\nfunction isNullOrUndefined(arg) {\\r\\n  return arg == null;\\r\\n}\\r\\nexports.isNullOrUndefined = isNullOrUndefined;\\r\\n\\r\\nfunction isNumber(arg) {\\r\\n  return typeof arg === 'number';\\r\\n}\\r\\nexports.isNumber = isNumber;\\r\\n\\r\\nfunction isString(arg) {\\r\\n  return typeof arg === 'string';\\r\\n}\\r\\nexports.isString = isString;\\r\\n\\r\\nfunction isSymbol(arg) {\\r\\n  return typeof arg === 'symbol';\\r\\n}\\r\\nexports.isSymbol = isSymbol;\\r\\n\\r\\nfunction isUndefined(arg) {\\r\\n  return arg === void 0;\\r\\n}\\r\\nexports.isUndefined = isUndefined;\\r\\n\\r\\nfunction isRegExp(re) {\\r\\n  return isObject(re) && objectToString(re) === '[object RegExp]';\\r\\n}\\r\\nexports.isRegExp = isRegExp;\\r\\n\\r\\nfunction isObject(arg) {\\r\\n  return typeof arg === 'object' && arg !== null;\\r\\n}\\r\\nexports.isObject = isObject;\\r\\n\\r\\nfunction isDate(d) {\\r\\n  return isObject(d) && objectToString(d) === '[object Date]';\\r\\n}\\r\\nexports.isDate = isDate;\\r\\n\\r\\nfunction isError(e) {\\r\\n  return isObject(e) &&\\r\\n      (objectToString(e) === '[object Error]' || e instanceof Error);\\r\\n}\\r\\nexports.isError = isError;\\r\\n\\r\\nfunction isFunction(arg) {\\r\\n  return typeof arg === 'function';\\r\\n}\\r\\nexports.isFunction = isFunction;\\r\\n\\r\\nfunction isPrimitive(arg) {\\r\\n  return arg === null ||\\r\\n         typeof arg === 'boolean' ||\\r\\n         typeof arg === 'number' ||\\r\\n         typeof arg === 'string' ||\\r\\n         typeof arg === 'symbol' ||  // ES6 symbol\\r\\n         typeof arg === 'undefined';\\r\\n}\\r\\nexports.isPrimitive = isPrimitive;\\r\\n\\r\\nfunction isBuffer(b) {\\r\\n  return b instanceof Buffer;\\r\\n}\\r\\nexports.isBuffer = isBuffer;\\r\\n\\r\\nfunction objectToString(o) {\\r\\n  return Object.prototype.toString.call(o);\\r\\n}\\r\\n\\r\\n\\r\\nfunction pad(n) {\\r\\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\\r\\n}\\r\\n\\r\\n\\r\\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\\r\\n              'Oct', 'Nov', 'Dec'];\\r\\n\\r\\n// 26 Feb 16:19:34\\r\\nfunction timestamp() {\\r\\n  var d = new Date();\\r\\n  var time = [pad(d.getHours()),\\r\\n              pad(d.getMinutes()),\\r\\n              pad(d.getSeconds())].join(':');\\r\\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\\r\\n}\\r\\n\\r\\n\\r\\n// log is just a thin wrapper to console.log that prepends a timestamp\\r\\nexports.log = function() {\\r\\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\\r\\n};\\r\\n\\r\\n\\r\\n/**\\r\\n * Inherit the prototype methods from one constructor into another.\\r\\n *\\r\\n * The Function.prototype.inherits from lang.js rewritten as a standalone\\r\\n * function (not on Function.prototype). NOTE: If this file is to be loaded\\r\\n * during bootstrapping this function needs to be rewritten using some native\\r\\n * functions as prototype setup using normal JavaScript does not work as\\r\\n * expected during bootstrapping (see mirror.js in r114903).\\r\\n *\\r\\n * @param {function} ctor Constructor function which needs to inherit the\\r\\n *     prototype.\\r\\n * @param {function} superCtor Constructor function to inherit prototype from.\\r\\n */\\r\\nexports.inherits = function(ctor, superCtor) {\\r\\n  ctor.super_ = superCtor;\\r\\n  ctor.prototype = Object.create(superCtor.prototype, {\\r\\n    constructor: {\\r\\n      value: ctor,\\r\\n      enumerable: false,\\r\\n      writable: true,\\r\\n      configurable: true\\r\\n    }\\r\\n  });\\r\\n};\\r\\n\\r\\nexports._extend = function(origin, add) {\\r\\n  // Don't do anything if add isn't an object\\r\\n  if (!add || !isObject(add)) return origin;\\r\\n\\r\\n  var keys = Object.keys(add);\\r\\n  var i = keys.length;\\r\\n  while (i--) {\\r\\n    origin[keys[i]] = add[keys[i]];\\r\\n  }\\r\\n  return origin;\\r\\n};\\r\\n\\r\\nfunction hasOwnProperty(obj, prop) {\\r\\n  return Object.prototype.hasOwnProperty.call(obj, prop);\\r\\n}\\r\\n\\r\\n\\r\\n//Deprecated old stuff.\\r\\n\\r\\nexports.p = exports.deprecate(function() {\\r\\n  for (var i = 0, len = arguments.length; i < len; ++i) {\\r\\n    console.error(exports.inspect(arguments[i]));\\r\\n  }\\r\\n}, 'util.p: Use console.error() instead');\\r\\n\\r\\n\\r\\nexports.exec = exports.deprecate(function() {\\r\\n  return require('child_process').exec.apply(this, arguments);\\r\\n}, 'util.exec is now called `child_process.exec`.');\\r\\n\\r\\n\\r\\nexports.print = exports.deprecate(function() {\\r\\n  for (var i = 0, len = arguments.length; i < len; ++i) {\\r\\n    process.stdout.write(String(arguments[i]));\\r\\n  }\\r\\n}, 'util.print: Use console.log instead');\\r\\n\\r\\n\\r\\nexports.puts = exports.deprecate(function() {\\r\\n  for (var i = 0, len = arguments.length; i < len; ++i) {\\r\\n    process.stdout.write(arguments[i] + '\\\\n');\\r\\n  }\\r\\n}, 'util.puts: Use console.log instead');\\r\\n\\r\\n\\r\\nexports.debug = exports.deprecate(function(x) {\\r\\n  process.stderr.write('DEBUG: ' + x + '\\\\n');\\r\\n}, 'util.debug: Use console.error instead');\\r\\n\\r\\n\\r\\nexports.error = exports.deprecate(function(x) {\\r\\n  for (var i = 0, len = arguments.length; i < len; ++i) {\\r\\n    process.stderr.write(arguments[i] + '\\\\n');\\r\\n  }\\r\\n}, 'util.error: Use console.error instead');\\r\\n\\r\\n\\r\\nexports.pump = exports.deprecate(function(readStream, writeStream, callback) {\\r\\n  var callbackCalled = false;\\r\\n\\r\\n  function call(a, b, c) {\\r\\n    if (callback && !callbackCalled) {\\r\\n      callback(a, b, c);\\r\\n      callbackCalled = true;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  readStream.addListener('data', function(chunk) {\\r\\n    if (writeStream.write(chunk) === false) readStream.pause();\\r\\n  });\\r\\n\\r\\n  writeStream.addListener('drain', function() {\\r\\n    readStream.resume();\\r\\n  });\\r\\n\\r\\n  readStream.addListener('end', function() {\\r\\n    writeStream.end();\\r\\n  });\\r\\n\\r\\n  readStream.addListener('close', function() {\\r\\n    call();\\r\\n  });\\r\\n\\r\\n  readStream.addListener('error', function(err) {\\r\\n    writeStream.end();\\r\\n    call(err);\\r\\n  });\\r\\n\\r\\n  writeStream.addListener('error', function(err) {\\r\\n    readStream.destroy();\\r\\n    call(err);\\r\\n  });\\r\\n}, 'util.pump(): Use readableStream.pipe() instead');\\r\\n\\r\\n\\r\\nvar uv;\\r\\nexports._errnoException = function(err, syscall, original) {\\r\\n  if (isUndefined(uv)) uv = process.binding('uv');\\r\\n  var errname = uv.errname(err);\\r\\n  var message = syscall + ' ' + errname;\\r\\n  if (original)\\r\\n    message += ' ' + original;\\r\\n  var e = new Error(message);\\r\\n  e.code = errname;\\r\\n  e.errno = errname;\\r\\n  e.syscall = syscall;\\r\\n  return e;\\r\\n};\\r\\n\",\"path\":\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n\\nvar isWindows = process.platform === 'win32';\\nvar util = require('util');\\n\\n\\n// resolves . and .. elements in a path array with directory names there\\n// must be no slashes, empty elements, or device names (c:\\\\) in the array\\n// (so also no leading and trailing slashes - it does not distinguish\\n// relative and absolute paths)\\nfunction normalizeArray(parts, allowAboveRoot) {\\n  // if the path tries to go above the root, `up` ends up > 0\\n  var up = 0;\\n  for (var i = parts.length - 1; i >= 0; i--) {\\n    var last = parts[i];\\n    if (last === '.') {\\n      parts.splice(i, 1);\\n    } else if (last === '..') {\\n      parts.splice(i, 1);\\n      up++;\\n    } else if (up) {\\n      parts.splice(i, 1);\\n      up--;\\n    }\\n  }\\n\\n  // if the path is allowed to go above the root, restore leading ..s\\n  if (allowAboveRoot) {\\n    for (; up--; up) {\\n      parts.unshift('..');\\n    }\\n  }\\n\\n  return parts;\\n}\\n\\n\\nif (isWindows) {\\n  // Regex to split a windows path into three parts: [*, device, slash,\\n  // tail] windows-only\\n  var splitDeviceRe =\\n      /^([a-zA-Z]:|[\\\\\\\\\\\\/]{2}[^\\\\\\\\\\\\/]+[\\\\\\\\\\\\/]+[^\\\\\\\\\\\\/]+)?([\\\\\\\\\\\\/])?([\\\\s\\\\S]*?)$/;\\n\\n  // Regex to split the tail part of the above into [*, dir, basename, ext]\\n  var splitTailRe =\\n      /^([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\\\\\\\\\/]+?|)(\\\\.[^.\\\\/\\\\\\\\]*|))(?:[\\\\\\\\\\\\/]*)$/;\\n\\n  // Function to split a filename into [root, dir, basename, ext]\\n  // windows version\\n  var splitPath = function(filename) {\\n    // Separate device+slash from tail\\n    var result = splitDeviceRe.exec(filename),\\n        device = (result[1] || '') + (result[2] || ''),\\n        tail = result[3] || '';\\n    // Split the tail into dir, basename and extension\\n    var result2 = splitTailRe.exec(tail),\\n        dir = result2[1],\\n        basename = result2[2],\\n        ext = result2[3];\\n    return [device, dir, basename, ext];\\n  };\\n\\n  var normalizeUNCRoot = function(device) {\\n    return '\\\\\\\\\\\\\\\\' + device.replace(/^[\\\\\\\\\\\\/]+/, '').replace(/[\\\\\\\\\\\\/]+/g, '\\\\\\\\');\\n  };\\n\\n  // path.resolve([from ...], to)\\n  // windows version\\n  exports.resolve = function() {\\n    var resolvedDevice = '',\\n        resolvedTail = '',\\n        resolvedAbsolute = false;\\n\\n    for (var i = arguments.length - 1; i >= -1; i--) {\\n      var path;\\n      if (i >= 0) {\\n        path = arguments[i];\\n      } else if (!resolvedDevice) {\\n        path = process.cwd();\\n      } else {\\n        // Windows has the concept of drive-specific current working\\n        // directories. If we've resolved a drive letter but not yet an\\n        // absolute path, get cwd for that drive. We're sure the device is not\\n        // an unc path at this points, because unc paths are always absolute.\\n        path = process.env['=' + resolvedDevice];\\n        // Verify that a drive-local cwd was found and that it actually points\\n        // to our drive. If not, default to the drive's root.\\n        if (!path || path.substr(0, 3).toLowerCase() !==\\n            resolvedDevice.toLowerCase() + '\\\\\\\\') {\\n          path = resolvedDevice + '\\\\\\\\';\\n        }\\n      }\\n\\n      // Skip empty and invalid entries\\n      if (!util.isString(path)) {\\n        throw new TypeError('Arguments to path.resolve must be strings');\\n      } else if (!path) {\\n        continue;\\n      }\\n\\n      var result = splitDeviceRe.exec(path),\\n          device = result[1] || '',\\n          isUnc = device && device.charAt(1) !== ':',\\n          isAbsolute = exports.isAbsolute(path),\\n          tail = result[3];\\n\\n      if (device &&\\n          resolvedDevice &&\\n          device.toLowerCase() !== resolvedDevice.toLowerCase()) {\\n        // This path points to another device so it is not applicable\\n        continue;\\n      }\\n\\n      if (!resolvedDevice) {\\n        resolvedDevice = device;\\n      }\\n      if (!resolvedAbsolute) {\\n        resolvedTail = tail + '\\\\\\\\' + resolvedTail;\\n        resolvedAbsolute = isAbsolute;\\n      }\\n\\n      if (resolvedDevice && resolvedAbsolute) {\\n        break;\\n      }\\n    }\\n\\n    // Convert slashes to backslashes when `resolvedDevice` points to an UNC\\n    // root. Also squash multiple slashes into a single one where appropriate.\\n    if (isUnc) {\\n      resolvedDevice = normalizeUNCRoot(resolvedDevice);\\n    }\\n\\n    // At this point the path should be resolved to a full absolute path,\\n    // but handle relative paths to be safe (might happen when process.cwd()\\n    // fails)\\n\\n    // Normalize the tail path\\n\\n    function f(p) {\\n      return !!p;\\n    }\\n\\n    resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\\\\\\\/]+/).filter(f),\\n                                  !resolvedAbsolute).join('\\\\\\\\');\\n\\n    return (resolvedDevice + (resolvedAbsolute ? '\\\\\\\\' : '') + resolvedTail) ||\\n           '.';\\n  };\\n\\n  // windows version\\n  exports.normalize = function(path) {\\n    var result = splitDeviceRe.exec(path),\\n        device = result[1] || '',\\n        isUnc = device && device.charAt(1) !== ':',\\n        isAbsolute = exports.isAbsolute(path),\\n        tail = result[3],\\n        trailingSlash = /[\\\\\\\\\\\\/]$/.test(tail);\\n\\n    // If device is a drive letter, we'll normalize to lower case.\\n    if (device && device.charAt(1) === ':') {\\n      device = device[0].toLowerCase() + device.substr(1);\\n    }\\n\\n    // Normalize the tail path\\n    tail = normalizeArray(tail.split(/[\\\\\\\\\\\\/]+/).filter(function(p) {\\n      return !!p;\\n    }), !isAbsolute).join('\\\\\\\\');\\n\\n    if (!tail && !isAbsolute) {\\n      tail = '.';\\n    }\\n    if (tail && trailingSlash) {\\n      tail += '\\\\\\\\';\\n    }\\n\\n    // Convert slashes to backslashes when `device` points to an UNC root.\\n    // Also squash multiple slashes into a single one where appropriate.\\n    if (isUnc) {\\n      device = normalizeUNCRoot(device);\\n    }\\n\\n    return device + (isAbsolute ? '\\\\\\\\' : '') + tail;\\n  };\\n\\n  // windows version\\n  exports.isAbsolute = function(path) {\\n    var result = splitDeviceRe.exec(path),\\n        device = result[1] || '',\\n        isUnc = !!device && device.charAt(1) !== ':';\\n    // UNC paths are always absolute\\n    return !!result[2] || isUnc;\\n  };\\n\\n  // windows version\\n  exports.join = function() {\\n    function f(p) {\\n      if (!util.isString(p)) {\\n        throw new TypeError('Arguments to path.join must be strings');\\n      }\\n      return p;\\n    }\\n\\n    var paths = Array.prototype.filter.call(arguments, f);\\n    var joined = paths.join('\\\\\\\\');\\n\\n    // Make sure that the joined path doesn't start with two slashes, because\\n    // normalize() will mistake it for an UNC path then.\\n    //\\n    // This step is skipped when it is very clear that the user actually\\n    // intended to point at an UNC path. This is assumed when the first\\n    // non-empty string arguments starts with exactly two slashes followed by\\n    // at least one more non-slash character.\\n    //\\n    // Note that for normalize() to treat a path as an UNC path it needs to\\n    // have at least 2 components, so we don't filter for that here.\\n    // This means that the user can use join to construct UNC paths from\\n    // a server name and a share name; for example:\\n    //   path.join('//server', 'share') -> '\\\\\\\\\\\\\\\\server\\\\\\\\share\\\\')\\n    if (!/^[\\\\\\\\\\\\/]{2}[^\\\\\\\\\\\\/]/.test(paths[0])) {\\n      joined = joined.replace(/^[\\\\\\\\\\\\/]{2,}/, '\\\\\\\\');\\n    }\\n\\n    return exports.normalize(joined);\\n  };\\n\\n  // path.relative(from, to)\\n  // it will solve the relative path from 'from' to 'to', for instance:\\n  // from = 'C:\\\\\\\\orandea\\\\\\\\test\\\\\\\\aaa'\\n  // to = 'C:\\\\\\\\orandea\\\\\\\\impl\\\\\\\\bbb'\\n  // The output of the function should be: '..\\\\\\\\..\\\\\\\\impl\\\\\\\\bbb'\\n  // windows version\\n  exports.relative = function(from, to) {\\n    from = exports.resolve(from);\\n    to = exports.resolve(to);\\n\\n    // windows is not case sensitive\\n    var lowerFrom = from.toLowerCase();\\n    var lowerTo = to.toLowerCase();\\n\\n    function trim(arr) {\\n      var start = 0;\\n      for (; start < arr.length; start++) {\\n        if (arr[start] !== '') break;\\n      }\\n\\n      var end = arr.length - 1;\\n      for (; end >= 0; end--) {\\n        if (arr[end] !== '') break;\\n      }\\n\\n      if (start > end) return [];\\n      return arr.slice(start, end + 1);\\n    }\\n\\n    var toParts = trim(to.split('\\\\\\\\'));\\n\\n    var lowerFromParts = trim(lowerFrom.split('\\\\\\\\'));\\n    var lowerToParts = trim(lowerTo.split('\\\\\\\\'));\\n\\n    var length = Math.min(lowerFromParts.length, lowerToParts.length);\\n    var samePartsLength = length;\\n    for (var i = 0; i < length; i++) {\\n      if (lowerFromParts[i] !== lowerToParts[i]) {\\n        samePartsLength = i;\\n        break;\\n      }\\n    }\\n\\n    if (samePartsLength == 0) {\\n      return to;\\n    }\\n\\n    var outputParts = [];\\n    for (var i = samePartsLength; i < lowerFromParts.length; i++) {\\n      outputParts.push('..');\\n    }\\n\\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\\n\\n    return outputParts.join('\\\\\\\\');\\n  };\\n\\n  exports.sep = '\\\\\\\\';\\n  exports.delimiter = ';';\\n\\n} else /* posix */ {\\n\\n  // Split a filename into [root, dir, basename, ext], unix version\\n  // 'root' is just a slash, or nothing.\\n  var splitPathRe =\\n      /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;\\n  var splitPath = function(filename) {\\n    return splitPathRe.exec(filename).slice(1);\\n  };\\n\\n  // path.resolve([from ...], to)\\n  // posix version\\n  exports.resolve = function() {\\n    var resolvedPath = '',\\n        resolvedAbsolute = false;\\n\\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\\n      var path = (i >= 0) ? arguments[i] : process.cwd();\\n\\n      // Skip empty and invalid entries\\n      if (!util.isString(path)) {\\n        throw new TypeError('Arguments to path.resolve must be strings');\\n      } else if (!path) {\\n        continue;\\n      }\\n\\n      resolvedPath = path + '/' + resolvedPath;\\n      resolvedAbsolute = path.charAt(0) === '/';\\n    }\\n\\n    // At this point the path should be resolved to a full absolute path, but\\n    // handle relative paths to be safe (might happen when process.cwd() fails)\\n\\n    // Normalize the path\\n    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {\\n      return !!p;\\n    }), !resolvedAbsolute).join('/');\\n\\n    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\\n  };\\n\\n  // path.normalize(path)\\n  // posix version\\n  exports.normalize = function(path) {\\n    var isAbsolute = exports.isAbsolute(path),\\n        trailingSlash = path[path.length - 1] === '/',\\n        segments = path.split('/'),\\n        nonEmptySegments = [];\\n\\n    // Normalize the path\\n    for (var i = 0; i < segments.length; i++) {\\n      if (segments[i]) {\\n        nonEmptySegments.push(segments[i]);\\n      }\\n    }\\n    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');\\n\\n    if (!path && !isAbsolute) {\\n      path = '.';\\n    }\\n    if (path && trailingSlash) {\\n      path += '/';\\n    }\\n\\n    return (isAbsolute ? '/' : '') + path;\\n  };\\n\\n  // posix version\\n  exports.isAbsolute = function(path) {\\n    return path.charAt(0) === '/';\\n  };\\n\\n  // posix version\\n  exports.join = function() {\\n    var path = '';\\n    for (var i = 0; i < arguments.length; i++) {\\n      var segment = arguments[i];\\n      if (!util.isString(segment)) {\\n        throw new TypeError('Arguments to path.join must be strings');\\n      }\\n      if (segment) {\\n        if (!path) {\\n          path += segment;\\n        } else {\\n          path += '/' + segment;\\n        }\\n      }\\n    }\\n    return exports.normalize(path);\\n  };\\n\\n\\n  // path.relative(from, to)\\n  // posix version\\n  exports.relative = function(from, to) {\\n    from = exports.resolve(from).substr(1);\\n    to = exports.resolve(to).substr(1);\\n\\n    function trim(arr) {\\n      var start = 0;\\n      for (; start < arr.length; start++) {\\n        if (arr[start] !== '') break;\\n      }\\n\\n      var end = arr.length - 1;\\n      for (; end >= 0; end--) {\\n        if (arr[end] !== '') break;\\n      }\\n\\n      if (start > end) return [];\\n      return arr.slice(start, end + 1);\\n    }\\n\\n    var fromParts = trim(from.split('/'));\\n    var toParts = trim(to.split('/'));\\n\\n    var length = Math.min(fromParts.length, toParts.length);\\n    var samePartsLength = length;\\n    for (var i = 0; i < length; i++) {\\n      if (fromParts[i] !== toParts[i]) {\\n        samePartsLength = i;\\n        break;\\n      }\\n    }\\n\\n    var outputParts = [];\\n    for (var i = samePartsLength; i < fromParts.length; i++) {\\n      outputParts.push('..');\\n    }\\n\\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\\n\\n    return outputParts.join('/');\\n  };\\n\\n  exports.sep = '/';\\n  exports.delimiter = ':';\\n}\\n\\nexports.dirname = function(path) {\\n  var result = splitPath(path),\\n      root = result[0],\\n      dir = result[1];\\n\\n  if (!root && !dir) {\\n    // No dirname whatsoever\\n    return '.';\\n  }\\n\\n  if (dir) {\\n    // It has a dirname, strip trailing slash\\n    dir = dir.substr(0, dir.length - 1);\\n  }\\n\\n  return root + dir;\\n};\\n\\n\\nexports.basename = function(path, ext) {\\n  var f = splitPath(path)[2];\\n  // TODO: make this comparison case-insensitive on windows?\\n  if (ext && f.substr(-1 * ext.length) === ext) {\\n    f = f.substr(0, f.length - ext.length);\\n  }\\n  return f;\\n};\\n\\n\\nexports.extname = function(path) {\\n  return splitPath(path)[3];\\n};\\n\\n\\nexports.exists = util.deprecate(function(path, callback) {\\n  require('fs').exists(path, callback);\\n}, 'path.exists is now called `fs.exists`.');\\n\\n\\nexports.existsSync = util.deprecate(function(path) {\\n  return require('fs').existsSync(path);\\n}, 'path.existsSync is now called `fs.existsSync`.');\\n\\n\\nif (isWindows) {\\n  exports._makeLong = function(path) {\\n    // Note: this will *probably* throw somewhere.\\n    if (!util.isString(path))\\n      return path;\\n\\n    if (!path) {\\n      return '';\\n    }\\n\\n    var resolvedPath = exports.resolve(path);\\n\\n    if (/^[a-zA-Z]\\\\:\\\\\\\\/.test(resolvedPath)) {\\n      // path is local filesystem path, which needs to be converted\\n      // to long UNC path.\\n      return '\\\\\\\\\\\\\\\\?\\\\\\\\' + resolvedPath;\\n    } else if (/^\\\\\\\\\\\\\\\\[^?.]/.test(resolvedPath)) {\\n      // path is network UNC path, which needs to be converted\\n      // to long UNC path.\\n      return '\\\\\\\\\\\\\\\\?\\\\\\\\UNC\\\\\\\\' + resolvedPath.substring(2);\\n    }\\n\\n    return path;\\n  };\\n} else {\\n  exports._makeLong = function(path) {\\n    return path;\\n  };\\n}\\n\",\"fs\":\"// Maintainers, keep in mind that ES1-style octal literals (`0666`) are not\\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\\n\\n//changes const => var\\n//changes 0o666 => 438 [octal represntation]\\n\\n'use strict';\\n\\nvar SlowBuffer = require('buffer').SlowBuffer;\\nvar util = require('util');\\nvar pathModule = require('path');\\n\\nvar binding = process.binding('fs_wrap');\\nvar constants = require('constants');\\nvar fs = exports;\\nvar Buffer = require('buffer').Buffer;\\nvar Stream = require('stream').Stream;\\nvar EventEmitter = require('events');\\nvar FSReqWrap = binding.FSReqWrap;\\nvar FSEvent = process.binding('fs_event_wrap').FSEvent;\\n\\nvar Readable = Stream.Readable;\\nvar Writable = Stream.Writable;\\n\\nvar kMinPoolSpace = 128;\\nvar kMaxLength = require('buffer').kMaxLength;\\n\\nvar O_APPEND = constants.O_APPEND || 0;\\nvar O_CREAT = constants.O_CREAT || 0;\\nvar O_EXCL = constants.O_EXCL || 0;\\nvar O_RDONLY = constants.O_RDONLY || 0;\\nvar O_RDWR = constants.O_RDWR || 0;\\nvar O_SYNC = constants.O_SYNC || 0;\\nvar O_TRUNC = constants.O_TRUNC || 0;\\nvar O_WRONLY = constants.O_WRONLY || 0;\\n\\nvar isWindows = process.platform === 'win32';\\n\\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\\nvar errnoException = util._errnoException;\\n\\nfunction throwOptionsError(options) {\\n  throw new TypeError('Expected options to be either an object or a string, ' +\\n    'but got ' + typeof options + ' instead');\\n}\\n\\nfunction rethrow() {\\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\\n  // is fairly slow to generate.\\n  if (DEBUG) {\\n    var backtrace = new Error();\\n    return function(err) {\\n      if (err) {\\n        backtrace.stack = err.name + ': ' + err.message +\\n                          backtrace.stack.substr(backtrace.name.length);\\n        throw backtrace;\\n      }\\n    };\\n  }\\n\\n  return function(err) {\\n    if (err) {\\n      throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\\n    }\\n  };\\n}\\n\\nfunction maybeCallback(cb) {\\n  return typeof cb === 'function' ? cb : rethrow();\\n}\\n\\n// Ensure that callbacks run in the global context. Only use this function\\n// for callbacks that are passed to the binding layer, callbacks that are\\n// invoked from JS already run in the proper scope.\\nfunction makeCallback(cb) {\\n  if (cb === undefined) {\\n    return rethrow();\\n  }\\n\\n  if (typeof cb !== 'function') {\\n    throw new TypeError('callback must be a function');\\n  }\\n\\n  return function() {\\n    return cb.apply(null, arguments);\\n  };\\n}\\n\\nfunction assertEncoding(encoding) {\\n  if (encoding && !Buffer.isEncoding(encoding)) {\\n    throw new Error('Unknown encoding: ' + encoding);\\n  }\\n}\\n\\nfunction nullCheck(path, callback) {\\n  if (('' + path).indexOf('\\\\u0000') !== -1) {\\n    var er = new Error('Path must be a string without null bytes.');\\n    er.code = 'ENOENT';\\n    if (typeof callback !== 'function')\\n      throw er;\\n    process.nextTick(callback, er);\\n    return false;\\n  }\\n  return true;\\n}\\n\\nfunction isFd(path) {\\n  return (path >>> 0) === path;\\n}\\n\\n// Static method to set the stats properties on a Stats object.\\nfs.Stats = function(\\n    dev,\\n    mode,\\n    nlink,\\n    uid,\\n    gid,\\n    rdev,\\n    blksize,\\n    ino,\\n    size,\\n    blocks,\\n    atim_msec,\\n    mtim_msec,\\n    ctim_msec,\\n    birthtim_msec) {\\n  this.dev = dev;\\n  this.mode = mode;\\n  this.nlink = nlink;\\n  this.uid = uid;\\n  this.gid = gid;\\n  this.rdev = rdev;\\n  this.blksize = blksize;\\n  this.ino = ino;\\n  this.size = size;\\n  this.blocks = blocks;\\n  this.atime = new Date(atim_msec);\\n  this.mtime = new Date(mtim_msec);\\n  this.ctime = new Date(ctim_msec);\\n  this.birthtime = new Date(birthtim_msec);\\n};\\n\\n// Create a C++ binding to the function which creates a Stats object.\\nbinding.FSInitialize(fs.Stats);\\n\\nfs.Stats.prototype._checkModeProperty = function(property) {\\n  return ((this.mode & constants.S_IFMT) === property);\\n};\\n\\nfs.Stats.prototype.isDirectory = function() {\\n  return this._checkModeProperty(constants.S_IFDIR);\\n};\\n\\nfs.Stats.prototype.isFile = function() {\\n  return this._checkModeProperty(constants.S_IFREG);\\n};\\n\\nfs.Stats.prototype.isBlockDevice = function() {\\n  return this._checkModeProperty(constants.S_IFBLK);\\n};\\n\\nfs.Stats.prototype.isCharacterDevice = function() {\\n  return this._checkModeProperty(constants.S_IFCHR);\\n};\\n\\nfs.Stats.prototype.isSymbolicLink = function() {\\n  return this._checkModeProperty(constants.S_IFLNK);\\n};\\n\\nfs.Stats.prototype.isFIFO = function() {\\n  return this._checkModeProperty(constants.S_IFIFO);\\n};\\n\\nfs.Stats.prototype.isSocket = function() {\\n  return this._checkModeProperty(constants.S_IFSOCK);\\n};\\n\\n// Don't allow mode to accidentally be overwritten.\\n['F_OK', 'R_OK', 'W_OK', 'X_OK'].forEach(function(key) {\\n  Object.defineProperty(fs, key, {\\n    enumerable: true, value: constants[key] || 0, writable: false\\n  });\\n});\\n\\nfs.access = function(path, mode, callback) {\\n  if (typeof mode === 'function') {\\n    callback = mode;\\n    mode = fs.F_OK;\\n  } else if (typeof callback !== 'function') {\\n    throw new TypeError('callback must be a function');\\n  }\\n\\n  if (!nullCheck(path, callback))\\n    return;\\n\\n  mode = mode | 0;\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.access(pathModule._makeLong(path), mode, req);\\n};\\n\\nfs.accessSync = function(path, mode) {\\n  nullCheck(path);\\n\\n  if (mode === undefined)\\n    mode = fs.F_OK;\\n  else\\n    mode = mode | 0;\\n\\n  binding.access(pathModule._makeLong(path), mode);\\n};\\n\\nfs.exists = function(path, callback) {\\n  if (!nullCheck(path, cb)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = cb;\\n  binding.stat(pathModule._makeLong(path), req);\\n  function cb(err, stats) {\\n    if (callback) callback(err ? false : true);\\n  }\\n};\\n\\nfs.existsSync = function(path) {\\n  try {\\n    nullCheck(path);\\n    binding.stat(pathModule._makeLong(path));\\n    return true;\\n  } catch (e) {\\n    return false;\\n  }\\n};\\n\\nfs.readFile = function(path, options, callback_) {\\n  var callback = maybeCallback(arguments[arguments.length - 1]);\\n\\n  if (!options || typeof options === 'function') {\\n    options = { encoding: null, flag: 'r' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, flag: 'r' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  var encoding = options.encoding;\\n  assertEncoding(encoding);\\n\\n  var flag = options.flag || 'r';\\n\\n  if (!nullCheck(path, callback))\\n    return;\\n\\n  var context = new ReadFileContext(callback, encoding);\\n  context.isUserFd = isFd(path); // file descriptor ownership\\n  var req = new FSReqWrap();\\n  req.context = context;\\n  req.oncomplete = readFileAfterOpen;\\n\\n  if (context.isUserFd) {\\n    process.nextTick(function() {\\n      req.oncomplete(null, path);\\n    });\\n    return;\\n  }\\n\\n  binding.open(pathModule._makeLong(path),\\n               stringToFlags(flag),\\n               438,\\n               req);\\n};\\n\\nvar kReadFileBufferLength = 8 * 1024;\\n\\nfunction ReadFileContext(callback, encoding) {\\n  this.fd = undefined;\\n  this.isUserFd = undefined;\\n  this.size = undefined;\\n  this.callback = callback;\\n  this.buffers = null;\\n  this.buffer = null;\\n  this.pos = 0;\\n  this.encoding = encoding;\\n  this.err = null;\\n}\\n\\nReadFileContext.prototype.read = function() {\\n  var buffer;\\n  var offset;\\n  var length;\\n\\n  if (this.size === 0) {\\n    buffer = this.buffer = new SlowBuffer(kReadFileBufferLength);\\n    offset = 0;\\n    length = kReadFileBufferLength;\\n  } else {\\n    buffer = this.buffer;\\n    offset = this.pos;\\n    length = this.size - this.pos;\\n  }\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = readFileAfterRead;\\n  req.context = this;\\n\\n  binding.read(this.fd, buffer, offset, length, -1, req);\\n};\\n\\nReadFileContext.prototype.close = function(err) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = readFileAfterClose;\\n  req.context = this;\\n  this.err = err;\\n\\n  if (this.isUserFd) {\\n    process.nextTick(function() {\\n      req.oncomplete(null);\\n    });\\n    return;\\n  }\\n\\n  binding.close(this.fd, req);\\n};\\n\\nfunction readFileAfterOpen(err, fd) {\\n  var context = this.context;\\n\\n  if (err) {\\n    context.callback(err);\\n    return;\\n  }\\n\\n  context.fd = fd;\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = readFileAfterStat;\\n  req.context = context;\\n  binding.fstat(fd, req);\\n}\\n\\nfunction readFileAfterStat(err, st) {\\n  var context = this.context;\\n\\n  if (err)\\n    return context.close(err);\\n\\n  var size = context.size = st.isFile() ? st.size : 0;\\n\\n  if (size === 0) {\\n    context.buffers = [];\\n    context.read();\\n    return;\\n  }\\n\\n  if (size > kMaxLength) {\\n    err = new RangeError('File size is greater than possible Buffer: ');\\n    // err = new RangeError('File size is greater than possible Buffer: ' +\\n    //                      `0x${kMaxLength.toString(16)} bytes`);\\n    return context.close(err);\\n  }\\n\\n  context.buffer = new SlowBuffer(size);\\n  context.read();\\n}\\n\\nfunction readFileAfterRead(err, bytesRead) {\\n  var context = this.context;\\n\\n  if (err)\\n    return context.close(err);\\n\\n  if (bytesRead === 0)\\n    return context.close();\\n\\n  context.pos += bytesRead;\\n\\n  if (context.size !== 0) {\\n    if (context.pos === context.size)\\n      context.close();\\n    else\\n      context.read();\\n  } else {\\n    // unknown size, just read until we don't get bytes.\\n    context.buffers.push(context.buffer.slice(0, bytesRead));\\n    context.read();\\n  }\\n}\\n\\nfunction readFileAfterClose(err) {\\n  var context = this.context;\\n  var buffer = null;\\n  var callback = context.callback;\\n\\n  if (context.err)\\n    return callback(context.err);\\n\\n  if (context.size === 0)\\n    buffer = Buffer.concat(context.buffers, context.pos);\\n  else if (context.pos < context.size)\\n    buffer = context.buffer.slice(0, context.pos);\\n  else\\n    buffer = context.buffer;\\n\\n  if (err) return callback(err, buffer);\\n\\n  if (context.encoding) {\\n    return tryToString(buffer, context.encoding, callback);\\n  }\\n\\n  callback(null, buffer);\\n}\\n\\nfunction tryToString(buf, encoding, callback) {\\n  var e = null;\\n  try {\\n    buf = buf.toString(encoding);\\n  } catch (err) {\\n    e = err;\\n  }\\n  callback(e, buf);\\n}\\n\\nfs.readFileSync = function(path, options) {\\n  if (!options) {\\n    options = { encoding: null, flag: 'r' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, flag: 'r' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  var encoding = options.encoding;\\n  assertEncoding(encoding);\\n\\n  var flag = options.flag || 'r';\\n  var isUserFd = isFd(path); // file descriptor ownership\\n  var fd = isUserFd ? path : fs.openSync(path, flag, 438);\\n\\n  var st;\\n  var size;\\n  var threw = true;\\n  try {\\n    st = fs.fstatSync(fd);\\n    size = st.isFile() ? st.size : 0;\\n    threw = false;\\n  } finally {\\n    if (threw && !isUserFd) fs.closeSync(fd);\\n  }\\n\\n  var pos = 0;\\n  var buffer; // single buffer with file data\\n  var buffers; // list for when size is unknown\\n\\n  if (size === 0) {\\n    buffers = [];\\n  } else {\\n    threw = true;\\n    try {\\n      buffer = Buffer(size);\\n      threw = false;\\n    } finally {\\n      if (threw && !isUserFd) fs.closeSync(fd);\\n    }\\n  }\\n\\n  var done = false;\\n  var bytesRead;\\n\\n  while (!done) {\\n    threw = true;\\n    try {\\n      if (size !== 0) {\\n        bytesRead = fs.readSync(fd, buffer, pos, size - pos);\\n      } else {\\n        // the kernel lies about many files.\\n        // Go ahead and try to read some bytes.\\n        buffer = Buffer(8192);\\n        bytesRead = fs.readSync(fd, buffer, 0, 8192);\\n        if (bytesRead) {\\n          buffers.push(buffer.slice(0, bytesRead));\\n        }\\n      }\\n      threw = false;\\n    } finally {\\n      if (threw && !isUserFd) fs.closeSync(fd);\\n    }\\n\\n    pos += bytesRead;\\n    done = (bytesRead === 0) || (size !== 0 && pos >= size);\\n  }\\n\\n  if (!isUserFd)\\n    fs.closeSync(fd);\\n\\n  if (size === 0) {\\n    // data was collected into the buffers list.\\n    buffer = Buffer.concat(buffers, pos);\\n  } else if (pos < size) {\\n    buffer = buffer.slice(0, pos);\\n  }\\n\\n  if (encoding) buffer = buffer.toString(encoding);\\n  return buffer;\\n};\\n\\n\\n// Used by binding.open and friends\\nfunction stringToFlags(flag) {\\n  // Only mess with strings\\n  if (typeof flag !== 'string') {\\n    return flag;\\n  }\\n\\n  switch (flag) {\\n    case 'r' : return O_RDONLY;\\n    case 'rs' : // fall through\\n    case 'sr' : return O_RDONLY | O_SYNC;\\n    case 'r+' : return O_RDWR;\\n    case 'rs+' : // fall through\\n    case 'sr+' : return O_RDWR | O_SYNC;\\n\\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\\n    case 'wx' : // fall through\\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\\n\\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\\n    case 'wx+': // fall through\\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\\n\\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\\n    case 'ax' : // fall through\\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\\n\\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\\n    case 'ax+': // fall through\\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\\n  }\\n\\n  throw new Error('Unknown file open flag: ' + flag);\\n}\\n\\n// exported but hidden, only used by test/simple/test-fs-open-flags.js\\nObject.defineProperty(exports, '_stringToFlags', {\\n  enumerable: false,\\n  value: stringToFlags\\n});\\n\\n\\n// Yes, the follow could be easily DRYed up but I provide the explicit\\n// list to make the arguments clear.\\n\\nfs.close = function(fd, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.close(fd, req);\\n};\\n\\nfs.closeSync = function(fd) {\\n  return binding.close(fd);\\n};\\n\\nfunction modeNum(m, def) {\\n  if (typeof m === 'number')\\n    return m;\\n  if (typeof m === 'string')\\n    return parseInt(m, 8);\\n  if (def)\\n    return modeNum(def);\\n  return undefined;\\n}\\n\\nfs.open = function(path, flags, mode, callback_) {\\n  var callback = makeCallback(arguments[arguments.length - 1]);\\n  mode = modeNum(mode, 438);\\n\\n  if (!nullCheck(path, callback)) return;\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n\\n  binding.open(pathModule._makeLong(path),\\n               stringToFlags(flags),\\n               mode,\\n               req);\\n};\\n\\nfs.openSync = function(path, flags, mode) {\\n  mode = modeNum(mode, 438);\\n  nullCheck(path);\\n  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);\\n};\\n\\nfs.read = function(fd, buffer, offset, length, position, callback) {\\n  if (!(Buffer.isBuffer(buffer))) {\\n    // legacy string interface (fd, length, position, encoding, callback)\\n    var cb = arguments[4],\\n        encoding = arguments[3];\\n\\n    assertEncoding(encoding);\\n\\n    position = arguments[2];\\n    length = arguments[1];\\n    buffer = Buffer(length);\\n    offset = 0;\\n\\n    callback = function(err, bytesRead) {\\n      if (!cb) return;\\n      if (err) return cb(err);\\n\\n      if (bytesRead > 0) {\\n        tryToStringWithEnd(buffer, encoding, bytesRead, cb);\\n      } else {\\n        (cb)(err, '', bytesRead);\\n      }\\n    };\\n  }\\n\\n  function wrapper(err, bytesRead) {\\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\\n    callback && callback(err, bytesRead || 0, buffer);\\n  }\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = wrapper;\\n\\n  binding.read(fd, buffer, offset, length, position, req);\\n};\\n\\nfunction tryToStringWithEnd(buf, encoding, end, callback) {\\n  var e;\\n  try {\\n    buf = buf.toString(encoding, 0, end);\\n  } catch (err) {\\n    e = err;\\n  }\\n  callback(e, buf, end);\\n}\\n\\nfs.readSync = function(fd, buffer, offset, length, position) {\\n  var legacy = false;\\n  var encoding;\\n\\n  if (!(util.isBuffer(buffer))) {\\n    // legacy string interface (fd, length, position, encoding, callback)\\n    legacy = true;\\n    encoding = arguments[3];\\n\\n    assertEncoding(encoding);\\n\\n    position = arguments[2];\\n    length = arguments[1];\\n    buffer = Buffer(length);\\n\\n    offset = 0;\\n  }\\n\\n  var r = binding.read(fd, buffer, offset, length, position);\\n  if (!legacy) {\\n    return r;\\n  }\\n\\n  var str = (r > 0) ? buffer.toString(encoding, 0, r) : '';\\n  return [str, r];\\n};\\n\\n// usage:\\n//  fs.write(fd, buffer, offset, length[, position], callback);\\n// OR\\n//  fs.write(fd, string[, position[, encoding]], callback);\\nfs.write = function(fd, buffer, offset, length, position, callback) {\\n  function wrapper(err, written) {\\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\\n    callback(err, written || 0, buffer);\\n  }\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = wrapper;\\n\\n  if (util.isBuffer(buffer)) {\\n    // if no position is passed then assume null\\n    if (typeof position === 'function') {\\n      callback = position;\\n      position = null;\\n    }\\n    callback = maybeCallback(callback);\\n    return binding.writeBuffer(fd, buffer, offset, length, position, req);\\n  }\\n\\n  if (typeof buffer !== 'string')\\n    buffer += '';\\n  if (typeof position !== 'function') {\\n    if (typeof offset === 'function') {\\n      position = offset;\\n      offset = null;\\n    } else {\\n      position = length;\\n    }\\n    length = 'utf8';\\n  }\\n  callback = maybeCallback(position);\\n  return binding.writeString(fd, buffer, offset, length, req);\\n};\\n\\n// usage:\\n//  fs.writeSync(fd, buffer, offset, length[, position]);\\n// OR\\n//  fs.writeSync(fd, string[, position[, encoding]]);\\nfs.writeSync = function(fd, buffer, offset, length, position) {\\n  if (util.isBuffer(buffer)) {\\n    if (position === undefined)\\n      position = null;\\n    return binding.writeBuffer(fd, buffer, offset, length, position);\\n  }\\n  if (typeof buffer !== 'string')\\n    buffer += '';\\n  if (offset === undefined)\\n    offset = null;\\n  return binding.writeString(fd, buffer, offset, length, position);\\n};\\n\\nfs.rename = function(oldPath, newPath, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(oldPath, callback)) return;\\n  if (!nullCheck(newPath, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.rename(pathModule._makeLong(oldPath),\\n                 pathModule._makeLong(newPath),\\n                 req);\\n};\\n\\nfs.renameSync = function(oldPath, newPath) {\\n  nullCheck(oldPath);\\n  nullCheck(newPath);\\n  return binding.rename(pathModule._makeLong(oldPath),\\n                        pathModule._makeLong(newPath));\\n};\\n\\nfs.truncate = function(path, len, callback) {\\n  if (typeof path === 'number') {\\n    return fs.ftruncate(path, len, callback);\\n  }\\n  if (typeof len === 'function') {\\n    callback = len;\\n    len = 0;\\n  } else if (len === undefined) {\\n    len = 0;\\n  }\\n\\n  callback = maybeCallback(callback);\\n  fs.open(path, 'r+', function(er, fd) {\\n    if (er) return callback(er);\\n    var req = new FSReqWrap();\\n    req.oncomplete = function ftruncateCb(er) {\\n      fs.close(fd, function(er2) {\\n        callback(er || er2);\\n      });\\n    };\\n    binding.ftruncate(fd, len, req);\\n  });\\n};\\n\\nfs.truncateSync = function(path, len) {\\n  if (typeof path === 'number') {\\n    // legacy\\n    return fs.ftruncateSync(path, len);\\n  }\\n  if (len === undefined) {\\n    len = 0;\\n  }\\n  // allow error to be thrown, but still close fd.\\n  var fd = fs.openSync(path, 'r+');\\n  var ret;\\n\\n  try {\\n    ret = fs.ftruncateSync(fd, len);\\n  } finally {\\n    fs.closeSync(fd);\\n  }\\n  return ret;\\n};\\n\\nfs.ftruncate = function(fd, len, callback) {\\n  if (typeof len === 'function') {\\n    callback = len;\\n    len = 0;\\n  } else if (len === undefined) {\\n    len = 0;\\n  }\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.ftruncate(fd, len, req);\\n};\\n\\nfs.ftruncateSync = function(fd, len) {\\n  if (len === undefined) {\\n    len = 0;\\n  }\\n  return binding.ftruncate(fd, len);\\n};\\n\\nfs.rmdir = function(path, callback) {\\n  callback = maybeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.rmdir(pathModule._makeLong(path), req);\\n};\\n\\nfs.rmdirSync = function(path) {\\n  nullCheck(path);\\n  return binding.rmdir(pathModule._makeLong(path));\\n};\\n\\nfs.fdatasync = function(fd, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fdatasync(fd, req);\\n};\\n\\nfs.fdatasyncSync = function(fd) {\\n  return binding.fdatasync(fd);\\n};\\n\\nfs.fsync = function(fd, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fsync(fd, req);\\n};\\n\\nfs.fsyncSync = function(fd) {\\n  return binding.fsync(fd);\\n};\\n\\nfs.mkdir = function(path, mode, callback) {\\n  if (typeof mode === 'function') callback = mode;\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.mkdir(pathModule._makeLong(path),\\n                modeNum(mode, 511),\\n                req);\\n};\\n\\nfs.mkdirSync = function(path, mode) {\\n  nullCheck(path);\\n  return binding.mkdir(pathModule._makeLong(path),\\n                       modeNum(mode, 511));\\n};\\n\\nfs.readdir = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.readdir(pathModule._makeLong(path), req);\\n};\\n\\nfs.readdirSync = function(path) {\\n  nullCheck(path);\\n  return binding.readdir(pathModule._makeLong(path));\\n};\\n\\nfs.fstat = function(fd, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fstat(fd, req);\\n};\\n\\nfs.lstat = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.lstat(pathModule._makeLong(path), req);\\n};\\n\\nfs.stat = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.stat(pathModule._makeLong(path), req);\\n};\\n\\nfs.fstatSync = function(fd) {\\n  return binding.fstat(fd);\\n};\\n\\nfs.lstatSync = function(path) {\\n  nullCheck(path);\\n  return binding.lstat(pathModule._makeLong(path));\\n};\\n\\nfs.statSync = function(path) {\\n  nullCheck(path);\\n  return binding.stat(pathModule._makeLong(path));\\n};\\n\\nfs.readlink = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.readlink(pathModule._makeLong(path), req);\\n};\\n\\nfs.readlinkSync = function(path) {\\n  nullCheck(path);\\n  return binding.readlink(pathModule._makeLong(path));\\n};\\n\\nfunction preprocessSymlinkDestination(path, type, linkPath) {\\n  if (!isWindows) {\\n    // No preprocessing is needed on Unix.\\n    return path;\\n  } else if (type === 'junction') {\\n    // Junctions paths need to be absolute and \\\\\\\\?\\\\-prefixed.\\n    // A relative target is relative to the link's parent directory.\\n    path = pathModule.resolve(linkPath, '..', path);\\n    return pathModule._makeLong(path);\\n  } else {\\n    // Windows symlinks don't tolerate forward slashes.\\n    return ('' + path).replace(/\\\\//g, '\\\\\\\\');\\n  }\\n}\\n\\nfs.symlink = function(target, path, type_, callback_) {\\n  var type = (typeof type_ === 'string' ? type_ : null);\\n  var callback = makeCallback(arguments[arguments.length - 1]);\\n\\n  if (!nullCheck(target, callback)) return;\\n  if (!nullCheck(path, callback)) return;\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n\\n  binding.symlink(preprocessSymlinkDestination(target, type, path),\\n                  pathModule._makeLong(path),\\n                  type,\\n                  req);\\n};\\n\\nfs.symlinkSync = function(target, path, type) {\\n  type = (typeof type === 'string' ? type : null);\\n\\n  nullCheck(target);\\n  nullCheck(path);\\n\\n  return binding.symlink(preprocessSymlinkDestination(target, type, path),\\n                         pathModule._makeLong(path),\\n                         type);\\n};\\n\\nfs.link = function(srcpath, dstpath, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(srcpath, callback)) return;\\n  if (!nullCheck(dstpath, callback)) return;\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n\\n  binding.link(pathModule._makeLong(srcpath),\\n               pathModule._makeLong(dstpath),\\n               req);\\n};\\n\\nfs.linkSync = function(srcpath, dstpath) {\\n  nullCheck(srcpath);\\n  nullCheck(dstpath);\\n  return binding.link(pathModule._makeLong(srcpath),\\n                      pathModule._makeLong(dstpath));\\n};\\n\\nfs.unlink = function(path, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.unlink(pathModule._makeLong(path), req);\\n};\\n\\nfs.unlinkSync = function(path) {\\n  nullCheck(path);\\n  return binding.unlink(pathModule._makeLong(path));\\n};\\n\\nfs.fchmod = function(fd, mode, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fchmod(fd, modeNum(mode), req);\\n};\\n\\nfs.fchmodSync = function(fd, mode) {\\n  return binding.fchmod(fd, modeNum(mode));\\n};\\n\\nif (constants.hasOwnProperty('O_SYMLINK')) {\\n  fs.lchmod = function(path, mode, callback) {\\n    callback = maybeCallback(callback);\\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\\n      if (err) {\\n        callback(err);\\n        return;\\n      }\\n      // prefer to return the chmod error, if one occurs,\\n      // but still try to close, and report closing errors if they occur.\\n      fs.fchmod(fd, mode, function(err) {\\n        fs.close(fd, function(err2) {\\n          callback(err || err2);\\n        });\\n      });\\n    });\\n  };\\n\\n  fs.lchmodSync = function(path, mode) {\\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\\n\\n    // prefer to return the chmod error, if one occurs,\\n    // but still try to close, and report closing errors if they occur.\\n    var err, err2, ret;\\n    try {\\n      ret = fs.fchmodSync(fd, mode);\\n    } catch (er) {\\n      err = er;\\n    }\\n    try {\\n      fs.closeSync(fd);\\n    } catch (er) {\\n      err2 = er;\\n    }\\n    if (err || err2) throw (err || err2);\\n    return ret;\\n  };\\n}\\n\\n\\nfs.chmod = function(path, mode, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.chmod(pathModule._makeLong(path),\\n                modeNum(mode),\\n                req);\\n};\\n\\nfs.chmodSync = function(path, mode) {\\n  nullCheck(path);\\n  return binding.chmod(pathModule._makeLong(path), modeNum(mode));\\n};\\n\\nif (constants.hasOwnProperty('O_SYMLINK')) {\\n  fs.lchown = function(path, uid, gid, callback) {\\n    callback = maybeCallback(callback);\\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\\n      if (err) {\\n        callback(err);\\n        return;\\n      }\\n      fs.fchown(fd, uid, gid, callback);\\n    });\\n  };\\n\\n  fs.lchownSync = function(path, uid, gid) {\\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\\n    return fs.fchownSync(fd, uid, gid);\\n  };\\n}\\n\\nfs.fchown = function(fd, uid, gid, callback) {\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.fchown(fd, uid, gid, req);\\n};\\n\\nfs.fchownSync = function(fd, uid, gid) {\\n  return binding.fchown(fd, uid, gid);\\n};\\n\\nfs.chown = function(path, uid, gid, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.chown(pathModule._makeLong(path), uid, gid, req);\\n};\\n\\nfs.chownSync = function(path, uid, gid) {\\n  nullCheck(path);\\n  return binding.chown(pathModule._makeLong(path), uid, gid);\\n};\\n\\n// converts Date or number to a fractional UNIX timestamp\\nfunction toUnixTimestamp(time) {\\n  if (typeof time === 'string' && +time == time) {\\n    return +time;\\n  }\\n  if (typeof time === 'number') {\\n    if (!Number.isFinite(time) || time < 0) {\\n      return Date.now() / 1000;\\n    }\\n    return time;\\n  }\\n  if (util.isDate(time)) {\\n    // convert to 123.456 UNIX timestamp\\n    return time.getTime() / 1000;\\n  }\\n  throw new Error('Cannot parse time: ' + time);\\n}\\n\\n// exported for unit tests, not for public consumption\\nfs._toUnixTimestamp = toUnixTimestamp;\\n\\nfs.utimes = function(path, atime, mtime, callback) {\\n  callback = makeCallback(callback);\\n  if (!nullCheck(path, callback)) return;\\n  var req = new FSReqWrap();\\n  req.oncomplete = callback;\\n  binding.utimes(pathModule._makeLong(path),\\n                 toUnixTimestamp(atime),\\n                 toUnixTimestamp(mtime),\\n                 req);\\n};\\n\\nfs.utimesSync = function(path, atime, mtime) {\\n  nullCheck(path);\\n  atime = toUnixTimestamp(atime);\\n  mtime = toUnixTimestamp(mtime);\\n  binding.utimes(pathModule._makeLong(path), atime, mtime);\\n};\\n\\nfs.futimes = function(fd, atime, mtime, callback) {\\n  atime = toUnixTimestamp(atime);\\n  mtime = toUnixTimestamp(mtime);\\n  var req = new FSReqWrap();\\n  req.oncomplete = makeCallback(callback);\\n  binding.futimes(fd, atime, mtime, req);\\n};\\n\\nfs.futimesSync = function(fd, atime, mtime) {\\n  atime = toUnixTimestamp(atime);\\n  mtime = toUnixTimestamp(mtime);\\n  binding.futimes(fd, atime, mtime);\\n};\\n\\nfunction writeAll(fd, isUserFd, buffer, offset, length, position, callback_) {\\n  var callback = maybeCallback(arguments[arguments.length - 1]);\\n\\n  // write(fd, buffer, offset, length, position, callback)\\n  fs.write(fd, buffer, offset, length, position, function(writeErr, written) {\\n    if (writeErr) {\\n      if (isUserFd) {\\n        if (callback) callback(writeErr);\\n      } else {\\n        fs.close(fd, function() {\\n          if (callback) callback(writeErr);\\n        });\\n      }\\n    } else {\\n      if (written === length) {\\n        if (isUserFd) {\\n          if (callback) callback(null);\\n        } else {\\n          fs.close(fd, callback);\\n        }\\n      } else {\\n        offset += written;\\n        length -= written;\\n        if (position !== null) {\\n          position += written;\\n        }\\n        writeAll(fd, isUserFd, buffer, offset, length, position, callback);\\n      }\\n    }\\n  });\\n}\\n\\nfs.writeFile = function(path, data, options, callback_) {\\n  var callback = maybeCallback(arguments[arguments.length - 1]);\\n\\n  if (!options || typeof options === 'function') {\\n    options = { encoding: 'utf8', mode: 438, flag: 'w' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, mode: 438, flag: 'w' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  assertEncoding(options.encoding);\\n\\n  var flag = options.flag || 'w';\\n\\n  if (isFd(path)) {\\n    writeFd(path, true);\\n    return;\\n  }\\n\\n  fs.open(path, flag, options.mode, function(openErr, fd) {\\n    if (openErr) {\\n      if (callback) callback(openErr);\\n    } else {\\n      writeFd(fd, false);\\n    }\\n  });\\n\\n  function writeFd(fd, isUserFd) {\\n    var buffer = (util.isBuffer(data)) ? data : Buffer('' + data,\\n        options.encoding || 'utf8');\\n    var position = /a/.test(flag) ? null : 0;\\n\\n    writeAll(fd, isUserFd, buffer, 0, buffer.length, position, callback);\\n  }\\n};\\n\\nfs.writeFileSync = function(path, data, options) {\\n  if (!options) {\\n    options = { encoding: 'utf8', mode: 438, flag: 'w' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, mode: 438, flag: 'w' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  assertEncoding(options.encoding);\\n\\n  var flag = options.flag || 'w';\\n  var isUserFd = isFd(path); // file descriptor ownership\\n  var fd = isUserFd ? path : fs.openSync(path, flag, options.mode);\\n\\n  if (!(util.isBuffer(data))) {\\n    data = Buffer('' + data, options.encoding || 'utf8');\\n  }\\n  var offset = 0;\\n  var length = data.length;\\n  var position = /a/.test(flag) ? null : 0;\\n  try {\\n    while (length > 0) {\\n      var written = fs.writeSync(fd, data, offset, length, position);\\n      offset += written;\\n      length -= written;\\n      if (position !== null) {\\n        position += written;\\n      }\\n    }\\n  } finally {\\n    if (!isUserFd) fs.closeSync(fd);\\n  }\\n};\\n\\nfs.appendFile = function(path, data, options, callback_) {\\n  var callback = maybeCallback(arguments[arguments.length - 1]);\\n\\n  if (!options || typeof options === 'function') {\\n    options = { encoding: 'utf8', mode: 438, flag: 'a' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, mode: 438, flag: 'a' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  if (!options.flag)\\n    options = util._extend({ flag: 'a' }, options);\\n\\n  // force append behavior when using a supplied file descriptor\\n  if (isFd(path))\\n    options.flag = 'a';\\n\\n  fs.writeFile(path, data, options, callback);\\n};\\n\\nfs.appendFileSync = function(path, data, options) {\\n  if (!options) {\\n    options = { encoding: 'utf8', mode: 438, flag: 'a' };\\n  } else if (typeof options === 'string') {\\n    options = { encoding: options, mode: 438, flag: 'a' };\\n  } else if (typeof options !== 'object') {\\n    throwOptionsError(options);\\n  }\\n\\n  if (!options.flag)\\n    options = util._extend({ flag: 'a' }, options);\\n\\n  // force append behavior when using a supplied file descriptor\\n  if (isFd(path))\\n    options.flag = 'a';\\n\\n  fs.writeFileSync(path, data, options);\\n};\\n\\nfunction FSWatcher() {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n  this._handle = new FSEvent();\\n  this._handle.owner = this;\\n\\n  this._handle.onchange = function(status, event, filename) {\\n    if (status < 0) {\\n      self._handle.close();\\n      var error = errnoException(status, 'watch ' + filename);\\n      error.filename = filename;\\n      self.emit('error', error);\\n    } else {\\n      self.emit('change', event, filename);\\n    }\\n  };\\n}\\nutil.inherits(FSWatcher, EventEmitter);\\n\\nFSWatcher.prototype.start = function(filename, persistent, recursive) {\\n  nullCheck(filename);\\n  var err = this._handle.start(pathModule._makeLong(filename),\\n                               persistent,\\n                               recursive);\\n  if (err) {\\n    this._handle.close();\\n    var error = errnoException(err, 'watch ' + filename);\\n    error.filename = filename;\\n    throw error;\\n  }\\n};\\n\\nFSWatcher.prototype.close = function() {\\n  this._handle.close();\\n};\\n\\nfs.watch = function(filename) {\\n  nullCheck(filename);\\n  var watcher;\\n  var options;\\n  var listener;\\n\\n  if (arguments[1] !== null && typeof arguments[1] === 'object') {\\n    options = arguments[1];\\n    listener = arguments[2];\\n  } else {\\n    options = {};\\n    listener = arguments[1];\\n  }\\n\\n  if (options.persistent === undefined) options.persistent = true;\\n  if (options.recursive === undefined) options.recursive = false;\\n\\n  watcher = new FSWatcher();\\n  watcher.start(filename, options.persistent, options.recursive);\\n\\n  if (listener) {\\n    watcher.addListener('change', listener);\\n  }\\n\\n  return watcher;\\n};\\n\\n\\n// Stat Change Watchers\\n\\nfunction StatWatcher() {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n  this._handle = new binding.StatWatcher();\\n\\n  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\\n  // the sake of backwards compatibility\\n  var oldStatus = -1;\\n\\n  this._handle.onchange = function(current, previous, newStatus) {\\n    if (oldStatus === -1 &&\\n        newStatus === -1 &&\\n        current.nlink === previous.nlink) return;\\n\\n    oldStatus = newStatus;\\n    self.emit('change', current, previous);\\n  };\\n\\n  this._handle.onstop = function() {\\n    self.emit('stop');\\n  };\\n}\\nutil.inherits(StatWatcher, EventEmitter);\\n\\n\\nStatWatcher.prototype.start = function(filename, persistent, interval) {\\n  nullCheck(filename);\\n  this._handle.start(pathModule._makeLong(filename), persistent, interval);\\n};\\n\\n\\nStatWatcher.prototype.stop = function() {\\n  this._handle.stop();\\n};\\n\\n\\nfunction _Map (){\\n  this.list = {};\\n  this.set = function(name, val){\\n    this.list[name] = val;\\n  };\\n\\n  this.get = function(name){\\n    return this.list[name];\\n  };\\n\\n  this.delete = function(name){\\n    delete this.list[name];\\n  };\\n}\\n\\nvar statWatchers = new _Map();\\n\\nfs.watchFile = function(filename, options, listener) {\\n  nullCheck(filename);\\n  filename = pathModule.resolve(filename);\\n  var stat;\\n\\n  var defaults = {\\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\\n    // a little on the slow side but let's stick with it for now to keep\\n    // behavioral changes to a minimum.\\n    interval: 5007,\\n    persistent: true\\n  };\\n\\n  if (options !== null && typeof options === 'object') {\\n    options = util._extend(defaults, options);\\n  } else {\\n    listener = options;\\n    options = defaults;\\n  }\\n\\n  if (typeof listener !== 'function') {\\n    throw new Error('watchFile requires a listener function');\\n  }\\n\\n  stat = statWatchers.get(filename);\\n\\n  if (stat === undefined) {\\n    stat = new StatWatcher();\\n    stat.start(filename, options.persistent, options.interval);\\n    statWatchers.set(filename, stat);\\n  }\\n\\n  stat.addListener('change', listener);\\n  return stat;\\n};\\n\\nfs.unwatchFile = function(filename, listener) {\\n  nullCheck(filename);\\n  filename = pathModule.resolve(filename);\\n  var stat = statWatchers.get(filename);\\n\\n  if (stat === undefined) return;\\n\\n  if (typeof listener === 'function') {\\n    stat.removeListener('change', listener);\\n  } else {\\n    stat.removeAllListeners('change');\\n  }\\n\\n  if (stat.listenerCount('change') === 0) {\\n    stat.stop();\\n    statWatchers.delete(filename);\\n  }\\n};\\n\\n// Regexp that finds the next partion of a (partial) path\\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\\nif (isWindows) {\\n  var nextPartRe = /(.*?)(?:[\\\\/\\\\\\\\]+|$)/g;\\n} else {\\n  var nextPartRe = /(.*?)(?:[\\\\/]+|$)/g;\\n}\\n\\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\\\\\'.\\nif (isWindows) {\\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\\\\\\\/]{2}[^\\\\\\\\\\\\/]+[\\\\\\\\\\\\/][^\\\\\\\\\\\\/]+)?[\\\\\\\\\\\\/]*/;\\n} else {\\n  var splitRootRe = /^[\\\\/]*/;\\n}\\n\\nfs.realpathSync = function realpathSync(p, cache) {\\n  // make p is absolute\\n  p = pathModule.resolve(p);\\n\\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\\n    return cache[p];\\n  }\\n\\n  var original = p,\\n      seenLinks = {},\\n      knownHard = {};\\n\\n  // current character position in p\\n  var pos;\\n  // the partial path so far, including a trailing slash if any\\n  var current;\\n  // the partial path without a trailing slash (except when pointing at a root)\\n  var base;\\n  // the partial path scanned in the previous round, with slash\\n  var previous;\\n\\n  start();\\n\\n  function start() {\\n    // Skip over roots\\n    var m = splitRootRe.exec(p);\\n    pos = m[0].length;\\n    current = m[0];\\n    base = m[0];\\n    previous = '';\\n\\n    // On windows, check that the root exists. On unix there is no need.\\n    if (isWindows && !knownHard[base]) {\\n      fs.lstatSync(base);\\n      knownHard[base] = true;\\n    }\\n  }\\n\\n  // walk down the path, swapping out linked pathparts for their real\\n  // values\\n  // NB: p.length changes.\\n  while (pos < p.length) {\\n    // find the next part\\n    nextPartRe.lastIndex = pos;\\n    var result = nextPartRe.exec(p);\\n    previous = current;\\n    current += result[0];\\n    base = previous + result[1];\\n    pos = nextPartRe.lastIndex;\\n\\n    // continue if not a symlink\\n    if (knownHard[base] || (cache && cache[base] === base)) {\\n      continue;\\n    }\\n\\n    var resolvedLink;\\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\\n      // some known symbolic link.  no need to stat again.\\n      resolvedLink = cache[base];\\n    } else {\\n      var stat = fs.lstatSync(base);\\n      if (!stat.isSymbolicLink()) {\\n        knownHard[base] = true;\\n        if (cache) cache[base] = base;\\n        continue;\\n      }\\n\\n      // read the link if it wasn't read before\\n      // dev/ino always return 0 on windows, so skip the check.\\n      var linkTarget = null;\\n      if (!isWindows) {\\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\\n        if (seenLinks.hasOwnProperty(id)) {\\n          linkTarget = seenLinks[id];\\n        }\\n      }\\n      if (linkTarget === null) {\\n        fs.statSync(base);\\n        linkTarget = fs.readlinkSync(base);\\n      }\\n      resolvedLink = pathModule.resolve(previous, linkTarget);\\n      // track this, if given a cache.\\n      if (cache) cache[base] = resolvedLink;\\n      if (!isWindows) seenLinks[id] = linkTarget;\\n    }\\n\\n    // resolve the link, then start over\\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\\n    start();\\n  }\\n\\n  if (cache) cache[original] = p;\\n\\n  return p;\\n};\\n\\n\\nfs.realpath = function realpath(p, cache, cb) {\\n  if (typeof cb !== 'function') {\\n    cb = maybeCallback(cache);\\n    cache = null;\\n  }\\n\\n  // make p is absolute\\n  p = pathModule.resolve(p);\\n\\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\\n    return process.nextTick(cb.bind(null, null, cache[p]));\\n  }\\n\\n  var original = p,\\n      seenLinks = {},\\n      knownHard = {};\\n\\n  // current character position in p\\n  var pos;\\n  // the partial path so far, including a trailing slash if any\\n  var current;\\n  // the partial path without a trailing slash (except when pointing at a root)\\n  var base;\\n  // the partial path scanned in the previous round, with slash\\n  var previous;\\n\\n  start();\\n\\n  function start() {\\n    // Skip over roots\\n    var m = splitRootRe.exec(p);\\n    pos = m[0].length;\\n    current = m[0];\\n    base = m[0];\\n    previous = '';\\n\\n    // On windows, check that the root exists. On unix there is no need.\\n    if (isWindows && !knownHard[base]) {\\n      fs.lstat(base, function(err) {\\n        if (err) return cb(err);\\n        knownHard[base] = true;\\n        LOOP();\\n      });\\n    } else {\\n      process.nextTick(LOOP);\\n    }\\n  }\\n\\n  // walk down the path, swapping out linked pathparts for their real\\n  // values\\n  function LOOP() {\\n    // stop if scanned past end of path\\n    if (pos >= p.length) {\\n      if (cache) cache[original] = p;\\n      return cb(null, p);\\n    }\\n\\n    // find the next part\\n    nextPartRe.lastIndex = pos;\\n    var result = nextPartRe.exec(p);\\n    previous = current;\\n    current += result[0];\\n    base = previous + result[1];\\n    pos = nextPartRe.lastIndex;\\n\\n    // continue if not a symlink\\n    if (knownHard[base] || (cache && cache[base] === base)) {\\n      return process.nextTick(LOOP);\\n    }\\n\\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\\n      // known symbolic link.  no need to stat again.\\n      return gotResolvedLink(cache[base]);\\n    }\\n\\n    return fs.lstat(base, gotStat);\\n  }\\n\\n  function gotStat(err, stat) {\\n    if (err) return cb(err);\\n\\n    // if not a symlink, skip to the next path part\\n    if (!stat.isSymbolicLink()) {\\n      knownHard[base] = true;\\n      if (cache) cache[base] = base;\\n      return process.nextTick(LOOP);\\n    }\\n\\n    // stat & read the link if not read before\\n    // call gotTarget as soon as the link target is known\\n    // dev/ino always return 0 on windows, so skip the check.\\n    if (!isWindows) {\\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\\n      if (seenLinks.hasOwnProperty(id)) {\\n        return gotTarget(null, seenLinks[id], base);\\n      }\\n    }\\n    fs.stat(base, function(err) {\\n      if (err) return cb(err);\\n\\n      fs.readlink(base, function(err, target) {\\n        if (!isWindows) seenLinks[id] = target;\\n        gotTarget(err, target);\\n      });\\n    });\\n  }\\n\\n  function gotTarget(err, target, base) {\\n    if (err) return cb(err);\\n\\n    var resolvedLink = pathModule.resolve(previous, target);\\n    if (cache) cache[base] = resolvedLink;\\n    gotResolvedLink(resolvedLink);\\n  }\\n\\n  function gotResolvedLink(resolvedLink) {\\n    // resolve the link, then start over\\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\\n    start();\\n  }\\n};\\n\\n\\nvar pool;\\nvar poolUsed = 0;\\nfunction allocNewPool(poolSize) {\\n  pool = Buffer(poolSize);\\n  poolUsed = 0;\\n}\\n\\n\\nfs.createReadStream = function(path, options) {\\n  return new ReadStream(path, options);\\n};\\n\\nutil.inherits(ReadStream, Readable);\\nfs.ReadStream = ReadStream;\\n\\nfunction ReadStream(path, options) {\\n  if (!(this instanceof ReadStream))\\n    return new ReadStream(path, options);\\n\\n  if (options === undefined)\\n    options = {};\\n  else if (typeof options === 'string')\\n    options = { encoding: options };\\n  else if (options === null || typeof options !== 'object')\\n    throw new TypeError('\\\"options\\\" argument must be a string or an object');\\n\\n  // a little bit bigger buffer and water marks by default\\n  options = Object.create(options);\\n  if (options.highWaterMark === undefined)\\n    options.highWaterMark = 64 * 1024;\\n\\n  Readable.call(this, options);\\n\\n  this.path = path;\\n  this.fd = options.fd === undefined ? null : options.fd;\\n  this.flags = options.flags === undefined ? 'r' : options.flags;\\n  this.mode = options.mode === undefined ? 438 : options.mode;\\n\\n  this.start = options.start;\\n  this.end = options.end;\\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\\n  this.pos = undefined;\\n\\n  if (this.start !== undefined) {\\n    if (typeof this.start !== 'number') {\\n      throw new TypeError('start must be a Number');\\n    }\\n    if (this.end === undefined) {\\n      this.end = Infinity;\\n    } else if (typeof this.end !== 'number') {\\n      throw new TypeError('end must be a Number');\\n    }\\n\\n    if (this.start > this.end) {\\n      throw new Error('start must be <= end');\\n    }\\n\\n    this.pos = this.start;\\n  }\\n\\n  if (typeof this.fd !== 'number')\\n    this.open();\\n\\n  this.on('end', function() {\\n    if (this.autoClose) {\\n      this.destroy();\\n    }\\n  });\\n}\\n\\nfs.FileReadStream = fs.ReadStream; // support the legacy name\\n\\nReadStream.prototype.open = function() {\\n  var self = this;\\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\\n    if (er) {\\n      if (self.autoClose) {\\n        self.destroy();\\n      }\\n      self.emit('error', er);\\n      return;\\n    }\\n\\n    self.fd = fd;\\n    self.emit('open', fd);\\n    // start the flow of data.\\n    self.read();\\n  });\\n};\\n\\nReadStream.prototype._read = function(n) {\\n  if (typeof this.fd !== 'number')\\n    return this.once('open', function() {\\n      this._read(n);\\n    });\\n\\n  if (this.destroyed)\\n    return;\\n\\n  if (!pool || pool.length - poolUsed < kMinPoolSpace) {\\n    // discard the old pool.\\n    pool = null;\\n    allocNewPool(this._readableState.highWaterMark);\\n  }\\n\\n  // Grab another reference to the pool in the case that while we're\\n  // in the thread pool another read() finishes up the pool, and\\n  // allocates a new one.\\n  var thisPool = pool;\\n  var toRead = Math.min(pool.length - poolUsed, n);\\n  var start = poolUsed;\\n\\n  if (this.pos !== undefined)\\n    toRead = Math.min(this.end - this.pos + 1, toRead);\\n\\n  // already read everything we were supposed to read!\\n  // treat as EOF.\\n  if (toRead <= 0)\\n    return this.push(null);\\n\\n  // the actual read.\\n  var self = this;\\n  fs.read(this.fd, pool, poolUsed, toRead, this.pos, onread);\\n\\n  // move the pool positions, and internal position for reading.\\n  if (this.pos !== undefined)\\n    this.pos += toRead;\\n  poolUsed += toRead;\\n\\n  function onread(er, bytesRead) {\\n    if (er) {\\n      if (self.autoClose) {\\n        self.destroy();\\n      }\\n      self.emit('error', er);\\n    } else {\\n      var b = null;\\n      if (bytesRead > 0)\\n        b = thisPool.slice(start, start + bytesRead);\\n\\n      self.push(b);\\n    }\\n  }\\n};\\n\\n\\nReadStream.prototype.destroy = function() {\\n  if (this.destroyed)\\n    return;\\n  this.destroyed = true;\\n  this.close();\\n};\\n\\n\\nReadStream.prototype.close = function(cb) {\\n  var self = this;\\n  if (cb)\\n    this.once('close', cb);\\n  if (this.closed || typeof this.fd !== 'number') {\\n    if (typeof this.fd !== 'number') {\\n      this.once('open', close);\\n      return;\\n    }\\n    return process.nextTick(this.emit.bind(this, 'close'));\\n  }\\n  this.closed = true;\\n  close();\\n\\n  function close(fd) {\\n    fs.close(fd || self.fd, function(er) {\\n      if (er)\\n        self.emit('error', er);\\n      else\\n        self.emit('close');\\n    });\\n    self.fd = null;\\n  }\\n};\\n\\n\\nfs.createWriteStream = function(path, options) {\\n  return new WriteStream(path, options);\\n};\\n\\nutil.inherits(WriteStream, Writable);\\nfs.WriteStream = WriteStream;\\nfunction WriteStream(path, options) {\\n  if (!(this instanceof WriteStream))\\n    return new WriteStream(path, options);\\n\\n  if (options === undefined)\\n    options = {};\\n  else if (typeof options === 'string')\\n    options = { encoding: options };\\n  else if (options === null || typeof options !== 'object')\\n    throw new TypeError('\\\"options\\\" argument must be a string or an object');\\n\\n  options = Object.create(options);\\n\\n  Writable.call(this, options);\\n\\n  this.path = path;\\n  this.fd = options.fd === undefined ? null : options.fd;\\n  this.flags = options.flags === undefined ? 'w' : options.flags;\\n  this.mode = options.mode === undefined ? 438 : options.mode;\\n\\n  this.start = options.start;\\n  this.pos = undefined;\\n  this.bytesWritten = 0;\\n\\n  if (this.start !== undefined) {\\n    if (typeof this.start !== 'number') {\\n      throw new TypeError('start must be a Number');\\n    }\\n    if (this.start < 0) {\\n      throw new Error('start must be >= zero');\\n    }\\n\\n    this.pos = this.start;\\n  }\\n\\n  if (options.encoding)\\n    this.setDefaultEncoding(options.encoding);\\n\\n  if (typeof this.fd !== 'number')\\n    this.open();\\n\\n  // dispose on finish.\\n  this.once('finish', this.close);\\n}\\n\\nfs.FileWriteStream = fs.WriteStream; // support the legacy name\\n\\n\\nWriteStream.prototype.open = function() {\\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\\n    if (er) {\\n      this.destroy();\\n      this.emit('error', er);\\n      return;\\n    }\\n\\n    this.fd = fd;\\n    this.emit('open', fd);\\n  }.bind(this));\\n};\\n\\n\\nWriteStream.prototype._write = function(data, encoding, cb) {\\n  if (!(util.isBuffer(data)))\\n    return this.emit('error', new Error('Invalid data'));\\n\\n  if (typeof this.fd !== 'number')\\n    return this.once('open', function() {\\n      this._write(data, encoding, cb);\\n    });\\n\\n  var self = this;\\n  fs.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {\\n    if (er) {\\n      self.destroy();\\n      return cb(er);\\n    }\\n    self.bytesWritten += bytes;\\n    cb();\\n  });\\n\\n  if (this.pos !== undefined)\\n    this.pos += data.length;\\n};\\n\\n\\nfunction writev(fd, chunks, position, callback) {\\n  function wrapper(err, written) {\\n    // Retain a reference to chunks so that they can't be GC'ed too soon.\\n    callback(err, written || 0, chunks);\\n  }\\n\\n  var req = new FSReqWrap();\\n  req.oncomplete = wrapper;\\n  binding.writeBuffers(fd, chunks, position, req);\\n}\\n\\n\\nWriteStream.prototype._writev = function(data, cb) {\\n  if (typeof this.fd !== 'number')\\n    return this.once('open', function() {\\n      this._writev(data, cb);\\n    });\\n\\n  var self = this;\\n  var len = data.length;\\n  var chunks = new Array(len);\\n  var size = 0;\\n\\n  for (var i = 0; i < len; i++) {\\n    var chunk = data[i].chunk;\\n\\n    chunks[i] = chunk;\\n    size += chunk.length;\\n  }\\n\\n  writev(this.fd, chunks, this.pos, function(er, bytes) {\\n    if (er) {\\n      self.destroy();\\n      return cb(er);\\n    }\\n    self.bytesWritten += bytes;\\n    cb();\\n  });\\n\\n  if (this.pos !== undefined)\\n    this.pos += size;\\n};\\n\\n\\nWriteStream.prototype.destroy = ReadStream.prototype.destroy;\\nWriteStream.prototype.close = ReadStream.prototype.close;\\n\\n// There is no shutdown() for files.\\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\\n\\n\\n// SyncWriteStream is internal. DO NOT USE.\\n// Temporary hack for process.stdout and process.stderr when piped to files.\\nfunction SyncWriteStream(fd, options) {\\n  Stream.call(this);\\n\\n  options = options || {};\\n\\n  this.fd = fd;\\n  this.writable = true;\\n  this.readable = false;\\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\\n}\\n\\nutil.inherits(SyncWriteStream, Stream);\\n\\n\\n// Export\\nObject.defineProperty(fs, 'SyncWriteStream', {\\n    configurable: true,\\n    writable: true,\\n    value: SyncWriteStream\\n});\\n\\nSyncWriteStream.prototype.write = function(data, arg1, arg2) {\\n  var encoding, cb;\\n\\n  // parse arguments\\n  if (arg1) {\\n    if (typeof arg1 === 'string') {\\n      encoding = arg1;\\n      cb = arg2;\\n    } else if (typeof arg1 === 'function') {\\n      cb = arg1;\\n    } else {\\n      throw new Error('bad arg');\\n    }\\n  }\\n  assertEncoding(encoding);\\n\\n  // Change strings to buffers. SLOW\\n  if (typeof data === 'string') {\\n    data = Buffer(data, encoding);\\n  }\\n\\n  fs.writeSync(this.fd, data, 0, data.length);\\n\\n  if (cb) {\\n    process.nextTick(cb);\\n  }\\n\\n  return true;\\n};\\n\\n\\nSyncWriteStream.prototype.end = function(data, arg1, arg2) {\\n  if (data) {\\n    this.write(data, arg1, arg2);\\n  }\\n  this.destroy();\\n};\\n\\n\\nSyncWriteStream.prototype.destroy = function() {\\n  if (this.autoClose)\\n    fs.closeSync(this.fd);\\n  this.fd = null;\\n  this.emit('close');\\n  return true;\\n};\\n\\nSyncWriteStream.prototype.destroySoon = SyncWriteStream.prototype.destroy;\\n\",\"url\":\"exports.parse = urlParse;\\r\\nexports.resolve = urlResolve;\\r\\nexports.resolveObject = urlResolveObject;\\r\\nexports.format = urlFormat;\\r\\n\\r\\n// define these here so at least they only have to be compiled once on the first module load.\\r\\nvar protocolPattern = /^([a-z0-9]+:)/,\\r\\n  portPattern = /:[0-9]+$/,\\r\\n  nonHostChars = [\\\"/\\\", \\\"?\\\", \\\";\\\", \\\"#\\\"],\\r\\n  hostlessProtocol = {\\r\\n    \\\"file\\\":true,\\r\\n    \\\"file:\\\":true\\r\\n  },\\r\\n  slashedProtocol = {\\r\\n    \\\"http\\\":true, \\\"https\\\":true, \\\"ftp\\\":true, \\\"gopher\\\":true, \\\"file\\\":true,\\r\\n    \\\"http:\\\":true, \\\"https:\\\":true, \\\"ftp:\\\":true, \\\"gopher:\\\":true, \\\"file:\\\":true\\r\\n  },\\r\\n  path = require(\\\"path\\\"), // internal module, guaranteed to be loaded already.\\r\\n  querystring = require('querystring');\\r\\n\\r\\nfunction urlParse (url, parseQueryString, slashesDenoteHost) {\\r\\n  if (url && typeof(url) === \\\"object\\\" && url.href) return url;\\r\\n\\r\\n  var out = { href : url },\\r\\n    rest = url;\\r\\n\\r\\n  var proto = protocolPattern.exec(rest);\\r\\n  if (proto) {\\r\\n    proto = proto[0];\\r\\n    out.protocol = proto;\\r\\n    rest = rest.substr(proto.length);\\r\\n  }\\r\\n\\r\\n  // figure out if it's got a host\\r\\n  // user@server is *always* interpreted as a hostname, and url\\r\\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\\r\\n  // how the browser resolves relative URLs.\\r\\n  if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {\\r\\n    var slashes = rest.substr(0, 2) === \\\"//\\\";\\r\\n    if (slashes && !(proto && hostlessProtocol[proto])) {\\r\\n      rest = rest.substr(2);\\r\\n      out.slashes = true;\\r\\n    }\\r\\n  }\\r\\n  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {\\r\\n    // there's a hostname.\\r\\n    // the first instance of /, ?, ;, or # ends the host.\\r\\n    // don't enforce full RFC correctness, just be unstupid about it.\\r\\n    var firstNonHost = -1;\\r\\n    for (var i = 0, l = nonHostChars.length; i < l; i ++) {\\r\\n      var index = rest.indexOf(nonHostChars[i]);\\r\\n      if (index !== -1 && (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;\\r\\n    }\\r\\n    if (firstNonHost !== -1) {\\r\\n      out.host = rest.substr(0, firstNonHost);\\r\\n      rest = rest.substr(firstNonHost);\\r\\n    } else {\\r\\n      out.host = rest;\\r\\n      rest = \\\"\\\";\\r\\n    }\\r\\n\\r\\n    // pull out the auth and port.\\r\\n    var p = parseHost(out.host);\\r\\n    var keys = Object.keys(p);\\r\\n    for (var i = 0, l = keys.length; i < l; i++) {\\r\\n      var key = keys[i];\\r\\n      out[key] = p[key];\\r\\n    }\\r\\n    // we've indicated that there is a hostname, so even if it's empty, it has to be present.\\r\\n    out.hostname = out.hostname || \\\"\\\";\\r\\n  }\\r\\n\\r\\n  // now rest is set to the post-host stuff.\\r\\n  // chop off from the tail first.\\r\\n  var hash = rest.indexOf(\\\"#\\\");\\r\\n  if (hash !== -1) {\\r\\n    // got a fragment string.\\r\\n    out.hash = rest.substr(hash);\\r\\n    rest = rest.slice(0, hash);\\r\\n  }\\r\\n  var qm = rest.indexOf(\\\"?\\\");\\r\\n  if (qm !== -1) {\\r\\n    out.search = rest.substr(qm);\\r\\n    out.query = rest.substr(qm+1);\\r\\n    if (parseQueryString) {\\r\\n      out.query = querystring.parse(out.query);\\r\\n    }\\r\\n    rest = rest.slice(0, qm);\\r\\n  }\\r\\n  if (rest) out.pathname = rest;\\r\\n\\r\\n  return out;\\r\\n};\\r\\n\\r\\n// format a parsed object into a url string\\r\\nfunction urlFormat (obj) {\\r\\n  // ensure it's an object, and not a string url. If it's an obj, this is a no-op.\\r\\n  // this way, you can call url_format() on strings to clean up potentially wonky urls.\\r\\n  if (typeof(obj) === \\\"string\\\") obj = urlParse(obj);\\r\\n\\r\\n  var protocol = obj.protocol || \\\"\\\",\\r\\n    host = (obj.host !== undefined) ? obj.host\\r\\n      : obj.hostname !== undefined ? (\\r\\n        (obj.auth ? obj.auth + \\\"@\\\" : \\\"\\\")\\r\\n        + obj.hostname\\r\\n        + (obj.port ? \\\":\\\" + obj.port : \\\"\\\")\\r\\n      )\\r\\n      : false,\\r\\n    pathname = obj.pathname || \\\"\\\",\\r\\n    search = obj.search || (\\r\\n      obj.query && ( \\\"?\\\" + (\\r\\n        typeof(obj.query) === \\\"object\\\"\\r\\n        ? querystring.stringify(obj.query)\\r\\n        : String(obj.query)\\r\\n      ))\\r\\n    ) || \\\"\\\",\\r\\n    hash = obj.hash || \\\"\\\";\\r\\n\\r\\n  if (protocol && protocol.substr(-1) !== \\\":\\\") protocol += \\\":\\\";\\r\\n\\r\\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\\r\\n  // unless they had them to begin with.\\r\\n  if (obj.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\\r\\n    host = \\\"//\\\" + (host || \\\"\\\");\\r\\n    if (pathname && pathname.charAt(0) !== \\\"/\\\") pathname = \\\"/\\\" + pathname;\\r\\n  } else if (!host) host = \\\"\\\";\\r\\n\\r\\n  if (hash && hash.charAt(0) !== \\\"#\\\") hash = \\\"#\\\" + hash;\\r\\n  if (search && search.charAt(0) !== \\\"?\\\") search = \\\"?\\\" + search;\\r\\n\\r\\n  return protocol + host + pathname + search + hash;\\r\\n};\\r\\n\\r\\nfunction urlResolve (source, relative) {\\r\\n  return urlFormat(urlResolveObject(source, relative));\\r\\n};\\r\\n\\r\\nfunction urlResolveObject (source, relative) {\\r\\n  if (!source) return relative;\\r\\n\\r\\n  source = urlParse(urlFormat(source), false, true);\\r\\n  relative = urlParse(urlFormat(relative), false, true);\\r\\n\\r\\n  // hash is always overridden, no matter what.\\r\\n  source.hash = relative.hash;\\r\\n\\r\\n  if (relative.href === \\\"\\\") return source;\\r\\n\\r\\n  // hrefs like //foo/bar always cut to the protocol.\\r\\n  if (relative.slashes && !relative.protocol) {\\r\\n    relative.protocol = source.protocol;\\r\\n    return relative;\\r\\n  }\\r\\n\\r\\n  if (relative.protocol && relative.protocol !== source.protocol) {\\r\\n    // if it's a known url protocol, then changing the protocol does weird things\\r\\n    // first, if it's not file:, then we MUST have a host, and if there was a path\\r\\n    // to begin with, then we MUST have a path.\\r\\n    // if it is file:, then the host is dropped, because that's known to be hostless.\\r\\n    // anything else is assumed to be absolute.\\r\\n\\r\\n    if (!slashedProtocol[relative.protocol]) return relative;\\r\\n\\r\\n    source.protocol = relative.protocol;\\r\\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\\r\\n      var relPath = (relative.pathname || \\\"\\\").split(\\\"/\\\");\\r\\n      while (relPath.length && !(relative.host = relPath.shift()));\\r\\n      if (!relative.host) relative.host = \\\"\\\";\\r\\n      if (relPath[0] !== \\\"\\\") relPath.unshift(\\\"\\\");\\r\\n      if (relPath.length < 2) relPath.unshift(\\\"\\\");\\r\\n      relative.pathname = relPath.join(\\\"/\\\");\\r\\n    }\\r\\n    source.pathname = relative.pathname;\\r\\n    source.search = relative.search;\\r\\n    source.query = relative.query;\\r\\n    source.host = relative.host || \\\"\\\";\\r\\n    delete source.auth;\\r\\n    delete source.hostname;\\r\\n    source.port = relative.port;\\r\\n    return source;\\r\\n  }\\r\\n\\r\\n  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === \\\"/\\\"),\\r\\n    isRelAbs = (\\r\\n      relative.host !== undefined\\r\\n      || relative.pathname && relative.pathname.charAt(0) === \\\"/\\\"\\r\\n    ),\\r\\n    mustEndAbs = (isRelAbs || isSourceAbs || (source.host && relative.pathname)),\\r\\n    removeAllDots = mustEndAbs,\\r\\n    srcPath = source.pathname && source.pathname.split(\\\"/\\\") || [],\\r\\n    relPath = relative.pathname && relative.pathname.split(\\\"/\\\") || [],\\r\\n    psychotic = source.protocol && !slashedProtocol[source.protocol] && source.host !== undefined;\\r\\n\\r\\n  // if the url is a non-slashed url, then relative links like ../.. should be able\\r\\n  // to crawl up to the hostname, as well.  This is strange.\\r\\n  // source.protocol has already been set by now.\\r\\n  // Later on, put the first path part into the host field.\\r\\n  if ( psychotic ) {\\r\\n\\r\\n    delete source.hostname;\\r\\n    delete source.auth;\\r\\n    delete source.port;\\r\\n    if (source.host) {\\r\\n      if (srcPath[0] === \\\"\\\") srcPath[0] = source.host;\\r\\n      else srcPath.unshift(source.host);\\r\\n    }\\r\\n    delete source.host;\\r\\n\\r\\n    if (relative.protocol) {\\r\\n      delete relative.hostname;\\r\\n      delete relative.auth;\\r\\n      delete relative.port;\\r\\n      if (relative.host) {\\r\\n        if (relPath[0] === \\\"\\\") relPath[0] = relative.host;\\r\\n        else relPath.unshift(relative.host);\\r\\n      }\\r\\n      delete relative.host;\\r\\n    }\\r\\n    mustEndAbs = mustEndAbs && (relPath[0] === \\\"\\\" || srcPath[0] === \\\"\\\");\\r\\n  }\\r\\n\\r\\n  if (isRelAbs) {\\r\\n    // it's absolute.\\r\\n    source.host = (relative.host || relative.host === \\\"\\\") ? relative.host : source.host;\\r\\n    source.search = relative.search;\\r\\n    source.query = relative.query;\\r\\n    srcPath = relPath;\\r\\n    // fall through to the dot-handling below.\\r\\n  } else if (relPath.length) {\\r\\n    // it's relative\\r\\n    // throw away the existing file, and take the new path instead.\\r\\n    if (!srcPath) srcPath = [];\\r\\n    srcPath.pop();\\r\\n    srcPath = srcPath.concat(relPath);\\r\\n    source.search = relative.search;\\r\\n    source.query = relative.query;\\r\\n  } else if (\\\"search\\\" in relative) {\\r\\n    // just pull out the search.\\r\\n    // like href=\\\"?foo\\\".\\r\\n    // Put this after the other two cases because it simplifies the booleans\\r\\n    if (psychotic) {\\r\\n      source.host = srcPath.shift();\\r\\n    }\\r\\n    source.search = relative.search;\\r\\n    source.query = relative.query;\\r\\n    return source;\\r\\n  }\\r\\n  if (!srcPath.length) {\\r\\n    // no path at all.  easy.\\r\\n    // we've already handled the other stuff above.\\r\\n    delete source.pathname;\\r\\n    return source;\\r\\n  }\\r\\n\\r\\n  // resolve dots.\\r\\n  // if a url ENDs in . or .., then it must get a trailing slash.\\r\\n  // however, if it ends in anything else non-slashy, then it must NOT get a trailing slash.\\r\\n  var last = srcPath.slice(-1)[0];\\r\\n  var hasTrailingSlash = (\\r\\n    (source.host || relative.host) && (last === \\\".\\\" || last === \\\"..\\\")\\r\\n    || last === \\\"\\\"\\r\\n  );\\r\\n\\r\\n  // Figure out if this has to end up as an absolute url, or should continue to be relative.\\r\\n  srcPath = path.normalizeArray(srcPath, true);\\r\\n  if (srcPath.length === 1 && srcPath[0] === \\\".\\\") srcPath = [];\\r\\n  if (mustEndAbs || removeAllDots) {\\r\\n    // all dots must go.\\r\\n    var dirs = [];\\r\\n    srcPath.forEach(function (dir, i) {\\r\\n      if (dir === \\\"..\\\") dirs.pop();\\r\\n      else if (dir !== \\\".\\\") dirs.push(dir);\\r\\n    });\\r\\n\\r\\n    if (mustEndAbs && dirs[0] !== \\\"\\\") {\\r\\n      dirs.unshift(\\\"\\\");\\r\\n    }\\r\\n    srcPath = dirs;\\r\\n  }\\r\\n  if (hasTrailingSlash && (srcPath.length < 2 || srcPath.slice(-1)[0] !== \\\"\\\")) srcPath.push(\\\"\\\");\\r\\n\\r\\n  // put the host back\\r\\n  if ( psychotic ) source.host = srcPath[0] === \\\"\\\" ? \\\"\\\" : srcPath.shift();\\r\\n\\r\\n  mustEndAbs = mustEndAbs || (source.host && srcPath.length);\\r\\n\\r\\n  if (mustEndAbs && srcPath[0] !== \\\"\\\") srcPath.unshift(\\\"\\\");\\r\\n\\r\\n  source.pathname = srcPath.join(\\\"/\\\");\\r\\n\\r\\n  return source;\\r\\n};\\r\\n\\r\\nfunction parseHost (host) {\\r\\n  var out = {};\\r\\n  var at = host.indexOf(\\\"@\\\");\\r\\n  if (at !== -1) {\\r\\n    out.auth = host.substr(0, at);\\r\\n    host = host.substr(at+1); // drop the @\\r\\n  }\\r\\n  var port = portPattern.exec(host);\\r\\n  if (port) {\\r\\n    port = port[0];\\r\\n    out.port = port.substr(1);\\r\\n    host = host.substr(0, host.length - port.length);\\r\\n  }\\r\\n  if (host) out.hostname = host;\\r\\n  return out;\\r\\n}\\r\\n\",\"readline\":\"// Inspiration for this code comes from Salvatore Sanfilippo's linenoise.\\r\\n// https://github.com/antirez/linenoise\\r\\n// Reference:\\r\\n// * http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\\r\\n// * http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html\\r\\n\\r\\n'use strict';\\r\\n\\r\\n/*! https://mths.be/codepointat v0.2.0 by @mathias */\\r\\nif (!String.prototype.codePointAt) {\\r\\n  (function() {\\r\\n    'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\\r\\n    var defineProperty = (function() {\\r\\n      // IE 8 only supports `Object.defineProperty` on DOM elements\\r\\n      try {\\r\\n        var object = {};\\r\\n        var $defineProperty = Object.defineProperty;\\r\\n        var result = $defineProperty(object, object, object) && $defineProperty;\\r\\n      } catch(error) {}\\r\\n      return result;\\r\\n    }());\\r\\n    var codePointAt = function(position) {\\r\\n      if (this == null) {\\r\\n        throw TypeError();\\r\\n      }\\r\\n      var string = String(this);\\r\\n      var size = string.length;\\r\\n      // `ToInteger`\\r\\n      var index = position ? Number(position) : 0;\\r\\n      if (index != index) { // better `isNaN`\\r\\n        index = 0;\\r\\n      }\\r\\n      // Account for out-of-bounds indices:\\r\\n      if (index < 0 || index >= size) {\\r\\n        return undefined;\\r\\n      }\\r\\n      // Get the first code unit\\r\\n      var first = string.charCodeAt(index);\\r\\n      var second;\\r\\n      if ( // check if its the start of a surrogate pair\\r\\n        first >= 0xD800 && first <= 0xDBFF && // high surrogate\\r\\n        size > index + 1 // there is a next code unit\\r\\n      ) {\\r\\n        second = string.charCodeAt(index + 1);\\r\\n        if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\\r\\n          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\\r\\n          return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\\r\\n        }\\r\\n      }\\r\\n      return first;\\r\\n    };\\r\\n    if (defineProperty) {\\r\\n      defineProperty(String.prototype, 'codePointAt', {\\r\\n        'value': codePointAt,\\r\\n        'configurable': true,\\r\\n        'writable': true\\r\\n      });\\r\\n    } else {\\r\\n      String.prototype.codePointAt = codePointAt;\\r\\n    }\\r\\n  }());\\r\\n}\\r\\n\\r\\nvar kHistorySize = 30;\\r\\n\\r\\nvar util = require('util');\\r\\nvar inherits = util.inherits;\\r\\nvar EventEmitter = require('events').EventEmitter;\\r\\n\\r\\n\\r\\nexports.createInterface = function(input, output, completer, terminal) {\\r\\n  var rl;\\r\\n  if (arguments.length === 1) {\\r\\n    rl = new Interface(input);\\r\\n  } else {\\r\\n    rl = new Interface(input, output, completer, terminal);\\r\\n  }\\r\\n  return rl;\\r\\n};\\r\\n\\r\\n\\r\\nfunction Interface(input, output, completer, terminal) {\\r\\n  if (!(this instanceof Interface)) {\\r\\n    // call the varructor preserving original number of arguments\\r\\n    var self = Object.create(Interface.prototype);\\r\\n    Interface.apply(self, arguments);\\r\\n    return self;\\r\\n  }\\r\\n\\r\\n  this._sawReturn = false;\\r\\n\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  if (arguments.length === 1) {\\r\\n    // an options object was given\\r\\n    output = input.output;\\r\\n    completer = input.completer;\\r\\n    terminal = input.terminal;\\r\\n    input = input.input;\\r\\n  }\\r\\n\\r\\n  completer = completer || function() { return []; };\\r\\n\\r\\n  if (typeof completer !== 'function') {\\r\\n    throw new TypeError('Argument \\\\'completer\\\\' must be a function');\\r\\n  }\\r\\n\\r\\n  // backwards compat; check the isTTY prop of the output stream\\r\\n  //  when `terminal` was not specified\\r\\n  if (terminal === undefined && !(output === null || output === undefined)) {\\r\\n    terminal = !!output.isTTY;\\r\\n  }\\r\\n\\r\\n  var self = this;\\r\\n\\r\\n  this.output = output;\\r\\n  this.input = input;\\r\\n\\r\\n  // Check arity, 2 - for async, 1 for sync\\r\\n  this.completer = completer.length === 2 ? completer : function(v, callback) {\\r\\n    callback(null, completer(v));\\r\\n  };\\r\\n\\r\\n  this.setPrompt('> ');\\r\\n\\r\\n  this.terminal = !!terminal;\\r\\n\\r\\n  function ondata(data) {\\r\\n    self._normalWrite(data);\\r\\n  }\\r\\n\\r\\n  function onend() {\\r\\n    if (typeof self._line_buffer === 'string' &&\\r\\n        self._line_buffer.length > 0) {\\r\\n      self.emit('line', self._line_buffer);\\r\\n    }\\r\\n    self.close();\\r\\n  }\\r\\n\\r\\n  function ontermend() {\\r\\n    if (typeof self.line === 'string' && self.line.length > 0) {\\r\\n      self.emit('line', self.line);\\r\\n    }\\r\\n    self.close();\\r\\n  }\\r\\n\\r\\n  function onkeypress(s, key) {\\r\\n    self._ttyWrite(s, key);\\r\\n  }\\r\\n\\r\\n  function onresize() {\\r\\n    self._refreshLine();\\r\\n  }\\r\\n\\r\\n  if (!this.terminal) {\\r\\n    input.on('data', ondata);\\r\\n    input.on('end', onend);\\r\\n    self.once('close', function() {\\r\\n      input.removeListener('data', ondata);\\r\\n      input.removeListener('end', onend);\\r\\n    });\\r\\n    var StringDecoder = require('string_decoder').StringDecoder; // lazy load\\r\\n    this._decoder = new StringDecoder('utf8');\\r\\n\\r\\n  } else {\\r\\n\\r\\n    exports.emitKeypressEvents(input);\\r\\n\\r\\n    // input usually refers to stdin\\r\\n    input.on('keypress', onkeypress);\\r\\n    input.on('end', ontermend);\\r\\n\\r\\n    // Current line\\r\\n    this.line = '';\\r\\n\\r\\n    this._setRawMode(true);\\r\\n    this.terminal = true;\\r\\n\\r\\n    // Cursor position on the line.\\r\\n    this.cursor = 0;\\r\\n\\r\\n    this.history = [];\\r\\n    this.historyIndex = -1;\\r\\n\\r\\n    if (output !== null && output !== undefined)\\r\\n      output.on('resize', onresize);\\r\\n\\r\\n    self.once('close', function() {\\r\\n      input.removeListener('keypress', onkeypress);\\r\\n      input.removeListener('end', ontermend);\\r\\n      if (output !== null && output !== undefined) {\\r\\n        output.removeListener('resize', onresize);\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  input.resume();\\r\\n}\\r\\n\\r\\ninherits(Interface, EventEmitter);\\r\\n\\r\\nInterface.prototype.__defineGetter__('columns', function() {\\r\\n  var columns = Infinity;\\r\\n  if (this.output && this.output.columns)\\r\\n    columns = this.output.columns;\\r\\n  return columns;\\r\\n});\\r\\n\\r\\nInterface.prototype.setPrompt = function(prompt) {\\r\\n  this._prompt = prompt;\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._setRawMode = function(mode) {\\r\\n  if (typeof this.input.setRawMode === 'function') {\\r\\n    return this.input.setRawMode(mode);\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.prompt = function(preserveCursor) {\\r\\n  if (this.paused) this.resume();\\r\\n  if (this.terminal) {\\r\\n    if (!preserveCursor) this.cursor = 0;\\r\\n    this._refreshLine();\\r\\n  } else {\\r\\n    this._writeToOutput(this._prompt);\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.question = function(query, cb) {\\r\\n  if (typeof cb === 'function') {\\r\\n    if (this._questionCallback) {\\r\\n      this.prompt();\\r\\n    } else {\\r\\n      this._oldPrompt = this._prompt;\\r\\n      this.setPrompt(query);\\r\\n      this._questionCallback = cb;\\r\\n      this.prompt();\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._onLine = function(line) {\\r\\n  if (this._questionCallback) {\\r\\n    var cb = this._questionCallback;\\r\\n    this._questionCallback = null;\\r\\n    this.setPrompt(this._oldPrompt);\\r\\n    cb(line);\\r\\n  } else {\\r\\n    this.emit('line', line);\\r\\n  }\\r\\n};\\r\\n\\r\\nInterface.prototype._writeToOutput = function _writeToOutput(stringToWrite) {\\r\\n  if (typeof stringToWrite !== 'string')\\r\\n    throw new TypeError('stringToWrite must be a string');\\r\\n\\r\\n  if (this.output !== null && this.output !== undefined)\\r\\n    this.output.write(stringToWrite);\\r\\n};\\r\\n\\r\\nInterface.prototype._addHistory = function() {\\r\\n  if (this.line.length === 0) return '';\\r\\n\\r\\n  if (this.history.length === 0 || this.history[0] !== this.line) {\\r\\n    this.history.unshift(this.line);\\r\\n\\r\\n    // Only store so many\\r\\n    if (this.history.length > kHistorySize) this.history.pop();\\r\\n  }\\r\\n\\r\\n  this.historyIndex = -1;\\r\\n  return this.history[0];\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._refreshLine = function() {\\r\\n  // line length\\r\\n  var line = this._prompt + this.line;\\r\\n  var dispPos = this._getDisplayPos(line);\\r\\n  var lineCols = dispPos.cols;\\r\\n  var lineRows = dispPos.rows;\\r\\n\\r\\n  // cursor position\\r\\n  var cursorPos = this._getCursorPos();\\r\\n\\r\\n  // first move to the bottom of the current line, based on cursor pos\\r\\n  var prevRows = this.prevRows || 0;\\r\\n  if (prevRows > 0) {\\r\\n    exports.moveCursor(this.output, 0, -prevRows);\\r\\n  }\\r\\n\\r\\n  // Cursor to left edge.\\r\\n  exports.cursorTo(this.output, 0);\\r\\n  // erase data\\r\\n  exports.clearScreenDown(this.output);\\r\\n\\r\\n  // Write the prompt and the current buffer content.\\r\\n  this._writeToOutput(line);\\r\\n\\r\\n  // Force terminal to allocate a new line\\r\\n  if (lineCols === 0) {\\r\\n    this._writeToOutput(' ');\\r\\n  }\\r\\n\\r\\n  // Move cursor to original position.\\r\\n  exports.cursorTo(this.output, cursorPos.cols);\\r\\n\\r\\n  var diff = lineRows - cursorPos.rows;\\r\\n  if (diff > 0) {\\r\\n    exports.moveCursor(this.output, 0, -diff);\\r\\n  }\\r\\n\\r\\n  this.prevRows = cursorPos.rows;\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.close = function() {\\r\\n  if (this.closed) return;\\r\\n  this.pause();\\r\\n  if (this.terminal) {\\r\\n    this._setRawMode(false);\\r\\n  }\\r\\n  this.closed = true;\\r\\n  this.emit('close');\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.pause = function() {\\r\\n  if (this.paused) return;\\r\\n  this.input.pause();\\r\\n  this.paused = true;\\r\\n  this.emit('pause');\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.resume = function() {\\r\\n  if (!this.paused) return;\\r\\n  this.input.resume();\\r\\n  this.paused = false;\\r\\n  this.emit('resume');\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.write = function(d, key) {\\r\\n  if (this.paused) this.resume();\\r\\n  this.terminal ? this._ttyWrite(d, key) : this._normalWrite(d);\\r\\n};\\r\\n\\r\\n// \\\\r\\\\n, \\\\n, or \\\\r followed by something other than \\\\n\\r\\nvar lineEnding = /\\\\r?\\\\n|\\\\r(?!\\\\n)/;\\r\\nInterface.prototype._normalWrite = function(b) {\\r\\n  if (b === undefined) {\\r\\n    return;\\r\\n  }\\r\\n  var string = this._decoder.write(b);\\r\\n  if (this._sawReturn) {\\r\\n    string = string.replace(/^\\\\n/, '');\\r\\n    this._sawReturn = false;\\r\\n  }\\r\\n\\r\\n  // Run test() on the new string chunk, not on the entire line buffer.\\r\\n  var newPartContainsEnding = lineEnding.test(string);\\r\\n\\r\\n  if (this._line_buffer) {\\r\\n    string = this._line_buffer + string;\\r\\n    this._line_buffer = null;\\r\\n  }\\r\\n  if (newPartContainsEnding) {\\r\\n    this._sawReturn = /\\\\r$/.test(string);\\r\\n\\r\\n    // got one or more newlines; process into \\\"line\\\" events\\r\\n    var lines = string.split(lineEnding);\\r\\n    // either '' or (concievably) the unfinished portion of the next line\\r\\n    string = lines.pop();\\r\\n    this._line_buffer = string;\\r\\n    lines.forEach(function(line) {\\r\\n      this._onLine(line);\\r\\n    }, this);\\r\\n  } else if (string) {\\r\\n    // no newlines this time, save what we have for next time\\r\\n    this._line_buffer = string;\\r\\n  }\\r\\n};\\r\\n\\r\\nInterface.prototype._insertString = function(c) {\\r\\n  //BUG: Problem when adding tabs with following content.\\r\\n  //     Perhaps the bug is in _refreshLine(). Not sure.\\r\\n  //     A hack would be to insert spaces instead of literal '\\\\t'.\\r\\n  if (this.cursor < this.line.length) {\\r\\n    var beg = this.line.slice(0, this.cursor);\\r\\n    var end = this.line.slice(this.cursor, this.line.length);\\r\\n    this.line = beg + c + end;\\r\\n    this.cursor += c.length;\\r\\n    this._refreshLine();\\r\\n  } else {\\r\\n    this.line += c;\\r\\n    this.cursor += c.length;\\r\\n\\r\\n    if (this._getCursorPos().cols === 0) {\\r\\n      this._refreshLine();\\r\\n    } else {\\r\\n      this._writeToOutput(c);\\r\\n    }\\r\\n\\r\\n    // a hack to get the line refreshed if it's needed\\r\\n    this._moveCursor(0);\\r\\n  }\\r\\n};\\r\\n\\r\\nInterface.prototype._tabComplete = function() {\\r\\n  var self = this;\\r\\n\\r\\n  self.pause();\\r\\n  self.completer(self.line.slice(0, self.cursor), function(err, rv) {\\r\\n    self.resume();\\r\\n\\r\\n    if (err) {\\r\\n      // XXX Log it somewhere?\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    var completions = rv[0],\\r\\n        completeOn = rv[1];  // the text that was completed\\r\\n    if (completions && completions.length) {\\r\\n      // Apply/show completions.\\r\\n      if (completions.length === 1) {\\r\\n        self._insertString(completions[0].slice(completeOn.length));\\r\\n      } else {\\r\\n        self._writeToOutput('\\\\r\\\\n');\\r\\n        var width = completions.reduce(function(a, b) {\\r\\n          return a.length > b.length ? a : b;\\r\\n        }).length + 2;  // 2 space padding\\r\\n        var maxColumns = Math.floor(self.columns / width) || 1;\\r\\n        var group = [], c;\\r\\n        for (var i = 0, compLen = completions.length; i < compLen; i++) {\\r\\n          c = completions[i];\\r\\n          if (c === '') {\\r\\n            handleGroup(self, group, width, maxColumns);\\r\\n            group = [];\\r\\n          } else {\\r\\n            group.push(c);\\r\\n          }\\r\\n        }\\r\\n        handleGroup(self, group, width, maxColumns);\\r\\n\\r\\n        // If there is a common prefix to all matches, then apply that\\r\\n        // portion.\\r\\n        var f = completions.filter(function(e) { if (e) return e; });\\r\\n        var prefix = commonPrefix(f);\\r\\n        if (prefix.length > completeOn.length) {\\r\\n          self._insertString(prefix.slice(completeOn.length));\\r\\n        }\\r\\n\\r\\n      }\\r\\n      self._refreshLine();\\r\\n    }\\r\\n  });\\r\\n};\\r\\n\\r\\n// this = Interface instance\\r\\nfunction handleGroup(self, group, width, maxColumns) {\\r\\n  if (group.length == 0) {\\r\\n    return;\\r\\n  }\\r\\n  var minRows = Math.ceil(group.length / maxColumns);\\r\\n  for (var row = 0; row < minRows; row++) {\\r\\n    for (var col = 0; col < maxColumns; col++) {\\r\\n      var idx = row * maxColumns + col;\\r\\n      if (idx >= group.length) {\\r\\n        break;\\r\\n      }\\r\\n      var item = group[idx];\\r\\n      self._writeToOutput(item);\\r\\n      if (col < maxColumns - 1) {\\r\\n        for (var s = 0, itemLen = item.length; s < width - itemLen;\\r\\n             s++) {\\r\\n          self._writeToOutput(' ');\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    self._writeToOutput('\\\\r\\\\n');\\r\\n  }\\r\\n  self._writeToOutput('\\\\r\\\\n');\\r\\n}\\r\\n\\r\\nfunction commonPrefix(strings) {\\r\\n  if (!strings || strings.length == 0) {\\r\\n    return '';\\r\\n  }\\r\\n  var sorted = strings.slice().sort();\\r\\n  var min = sorted[0];\\r\\n  var max = sorted[sorted.length - 1];\\r\\n  for (var i = 0, len = min.length; i < len; i++) {\\r\\n    if (min[i] != max[i]) {\\r\\n      return min.slice(0, i);\\r\\n    }\\r\\n  }\\r\\n  return min;\\r\\n}\\r\\n\\r\\n\\r\\nInterface.prototype._wordLeft = function() {\\r\\n  if (this.cursor > 0) {\\r\\n    var leading = this.line.slice(0, this.cursor);\\r\\n    var match = leading.match(/([^\\\\w\\\\s]+|\\\\w+|)\\\\s*$/);\\r\\n    this._moveCursor(-match[0].length);\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._wordRight = function() {\\r\\n  if (this.cursor < this.line.length) {\\r\\n    var trailing = this.line.slice(this.cursor);\\r\\n    var match = trailing.match(/^(\\\\s+|\\\\W+|\\\\w+)\\\\s*/);\\r\\n    this._moveCursor(match[0].length);\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._deleteLeft = function() {\\r\\n  if (this.cursor > 0 && this.line.length > 0) {\\r\\n    this.line = this.line.slice(0, this.cursor - 1) +\\r\\n                this.line.slice(this.cursor, this.line.length);\\r\\n\\r\\n    this.cursor--;\\r\\n    this._refreshLine();\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._deleteRight = function() {\\r\\n  this.line = this.line.slice(0, this.cursor) +\\r\\n              this.line.slice(this.cursor + 1, this.line.length);\\r\\n  this._refreshLine();\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._deleteWordLeft = function() {\\r\\n  if (this.cursor > 0) {\\r\\n    var leading = this.line.slice(0, this.cursor);\\r\\n    var match = leading.match(/([^\\\\w\\\\s]+|\\\\w+|)\\\\s*$/);\\r\\n    leading = leading.slice(0, leading.length - match[0].length);\\r\\n    this.line = leading + this.line.slice(this.cursor, this.line.length);\\r\\n    this.cursor = leading.length;\\r\\n    this._refreshLine();\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._deleteWordRight = function() {\\r\\n  if (this.cursor < this.line.length) {\\r\\n    var trailing = this.line.slice(this.cursor);\\r\\n    var match = trailing.match(/^(\\\\s+|\\\\W+|\\\\w+)\\\\s*/);\\r\\n    this.line = this.line.slice(0, this.cursor) +\\r\\n                trailing.slice(match[0].length);\\r\\n    this._refreshLine();\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._deleteLineLeft = function() {\\r\\n  this.line = this.line.slice(this.cursor);\\r\\n  this.cursor = 0;\\r\\n  this._refreshLine();\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._deleteLineRight = function() {\\r\\n  this.line = this.line.slice(0, this.cursor);\\r\\n  this._refreshLine();\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype.clearLine = function() {\\r\\n  this._moveCursor(+Infinity);\\r\\n  this._writeToOutput('\\\\r\\\\n');\\r\\n  this.line = '';\\r\\n  this.cursor = 0;\\r\\n  this.prevRows = 0;\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._line = function() {\\r\\n  var line = this._addHistory();\\r\\n  this.clearLine();\\r\\n  this._onLine(line);\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._historyNext = function() {\\r\\n  if (this.historyIndex > 0) {\\r\\n    this.historyIndex--;\\r\\n    this.line = this.history[this.historyIndex];\\r\\n    this.cursor = this.line.length; // set cursor to end of line.\\r\\n    this._refreshLine();\\r\\n\\r\\n  } else if (this.historyIndex === 0) {\\r\\n    this.historyIndex = -1;\\r\\n    this.cursor = 0;\\r\\n    this.line = '';\\r\\n    this._refreshLine();\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nInterface.prototype._historyPrev = function() {\\r\\n  if (this.historyIndex + 1 < this.history.length) {\\r\\n    this.historyIndex++;\\r\\n    this.line = this.history[this.historyIndex];\\r\\n    this.cursor = this.line.length; // set cursor to end of line.\\r\\n\\r\\n    this._refreshLine();\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\n// Returns the last character's display position of the given string\\r\\nInterface.prototype._getDisplayPos = function(str) {\\r\\n  var offset = 0;\\r\\n  var col = this.columns;\\r\\n  var row = 0;\\r\\n  var code;\\r\\n  str = stripVTControlCharacters(str);\\r\\n  for (var i = 0, len = str.length; i < len; i++) {\\r\\n    code = str.codePointAt(i);\\r\\n    if (code >= 0x10000) { // surrogates\\r\\n      i++;\\r\\n    }\\r\\n    if (code === 0x0a) { // new line \\\\n\\r\\n      offset = 0;\\r\\n      row += 1;\\r\\n      continue;\\r\\n    }\\r\\n    if (isFullWidthCodePoint(code)) {\\r\\n      if ((offset + 1) % col === 0) {\\r\\n        offset++;\\r\\n      }\\r\\n      offset += 2;\\r\\n    } else {\\r\\n      offset++;\\r\\n    }\\r\\n  }\\r\\n  var cols = offset % col;\\r\\n  var rows = row + (offset - cols) / col;\\r\\n  return {cols: cols, rows: rows};\\r\\n};\\r\\n\\r\\n\\r\\n// Returns current cursor's position and line\\r\\nInterface.prototype._getCursorPos = function() {\\r\\n  var columns = this.columns;\\r\\n  var strBeforeCursor = this._prompt + this.line.substring(0, this.cursor);\\r\\n  var dispPos = this._getDisplayPos(stripVTControlCharacters(strBeforeCursor));\\r\\n  var cols = dispPos.cols;\\r\\n  var rows = dispPos.rows;\\r\\n  // If the cursor is on a full-width character which steps over the line,\\r\\n  // move the cursor to the beginning of the next line.\\r\\n  if (cols + 1 === columns &&\\r\\n      this.cursor < this.line.length &&\\r\\n      isFullWidthCodePoint(this.line.codePointAt(this.cursor))) {\\r\\n    rows++;\\r\\n    cols = 0;\\r\\n  }\\r\\n  return {cols: cols, rows: rows};\\r\\n};\\r\\n\\r\\n\\r\\n// This function moves cursor dx places to the right\\r\\n// (-dx for left) and refreshes the line if it is needed\\r\\nInterface.prototype._moveCursor = function(dx) {\\r\\n  var oldcursor = this.cursor;\\r\\n  var oldPos = this._getCursorPos();\\r\\n  this.cursor += dx;\\r\\n\\r\\n  // bounds check\\r\\n  if (this.cursor < 0) this.cursor = 0;\\r\\n  else if (this.cursor > this.line.length) this.cursor = this.line.length;\\r\\n\\r\\n  var newPos = this._getCursorPos();\\r\\n\\r\\n  // check if cursors are in the same line\\r\\n  if (oldPos.rows === newPos.rows) {\\r\\n    var diffCursor = this.cursor - oldcursor;\\r\\n    var diffWidth;\\r\\n    if (diffCursor < 0) {\\r\\n      diffWidth = -getStringWidth(\\r\\n          this.line.substring(this.cursor, oldcursor)\\r\\n          );\\r\\n    } else if (diffCursor > 0) {\\r\\n      diffWidth = getStringWidth(\\r\\n          this.line.substring(this.cursor, oldcursor)\\r\\n          );\\r\\n    }\\r\\n    exports.moveCursor(this.output, diffWidth, 0);\\r\\n    this.prevRows = newPos.rows;\\r\\n  } else {\\r\\n    this._refreshLine();\\r\\n  }\\r\\n};\\r\\n\\r\\n// handle a write from the tty\\r\\nInterface.prototype._ttyWrite = function(s, key) {\\r\\n  key = key || {};\\r\\n  // Ignore escape key - Fixes #2876\\r\\n  if (key.name == 'escape') return;\\r\\n\\r\\n  if (key.ctrl && key.shift) {\\r\\n    /* Control and shift pressed */\\r\\n    switch (key.name) {\\r\\n      case 'backspace':\\r\\n        this._deleteLineLeft();\\r\\n        break;\\r\\n\\r\\n      case 'delete':\\r\\n        this._deleteLineRight();\\r\\n        break;\\r\\n    }\\r\\n\\r\\n  } else if (key.ctrl) {\\r\\n    /* Control key pressed */\\r\\n\\r\\n    switch (key.name) {\\r\\n      case 'c':\\r\\n        if (EventEmitter.listenerCount(this, 'SIGINT') > 0) {\\r\\n          this.emit('SIGINT');\\r\\n        } else {\\r\\n          // This readline instance is finished\\r\\n          this.close();\\r\\n        }\\r\\n        break;\\r\\n\\r\\n      case 'h': // delete left\\r\\n        this._deleteLeft();\\r\\n        break;\\r\\n\\r\\n      case 'd': // delete right or EOF\\r\\n        if (this.cursor === 0 && this.line.length === 0) {\\r\\n          // This readline instance is finished\\r\\n          this.close();\\r\\n        } else if (this.cursor < this.line.length) {\\r\\n          this._deleteRight();\\r\\n        }\\r\\n        break;\\r\\n\\r\\n      case 'u': // delete the whole line\\r\\n        this.cursor = 0;\\r\\n        this.line = '';\\r\\n        this._refreshLine();\\r\\n        break;\\r\\n\\r\\n      case 'k': // delete from current to end of line\\r\\n        this._deleteLineRight();\\r\\n        break;\\r\\n\\r\\n      case 'a': // go to the start of the line\\r\\n        this._moveCursor(-Infinity);\\r\\n        break;\\r\\n\\r\\n      case 'e': // go to the end of the line\\r\\n        this._moveCursor(+Infinity);\\r\\n        break;\\r\\n\\r\\n      case 'b': // back one character\\r\\n        this._moveCursor(-1);\\r\\n        break;\\r\\n\\r\\n      case 'f': // forward one character\\r\\n        this._moveCursor(+1);\\r\\n        break;\\r\\n\\r\\n      case 'l': // clear the whole screen\\r\\n        exports.cursorTo(this.output, 0, 0);\\r\\n        exports.clearScreenDown(this.output);\\r\\n        this._refreshLine();\\r\\n        break;\\r\\n\\r\\n      case 'n': // next history item\\r\\n        this._historyNext();\\r\\n        break;\\r\\n\\r\\n      case 'p': // previous history item\\r\\n        this._historyPrev();\\r\\n        break;\\r\\n\\r\\n      case 'z':\\r\\n        if (process.platform == 'win32') break;\\r\\n        if (EventEmitter.listenerCount(this, 'SIGTSTP') > 0) {\\r\\n          this.emit('SIGTSTP');\\r\\n        } else {\\r\\n          process.once('SIGCONT', (function(self) {\\r\\n            return function() {\\r\\n              // Don't raise events if stream has already been abandoned.\\r\\n              if (!self.paused) {\\r\\n                // Stream must be paused and resumed after SIGCONT to catch\\r\\n                // SIGINT, SIGTSTP, and EOF.\\r\\n                self.pause();\\r\\n                self.emit('SIGCONT');\\r\\n              }\\r\\n              // explicitly re-enable \\\"raw mode\\\" and move the cursor to\\r\\n              // the correct position.\\r\\n              // See https://github.com/joyent/node/issues/3295.\\r\\n              self._setRawMode(true);\\r\\n              self._refreshLine();\\r\\n            };\\r\\n          })(this));\\r\\n          this._setRawMode(false);\\r\\n          process.kill(process.pid, 'SIGTSTP');\\r\\n        }\\r\\n        break;\\r\\n\\r\\n      case 'w': // delete backwards to a word boundary\\r\\n      case 'backspace':\\r\\n        this._deleteWordLeft();\\r\\n        break;\\r\\n\\r\\n      case 'delete': // delete forward to a word boundary\\r\\n        this._deleteWordRight();\\r\\n        break;\\r\\n\\r\\n      case 'left':\\r\\n        this._wordLeft();\\r\\n        break;\\r\\n\\r\\n      case 'right':\\r\\n        this._wordRight();\\r\\n        break;\\r\\n    }\\r\\n\\r\\n  } else if (key.meta) {\\r\\n    /* Meta key pressed */\\r\\n\\r\\n    switch (key.name) {\\r\\n      case 'b': // backward word\\r\\n        this._wordLeft();\\r\\n        break;\\r\\n\\r\\n      case 'f': // forward word\\r\\n        this._wordRight();\\r\\n        break;\\r\\n\\r\\n      case 'd': // delete forward word\\r\\n      case 'delete':\\r\\n        this._deleteWordRight();\\r\\n        break;\\r\\n\\r\\n      case 'backspace': // delete backwards to a word boundary\\r\\n        this._deleteWordLeft();\\r\\n        break;\\r\\n    }\\r\\n\\r\\n  } else {\\r\\n    /* No modifier keys used */\\r\\n\\r\\n    // \\\\r bookkeeping is only relevant if a \\\\n comes right after.\\r\\n    if (this._sawReturn && key.name !== 'enter')\\r\\n      this._sawReturn = false;\\r\\n\\r\\n    switch (key.name) {\\r\\n      case 'return':  // carriage return, i.e. \\\\r\\r\\n        this._sawReturn = true;\\r\\n        this._line();\\r\\n        break;\\r\\n\\r\\n      case 'enter':\\r\\n        if (this._sawReturn)\\r\\n          this._sawReturn = false;\\r\\n        else\\r\\n          this._line();\\r\\n        break;\\r\\n\\r\\n      case 'backspace':\\r\\n        this._deleteLeft();\\r\\n        break;\\r\\n\\r\\n      case 'delete':\\r\\n        this._deleteRight();\\r\\n        break;\\r\\n\\r\\n      case 'tab': // tab completion\\r\\n        this._tabComplete();\\r\\n        break;\\r\\n\\r\\n      case 'left':\\r\\n        this._moveCursor(-1);\\r\\n        break;\\r\\n\\r\\n      case 'right':\\r\\n        this._moveCursor(+1);\\r\\n        break;\\r\\n\\r\\n      case 'home':\\r\\n        this._moveCursor(-Infinity);\\r\\n        break;\\r\\n\\r\\n      case 'end':\\r\\n        this._moveCursor(+Infinity);\\r\\n        break;\\r\\n\\r\\n      case 'up':\\r\\n        this._historyPrev();\\r\\n        break;\\r\\n\\r\\n      case 'down':\\r\\n        this._historyNext();\\r\\n        break;\\r\\n\\r\\n      default:\\r\\n        if (s instanceof Buffer)\\r\\n          s = s.toString('utf-8');\\r\\n\\r\\n        if (s) {\\r\\n          var lines = s.split(/\\\\r\\\\n|\\\\n|\\\\r/);\\r\\n          for (var i = 0, len = lines.length; i < len; i++) {\\r\\n            if (i > 0) {\\r\\n              this._line();\\r\\n            }\\r\\n            this._insertString(lines[i]);\\r\\n          }\\r\\n        }\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nexports.Interface = Interface;\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * accepts a readable Stream instance and makes it emit \\\"keypress\\\" events\\r\\n */\\r\\n\\r\\nfunction emitKeypressEvents(stream) {\\r\\n  if (stream._keypressDecoder) return;\\r\\n  var StringDecoder = require('string_decoder').StringDecoder; // lazy load\\r\\n  stream._keypressDecoder = new StringDecoder('utf8');\\r\\n\\r\\n  function onData(b) {\\r\\n    if (EventEmitter.listenerCount(stream, 'keypress') > 0) {\\r\\n      var r = stream._keypressDecoder.write(b);\\r\\n      if (r) emitKeys(stream, r);\\r\\n    } else {\\r\\n      // Nobody's watching anyway\\r\\n      stream.removeListener('data', onData);\\r\\n      stream.on('newListener', onNewListener);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function onNewListener(event) {\\r\\n    if (event == 'keypress') {\\r\\n      stream.on('data', onData);\\r\\n      stream.removeListener('newListener', onNewListener);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (EventEmitter.listenerCount(stream, 'keypress') > 0) {\\r\\n    stream.on('data', onData);\\r\\n  } else {\\r\\n    stream.on('newListener', onNewListener);\\r\\n  }\\r\\n}\\r\\nexports.emitKeypressEvents = emitKeypressEvents;\\r\\n\\r\\n/*\\r\\n  Some patterns seen in terminal key escape codes, derived from combos seen\\r\\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\\r\\n\\r\\n  ESC letter\\r\\n  ESC [ letter\\r\\n  ESC [ modifier letter\\r\\n  ESC [ 1 ; modifier letter\\r\\n  ESC [ num char\\r\\n  ESC [ num ; modifier char\\r\\n  ESC O letter\\r\\n  ESC O modifier letter\\r\\n  ESC O 1 ; modifier letter\\r\\n  ESC N letter\\r\\n  ESC [ [ num ; modifier char\\r\\n  ESC [ [ 1 ; modifier letter\\r\\n  ESC ESC [ num char\\r\\n  ESC ESC O letter\\r\\n\\r\\n  - char is usually ~ but $ and ^ also happen with rxvt\\r\\n  - modifier is 1 +\\r\\n                (shift     * 1) +\\r\\n                (left_alt  * 2) +\\r\\n                (ctrl      * 4) +\\r\\n                (right_alt * 8)\\r\\n  - two leading ESCs apparently mean the same as one leading ESC\\r\\n*/\\r\\n\\r\\n// Regexes used for ansi escape code splitting\\r\\nvar metaKeyCodeReAnywhere = /(?:\\\\x1b)([a-zA-Z0-9])/;\\r\\nvar metaKeyCodeRe = new RegExp('^' + metaKeyCodeReAnywhere.source + '$');\\r\\nvar functionKeyCodeReAnywhere = new RegExp('(?:\\\\x1b+)(O|N|\\\\\\\\[|\\\\\\\\[\\\\\\\\[)(?:' + [\\r\\n  '(\\\\\\\\d+)(?:;(\\\\\\\\d+))?([~^$])',\\r\\n  '(?:M([@ #!a`])(.)(.))', // mouse\\r\\n  '(?:1;)?(\\\\\\\\d+)?([a-zA-Z])'\\r\\n].join('|') + ')');\\r\\nvar functionKeyCodeRe = new RegExp('^' + functionKeyCodeReAnywhere.source);\\r\\nvar escapeCodeReAnywhere = new RegExp([\\r\\n  functionKeyCodeReAnywhere.source, metaKeyCodeReAnywhere.source, /\\\\x1b./.source\\r\\n].join('|'));\\r\\n\\r\\nfunction emitKeys(stream, s) {\\r\\n  if (s instanceof Buffer) {\\r\\n    if (s[0] > 127 && s[1] === undefined) {\\r\\n      s[0] -= 128;\\r\\n      s = '\\\\x1b' + s.toString(stream.encoding || 'utf-8');\\r\\n    } else {\\r\\n      s = s.toString(stream.encoding || 'utf-8');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var buffer = [];\\r\\n  var match;\\r\\n  while (match = escapeCodeReAnywhere.exec(s)) {\\r\\n    buffer = buffer.concat(s.slice(0, match.index).split(''));\\r\\n    buffer.push(match[0]);\\r\\n    s = s.slice(match.index + match[0].length);\\r\\n  }\\r\\n  buffer = buffer.concat(s.split(''));\\r\\n\\r\\n  buffer.forEach(function(s) {\\r\\n    var ch,\\r\\n        key = {\\r\\n          sequence: s,\\r\\n          name: undefined,\\r\\n          ctrl: false,\\r\\n          meta: false,\\r\\n          shift: false\\r\\n        },\\r\\n        parts;\\r\\n\\r\\n    if (s === '\\\\r') {\\r\\n      // carriage return\\r\\n      key.name = 'return';\\r\\n\\r\\n    } else if (s === '\\\\n') {\\r\\n      // enter, should have been called linefeed\\r\\n      key.name = 'enter';\\r\\n\\r\\n    } else if (s === '\\\\t') {\\r\\n      // tab\\r\\n      key.name = 'tab';\\r\\n\\r\\n    } else if (s === '\\\\b' || s === '\\\\x7f' ||\\r\\n               s === '\\\\x1b\\\\x7f' || s === '\\\\x1b\\\\b') {\\r\\n      // backspace or ctrl+h\\r\\n      key.name = 'backspace';\\r\\n      key.meta = (s.charAt(0) === '\\\\x1b');\\r\\n\\r\\n    } else if (s === '\\\\x1b' || s === '\\\\x1b\\\\x1b') {\\r\\n      // escape key\\r\\n      key.name = 'escape';\\r\\n      key.meta = (s.length === 2);\\r\\n\\r\\n    } else if (s === ' ' || s === '\\\\x1b ') {\\r\\n      key.name = 'space';\\r\\n      key.meta = (s.length === 2);\\r\\n\\r\\n    } else if (s.length === 1 && s <= '\\\\x1a') {\\r\\n      // ctrl+letter\\r\\n      key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);\\r\\n      key.ctrl = true;\\r\\n\\r\\n    } else if (s.length === 1 && s >= 'a' && s <= 'z') {\\r\\n      // lowercase letter\\r\\n      key.name = s;\\r\\n\\r\\n    } else if (s.length === 1 && s >= 'A' && s <= 'Z') {\\r\\n      // shift+letter\\r\\n      key.name = s.toLowerCase();\\r\\n      key.shift = true;\\r\\n\\r\\n    } else if (parts = metaKeyCodeRe.exec(s)) {\\r\\n      // meta+character key\\r\\n      key.name = parts[1].toLowerCase();\\r\\n      key.meta = true;\\r\\n      key.shift = /^[A-Z]$/.test(parts[1]);\\r\\n\\r\\n    } else if (parts = functionKeyCodeRe.exec(s)) {\\r\\n      // ansi escape sequence\\r\\n\\r\\n      // reassemble the key code leaving out leading \\\\x1b's,\\r\\n      // the modifier key bitflag and any meaningless \\\"1;\\\" sequence\\r\\n      var code = (parts[1] || '') + (parts[2] || '') +\\r\\n                 (parts[4] || '') + (parts[9] || ''),\\r\\n          modifier = (parts[3] || parts[8] || 1) - 1;\\r\\n\\r\\n      // Parse the key modifier\\r\\n      key.ctrl = !!(modifier & 4);\\r\\n      key.meta = !!(modifier & 10);\\r\\n      key.shift = !!(modifier & 1);\\r\\n      key.code = code;\\r\\n\\r\\n      // Parse the key itself\\r\\n      switch (code) {\\r\\n        /* xterm/gnome ESC O letter */\\r\\n        case 'OP': key.name = 'f1'; break;\\r\\n        case 'OQ': key.name = 'f2'; break;\\r\\n        case 'OR': key.name = 'f3'; break;\\r\\n        case 'OS': key.name = 'f4'; break;\\r\\n\\r\\n        /* xterm/rxvt ESC [ number ~ */\\r\\n        case '[11~': key.name = 'f1'; break;\\r\\n        case '[12~': key.name = 'f2'; break;\\r\\n        case '[13~': key.name = 'f3'; break;\\r\\n        case '[14~': key.name = 'f4'; break;\\r\\n\\r\\n        /* from Cygwin and used in libuv */\\r\\n        case '[[A': key.name = 'f1'; break;\\r\\n        case '[[B': key.name = 'f2'; break;\\r\\n        case '[[C': key.name = 'f3'; break;\\r\\n        case '[[D': key.name = 'f4'; break;\\r\\n        case '[[E': key.name = 'f5'; break;\\r\\n\\r\\n        /* common */\\r\\n        case '[15~': key.name = 'f5'; break;\\r\\n        case '[17~': key.name = 'f6'; break;\\r\\n        case '[18~': key.name = 'f7'; break;\\r\\n        case '[19~': key.name = 'f8'; break;\\r\\n        case '[20~': key.name = 'f9'; break;\\r\\n        case '[21~': key.name = 'f10'; break;\\r\\n        case '[23~': key.name = 'f11'; break;\\r\\n        case '[24~': key.name = 'f12'; break;\\r\\n\\r\\n        /* xterm ESC [ letter */\\r\\n        case '[A': key.name = 'up'; break;\\r\\n        case '[B': key.name = 'down'; break;\\r\\n        case '[C': key.name = 'right'; break;\\r\\n        case '[D': key.name = 'left'; break;\\r\\n        case '[E': key.name = 'clear'; break;\\r\\n        case '[F': key.name = 'end'; break;\\r\\n        case '[H': key.name = 'home'; break;\\r\\n\\r\\n        /* xterm/gnome ESC O letter */\\r\\n        case 'OA': key.name = 'up'; break;\\r\\n        case 'OB': key.name = 'down'; break;\\r\\n        case 'OC': key.name = 'right'; break;\\r\\n        case 'OD': key.name = 'left'; break;\\r\\n        case 'OE': key.name = 'clear'; break;\\r\\n        case 'OF': key.name = 'end'; break;\\r\\n        case 'OH': key.name = 'home'; break;\\r\\n\\r\\n        /* xterm/rxvt ESC [ number ~ */\\r\\n        case '[1~': key.name = 'home'; break;\\r\\n        case '[2~': key.name = 'insert'; break;\\r\\n        case '[3~': key.name = 'delete'; break;\\r\\n        case '[4~': key.name = 'end'; break;\\r\\n        case '[5~': key.name = 'pageup'; break;\\r\\n        case '[6~': key.name = 'pagedown'; break;\\r\\n\\r\\n        /* putty */\\r\\n        case '[[5~': key.name = 'pageup'; break;\\r\\n        case '[[6~': key.name = 'pagedown'; break;\\r\\n\\r\\n        /* rxvt */\\r\\n        case '[7~': key.name = 'home'; break;\\r\\n        case '[8~': key.name = 'end'; break;\\r\\n\\r\\n        /* rxvt keys with modifiers */\\r\\n        case '[a': key.name = 'up'; key.shift = true; break;\\r\\n        case '[b': key.name = 'down'; key.shift = true; break;\\r\\n        case '[c': key.name = 'right'; key.shift = true; break;\\r\\n        case '[d': key.name = 'left'; key.shift = true; break;\\r\\n        case '[e': key.name = 'clear'; key.shift = true; break;\\r\\n\\r\\n        case '[2$': key.name = 'insert'; key.shift = true; break;\\r\\n        case '[3$': key.name = 'delete'; key.shift = true; break;\\r\\n        case '[5$': key.name = 'pageup'; key.shift = true; break;\\r\\n        case '[6$': key.name = 'pagedown'; key.shift = true; break;\\r\\n        case '[7$': key.name = 'home'; key.shift = true; break;\\r\\n        case '[8$': key.name = 'end'; key.shift = true; break;\\r\\n\\r\\n        case 'Oa': key.name = 'up'; key.ctrl = true; break;\\r\\n        case 'Ob': key.name = 'down'; key.ctrl = true; break;\\r\\n        case 'Oc': key.name = 'right'; key.ctrl = true; break;\\r\\n        case 'Od': key.name = 'left'; key.ctrl = true; break;\\r\\n        case 'Oe': key.name = 'clear'; key.ctrl = true; break;\\r\\n\\r\\n        case '[2^': key.name = 'insert'; key.ctrl = true; break;\\r\\n        case '[3^': key.name = 'delete'; key.ctrl = true; break;\\r\\n        case '[5^': key.name = 'pageup'; key.ctrl = true; break;\\r\\n        case '[6^': key.name = 'pagedown'; key.ctrl = true; break;\\r\\n        case '[7^': key.name = 'home'; key.ctrl = true; break;\\r\\n        case '[8^': key.name = 'end'; key.ctrl = true; break;\\r\\n\\r\\n        /* misc. */\\r\\n        case '[Z': key.name = 'tab'; key.shift = true; break;\\r\\n        default: key.name = 'undefined'; break;\\r\\n\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Don't emit a key if no name was found\\r\\n    if (key.name === undefined) {\\r\\n      key = undefined;\\r\\n    }\\r\\n\\r\\n    if (s.length === 1) {\\r\\n      ch = s;\\r\\n    }\\r\\n\\r\\n    if (key || ch) {\\r\\n      stream.emit('keypress', ch, key);\\r\\n    }\\r\\n  });\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * moves the cursor to the x and y coordinate on the given stream\\r\\n */\\r\\n\\r\\nfunction cursorTo(stream, x, y) {\\r\\n  if (stream === null || stream === undefined)\\r\\n    return;\\r\\n\\r\\n  if (typeof x !== 'number' && typeof y !== 'number')\\r\\n    return;\\r\\n\\r\\n  if (typeof x !== 'number')\\r\\n    throw new Error(\\\"Can't set cursor row without also setting it's column\\\");\\r\\n\\r\\n  if (typeof y !== 'number') {\\r\\n    stream.write('\\\\x1b[' + (x + 1) + 'G');\\r\\n  } else {\\r\\n    stream.write('\\\\x1b[' + (y + 1) + ';' + (x + 1) + 'H');\\r\\n  }\\r\\n}\\r\\nexports.cursorTo = cursorTo;\\r\\n\\r\\n\\r\\n/**\\r\\n * moves the cursor relative to its current location\\r\\n */\\r\\n\\r\\nfunction moveCursor(stream, dx, dy) {\\r\\n  if (stream === null || stream === undefined)\\r\\n    return;\\r\\n\\r\\n  if (dx < 0) {\\r\\n    stream.write('\\\\x1b[' + (-dx) + 'D');\\r\\n  } else if (dx > 0) {\\r\\n    stream.write('\\\\x1b[' + dx + 'C');\\r\\n  }\\r\\n\\r\\n  if (dy < 0) {\\r\\n    stream.write('\\\\x1b[' + (-dy) + 'A');\\r\\n  } else if (dy > 0) {\\r\\n    stream.write('\\\\x1b[' + dy + 'B');\\r\\n  }\\r\\n}\\r\\nexports.moveCursor = moveCursor;\\r\\n\\r\\n\\r\\n/**\\r\\n * clears the current line the cursor is on:\\r\\n *   -1 for left of the cursor\\r\\n *   +1 for right of the cursor\\r\\n *    0 for the entire line\\r\\n */\\r\\n\\r\\nfunction clearLine(stream, dir) {\\r\\n  if (stream === null || stream === undefined)\\r\\n    return;\\r\\n\\r\\n  if (dir < 0) {\\r\\n    // to the beginning\\r\\n    stream.write('\\\\x1b[1K');\\r\\n  } else if (dir > 0) {\\r\\n    // to the end\\r\\n    stream.write('\\\\x1b[0K');\\r\\n  } else {\\r\\n    // entire line\\r\\n    stream.write('\\\\x1b[2K');\\r\\n  }\\r\\n}\\r\\nexports.clearLine = clearLine;\\r\\n\\r\\n\\r\\n/**\\r\\n * clears the screen from the current position of the cursor down\\r\\n */\\r\\n\\r\\nfunction clearScreenDown(stream) {\\r\\n  if (stream === null || stream === undefined)\\r\\n    return;\\r\\n\\r\\n  stream.write('\\\\x1b[0J');\\r\\n}\\r\\nexports.clearScreenDown = clearScreenDown;\\r\\n\\r\\n\\r\\n/**\\r\\n * Returns the number of columns required to display the given string.\\r\\n */\\r\\n\\r\\nfunction getStringWidth(str) {\\r\\n  var width = 0;\\r\\n  str = stripVTControlCharacters(str);\\r\\n  for (var i = 0, len = str.length; i < len; i++) {\\r\\n    var code = str.codePointAt(i);\\r\\n    if (code >= 0x10000) { // surrogates\\r\\n      i++;\\r\\n    }\\r\\n    if (isFullWidthCodePoint(code)) {\\r\\n      width += 2;\\r\\n    } else {\\r\\n      width++;\\r\\n    }\\r\\n  }\\r\\n  return width;\\r\\n}\\r\\nexports.getStringWidth = getStringWidth;\\r\\n\\r\\n\\r\\n/**\\r\\n * Returns true if the character represented by a given\\r\\n * Unicode code point is full-width. Otherwise returns false.\\r\\n */\\r\\n\\r\\nfunction isFullWidthCodePoint(code) {\\r\\n  if (isNaN(code)) {\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  // Code points are derived from:\\r\\n  // http://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\\r\\n  if (code >= 0x1100 && (\\r\\n      code <= 0x115f ||  // Hangul Jamo\\r\\n      0x2329 === code || // LEFT-POINTING ANGLE BRACKET\\r\\n      0x232a === code || // RIGHT-POINTING ANGLE BRACKET\\r\\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\\r\\n      (0x2e80 <= code && code <= 0x3247 && code !== 0x303f) ||\\r\\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\\r\\n      0x3250 <= code && code <= 0x4dbf ||\\r\\n      // CJK Unified Ideographs .. Yi Radicals\\r\\n      0x4e00 <= code && code <= 0xa4c6 ||\\r\\n      // Hangul Jamo Extended-A\\r\\n      0xa960 <= code && code <= 0xa97c ||\\r\\n      // Hangul Syllables\\r\\n      0xac00 <= code && code <= 0xd7a3 ||\\r\\n      // CJK Compatibility Ideographs\\r\\n      0xf900 <= code && code <= 0xfaff ||\\r\\n      // Vertical Forms\\r\\n      0xfe10 <= code && code <= 0xfe19 ||\\r\\n      // CJK Compatibility Forms .. Small Form Variants\\r\\n      0xfe30 <= code && code <= 0xfe6b ||\\r\\n      // Halfwidth and Fullwidth Forms\\r\\n      0xff01 <= code && code <= 0xff60 ||\\r\\n      0xffe0 <= code && code <= 0xffe6 ||\\r\\n      // Kana Supplement\\r\\n      0x1b000 <= code && code <= 0x1b001 ||\\r\\n      // Enclosed Ideographic Supplement\\r\\n      0x1f200 <= code && code <= 0x1f251 ||\\r\\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\\r\\n      0x20000 <= code && code <= 0x3fffd)) {\\r\\n    return true;\\r\\n  }\\r\\n  return false;\\r\\n}\\r\\nexports.isFullWidthCodePoint = isFullWidthCodePoint;\\r\\n\\r\\n\\r\\n/**\\r\\n * Returns the Unicode code point for the character at the\\r\\n * given index in the given string. Similar to String.charCodeAt(),\\r\\n * but this function handles surrogates (code point >= 0x10000).\\r\\n */\\r\\n\\r\\nfunction codePointAt(str, index) {\\r\\n  var code = str.charCodeAt(index);\\r\\n  var low;\\r\\n  if (0xd800 <= code && code <= 0xdbff) { // High surrogate\\r\\n    low = str.charCodeAt(index + 1);\\r\\n    if (!isNaN(low)) {\\r\\n      code = 0x10000 + (code - 0xd800) * 0x400 + (low - 0xdc00);\\r\\n    }\\r\\n  }\\r\\n  return code;\\r\\n}\\r\\nexports.codePointAt = util.deprecate(codePointAt,\\r\\n    'codePointAt() is deprecated. Use String.prototype.codePointAt');\\r\\n\\r\\n\\r\\n/**\\r\\n * Tries to remove all VT control characters. Use to estimate displayed\\r\\n * string width. May be buggy due to not running a real state machine\\r\\n */\\r\\nfunction stripVTControlCharacters(str) {\\r\\n  str = str.replace(new RegExp(functionKeyCodeReAnywhere.source, 'g'), '');\\r\\n  return str.replace(new RegExp(metaKeyCodeReAnywhere.source, 'g'), '');\\r\\n}\\r\\nexports.stripVTControlCharacters = stripVTControlCharacters;\\r\\n\",\"querystring\":\"// Query String Utilities\\r\\n\\r\\nvar QueryString = exports;\\r\\nvar urlDecode = process.binding(\\\"http_parser\\\").urlDecode;\\r\\n\\r\\n// a safe fast alternative to decodeURIComponent\\r\\nQueryString.unescape = urlDecode;\\r\\n\\r\\nQueryString.escape = function (str) {\\r\\n  return encodeURIComponent(str);\\r\\n};\\r\\n\\r\\nvar stringifyPrimitive = function(v) {\\r\\n  switch (typeof v) {\\r\\n    case \\\"string\\\":\\r\\n      return v;\\r\\n\\r\\n    case \\\"boolean\\\":\\r\\n      return v ? \\\"true\\\" : \\\"false\\\";\\r\\n\\r\\n    case \\\"number\\\":\\r\\n      return isFinite(v) ? v : \\\"\\\";\\r\\n\\r\\n    default:\\r\\n      return \\\"\\\";\\r\\n  }\\r\\n};\\r\\n\\r\\n/**\\r\\n * <p>Converts an arbitrary value to a Query String representation.</p>\\r\\n *\\r\\n * <p>Objects with cyclical references will trigger an exception.</p>\\r\\n *\\r\\n * @method stringify\\r\\n * @param obj {Variant} any arbitrary value to convert to query string\\r\\n * @param sep {String} (optional) Character that should join param k=v pairs together. Default: \\\"&\\\"\\r\\n * @param eq  {String} (optional) Character that should join keys to their values. Default: \\\"=\\\"\\r\\n * @param name {String} (optional) Name of the current key, for handling children recursively.\\r\\n * @static\\r\\n */\\r\\nQueryString.stringify = QueryString.encode = function (obj, sep, eq, name) {\\r\\n  sep = sep || \\\"&\\\";\\r\\n  eq = eq || \\\"=\\\";\\r\\n  obj = (obj === null) ? undefined : obj;\\r\\n\\r\\n  switch (typeof obj) {\\r\\n    case \\\"object\\\":\\r\\n      return Object.keys(obj).map(function(k) {\\r\\n        if (Array.isArray(obj[k])) {\\r\\n          return obj[k].map(function(v) {\\r\\n            return QueryString.escape(stringifyPrimitive(k)) +\\r\\n                   eq +\\r\\n                   QueryString.escape(stringifyPrimitive(v));\\r\\n          }).join(sep);\\r\\n        } else {\\r\\n          return QueryString.escape(stringifyPrimitive(k)) + \\r\\n                 eq +\\r\\n                 QueryString.escape(stringifyPrimitive(obj[k]));\\r\\n        }\\r\\n      }).join(sep);\\r\\n\\r\\n    default:\\r\\n      return (name) ?\\r\\n        QueryString.escape(stringifyPrimitive(name)) + eq +\\r\\n          QueryString.escape(stringifyPrimitive(obj)) :\\r\\n        \\\"\\\";\\r\\n  }\\r\\n};\\r\\n\\r\\n// Parse a key=val string.\\r\\nQueryString.parse = QueryString.decode = function (qs, sep, eq) {\\r\\n  sep = sep || \\\"&\\\";\\r\\n  eq = eq || \\\"=\\\";\\r\\n  var obj = {};\\r\\n\\r\\n  if (typeof qs !== 'string') {\\r\\n    return obj;\\r\\n  }\\r\\n\\r\\n  qs.split(sep).forEach(function(kvp) {\\r\\n    var x = kvp.split(eq);\\r\\n    var k = QueryString.unescape(x[0], true);\\r\\n    var v = QueryString.unescape(x.slice(1).join(eq), true);\\r\\n\\r\\n    if (!(k in obj)) {\\r\\n        obj[k] = v;\\r\\n    } else if (!Array.isArray(obj[k])) {\\r\\n        obj[k] = [obj[k], v];\\r\\n    } else {\\r\\n        obj[k].push(v);\\r\\n    }\\r\\n  });\\r\\n\\r\\n  return obj;\\r\\n};\\r\\n\",\"assert\":\"// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\\n//\\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\\n//\\n// Originally from narwhal.js (http://narwhaljs.org)\\n// Copyright (c) 2009 Thomas Robinson <280north.com>\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the 'Software'), to\\n// deal in the Software without restriction, including without limitation the\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\\n// sell copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// UTILITY\\nvar util = require('util');\\nvar pSlice = Array.prototype.slice;\\n\\n// 1. The assert module provides functions that throw\\n// AssertionError's when particular conditions are not met. The\\n// assert module must conform to the following interface.\\n\\nvar assert = module.exports = ok;\\n\\n// 2. The AssertionError is defined in assert.\\n// new assert.AssertionError({ message: message,\\n//                             actual: actual,\\n//                             expected: expected })\\n\\nassert.AssertionError = function AssertionError(options) {\\n  this.name = 'AssertionError';\\n  this.actual = options.actual;\\n  this.expected = options.expected;\\n  this.operator = options.operator;\\n  if (options.message) {\\n    this.message = options.message;\\n    this.generatedMessage = false;\\n  } else {\\n    this.message = getMessage(this);\\n    this.generatedMessage = true;\\n  }\\n  var stackStartFunction = options.stackStartFunction || fail;\\n  //Error.captureStackTrace(this, stackStartFunction);\\n};\\n\\n// assert.AssertionError instanceof Error\\nutil.inherits(assert.AssertionError, Error);\\n\\nfunction replacer(key, value) {\\n  if (util.isUndefined(value)) {\\n    return '' + value;\\n  }\\n  if (util.isNumber(value) && !isFinite(value)) {\\n    return value.toString();\\n  }\\n  if (util.isFunction(value) || util.isRegExp(value)) {\\n    return value.toString();\\n  }\\n  return value;\\n}\\n\\nfunction truncate(s, n) {\\n  if (util.isString(s)) {\\n    return s.length < n ? s : s.slice(0, n);\\n  } else {\\n    return s;\\n  }\\n}\\n\\nfunction getMessage(self) {\\n  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +\\n         self.operator + ' ' +\\n         truncate(JSON.stringify(self.expected, replacer), 128);\\n}\\n\\n// At present only the three keys mentioned above are used and\\n// understood by the spec. Implementations or sub modules can pass\\n// other keys to the AssertionError's constructor - they will be\\n// ignored.\\n\\n// 3. All of the following functions must throw an AssertionError\\n// when a corresponding condition is not met, with a message that\\n// may be undefined if not provided.  All assertion methods provide\\n// both the actual and expected values to the assertion error for\\n// display purposes.\\n\\nfunction fail(actual, expected, message, operator, stackStartFunction) {\\n  throw new assert.AssertionError({\\n    message: message,\\n    actual: actual,\\n    expected: expected,\\n    operator: operator,\\n    stackStartFunction: stackStartFunction\\n  });\\n}\\n\\n// EXTENSION! allows for well behaved errors defined elsewhere.\\nassert.fail = fail;\\n\\n// 4. Pure assertion tests whether a value is truthy, as determined\\n// by !!guard.\\n// assert.ok(guard, message_opt);\\n// This statement is equivalent to assert.equal(true, !!guard,\\n// message_opt);. To test strictly for the value true, use\\n// assert.strictEqual(true, guard, message_opt);.\\n\\nfunction ok(value, message) {\\n  if (!value) fail(value, true, message, '==', assert.ok);\\n}\\nassert.ok = ok;\\n\\n// 5. The equality assertion tests shallow, coercive equality with\\n// ==.\\n// assert.equal(actual, expected, message_opt);\\n\\nassert.equal = function equal(actual, expected, message) {\\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\\n};\\n\\n// 6. The non-equality assertion tests for whether two objects are not equal\\n// with != assert.notEqual(actual, expected, message_opt);\\n\\nassert.notEqual = function notEqual(actual, expected, message) {\\n  if (actual == expected) {\\n    fail(actual, expected, message, '!=', assert.notEqual);\\n  }\\n};\\n\\n// 7. The equivalence assertion tests a deep equality relation.\\n// assert.deepEqual(actual, expected, message_opt);\\n\\nassert.deepEqual = function deepEqual(actual, expected, message) {\\n  if (!_deepEqual(actual, expected)) {\\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\\n  }\\n};\\n\\nfunction _deepEqual(actual, expected) {\\n  // 7.1. All identical values are equivalent, as determined by ===.\\n  if (actual === expected) {\\n    return true;\\n\\n  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {\\n    if (actual.length != expected.length) return false;\\n\\n    for (var i = 0; i < actual.length; i++) {\\n      if (actual[i] !== expected[i]) return false;\\n    }\\n\\n    return true;\\n\\n  // 7.2. If the expected value is a Date object, the actual value is\\n  // equivalent if it is also a Date object that refers to the same time.\\n  } else if (util.isDate(actual) && util.isDate(expected)) {\\n    return actual.getTime() === expected.getTime();\\n\\n  // 7.3 If the expected value is a RegExp object, the actual value is\\n  // equivalent if it is also a RegExp object with the same source and\\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\\n    return actual.source === expected.source &&\\n           actual.global === expected.global &&\\n           actual.multiline === expected.multiline &&\\n           actual.lastIndex === expected.lastIndex &&\\n           actual.ignoreCase === expected.ignoreCase;\\n\\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\\n  // equivalence is determined by ==.\\n  } else if (!util.isObject(actual) && !util.isObject(expected)) {\\n    return actual == expected;\\n\\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\\n  // determined by having the same number of owned properties (as verified\\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\\n  // (although not necessarily the same order), equivalent values for every\\n  // corresponding key, and an identical 'prototype' property. Note: this\\n  // accounts for both named and indexed properties on Arrays.\\n  } else {\\n    return objEquiv(actual, expected);\\n  }\\n}\\n\\nfunction isArguments(object) {\\n  return Object.prototype.toString.call(object) == '[object Arguments]';\\n}\\n\\nfunction objEquiv(a, b) {\\n  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))\\n    return false;\\n  // an identical 'prototype' property.\\n  if (a.prototype !== b.prototype) return false;\\n  //~~~I've managed to break Object.keys through screwy arguments passing.\\n  //   Converting to array solves the problem.\\n  var aIsArgs = isArguments(a),\\n      bIsArgs = isArguments(b);\\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\\n    return false;\\n  if (aIsArgs) {\\n    a = pSlice.call(a);\\n    b = pSlice.call(b);\\n    return _deepEqual(a, b);\\n  }\\n  try {\\n    var ka = Object.keys(a),\\n        kb = Object.keys(b),\\n        key, i;\\n  } catch (e) {//happens when one is a string literal and the other isn't\\n    return false;\\n  }\\n  // having the same number of owned properties (keys incorporates\\n  // hasOwnProperty)\\n  if (ka.length != kb.length)\\n    return false;\\n  //the same set of keys (although not necessarily the same order),\\n  ka.sort();\\n  kb.sort();\\n  //~~~cheap key test\\n  for (i = ka.length - 1; i >= 0; i--) {\\n    if (ka[i] != kb[i])\\n      return false;\\n  }\\n  //equivalent values for every corresponding key, and\\n  //~~~possibly expensive deep test\\n  for (i = ka.length - 1; i >= 0; i--) {\\n    key = ka[i];\\n    if (!_deepEqual(a[key], b[key])) return false;\\n  }\\n  return true;\\n}\\n\\n// 8. The non-equivalence assertion tests for any deep inequality.\\n// assert.notDeepEqual(actual, expected, message_opt);\\n\\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\\n  if (_deepEqual(actual, expected)) {\\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\\n  }\\n};\\n\\n// 9. The strict equality assertion tests strict equality, as determined by ===.\\n// assert.strictEqual(actual, expected, message_opt);\\n\\nassert.strictEqual = function strictEqual(actual, expected, message) {\\n  if (actual !== expected) {\\n    fail(actual, expected, message, '===', assert.strictEqual);\\n  }\\n};\\n\\n// 10. The strict non-equality assertion tests for strict inequality, as\\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\\n\\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\\n  if (actual === expected) {\\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\\n  }\\n};\\n\\nfunction expectedException(actual, expected) {\\n  if (!actual || !expected) {\\n    return false;\\n  }\\n\\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\\n    return expected.test(actual);\\n  } else if (actual instanceof expected) {\\n    return true;\\n  } else if (expected.call({}, actual) === true) {\\n    return true;\\n  }\\n\\n  return false;\\n}\\n\\nfunction _throws(shouldThrow, block, expected, message) {\\n  var actual;\\n\\n  if (util.isString(expected)) {\\n    message = expected;\\n    expected = null;\\n  }\\n\\n  try {\\n    block();\\n  } catch (e) {\\n    actual = e;\\n  }\\n\\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\\n            (message ? ' ' + message : '.');\\n\\n  if (shouldThrow && !actual) {\\n    fail(actual, expected, 'Missing expected exception' + message);\\n  }\\n\\n  if (!shouldThrow && expectedException(actual, expected)) {\\n    fail(actual, expected, 'Got unwanted exception' + message);\\n  }\\n\\n  if ((shouldThrow && actual && expected &&\\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\\n    throw actual;\\n  }\\n}\\n\\n// 11. Expected to throw an error:\\n// assert.throws(block, Error_opt, message_opt);\\n\\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\\n};\\n\\n// EXTENSION! This is annoying to write outside this module.\\nassert.doesNotThrow = function(block, /*optional*/message) {\\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\\n};\\n\\nassert.ifError = function(err) { if (err) {throw err;}};\\n\",\"console\":\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nvar util = require('util');\\nvar NEWLINE = '';\\n\\nfunction Console(stdout, stderr) {\\n  if (!(this instanceof Console)) {\\n    return new Console(stdout, stderr);\\n  }\\n  if (!stdout || !util.isFunction(stdout.write)) {\\n    throw new TypeError('Console expects a writable stream instance');\\n  }\\n  if (!stderr) {\\n    stderr = stdout;\\n  }\\n  var prop = {\\n    writable: true,\\n    enumerable: false,\\n    configurable: true\\n  };\\n  prop.value = stdout;\\n  Object.defineProperty(this, '_stdout', prop);\\n  prop.value = stderr;\\n  Object.defineProperty(this, '_stderr', prop);\\n  prop.value = {};\\n  Object.defineProperty(this, '_times', prop);\\n\\n  // bind the prototype functions to this Console instance\\n  Object.keys(Console.prototype).forEach(function(k) {\\n    this[k] = this[k].bind(this);\\n  }, this);\\n}\\n\\nConsole.prototype.log = function() {\\n  this._stdout.write(util.format.apply(this, arguments) + NEWLINE );\\n};\\n\\n\\nConsole.prototype.info = Console.prototype.log;\\n\\n\\nConsole.prototype.warn = function() {\\n  this._stderr.write(util.format.apply(this, arguments) + NEWLINE );\\n};\\n\\n\\nConsole.prototype.error = Console.prototype.warn;\\n\\n\\nConsole.prototype.dir = function(object, options) {\\n  this._stdout.write(util.inspect(object, util._extend({\\n    customInspect: false\\n  }, options)) + NEWLINE );\\n};\\n\\n\\nConsole.prototype.time = function(label) {\\n  this._times[label] = Date.now();\\n};\\n\\n\\nConsole.prototype.timeEnd = function(label) {\\n  var time = this._times[label];\\n  if (!time) {\\n    throw new Error('No such label: ' + label);\\n  }\\n  var duration = Date.now() - time;\\n  this.log('%s: %dms', label, duration);\\n};\\n\\n\\nConsole.prototype.trace = function() {\\n  // TODO probably can to do this better with V8's debug object once that is\\n  // exposed.\\n  var err = new Error;\\n  err.name = 'Trace';\\n  err.message = util.format.apply(this, arguments);\\n  Error.captureStackTrace(err, arguments.callee);\\n  this.error(err.stack);\\n};\\n\\n\\nConsole.prototype.assert = function(expression) {\\n  if (!expression) {\\n    var arr = Array.prototype.slice.call(arguments, 1);\\n    require('assert').ok(false, util.format.apply(this, arr));\\n  }\\n};\\n\\nvar std = {\\n  write : print\\n};\\n\\nmodule.exports = new Console(std, std);\\nmodule.exports.Console = Console;\\n\",\"constants\":\"'use strict';\\r\\n\\r\\nmodule.exports = process.binding('constants');\\r\\n\",\"events\":\"'use strict';\\n\\nvar domain;\\n\\nfunction EventEmitter() {\\n  EventEmitter.init.call(this);\\n}\\nmodule.exports = EventEmitter;\\n\\n// Backwards-compat with node 0.10.x\\nEventEmitter.EventEmitter = EventEmitter;\\n\\nEventEmitter.usingDomains = false;\\n\\nEventEmitter.prototype.domain = undefined;\\nEventEmitter.prototype._events = undefined;\\nEventEmitter.prototype._maxListeners = undefined;\\n\\n// By default EventEmitters will print a warning if more than 10 listeners are\\n// added to it. This is a useful default which helps finding memory leaks.\\nEventEmitter.defaultMaxListeners = 10;\\n\\nEventEmitter.init = function() {\\n  this.domain = null;\\n  if (EventEmitter.usingDomains) {\\n    // if there is an active domain, then attach to it.\\n    domain = domain || require('domain');\\n    if (domain.active && !(this instanceof domain.Domain)) {\\n      this.domain = domain.active;\\n    }\\n  }\\n\\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\\n    this._events = {};\\n    this._eventsCount = 0;\\n  }\\n\\n  this._maxListeners = this._maxListeners || undefined;\\n};\\n\\n// Obviously not all Emitters should be limited to 10. This function allows\\n// that to be increased. Set to zero for unlimited.\\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\\n    throw new TypeError('\\\"n\\\" argument must be a positive number');\\n  this._maxListeners = n;\\n  return this;\\n};\\n\\nfunction $getMaxListeners(that) {\\n  if (that._maxListeners === undefined)\\n    return EventEmitter.defaultMaxListeners;\\n  return that._maxListeners;\\n}\\n\\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\\n  return $getMaxListeners(this);\\n};\\n\\n// These standalone emit* functions are used to optimize calling of event\\n// handlers for fast cases because emit() itself often has a variable number of\\n// arguments and can be deoptimized because of that. These functions always have\\n// the same number of arguments and thus do not get deoptimized, so the code\\n// inside them can execute faster.\\nfunction emitNone(handler, isFn, self) {\\n  if (isFn)\\n    handler.call(self);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].call(self);\\n  }\\n}\\nfunction emitOne(handler, isFn, self, arg1) {\\n  if (isFn)\\n    handler.call(self, arg1);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].call(self, arg1);\\n  }\\n}\\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\\n  if (isFn)\\n    handler.call(self, arg1, arg2);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].call(self, arg1, arg2);\\n  }\\n}\\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\\n  if (isFn)\\n    handler.call(self, arg1, arg2, arg3);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].call(self, arg1, arg2, arg3);\\n  }\\n}\\n\\nfunction emitMany(handler, isFn, self, args) {\\n  if (isFn)\\n    handler.apply(self, args);\\n  else {\\n    var len = handler.length;\\n    var listeners = arrayClone(handler, len);\\n    for (var i = 0; i < len; ++i)\\n      listeners[i].apply(self, args);\\n  }\\n}\\n\\nEventEmitter.prototype.emit = function emit(type) {\\n  var er, handler, len, args, i, events, domain;\\n  var needDomainExit = false;\\n  var doError = (type === 'error');\\n\\n  events = this._events;\\n  if (events)\\n    doError = (doError && events.error == null);\\n  else if (!doError)\\n    return false;\\n\\n  domain = this.domain;\\n\\n  // If there is no 'error' event listener then throw.\\n  if (doError) {\\n    er = arguments[1];\\n    if (domain) {\\n      if (!er)\\n        er = new Error('Uncaught, unspecified \\\"error\\\" event');\\n      er.domainEmitter = this;\\n      er.domain = domain;\\n      er.domainThrown = false;\\n      domain.emit('error', er);\\n    } else if (er instanceof Error) {\\n      throw er; // Unhandled 'error' event\\n    } else {\\n      // At least give some kind of context to the user\\n      var err = new Error('Uncaught, unspecified \\\"error\\\" event. (' + er + ')');\\n      err.context = er;\\n      throw err;\\n    }\\n    return false;\\n  }\\n\\n  handler = events[type];\\n\\n  if (!handler)\\n    return false;\\n\\n  if (domain && this !== process) {\\n    domain.enter();\\n    needDomainExit = true;\\n  }\\n\\n  var isFn = typeof handler === 'function';\\n  len = arguments.length;\\n  switch (len) {\\n    // fast cases\\n    case 1:\\n      emitNone(handler, isFn, this);\\n      break;\\n    case 2:\\n      emitOne(handler, isFn, this, arguments[1]);\\n      break;\\n    case 3:\\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\\n      break;\\n    case 4:\\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\\n      break;\\n    // slower\\n    default:\\n      args = new Array(len - 1);\\n      for (i = 1; i < len; i++)\\n        args[i - 1] = arguments[i];\\n      emitMany(handler, isFn, this, args);\\n  }\\n\\n  if (needDomainExit)\\n    domain.exit();\\n\\n  return true;\\n};\\n\\nEventEmitter.prototype.addListener = function addListener(type, listener) {\\n  var m;\\n  var events;\\n  var existing;\\n\\n  if (typeof listener !== 'function')\\n    throw new TypeError('\\\"listener\\\" argument must be a function');\\n\\n  events = this._events;\\n  if (!events) {\\n    events = this._events = {};\\n    this._eventsCount = 0;\\n  } else {\\n    // To avoid recursion in the case that type === \\\"newListener\\\"! Before\\n    // adding it to the listeners, first emit \\\"newListener\\\".\\n    if (events.newListener) {\\n      this.emit('newListener', type,\\n                listener.listener ? listener.listener : listener);\\n\\n      // Re-assign `events` because a newListener handler could have caused the\\n      // this._events to be assigned to a new object\\n      events = this._events;\\n    }\\n    existing = events[type];\\n  }\\n\\n  if (!existing) {\\n    // Optimize the case of one listener. Don't need the extra array object.\\n    existing = events[type] = listener;\\n    ++this._eventsCount;\\n  } else {\\n    if (typeof existing === 'function') {\\n      // Adding the second element, need to change to array.\\n      existing = events[type] = [existing, listener];\\n    } else {\\n      // If we've already got an array, just append.\\n      existing.push(listener);\\n    }\\n\\n    // Check for listener leak\\n    if (!existing.warned) {\\n      m = $getMaxListeners(this);\\n      if (m && m > 0 && existing.length > m) {\\n        existing.warned = true;\\n        console.error('(node) warning: possible EventEmitter memory ' +\\n                      'leak detected. %d %s listeners added. ' +\\n                      'Use emitter.setMaxListeners() to increase limit.',\\n                      existing.length, type);\\n        console.trace();\\n      }\\n    }\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\\n\\nEventEmitter.prototype.once = function once(type, listener) {\\n  if (typeof listener !== 'function')\\n    throw new TypeError('\\\"listener\\\" argument must be a function');\\n\\n  var fired = false;\\n\\n  function g() {\\n    this.removeListener(type, g);\\n\\n    if (!fired) {\\n      fired = true;\\n      listener.apply(this, arguments);\\n    }\\n  }\\n\\n  g.listener = listener;\\n  this.on(type, g);\\n\\n  return this;\\n};\\n\\n// emits a 'removeListener' event iff the listener was removed\\nEventEmitter.prototype.removeListener =\\n    function removeListener(type, listener) {\\n      var list, events, position, i;\\n\\n      if (typeof listener !== 'function')\\n        throw new TypeError('\\\"listener\\\" argument must be a function');\\n\\n      events = this._events;\\n      if (!events)\\n        return this;\\n\\n      list = events[type];\\n      if (!list)\\n        return this;\\n\\n      if (list === listener || (list.listener && list.listener === listener)) {\\n        if (--this._eventsCount === 0)\\n          this._events = {};\\n        else {\\n          delete events[type];\\n          if (events.removeListener)\\n            this.emit('removeListener', type, listener);\\n        }\\n      } else if (typeof list !== 'function') {\\n        position = -1;\\n\\n        for (i = list.length; i-- > 0;) {\\n          if (list[i] === listener ||\\n              (list[i].listener && list[i].listener === listener)) {\\n            position = i;\\n            break;\\n          }\\n        }\\n\\n        if (position < 0)\\n          return this;\\n\\n        if (list.length === 1) {\\n          list[0] = undefined;\\n          if (--this._eventsCount === 0) {\\n            this._events = {};\\n            return this;\\n          } else {\\n            delete events[type];\\n          }\\n        } else {\\n          spliceOne(list, position);\\n        }\\n\\n        if (events.removeListener)\\n          this.emit('removeListener', type, listener);\\n      }\\n\\n      return this;\\n    };\\n\\nEventEmitter.prototype.removeAllListeners =\\n    function removeAllListeners(type) {\\n      var listeners, events;\\n\\n      events = this._events;\\n      if (!events)\\n        return this;\\n\\n      // not listening for removeListener, no need to emit\\n      if (!events.removeListener) {\\n        if (arguments.length === 0) {\\n          this._events = {};\\n          this._eventsCount = 0;\\n        } else if (events[type]) {\\n          if (--this._eventsCount === 0)\\n            this._events = {};\\n          else\\n            delete events[type];\\n        }\\n        return this;\\n      }\\n\\n      // emit removeListener for all listeners on all events\\n      if (arguments.length === 0) {\\n        var keys = Object.keys(events);\\n        for (var i = 0, key; i < keys.length; ++i) {\\n          key = keys[i];\\n          if (key === 'removeListener') continue;\\n          this.removeAllListeners(key);\\n        }\\n        this.removeAllListeners('removeListener');\\n        this._events = {};\\n        this._eventsCount = 0;\\n        return this;\\n      }\\n\\n      listeners = events[type];\\n\\n      if (typeof listeners === 'function') {\\n        this.removeListener(type, listeners);\\n      } else if (listeners) {\\n        // LIFO order\\n        do {\\n          this.removeListener(type, listeners[listeners.length - 1]);\\n        } while (listeners[0]);\\n      }\\n\\n      return this;\\n    };\\n\\nEventEmitter.prototype.listeners = function listeners(type) {\\n  var evlistener;\\n  var ret;\\n  var events = this._events;\\n\\n  if (!events)\\n    ret = [];\\n  else {\\n    evlistener = events[type];\\n    if (!evlistener)\\n      ret = [];\\n    else if (typeof evlistener === 'function')\\n      ret = [evlistener];\\n    else\\n      ret = arrayClone(evlistener, evlistener.length);\\n  }\\n\\n  return ret;\\n};\\n\\nEventEmitter.listenerCount = function(emitter, type) {\\n  if (typeof emitter.listenerCount === 'function') {\\n    return emitter.listenerCount(type);\\n  } else {\\n    return listenerCount.call(emitter, type);\\n  }\\n};\\n\\nEventEmitter.prototype.listenerCount = listenerCount;\\nfunction listenerCount(type) {\\n  var events = this._events;\\n\\n  if (events) {\\n    var evlistener = events[type];\\n\\n    if (typeof evlistener === 'function') {\\n      return 1;\\n    } else if (evlistener) {\\n      return evlistener.length;\\n    }\\n  }\\n\\n  return 0;\\n};\\n\\n// About 1.5x faster than the two-arg version of Array#splice().\\nfunction spliceOne(list, index) {\\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\\n    list[i] = list[k];\\n  list.pop();\\n}\\n\\nfunction arrayClone(arr, i) {\\n  var copy = new Array(i);\\n  while (i--)\\n    copy[i] = arr[i];\\n  return copy;\\n}\\n\",\"timers\":\"'use strict';\\n\\nvar Timer = process.binding('timer_wrap').Timer;\\nvar L = require('internal/linkedlist');\\nvar assert = require('assert').ok;\\nvar util = require('util');\\nvar debug = util.debuglog('timer');\\nvar kOnTimeout = Timer.kOnTimeout;\\n\\n// Timeout values > TIMEOUT_MAX are set to 1.\\nvar TIMEOUT_MAX = 2147483647; // 2^31-1\\n\\n// IDLE TIMEOUTS\\n//\\n// Because often many sockets will have the same idle timeout we will not\\n// use one timeout watcher per item. It is too much overhead.  Instead\\n// we'll use a single watcher for all sockets with the same timeout value\\n// and a linked list. This technique is described in the libev manual:\\n// http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts\\n\\n// Object containing all lists, timers\\n// key = time in milliseconds\\n// value = list\\nvar lists = {};\\n\\n\\n// call this whenever the item is active (not idle)\\n// it will reset its timeout.\\n// the main function - creates lists on demand and the watchers associated\\n// with them.\\nexports.active = function(item) {\\n  var msecs = item._idleTimeout;\\n  if (msecs < 0 || msecs === undefined) return;\\n\\n  item._idleStart = Timer.now();\\n\\n  var list;\\n\\n  if (lists[msecs]) {\\n    list = lists[msecs];\\n  } else {\\n    list = new Timer();\\n    list.start(msecs, 0);\\n\\n    L.init(list);\\n\\n    lists[msecs] = list;\\n    list.msecs = msecs;\\n    list[kOnTimeout] = listOnTimeout;\\n  }\\n\\n  L.append(list, item);\\n  assert(!L.isEmpty(list)); // list is not empty\\n};\\n\\nfunction listOnTimeout() {\\n  var msecs = this.msecs;\\n  var list = this;\\n\\n  debug('timeout callback %d', msecs);\\n\\n  var now = Timer.now();\\n  debug('now: %s', now);\\n\\n  var diff, first, threw;\\n  while (first = L.peek(list)) {\\n    diff = now - first._idleStart;\\n    if (diff < msecs) {\\n      list.start(msecs - diff, 0);\\n      debug('%d list wait because diff is %d', msecs, diff);\\n      return;\\n    } else {\\n      L.remove(first);\\n      assert(first !== L.peek(list));\\n\\n      if (!first._onTimeout) continue;\\n\\n      // v0.4 compatibility: if the timer callback throws and the\\n      // domain or uncaughtException handler ignore the exception,\\n      // other timers that expire on this tick should still run.\\n      //\\n      // https://github.com/joyent/node/issues/2631\\n      var domain = first.domain;\\n      if (domain && domain._disposed)\\n        continue;\\n\\n      try {\\n        if (domain)\\n          domain.enter();\\n        threw = true;\\n        first._called = true;\\n        first._onTimeout();\\n        if (domain)\\n          domain.exit();\\n        threw = false;\\n      } finally {\\n        if (threw) {\\n          // We need to continue processing after domain error handling\\n          // is complete, but not by using whatever domain was left over\\n          // when the timeout threw its exception.\\n          var oldDomain = process.domain;\\n          process.domain = null;\\n          process.nextTick(listOnTimeoutNT, list);\\n          process.domain = oldDomain;\\n        }\\n      }\\n    }\\n  }\\n\\n  debug('%d list empty', msecs);\\n  assert(L.isEmpty(list));\\n  list.close();\\n  delete lists[msecs];\\n}\\n\\n\\nfunction listOnTimeoutNT(list) {\\n  list[kOnTimeout]();\\n}\\n\\n\\nfunction reuse(item) {\\n  L.remove(item);\\n\\n  var list = lists[item._idleTimeout];\\n  // if empty - reuse the watcher\\n  if (list && L.isEmpty(list)) {\\n    debug('reuse hit');\\n    list.stop();\\n    delete lists[item._idleTimeout];\\n    return list;\\n  }\\n\\n  return null;\\n}\\n\\n\\nvar unenroll = exports.unenroll = function(item) {\\n  var list = reuse(item);\\n  if (list) {\\n    debug('unenroll: list empty');\\n    list.close();\\n  }\\n  // if active is called later, then we want to make sure not to insert again\\n  item._idleTimeout = -1;\\n};\\n\\n\\n// Does not start the time, just sets up the members needed.\\nexports.enroll = function(item, msecs) {\\n  if (typeof msecs !== 'number') {\\n    throw new TypeError('\\\"msecs\\\" argument must be a number');\\n  }\\n\\n  if (msecs < 0 || !isFinite(msecs)) {\\n    throw new RangeError('\\\"msecs\\\" argument must be ' +\\n                         'a non-negative finite number');\\n  }\\n\\n  // if this item was already in a list somewhere\\n  // then we should unenroll it from that\\n  if (item._idleNext) unenroll(item);\\n\\n  // Ensure that msecs fits into signed int32\\n  if (msecs > TIMEOUT_MAX) {\\n    msecs = TIMEOUT_MAX;\\n  }\\n\\n  item._idleTimeout = msecs;\\n  L.init(item);\\n};\\n\\n\\n/*\\n * DOM-style timers\\n */\\n\\n\\nexports.setTimeout = function(callback, after) {\\n  after *= 1; // coalesce to number or NaN\\n\\n  if (!(after >= 1 && after <= TIMEOUT_MAX)) {\\n    after = 1; // schedule on next tick, follows browser behaviour\\n  }\\n\\n  var timer = new Timeout(after);\\n  var length = arguments.length;\\n  var ontimeout = callback;\\n  switch (length) {\\n    // fast cases\\n    case 0:\\n    case 1:\\n    case 2:\\n      break;\\n    case 3:\\n      ontimeout = callback.bind(timer, arguments[2]);\\n      break;\\n    case 4:\\n      ontimeout = callback.bind(timer, arguments[2], arguments[3]);\\n      break;\\n    case 5:\\n      ontimeout =\\n          callback.bind(timer, arguments[2], arguments[3], arguments[4]);\\n      break;\\n    // slow case\\n    default:\\n      var args = new Array(length - 2);\\n      for (var i = 2; i < length; i++)\\n        args[i - 2] = arguments[i];\\n      ontimeout = callback.apply.bind(callback, timer, args);\\n      break;\\n  }\\n  timer._onTimeout = ontimeout;\\n\\n  if (process.domain) timer.domain = process.domain;\\n\\n  exports.active(timer);\\n\\n  return timer;\\n};\\n\\n\\nexports.clearTimeout = function(timer) {\\n  if (timer && (timer[kOnTimeout] || timer._onTimeout)) {\\n    timer[kOnTimeout] = timer._onTimeout = null;\\n    if (timer instanceof Timeout) {\\n      timer.close(); // for after === 0\\n    } else {\\n      exports.unenroll(timer);\\n    }\\n  }\\n};\\n\\n\\nexports.setInterval = function(callback, repeat) {\\n  repeat *= 1; // coalesce to number or NaN\\n\\n  if (!(repeat >= 1 && repeat <= TIMEOUT_MAX)) {\\n    repeat = 1; // schedule on next tick, follows browser behaviour\\n  }\\n\\n  var timer = new Timeout(repeat);\\n  var length = arguments.length;\\n  var ontimeout = callback;\\n  switch (length) {\\n    case 0:\\n    case 1:\\n    case 2:\\n      break;\\n    case 3:\\n      ontimeout = callback.bind(timer, arguments[2]);\\n      break;\\n    case 4:\\n      ontimeout = callback.bind(timer, arguments[2], arguments[3]);\\n      break;\\n    case 5:\\n      ontimeout =\\n          callback.bind(timer, arguments[2], arguments[3], arguments[4]);\\n      break;\\n    default:\\n      var args = new Array(length - 2);\\n      for (var i = 2; i < length; i += 1)\\n        args[i - 2] = arguments[i];\\n      ontimeout = callback.apply.bind(callback, timer, args);\\n      break;\\n  }\\n  timer._onTimeout = wrapper;\\n  timer._repeat = ontimeout;\\n\\n  if (process.domain) timer.domain = process.domain;\\n  exports.active(timer);\\n\\n  return timer;\\n\\n  function wrapper() {\\n    timer._repeat.call(this);\\n\\n    // Timer might be closed - no point in restarting it\\n    if (!timer._repeat)\\n      return;\\n\\n    // If timer is unref'd (or was - it's permanently removed from the list.)\\n    if (this._handle) {\\n      this._handle.start(repeat, 0);\\n    } else {\\n      timer._idleTimeout = repeat;\\n      exports.active(timer);\\n    }\\n  }\\n};\\n\\n\\nexports.clearInterval = function(timer) {\\n  if (timer && timer._repeat) {\\n    timer._repeat = null;\\n    clearTimeout(timer);\\n  }\\n};\\n\\n\\nvar Timeout = function(after) {\\n  this._called = false;\\n  this._idleTimeout = after;\\n  this._idlePrev = this;\\n  this._idleNext = this;\\n  this._idleStart = null;\\n  this._onTimeout = null;\\n  this._repeat = null;\\n};\\n\\n\\nfunction unrefdHandle() {\\n  this.owner._onTimeout();\\n  if (!this.owner._repeat)\\n    this.owner.close();\\n}\\n\\n\\nTimeout.prototype.unref = function() {\\n  if (this._handle) {\\n    this._handle.unref();\\n  } else if (typeof(this._onTimeout) === 'function') {\\n    var now = Timer.now();\\n    if (!this._idleStart) this._idleStart = now;\\n    var delay = this._idleStart + this._idleTimeout - now;\\n    if (delay < 0) delay = 0;\\n\\n    // Prevent running cb again when unref() is called during the same cb\\n    if (this._called && !this._repeat) {\\n      exports.unenroll(this);\\n      return;\\n    }\\n\\n    var handle = reuse(this);\\n\\n    this._handle = handle || new Timer();\\n    this._handle.owner = this;\\n    this._handle[kOnTimeout] = unrefdHandle;\\n    this._handle.start(delay, 0);\\n    this._handle.domain = this.domain;\\n    this._handle.unref();\\n  }\\n  return this;\\n};\\n\\nTimeout.prototype.ref = function() {\\n  if (this._handle)\\n    this._handle.ref();\\n  return this;\\n};\\n\\nTimeout.prototype.close = function() {\\n  this._onTimeout = null;\\n  if (this._handle) {\\n    this._handle[kOnTimeout] = null;\\n    this._handle.close();\\n  } else {\\n    exports.unenroll(this);\\n  }\\n  return this;\\n};\\n\\n\\nvar immediateQueue = {};\\nL.init(immediateQueue);\\n\\n\\nfunction processImmediate() {\\n  var queue = immediateQueue;\\n  var domain, immediate;\\n\\n  immediateQueue = {};\\n  L.init(immediateQueue);\\n\\n  while (L.isEmpty(queue) === false) {\\n    immediate = L.shift(queue);\\n    domain = immediate.domain;\\n\\n    if (domain)\\n      domain.enter();\\n\\n    var threw = true;\\n    try {\\n      immediate._onImmediate();\\n      threw = false;\\n    } finally {\\n      if (threw) {\\n        if (!L.isEmpty(queue)) {\\n          // Handle any remaining on next tick, assuming we're still\\n          // alive to do so.\\n          while (!L.isEmpty(immediateQueue)) {\\n            L.append(queue, L.shift(immediateQueue));\\n          }\\n          immediateQueue = queue;\\n          process.nextTick(processImmediate);\\n        }\\n      }\\n    }\\n\\n    if (domain)\\n      domain.exit();\\n  }\\n\\n  // Only round-trip to C++ land if we have to. Calling clearImmediate() on an\\n  // immediate that's in |queue| is okay. Worst case is we make a superfluous\\n  // call to NeedImmediateCallbackSetter().\\n  if (L.isEmpty(immediateQueue)) {\\n    process._needImmediateCallback = false;\\n  }\\n}\\n\\n\\nfunction Immediate() { }\\n\\nImmediate.prototype.domain = undefined;\\nImmediate.prototype._onImmediate = undefined;\\nImmediate.prototype._idleNext = undefined;\\nImmediate.prototype._idlePrev = undefined;\\n\\n\\nexports.setImmediate = function(callback, arg1, arg2, arg3) {\\n  var i, args;\\n  var len = arguments.length;\\n  var immediate = new Immediate();\\n\\n  L.init(immediate);\\n\\n  switch (len) {\\n    // fast cases\\n    case 0:\\n    case 1:\\n      immediate._onImmediate = callback;\\n      break;\\n    case 2:\\n      immediate._onImmediate = function() {\\n        callback.call(immediate, arg1);\\n      };\\n      break;\\n    case 3:\\n      immediate._onImmediate = function() {\\n        callback.call(immediate, arg1, arg2);\\n      };\\n      break;\\n    case 4:\\n      immediate._onImmediate = function() {\\n        callback.call(immediate, arg1, arg2, arg3);\\n      };\\n      break;\\n    // slow case\\n    default:\\n      args = new Array(len - 1);\\n      for (i = 1; i < len; i++)\\n        args[i - 1] = arguments[i];\\n\\n      immediate._onImmediate = function() {\\n        callback.apply(immediate, args);\\n      };\\n      break;\\n  }\\n\\n  if (!process._needImmediateCallback) {\\n    process._needImmediateCallback = true;\\n    process._immediateCallback = processImmediate;\\n  }\\n\\n  if (process.domain)\\n    immediate.domain = process.domain;\\n\\n  L.append(immediateQueue, immediate);\\n\\n  return immediate;\\n};\\n\\n\\nexports.clearImmediate = function(immediate) {\\n  if (!immediate) return;\\n\\n  immediate._onImmediate = undefined;\\n\\n  L.remove(immediate);\\n\\n  if (L.isEmpty(immediateQueue)) {\\n    process._needImmediateCallback = false;\\n  }\\n};\\n\\n\\n// Internal APIs that need timeouts should use timers._unrefActive instead of\\n// timers.active as internal timeouts shouldn't hold the loop open\\n\\nvar unrefList, unrefTimer;\\n\\nfunction _makeTimerTimeout(timer) {\\n  var domain = timer.domain;\\n  var msecs = timer._idleTimeout;\\n\\n  L.remove(timer);\\n\\n  // Timer has been unenrolled by another timer that fired at the same time,\\n  // so don't make it timeout.\\n  if (msecs <= 0)\\n    return;\\n\\n  if (!timer._onTimeout)\\n    return;\\n\\n  if (domain) {\\n    if (domain._disposed)\\n      return;\\n\\n    domain.enter();\\n  }\\n\\n  debug('unreftimer firing timeout');\\n  timer._called = true;\\n  _runOnTimeout(timer);\\n\\n  if (domain)\\n    domain.exit();\\n}\\n\\nfunction _runOnTimeout(timer) {\\n  var threw = true;\\n  try {\\n    timer._onTimeout();\\n    threw = false;\\n  } finally {\\n    if (threw) process.nextTick(unrefTimeout);\\n  }\\n}\\n\\nfunction unrefTimeout() {\\n  var now = Timer.now();\\n\\n  debug('unrefTimer fired');\\n\\n  var timeSinceLastActive;\\n  var nextTimeoutTime;\\n  var nextTimeoutDuration;\\n  var minNextTimeoutTime = TIMEOUT_MAX;\\n  var timersToTimeout = [];\\n\\n  // The actual timer fired and has not yet been rearmed,\\n  // let's consider its next firing time is invalid for now.\\n  // It may be set to a relevant time in the future once\\n  // we scanned through the whole list of timeouts and if\\n  // we find a timeout that needs to expire.\\n  unrefTimer.when = -1;\\n\\n  // Iterate over the list of timeouts,\\n  // call the onTimeout callback for those expired,\\n  // and rearm the actual timer if the next timeout to expire\\n  // will expire before the current actual timer.\\n  var cur = unrefList._idlePrev;\\n  while (cur !== unrefList) {\\n    timeSinceLastActive = now - cur._idleStart;\\n\\n    if (timeSinceLastActive < cur._idleTimeout) {\\n      // This timer hasn't expired yet, but check if its expiring time is\\n      // earlier than the actual timer's expiring time\\n\\n      nextTimeoutDuration = cur._idleTimeout - timeSinceLastActive;\\n      nextTimeoutTime = now + nextTimeoutDuration;\\n      if (minNextTimeoutTime === TIMEOUT_MAX ||\\n          (nextTimeoutTime < minNextTimeoutTime)) {\\n        // We found a timeout that will expire earlier,\\n        // store its next timeout time now so that we\\n        // can rearm the actual timer accordingly when\\n        // we scanned through the whole list.\\n        minNextTimeoutTime = nextTimeoutTime;\\n      }\\n    } else {\\n      // We found a timer that expired. Do not call its _onTimeout callback\\n      // right now, as it could mutate any item of the list (including itself).\\n      // Instead, add it to another list that will be processed once the list\\n      // of current timers has been fully traversed.\\n      timersToTimeout.push(cur);\\n    }\\n\\n    cur = cur._idlePrev;\\n  }\\n\\n  var nbTimersToTimeout = timersToTimeout.length;\\n  for (var timerIdx = 0; timerIdx < nbTimersToTimeout; ++timerIdx)\\n    _makeTimerTimeout(timersToTimeout[timerIdx]);\\n\\n\\n  // Rearm the actual timer with the timeout delay\\n  // of the earliest timeout found.\\n  if (minNextTimeoutTime !== TIMEOUT_MAX) {\\n    unrefTimer.start(minNextTimeoutTime - now, 0);\\n    unrefTimer.when = minNextTimeoutTime;\\n    debug('unrefTimer rescheduled');\\n  } else if (L.isEmpty(unrefList)) {\\n    debug('unrefList is empty');\\n  }\\n}\\n\\n\\nexports._unrefActive = function(item) {\\n  var msecs = item._idleTimeout;\\n  if (!msecs || msecs < 0) return;\\n  assert(msecs >= 0);\\n\\n  L.remove(item);\\n\\n  if (!unrefList) {\\n    debug('unrefList initialized');\\n    unrefList = {};\\n    L.init(unrefList);\\n\\n    debug('unrefTimer initialized');\\n    unrefTimer = new Timer();\\n    unrefTimer.unref();\\n    unrefTimer.when = -1;\\n    unrefTimer[kOnTimeout] = unrefTimeout;\\n  }\\n\\n  var now = Timer.now();\\n  item._idleStart = now;\\n\\n  var when = now + msecs;\\n\\n  // If the actual timer is set to fire too late, or not set to fire at all,\\n  // we need to make it fire earlier\\n  if (unrefTimer.when === -1 || unrefTimer.when > when) {\\n    unrefTimer.start(msecs, 0);\\n    unrefTimer.when = when;\\n    debug('unrefTimer scheduled');\\n  }\\n\\n  debug('unrefList append to end');\\n  L.append(unrefList, item);\\n};\\n\",\"net\":\"'use strict';\\r\\n\\r\\nvar EventEmitter = require('events');\\r\\nvar stream = require('stream');\\r\\nvar timers = require('timers');\\r\\nvar util = require('util');\\r\\nvar internalUtil = require('internal/util');\\r\\nvar assert = require('assert');\\r\\nvar cares = process.binding('cares_wrap');\\r\\nvar uv = process.binding('uv');\\r\\n\\r\\nvar Buffer = require('buffer').Buffer;\\r\\nvar TTYWrap = process.binding('tty_wrap');\\r\\nvar TCP = process.binding('tcp_wrap').TCP;\\r\\nvar Pipe = process.binding('pipe_wrap').Pipe;\\r\\nvar TCPConnectWrap = process.binding('tcp_wrap').TCPConnectWrap;\\r\\nvar PipeConnectWrap = process.binding('pipe_wrap').PipeConnectWrap;\\r\\nvar ShutdownWrap = process.binding('stream_wrap').ShutdownWrap;\\r\\nvar WriteWrap = process.binding('stream_wrap').WriteWrap;\\r\\n\\r\\n\\r\\nvar cluster;\\r\\nvar errnoException = util._errnoException;\\r\\nvar exceptionWithHostPort = util._exceptionWithHostPort;\\r\\n\\r\\nfunction noop() {}\\r\\n\\r\\nfunction createHandle(fd) {\\r\\n  var type = TTYWrap.guessHandleType(fd);\\r\\n  if (type === 'PIPE') return new Pipe();\\r\\n  if (type === 'TCP') return new TCP();\\r\\n  throw new TypeError('Unsupported fd type: ' + type);\\r\\n}\\r\\n\\r\\n\\r\\nvar debug = util.debuglog('net');\\r\\n\\r\\nfunction isPipeName(s) {\\r\\n  return typeof s === 'string' && toNumber(s) === false;\\r\\n}\\r\\n\\r\\nexports.createServer = function(options, connectionListener) {\\r\\n  return new Server(options, connectionListener);\\r\\n};\\r\\n\\r\\n\\r\\n// Target API:\\r\\n//\\r\\n// var s = net.connect({port: 80, host: 'google.com'}, function() {\\r\\n//   ...\\r\\n// });\\r\\n//\\r\\n// There are various forms:\\r\\n//\\r\\n// connect(options, [cb])\\r\\n// connect(port, [host], [cb])\\r\\n// connect(path, [cb]);\\r\\n//\\r\\nexports.connect = exports.createConnection = function() {\\r\\n  var args = normalizeConnectArgs(arguments);\\r\\n  debug('createConnection', args);\\r\\n  var s = new Socket(args[0]);\\r\\n  return Socket.prototype.connect.apply(s, args);\\r\\n};\\r\\n\\r\\n// Returns an array [options] or [options, cb]\\r\\n// It is the same as the argument of Socket.prototype.connect().\\r\\nfunction normalizeConnectArgs(args) {\\r\\n  var options = {};\\r\\n\\r\\n  if (args[0] !== null && typeof args[0] === 'object') {\\r\\n    // connect(options, [cb])\\r\\n    options = args[0];\\r\\n  } else if (isPipeName(args[0])) {\\r\\n    // connect(path, [cb]);\\r\\n    options.path = args[0];\\r\\n  } else {\\r\\n    // connect(port, [host], [cb])\\r\\n    options.port = args[0];\\r\\n    if (typeof args[1] === 'string') {\\r\\n      options.host = args[1];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  var cb = args[args.length - 1];\\r\\n  return typeof cb === 'function' ? [options, cb] : [options];\\r\\n}\\r\\nexports._normalizeConnectArgs = normalizeConnectArgs;\\r\\n\\r\\n\\r\\n// called when creating new Socket, or when re-using a closed Socket\\r\\nfunction initSocketHandle(self) {\\r\\n  self.destroyed = false;\\r\\n  self.bytesRead = 0;\\r\\n  self._bytesDispatched = 0;\\r\\n  self._sockname = null;\\r\\n\\r\\n  // Handle creation may be deferred to bind() or connect() time.\\r\\n  if (self._handle) {\\r\\n    self._handle.owner = self;\\r\\n    self._handle.onread = onread;\\r\\n\\r\\n    // If handle doesn't support writev - neither do we\\r\\n    if (!self._handle.writev)\\r\\n      self._writev = null;\\r\\n  }\\r\\n}\\r\\n\\r\\nfunction Socket(options) {\\r\\n  if (!(this instanceof Socket)) return new Socket(options);\\r\\n\\r\\n  this._connecting = false;\\r\\n  this._hadError = false;\\r\\n  this._handle = null;\\r\\n  this._parent = null;\\r\\n  this._host = null;\\r\\n\\r\\n  if (typeof options === 'number')\\r\\n    options = { fd: options }; // Legacy interface.\\r\\n  else if (options === undefined)\\r\\n    options = {};\\r\\n\\r\\n  stream.Duplex.call(this, options);\\r\\n\\r\\n  if (options.handle) {\\r\\n    this._handle = options.handle; // private\\r\\n  } else if (options.fd !== undefined) {\\r\\n    this._handle = createHandle(options.fd);\\r\\n    this._handle.open(options.fd);\\r\\n    if ((options.fd == 1 || options.fd == 2) &&\\r\\n        (this._handle instanceof Pipe) &&\\r\\n        process.platform === 'win32') {\\r\\n      // Make stdout and stderr blocking on Windows\\r\\n      var err = this._handle.setBlocking(true);\\r\\n      if (err)\\r\\n        throw errnoException(err, 'setBlocking');\\r\\n    }\\r\\n    this.readable = options.readable !== false;\\r\\n    this.writable = options.writable !== false;\\r\\n  } else {\\r\\n    // these will be set once there is a connection\\r\\n    this.readable = this.writable = false;\\r\\n  }\\r\\n\\r\\n  // shut down the socket when we're finished with it.\\r\\n  this.on('finish', onSocketFinish);\\r\\n  this.on('_socketEnd', onSocketEnd);\\r\\n\\r\\n  initSocketHandle(this);\\r\\n\\r\\n  this._pendingData = null;\\r\\n  this._pendingEncoding = '';\\r\\n\\r\\n  // handle strings directly\\r\\n  this._writableState.decodeStrings = false;\\r\\n\\r\\n  // default to *not* allowing half open sockets\\r\\n  this.allowHalfOpen = options && options.allowHalfOpen || false;\\r\\n\\r\\n  // if we have a handle, then start the flow of data into the\\r\\n  // buffer.  if not, then this will happen when we connect\\r\\n  if (this._handle && options.readable !== false) {\\r\\n    if (options.pauseOnCreate) {\\r\\n      // stop the handle from reading and pause the stream\\r\\n      this._handle.reading = false;\\r\\n      this._handle.readStop();\\r\\n      this._readableState.flowing = false;\\r\\n    } else {\\r\\n      this.read(0);\\r\\n    }\\r\\n  }\\r\\n}\\r\\nutil.inherits(Socket, stream.Duplex);\\r\\n\\r\\nSocket.prototype._unrefTimer = function unrefTimer() {\\r\\n  for (var s = this; s !== null; s = s._parent)\\r\\n    timers._unrefActive(s);\\r\\n};\\r\\n\\r\\n// the user has called .end(), and all the bytes have been\\r\\n// sent out to the other side.\\r\\n// If allowHalfOpen is false, or if the readable side has\\r\\n// ended already, then destroy.\\r\\n// If allowHalfOpen is true, then we need to do a shutdown,\\r\\n// so that only the writable side will be cleaned up.\\r\\nfunction onSocketFinish() {\\r\\n  // If still connecting - defer handling 'finish' until 'connect' will happen\\r\\n  if (this._connecting) {\\r\\n    debug('osF: not yet connected');\\r\\n    return this.once('connect', onSocketFinish);\\r\\n  }\\r\\n\\r\\n  debug('onSocketFinish');\\r\\n  if (!this.readable || this._readableState.ended) {\\r\\n    debug('oSF: ended, destroy', this._readableState);\\r\\n    return this.destroy();\\r\\n  }\\r\\n\\r\\n  debug('oSF: not ended, call shutdown()');\\r\\n\\r\\n  // otherwise, just shutdown, or destroy() if not possible\\r\\n  if (!this._handle || !this._handle.shutdown)\\r\\n    return this.destroy();\\r\\n\\r\\n  var req = new ShutdownWrap();\\r\\n  req.oncomplete = afterShutdown;\\r\\n  req.handle = this._handle;\\r\\n  var err = this._handle.shutdown(req);\\r\\n\\r\\n  if (err)\\r\\n    return this._destroy(errnoException(err, 'shutdown'));\\r\\n}\\r\\n\\r\\n\\r\\nfunction afterShutdown(status, handle, req) {\\r\\n  var self = handle.owner;\\r\\n\\r\\n  debug('afterShutdown destroyed=%j', self.destroyed,\\r\\n        self._readableState);\\r\\n\\r\\n  // callback may come after call to destroy.\\r\\n  if (self.destroyed)\\r\\n    return;\\r\\n\\r\\n  if (self._readableState.ended) {\\r\\n    debug('readableState ended, destroying');\\r\\n    self.destroy();\\r\\n  } else {\\r\\n    self.once('_socketEnd', self.destroy);\\r\\n  }\\r\\n}\\r\\n\\r\\n// the EOF has been received, and no more bytes are coming.\\r\\n// if the writable side has ended already, then clean everything\\r\\n// up.\\r\\nfunction onSocketEnd() {\\r\\n  // XXX Should not have to do as much crap in this function.\\r\\n  // ended should already be true, since this is called *after*\\r\\n  // the EOF errno and onread has eof'ed\\r\\n  debug('onSocketEnd', this._readableState);\\r\\n  this._readableState.ended = true;\\r\\n  if (this._readableState.endEmitted) {\\r\\n    this.readable = false;\\r\\n    maybeDestroy(this);\\r\\n  } else {\\r\\n    this.once('end', function() {\\r\\n      this.readable = false;\\r\\n      maybeDestroy(this);\\r\\n    });\\r\\n    this.read(0);\\r\\n  }\\r\\n\\r\\n  if (!this.allowHalfOpen) {\\r\\n    this.write = writeAfterFIN;\\r\\n    this.destroySoon();\\r\\n  }\\r\\n}\\r\\n\\r\\n// Provide a better error message when we call end() as a result\\r\\n// of the other side sending a FIN.  The standard 'write after end'\\r\\n// is overly vague, and makes it seem like the user's code is to blame.\\r\\nfunction writeAfterFIN(chunk, encoding, cb) {\\r\\n  if (typeof encoding === 'function') {\\r\\n    cb = encoding;\\r\\n    encoding = null;\\r\\n  }\\r\\n\\r\\n  var er = new Error('This socket has been ended by the other party');\\r\\n  er.code = 'EPIPE';\\r\\n  var self = this;\\r\\n  // TODO: defer error events consistently everywhere, not just the cb\\r\\n  self.emit('error', er);\\r\\n  if (typeof cb === 'function') {\\r\\n    process.nextTick(cb, er);\\r\\n  }\\r\\n}\\r\\n\\r\\nexports.Socket = Socket;\\r\\nexports.Stream = Socket; // Legacy naming.\\r\\n\\r\\nSocket.prototype.read = function(n) {\\r\\n  if (n === 0)\\r\\n    return stream.Readable.prototype.read.call(this, n);\\r\\n\\r\\n  this.read = stream.Readable.prototype.read;\\r\\n  this._consuming = true;\\r\\n  return this.read(n);\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.listen = function() {\\r\\n  debug('socket.listen');\\r\\n  var self = this;\\r\\n  self.on('connection', arguments[0]);\\r\\n  listen(self, null, null, null);\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.setTimeout = function(msecs, callback) {\\r\\n  if (msecs === 0) {\\r\\n    timers.unenroll(this);\\r\\n    if (callback) {\\r\\n      this.removeListener('timeout', callback);\\r\\n    }\\r\\n  } else {\\r\\n    timers.enroll(this, msecs);\\r\\n    timers._unrefActive(this);\\r\\n    if (callback) {\\r\\n      this.once('timeout', callback);\\r\\n    }\\r\\n  }\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype._onTimeout = function() {\\r\\n  debug('_onTimeout');\\r\\n  this.emit('timeout');\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.setNoDelay = function(enable) {\\r\\n  if (!this._handle) {\\r\\n    this.once('connect',\\r\\n              enable ? this.setNoDelay : this.setNoDelay.bind(this, enable));\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  // backwards compatibility: assume true when `enable` is omitted\\r\\n  if (this._handle.setNoDelay)\\r\\n    this._handle.setNoDelay(enable === undefined ? true : !!enable);\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.setKeepAlive = function(setting, msecs) {\\r\\n  if (!this._handle) {\\r\\n    this.once('connect', this.setKeepAlive.bind(this, setting, msecs));\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  if (this._handle.setKeepAlive)\\r\\n    this._handle.setKeepAlive(setting, ~~(msecs / 1000));\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.address = function() {\\r\\n  return this._getsockname();\\r\\n};\\r\\n\\r\\n\\r\\nObject.defineProperty(Socket.prototype, 'readyState', {\\r\\n  get: function() {\\r\\n    if (this._connecting) {\\r\\n      return 'opening';\\r\\n    } else if (this.readable && this.writable) {\\r\\n      return 'open';\\r\\n    } else if (this.readable && !this.writable) {\\r\\n      return 'readOnly';\\r\\n    } else if (!this.readable && this.writable) {\\r\\n      return 'writeOnly';\\r\\n    } else {\\r\\n      return 'closed';\\r\\n    }\\r\\n  }\\r\\n});\\r\\n\\r\\n\\r\\nObject.defineProperty(Socket.prototype, 'bufferSize', {\\r\\n  get: function() {\\r\\n    if (this._handle) {\\r\\n      return this._handle.writeQueueSize + this._writableState.length;\\r\\n    }\\r\\n  }\\r\\n});\\r\\n\\r\\n\\r\\n// Just call handle.readStart until we have enough in the buffer\\r\\nSocket.prototype._read = function(n) {\\r\\n  debug('_read');\\r\\n\\r\\n  if (this._connecting || !this._handle) {\\r\\n    debug('_read wait for connection');\\r\\n    this.once('connect', this._read.bind(this, n));\\r\\n  } else if (!this._handle.reading) {\\r\\n    // not already reading, start the flow\\r\\n    debug('Socket._read readStart');\\r\\n    this._handle.reading = true;\\r\\n    var err = this._handle.readStart();\\r\\n    if (err)\\r\\n      this._destroy(errnoException(err, 'read'));\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.end = function(data, encoding) {\\r\\n  stream.Duplex.prototype.end.call(this, data, encoding);\\r\\n  this.writable = false;\\r\\n  DTRACE_NET_STREAM_END(this);\\r\\n  LTTNG_NET_STREAM_END(this);\\r\\n\\r\\n  // just in case we're waiting for an EOF.\\r\\n  if (this.readable && !this._readableState.endEmitted)\\r\\n    this.read(0);\\r\\n  else\\r\\n    maybeDestroy(this);\\r\\n};\\r\\n\\r\\n\\r\\n// Call whenever we set writable=false or readable=false\\r\\nfunction maybeDestroy(socket) {\\r\\n  if (!socket.readable &&\\r\\n      !socket.writable &&\\r\\n      !socket.destroyed &&\\r\\n      !socket._connecting &&\\r\\n      !socket._writableState.length) {\\r\\n    socket.destroy();\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nSocket.prototype.destroySoon = function() {\\r\\n  if (this.writable)\\r\\n    this.end();\\r\\n\\r\\n  if (this._writableState.finished)\\r\\n    this.destroy();\\r\\n  else\\r\\n    this.once('finish', this.destroy);\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype._destroy = function(exception, cb) {\\r\\n  debug('destroy');\\r\\n\\r\\n  var self = this;\\r\\n\\r\\n  function fireErrorCallbacks() {\\r\\n    if (cb) cb(exception);\\r\\n    if (exception && !self._writableState.errorEmitted) {\\r\\n      process.nextTick(emitErrorNT, self, exception);\\r\\n      self._writableState.errorEmitted = true;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (this.destroyed) {\\r\\n    debug('already destroyed, fire error callbacks');\\r\\n    fireErrorCallbacks();\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  self._connecting = false;\\r\\n\\r\\n  this.readable = this.writable = false;\\r\\n\\r\\n  for (var s = this; s !== null; s = s._parent)\\r\\n    timers.unenroll(s);\\r\\n\\r\\n  debug('close');\\r\\n  if (this._handle) {\\r\\n    if (this !== process.stderr)\\r\\n      debug('close handle');\\r\\n    var isException = exception ? true : false;\\r\\n    this._handle.close(function() {\\r\\n      debug('emit close');\\r\\n      self.emit('close', isException);\\r\\n    });\\r\\n    this._handle.onread = noop;\\r\\n    this._handle = null;\\r\\n    this._sockname = null;\\r\\n  }\\r\\n\\r\\n  // we set destroyed to true before firing error callbacks in order\\r\\n  // to make it re-entrance safe in case Socket.prototype.destroy()\\r\\n  // is called within callbacks\\r\\n  this.destroyed = true;\\r\\n  fireErrorCallbacks();\\r\\n\\r\\n  if (this.server) {\\r\\n    COUNTER_NET_SERVER_CONNECTION_CLOSE(this);\\r\\n    debug('has server');\\r\\n    this.server._connections--;\\r\\n    if (this.server._emitCloseIfDrained) {\\r\\n      this.server._emitCloseIfDrained();\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.destroy = function(exception) {\\r\\n  debug('destroy', exception);\\r\\n  this._destroy(exception);\\r\\n};\\r\\n\\r\\n\\r\\n// This function is called whenever the handle gets a\\r\\n// buffer, or when there's an error reading.\\r\\nfunction onread(nread, buffer) {\\r\\n  var handle = this;\\r\\n  var self = handle.owner;\\r\\n  assert(handle === self._handle, 'handle != self._handle');\\r\\n\\r\\n  self._unrefTimer();\\r\\n\\r\\n  debug('onread', nread);\\r\\n\\r\\n  if (nread > 0) {\\r\\n    debug('got data');\\r\\n    // read success.\\r\\n    // In theory (and in practice) calling readStop right now\\r\\n    // will prevent this from being called again until _read() gets\\r\\n    // called again.\\r\\n\\r\\n    // if it's not enough data, we'll just call handle.readStart()\\r\\n    // again right away.\\r\\n    self.bytesRead += nread;\\r\\n\\r\\n    // Optimization: emit the original buffer with end points\\r\\n    var ret = self.push(buffer);\\r\\n\\r\\n    if (handle.reading && !ret) {\\r\\n      handle.reading = false;\\r\\n      debug('readStop');\\r\\n      var err = handle.readStop();\\r\\n      if (err)\\r\\n        self._destroy(errnoException(err, 'read'));\\r\\n    }\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // if we didn't get any bytes, that doesn't necessarily mean EOF.\\r\\n  // wait for the next one.\\r\\n  if (nread === 0) {\\r\\n    debug('not any data, keep waiting');\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // Error, possibly EOF.\\r\\n  if (nread !== uv.UV_EOF) {\\r\\n    return self._destroy(errnoException(nread, 'read'));\\r\\n  }\\r\\n\\r\\n  debug('EOF');\\r\\n\\r\\n  if (self._readableState.length === 0) {\\r\\n    self.readable = false;\\r\\n    maybeDestroy(self);\\r\\n  }\\r\\n\\r\\n  // push a null to signal the end of data.\\r\\n  self.push(null);\\r\\n\\r\\n  // internal end event so that we know that the actual socket\\r\\n  // is no longer readable, and we can start the shutdown\\r\\n  // procedure. No need to wait for all the data to be consumed.\\r\\n  self.emit('_socketEnd');\\r\\n}\\r\\n\\r\\n\\r\\nSocket.prototype._getpeername = function() {\\r\\n  if (!this._peername) {\\r\\n    if (!this._handle || !this._handle.getpeername) {\\r\\n      return {};\\r\\n    }\\r\\n    var out = {};\\r\\n    var err = this._handle.getpeername(out);\\r\\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\\r\\n    this._peername = out;\\r\\n  }\\r\\n  return this._peername;\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.__defineGetter__('remoteAddress', function() {\\r\\n  return this._getpeername().address;\\r\\n});\\r\\n\\r\\nSocket.prototype.__defineGetter__('remoteFamily', function() {\\r\\n  return this._getpeername().family;\\r\\n});\\r\\n\\r\\nSocket.prototype.__defineGetter__('remotePort', function() {\\r\\n  return this._getpeername().port;\\r\\n});\\r\\n\\r\\n\\r\\nSocket.prototype._getsockname = function() {\\r\\n  if (!this._handle || !this._handle.getsockname) {\\r\\n    return {};\\r\\n  }\\r\\n  if (!this._sockname) {\\r\\n    var out = {};\\r\\n    var err = this._handle.getsockname(out);\\r\\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\\r\\n    this._sockname = out;\\r\\n  }\\r\\n  return this._sockname;\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.__defineGetter__('localAddress', function() {\\r\\n  return this._getsockname().address;\\r\\n});\\r\\n\\r\\n\\r\\nSocket.prototype.__defineGetter__('localPort', function() {\\r\\n  return this._getsockname().port;\\r\\n});\\r\\n\\r\\n\\r\\nSocket.prototype.write = function(chunk, encoding, cb) {\\r\\n  if (typeof chunk !== 'string' && (!Buffer.isBuffer(chunk)))\\r\\n    throw new TypeError('Invalid data');\\r\\n  return stream.Duplex.prototype.write.apply(this, arguments);\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype._writeGeneric = function(writev, data, encoding, cb) {\\r\\n  // If we are still connecting, then buffer this for later.\\r\\n  // The Writable logic will buffer up any more writes while\\r\\n  // waiting for this one to be done.\\r\\n  if (this._connecting) {\\r\\n    this._pendingData = data;\\r\\n    this._pendingEncoding = encoding;\\r\\n    this.once('connect', function() {\\r\\n      this._writeGeneric(writev, data, encoding, cb);\\r\\n    });\\r\\n    return;\\r\\n  }\\r\\n  this._pendingData = null;\\r\\n  this._pendingEncoding = '';\\r\\n\\r\\n  this._unrefTimer();\\r\\n\\r\\n  if (!this._handle) {\\r\\n    this._destroy(new Error('This socket is closed'), cb);\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  var req = new WriteWrap();\\r\\n  req.handle = this._handle;\\r\\n  req.oncomplete = afterWrite;\\r\\n  req.async = false;\\r\\n  var err;\\r\\n\\r\\n  if (writev) {\\r\\n    var chunks = new Array(data.length << 1);\\r\\n    for (var i = 0; i < data.length; i++) {\\r\\n      var entry = data[i];\\r\\n      var chunk = entry.chunk;\\r\\n      var enc = entry.encoding;\\r\\n      chunks[i * 2] = chunk;\\r\\n      chunks[i * 2 + 1] = enc;\\r\\n    }\\r\\n    err = this._handle.writev(req, chunks);\\r\\n\\r\\n    // Retain chunks\\r\\n    if (err === 0) req._chunks = chunks;\\r\\n  } else {\\r\\n    var enc;\\r\\n    if (typeof data === 'buffer') {\\r\\n      req.buffer = data;  // Keep reference alive.\\r\\n      enc = 'buffer';\\r\\n    } else {\\r\\n      enc = encoding;\\r\\n    }\\r\\n    err = createWriteReq(req, this._handle, data, enc);\\r\\n  }\\r\\n\\r\\n  if (err)\\r\\n    return this._destroy(errnoException(err, 'write', req.error), cb);\\r\\n\\r\\n  this._bytesDispatched += req.bytes;\\r\\n\\r\\n  // If it was entirely flushed, we can write some more right now.\\r\\n  // However, if more is left in the queue, then wait until that clears.\\r\\n  if (req.async && this._handle.writeQueueSize != 0)\\r\\n    req.cb = cb;\\r\\n  else\\r\\n    cb();\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype._writev = function(chunks, cb) {\\r\\n  this._writeGeneric(true, chunks, '', cb);\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype._write = function(data, encoding, cb) {\\r\\n  this._writeGeneric(false, data, encoding, cb);\\r\\n};\\r\\n\\r\\nfunction createWriteReq(req, handle, data, encoding) {\\r\\n  switch (encoding) {\\r\\n    case 'binary':\\r\\n      return handle.writeBinaryString(req, data);\\r\\n\\r\\n    case 'buffer':\\r\\n      return handle.writeBuffer(req, data);\\r\\n\\r\\n    case 'utf8':\\r\\n    case 'utf-8':\\r\\n      return handle.writeUtf8String(req, data);\\r\\n\\r\\n    case 'ascii':\\r\\n      return handle.writeAsciiString(req, data);\\r\\n\\r\\n    case 'ucs2':\\r\\n    case 'ucs-2':\\r\\n    case 'utf16le':\\r\\n    case 'utf-16le':\\r\\n      return handle.writeUcs2String(req, data);\\r\\n\\r\\n    default:\\r\\n      return handle.writeBuffer(req, Buffer(data, encoding));\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nSocket.prototype.__defineGetter__('bytesWritten', function() {\\r\\n  var bytes = this._bytesDispatched,\\r\\n      state = this._writableState,\\r\\n      data = this._pendingData,\\r\\n      encoding = this._pendingEncoding;\\r\\n\\r\\n  if (!state)\\r\\n    return undefined;\\r\\n\\r\\n  state.getBuffer().forEach(function(el) {\\r\\n    if (el.chunk instanceof Buffer)\\r\\n      bytes += el.chunk.length;\\r\\n    else\\r\\n      bytes += Buffer.byteLength(el.chunk, el.encoding);\\r\\n  });\\r\\n\\r\\n  if (data) {\\r\\n    if (data instanceof Buffer)\\r\\n      bytes += data.length;\\r\\n    else\\r\\n      bytes += Buffer.byteLength(data, encoding);\\r\\n  }\\r\\n\\r\\n  return bytes;\\r\\n});\\r\\n\\r\\n\\r\\nfunction afterWrite(status, handle, req, err) {\\r\\n  var self = handle.owner;\\r\\n  if (self !== process.stderr && self !== process.stdout)\\r\\n    debug('afterWrite', status);\\r\\n\\r\\n  // callback may come after call to destroy.\\r\\n  if (self.destroyed) {\\r\\n    debug('afterWrite destroyed');\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  if (status < 0) {\\r\\n    var ex = exceptionWithHostPort(status, 'write', req.address, req.port);\\r\\n    debug('write failure', ex);\\r\\n    self._destroy(ex, req.cb);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  self._unrefTimer();\\r\\n\\r\\n  if (self !== process.stderr && self !== process.stdout)\\r\\n    debug('afterWrite call cb');\\r\\n\\r\\n  if (req.cb)\\r\\n    req.cb.call(self);\\r\\n}\\r\\n\\r\\n\\r\\nfunction connect(self, address, port, addressType, localAddress, localPort) {\\r\\n  // TODO return promise from Socket.prototype.connect which\\r\\n  // wraps _connectReq.\\r\\n\\r\\n  assert.ok(self._connecting);\\r\\n\\r\\n  var err;\\r\\n\\r\\n  if (localAddress || localPort) {\\r\\n    var bind;\\r\\n\\r\\n    if (addressType === 4) {\\r\\n      localAddress = localAddress || '0.0.0.0';\\r\\n      bind = self._handle.bind;\\r\\n    } else if (addressType === 6) {\\r\\n      localAddress = localAddress || '::';\\r\\n      bind = self._handle.bind6;\\r\\n    } else {\\r\\n      self._destroy(new TypeError('Invalid addressType: ' + addressType));\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    debug('binding to localAddress: %s and localPort: %d',\\r\\n          localAddress,\\r\\n          localPort);\\r\\n\\r\\n    bind = bind.bind(self._handle);\\r\\n    err = bind(localAddress, localPort);\\r\\n\\r\\n    if (err) {\\r\\n      var ex = exceptionWithHostPort(err, 'bind', localAddress, localPort);\\r\\n      self._destroy(ex);\\r\\n      return;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (addressType === 6 || addressType === 4) {\\r\\n    var req = new TCPConnectWrap();\\r\\n    req.oncomplete = afterConnect;\\r\\n    req.address = address;\\r\\n    req.port = port;\\r\\n\\r\\n    if (addressType === 4)\\r\\n      err = self._handle.connect(req, address, port);\\r\\n    else\\r\\n      err = self._handle.connect6(req, address, port);\\r\\n\\r\\n  } else {\\r\\n    var req = new PipeConnectWrap();\\r\\n    req.address = address;\\r\\n    req.oncomplete = afterConnect;\\r\\n    err = self._handle.connect(req, address, afterConnect);\\r\\n  }\\r\\n\\r\\n  if (err) {\\r\\n    var sockname = self._getsockname();\\r\\n    var details;\\r\\n\\r\\n    if (sockname) {\\r\\n      details = sockname.address + ':' + sockname.port;\\r\\n    }\\r\\n\\r\\n    var ex = exceptionWithHostPort(err, 'connect', address, port, details);\\r\\n    self._destroy(ex);\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n// Check that the port number is not NaN when coerced to a number,\\r\\n// is an integer and that it falls within the legal range of port numbers.\\r\\nfunction isLegalPort(port) {\\r\\n  if (typeof port === 'string' && port.trim() === '')\\r\\n    return false;\\r\\n  return +port === (port >>> 0) && port >= 0 && port <= 0xFFFF;\\r\\n}\\r\\n\\r\\n\\r\\nSocket.prototype.connect = function(options, cb) {\\r\\n  if (this.write !== Socket.prototype.write)\\r\\n    this.write = Socket.prototype.write;\\r\\n\\r\\n  if (options === null || typeof options !== 'object') {\\r\\n    // Old API:\\r\\n    // connect(port, [host], [cb])\\r\\n    // connect(path, [cb]);\\r\\n    var args = normalizeConnectArgs(arguments);\\r\\n    return Socket.prototype.connect.apply(this, args);\\r\\n  }\\r\\n\\r\\n  if (this.destroyed) {\\r\\n    this._readableState.reading = false;\\r\\n    this._readableState.ended = false;\\r\\n    this._readableState.endEmitted = false;\\r\\n    this._writableState.ended = false;\\r\\n    this._writableState.ending = false;\\r\\n    this._writableState.finished = false;\\r\\n    this._writableState.errorEmitted = false;\\r\\n    this.destroyed = false;\\r\\n    this._handle = null;\\r\\n    this._peername = null;\\r\\n    this._sockname = null;\\r\\n  }\\r\\n\\r\\n  var self = this;\\r\\n  var pipe = !!options.path;\\r\\n  debug('pipe', pipe, options.path);\\r\\n\\r\\n  if (!this._handle) {\\r\\n    this._handle = pipe ? new Pipe() : new TCP();\\r\\n    initSocketHandle(this);\\r\\n  }\\r\\n\\r\\n  if (typeof cb === 'function') {\\r\\n    self.once('connect', cb);\\r\\n  }\\r\\n\\r\\n  this._unrefTimer();\\r\\n\\r\\n  self._connecting = true;\\r\\n  self.writable = true;\\r\\n\\r\\n  if (pipe) {\\r\\n    connect(self, options.path);\\r\\n\\r\\n  } else {\\r\\n    lookupAndConnect(self, options);\\r\\n  }\\r\\n  return self;\\r\\n};\\r\\n\\r\\n\\r\\nfunction lookupAndConnect(self, options) {\\r\\n  var dns = require('dns');\\r\\n  var host = options.host || 'localhost';\\r\\n  var port = options.port;\\r\\n  var localAddress = options.localAddress;\\r\\n  var localPort = options.localPort;\\r\\n\\r\\n  if (localAddress && !exports.isIP(localAddress))\\r\\n    throw new TypeError('\\\"localAddress\\\" option must be a valid IP: ' +\\r\\n                        localAddress);\\r\\n\\r\\n  if (localPort && typeof localPort !== 'number')\\r\\n    throw new TypeError('\\\"localPort\\\" option should be a number: ' + localPort);\\r\\n\\r\\n  if (typeof port !== 'undefined') {\\r\\n    if (typeof port !== 'number' && typeof port !== 'string')\\r\\n      throw new TypeError('\\\"port\\\" option should be a number or string: ' +\\r\\n                          port);\\r\\n    if (!isLegalPort(port))\\r\\n      throw new RangeError('\\\"port\\\" option should be >= 0 and < 65536: ' + port);\\r\\n  }\\r\\n  port |= 0;\\r\\n\\r\\n  // If host is an IP, skip performing a lookup\\r\\n  // TODO(evanlucas) should we hot path this for localhost?\\r\\n  var addressType = exports.isIP(host);\\r\\n  if (addressType) {\\r\\n    process.nextTick(function() {\\r\\n      if (self._connecting)\\r\\n        connect(self, host, port, addressType, localAddress, localPort);\\r\\n    });\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  if (options.lookup && typeof options.lookup !== 'function')\\r\\n    throw new TypeError('\\\"lookup\\\" option should be a function');\\r\\n\\r\\n  var dnsopts = {\\r\\n    family: options.family,\\r\\n    hints: 0\\r\\n  };\\r\\n\\r\\n  if (dnsopts.family !== 4 && dnsopts.family !== 6) {\\r\\n    dnsopts.hints = dns.ADDRCONFIG;\\r\\n    // The AI_V4MAPPED hint is not supported on FreeBSD, and getaddrinfo\\r\\n    // returns EAI_BADFLAGS. However, it seems to be supported on most other\\r\\n    // systems. See\\r\\n    // http://lists.freebsd.org/pipermail/freebsd-bugs/2008-February/028260.html\\r\\n    // for more information on the lack of support for FreeBSD.\\r\\n    if (process.platform !== 'freebsd')\\r\\n      dnsopts.hints |= dns.V4MAPPED;\\r\\n  }\\r\\n\\r\\n  debug('connect: find host ' + host);\\r\\n  debug('connect: dns options', dnsopts);\\r\\n  self._host = host;\\r\\n  var lookup = options.lookup || dns.lookup;\\r\\n  lookup(host, dnsopts, function(err, ip, addressType) {\\r\\n    self.emit('lookup', err, ip, addressType);\\r\\n\\r\\n    // It's possible we were destroyed while looking this up.\\r\\n    // XXX it would be great if we could cancel the promise returned by\\r\\n    // the look up.\\r\\n    if (!self._connecting) return;\\r\\n\\r\\n    if (err) {\\r\\n      // net.createConnection() creates a net.Socket object and\\r\\n      // immediately calls net.Socket.connect() on it (that's us).\\r\\n      // There are no event listeners registered yet so defer the\\r\\n      // error event to the next tick.\\r\\n      err.host = options.host;\\r\\n      err.port = options.port;\\r\\n      err.message = err.message + ' ' + options.host + ':' + options.port;\\r\\n      process.nextTick(connectErrorNT, self, err);\\r\\n    } else {\\r\\n      self._unrefTimer();\\r\\n      connect(self,\\r\\n              ip,\\r\\n              port,\\r\\n              addressType,\\r\\n              localAddress,\\r\\n              localPort);\\r\\n    }\\r\\n  });\\r\\n}\\r\\n\\r\\n\\r\\nfunction connectErrorNT(self, err) {\\r\\n  self.emit('error', err);\\r\\n  self._destroy();\\r\\n}\\r\\n\\r\\n\\r\\nSocket.prototype.ref = function() {\\r\\n  if (!this._handle) {\\r\\n    this.once('connect', this.ref);\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  this._handle.ref();\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nSocket.prototype.unref = function() {\\r\\n  if (!this._handle) {\\r\\n    this.once('connect', this.unref);\\r\\n    return this;\\r\\n  }\\r\\n\\r\\n  this._handle.unref();\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nfunction afterConnect(status, handle, req, readable, writable) {\\r\\n  var self = handle.owner;\\r\\n\\r\\n  // callback may come after call to destroy\\r\\n  if (self.destroyed) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // Update handle if it was wrapped\\r\\n  // TODO(indutny): assert that the handle is actually an ancestor of old one\\r\\n  handle = self._handle;\\r\\n\\r\\n  debug('afterConnect');\\r\\n\\r\\n  assert.ok(self._connecting);\\r\\n  self._connecting = false;\\r\\n  self._sockname = null;\\r\\n\\r\\n  if (status == 0) {\\r\\n    self.readable = readable;\\r\\n    self.writable = writable;\\r\\n    self._unrefTimer();\\r\\n\\r\\n    self.emit('connect');\\r\\n\\r\\n    // start the first read, or get an immediate EOF.\\r\\n    // this doesn't actually consume any bytes, because len=0.\\r\\n    if (readable && !self.isPaused())\\r\\n      self.read(0);\\r\\n\\r\\n  } else {\\r\\n    self._connecting = false;\\r\\n    var details;\\r\\n    if (req.localAddress && req.localPort) {\\r\\n      ex.localAddress = req.localAddress;\\r\\n      ex.localPort = req.localPort;\\r\\n      details = ex.localAddress + ':' + ex.localPort;\\r\\n    }\\r\\n    var ex = exceptionWithHostPort(status,\\r\\n                                   'connect',\\r\\n                                   req.address,\\r\\n                                   req.port,\\r\\n                                   details);\\r\\n    self._destroy(ex);\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nfunction Server(options, connectionListener) {\\r\\n  if (!(this instanceof Server))\\r\\n    return new Server(options, connectionListener);\\r\\n\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  var self = this;\\r\\n  var options;\\r\\n\\r\\n  if (typeof options === 'function') {\\r\\n    connectionListener = options;\\r\\n    options = {};\\r\\n    self.on('connection', connectionListener);\\r\\n  } else {\\r\\n    options = options || {};\\r\\n\\r\\n    if (typeof connectionListener === 'function') {\\r\\n      self.on('connection', connectionListener);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  this._connections = 0;\\r\\n\\r\\n  Object.defineProperty(this, 'connections', {\\r\\n    get: internalUtil.deprecate(function() {\\r\\n\\r\\n      if (self._usingSlaves) {\\r\\n        return null;\\r\\n      }\\r\\n      return self._connections;\\r\\n    }, 'Server.connections property is deprecated. ' +\\r\\n       'Use Server.getConnections method instead.'),\\r\\n    set: internalUtil.deprecate(function(val) {\\r\\n      return (self._connections = val);\\r\\n    }, 'Server.connections property is deprecated.'),\\r\\n    configurable: true, enumerable: false\\r\\n  });\\r\\n\\r\\n  this._handle = null;\\r\\n  this._usingSlaves = false;\\r\\n  this._slaves = [];\\r\\n  this._unref = false;\\r\\n\\r\\n  this.allowHalfOpen = options.allowHalfOpen || false;\\r\\n  this.pauseOnConnect = !!options.pauseOnConnect;\\r\\n}\\r\\nutil.inherits(Server, EventEmitter);\\r\\nexports.Server = Server;\\r\\n\\r\\n\\r\\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\\r\\n\\r\\nfunction _listen(handle, backlog) {\\r\\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\\r\\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\\r\\n  // which will thus give us a backlog of 512 entries.\\r\\n  return handle.listen(backlog || 511);\\r\\n}\\r\\n\\r\\nvar createServerHandle = exports._createServerHandle =\\r\\n    function(address, port, addressType, fd) {\\r\\n  var err = 0;\\r\\n  // assign handle in listen, and clean up if bind or listen fails\\r\\n  var handle;\\r\\n\\r\\n  var isTCP = false;\\r\\n  if (typeof fd === 'number' && fd >= 0) {\\r\\n    try {\\r\\n      handle = createHandle(fd);\\r\\n    }\\r\\n    catch (e) {\\r\\n      // Not a fd we can listen on.  This will trigger an error.\\r\\n      debug('listen invalid fd=' + fd + ': ' + e.message);\\r\\n      return uv.UV_EINVAL;\\r\\n    }\\r\\n    handle.open(fd);\\r\\n    handle.readable = true;\\r\\n    handle.writable = true;\\r\\n    assert(!address && !port);\\r\\n  } else if (port === -1 && addressType === -1) {\\r\\n    handle = new Pipe();\\r\\n    if (process.platform === 'win32') {\\r\\n      var instances = parseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\\r\\n      if (!isNaN(instances)) {\\r\\n        handle.setPendingInstances(instances);\\r\\n      }\\r\\n    }\\r\\n  } else {\\r\\n    handle = new TCP();\\r\\n    isTCP = true;\\r\\n  }\\r\\n\\r\\n  if (address || port || isTCP) {\\r\\n    debug('bind to ' + (address || 'anycast'));\\r\\n    if (!address) {\\r\\n      // Try binding to ipv6 first\\r\\n      err = handle.bind6('::', port);\\r\\n      if (err) {\\r\\n        handle.close();\\r\\n        // Fallback to ipv4\\r\\n        return createServerHandle('0.0.0.0', port);\\r\\n      }\\r\\n    } else if (addressType === 6) {\\r\\n      err = handle.bind6(address, port);\\r\\n    } else {\\r\\n      err = handle.bind(address, port);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (err) {\\r\\n    handle.close();\\r\\n    return err;\\r\\n  }\\r\\n\\r\\n  return handle;\\r\\n};\\r\\n\\r\\n\\r\\nServer.prototype._listen2 = function(address, port, addressType, backlog, fd) {\\r\\n  debug('listen2', address, port, addressType, backlog, fd);\\r\\n  var self = this;\\r\\n\\r\\n  // If there is not yet a handle, we need to create one and bind.\\r\\n  // In the case of a server sent via IPC, we don't need to do this.\\r\\n  if (self._handle) {\\r\\n    debug('_listen2: have a handle already');\\r\\n  } else {\\r\\n    debug('_listen2: create a handle');\\r\\n\\r\\n    var rval = null;\\r\\n\\r\\n    if (!address && typeof fd !== 'number') {\\r\\n      rval = createServerHandle('::', port, 6, fd);\\r\\n\\r\\n      if (typeof rval === 'number') {\\r\\n        rval = null;\\r\\n        address = '0.0.0.0';\\r\\n        addressType = 4;\\r\\n      } else {\\r\\n        address = '::';\\r\\n        addressType = 6;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (rval === null)\\r\\n      rval = createServerHandle(address, port, addressType, fd);\\r\\n\\r\\n    if (typeof rval === 'number') {\\r\\n      var error = exceptionWithHostPort(rval, 'listen', address, port);\\r\\n      process.nextTick(emitErrorNT, self, error);\\r\\n      return;\\r\\n    }\\r\\n    self._handle = rval;\\r\\n  }\\r\\n\\r\\n  self._handle.onconnection = onconnection;\\r\\n  self._handle.owner = self;\\r\\n\\r\\n  var err = _listen(self._handle, backlog);\\r\\n\\r\\n  if (err) {\\r\\n    var ex = exceptionWithHostPort(err, 'listen', address, port);\\r\\n    self._handle.close();\\r\\n    self._handle = null;\\r\\n    process.nextTick(emitErrorNT, self, ex);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // generate connection key, this should be unique to the connection\\r\\n  this._connectionKey = addressType + ':' + address + ':' + port;\\r\\n\\r\\n  // unref the handle if the server was unref'ed prior to listening\\r\\n  if (this._unref)\\r\\n    this.unref();\\r\\n\\r\\n  process.nextTick(emitListeningNT, self);\\r\\n};\\r\\n\\r\\n\\r\\nfunction emitErrorNT(self, err) {\\r\\n  self.emit('error', err);\\r\\n}\\r\\n\\r\\n\\r\\nfunction emitListeningNT(self) {\\r\\n  // ensure handle hasn't closed\\r\\n  if (self._handle)\\r\\n    self.emit('listening');\\r\\n}\\r\\n\\r\\n\\r\\nfunction listen(self, address, port, addressType, backlog, fd, exclusive) {\\r\\n  exclusive = !!exclusive;\\r\\n\\r\\n  if (!cluster) cluster = require('cluster');\\r\\n\\r\\n  if (cluster.isMaster || exclusive) {\\r\\n    self._listen2(address, port, addressType, backlog, fd);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  cluster._getServer(self, {\\r\\n    address: address,\\r\\n    port: port,\\r\\n    addressType: addressType,\\r\\n    fd: fd,\\r\\n    flags: 0\\r\\n  }, cb);\\r\\n\\r\\n  function cb(err, handle) {\\r\\n    // EADDRINUSE may not be reported until we call listen(). To complicate\\r\\n    // matters, a failed bind() followed by listen() will implicitly bind to\\r\\n    // a random port. Ergo, check that the socket is bound to the expected\\r\\n    // port before calling listen().\\r\\n    //\\r\\n    // FIXME(bnoordhuis) Doesn't work for pipe handles, they don't have a\\r\\n    // getsockname() method. Non-issue for now, the cluster module doesn't\\r\\n    // really support pipes anyway.\\r\\n    if (err === 0 && port > 0 && handle.getsockname) {\\r\\n      var out = {};\\r\\n      err = handle.getsockname(out);\\r\\n      if (err === 0 && port !== out.port)\\r\\n        err = uv.UV_EADDRINUSE;\\r\\n    }\\r\\n\\r\\n    if (err) {\\r\\n      var ex = exceptionWithHostPort(err, 'bind', address, port);\\r\\n      return self.emit('error', ex);\\r\\n    }\\r\\n\\r\\n    self._handle = handle;\\r\\n    self._listen2(address, port, addressType, backlog, fd);\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\nServer.prototype.listen = function() {\\r\\n  var self = this;\\r\\n\\r\\n  var lastArg = arguments[arguments.length - 1];\\r\\n  if (typeof lastArg === 'function') {\\r\\n    self.once('listening', lastArg);\\r\\n  }\\r\\n\\r\\n  var port = toNumber(arguments[0]);\\r\\n\\r\\n  // The third optional argument is the backlog size.\\r\\n  // When the ip is omitted it can be the second argument.\\r\\n  var backlog = toNumber(arguments[1]) || toNumber(arguments[2]);\\r\\n\\r\\n  if (arguments.length === 0 || typeof arguments[0] === 'function') {\\r\\n    // Bind to a random port.\\r\\n    listen(self, null, 0, null, backlog);\\r\\n  } else if (arguments[0] !== null && typeof arguments[0] === 'object') {\\r\\n    var h = arguments[0];\\r\\n    h = h._handle || h.handle || h;\\r\\n\\r\\n    if (h instanceof TCP) {\\r\\n      self._handle = h;\\r\\n      listen(self, null, -1, -1, backlog);\\r\\n    } else if (typeof h.fd === 'number' && h.fd >= 0) {\\r\\n      listen(self, null, null, null, backlog, h.fd);\\r\\n    } else {\\r\\n      // The first argument is a configuration object\\r\\n      if (h.backlog)\\r\\n        backlog = h.backlog;\\r\\n\\r\\n      if (typeof h.port === 'number' || typeof h.port === 'string' ||\\r\\n          (typeof h.port === 'undefined' && 'port' in h)) {\\r\\n        // Undefined is interpreted as zero (random port) for consistency\\r\\n        // with net.connect().\\r\\n        if (typeof h.port !== 'undefined' && !isLegalPort(h.port))\\r\\n          throw new RangeError('\\\"port\\\" option should be >= 0 and < 65536: ' +\\r\\n                               h.port);\\r\\n        if (h.host)\\r\\n          listenAfterLookup(h.port | 0, h.host, backlog, h.exclusive);\\r\\n        else\\r\\n          listen(self, null, h.port | 0, 4, backlog, undefined, h.exclusive);\\r\\n      } else if (h.path && isPipeName(h.path)) {\\r\\n        var pipeName = self._pipeName = h.path;\\r\\n        listen(self, pipeName, -1, -1, backlog, undefined, h.exclusive);\\r\\n      } else {\\r\\n        throw new Error('Invalid listen argument: ' + h);\\r\\n      }\\r\\n    }\\r\\n  } else if (isPipeName(arguments[0])) {\\r\\n    // UNIX socket or Windows pipe.\\r\\n    var pipeName = self._pipeName = arguments[0];\\r\\n    listen(self, pipeName, -1, -1, backlog);\\r\\n\\r\\n  } else if (arguments[1] === undefined ||\\r\\n             typeof arguments[1] === 'function' ||\\r\\n             typeof arguments[1] === 'number') {\\r\\n    // The first argument is the port, no IP given.\\r\\n    listen(self, null, port, 4, backlog);\\r\\n\\r\\n  } else {\\r\\n    // The first argument is the port, the second an IP.\\r\\n    listenAfterLookup(port, arguments[1], backlog);\\r\\n  }\\r\\n\\r\\n  function listenAfterLookup(port, address, backlog, exclusive) {\\r\\n    require('dns').lookup(address, function(err, ip, addressType) {\\r\\n      if (err) {\\r\\n        self.emit('error', err);\\r\\n      } else {\\r\\n        addressType = ip ? addressType : 4;\\r\\n        listen(self, ip, port, addressType, backlog, undefined, exclusive);\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return self;\\r\\n};\\r\\n\\r\\nServer.prototype.address = function() {\\r\\n  if (this._handle && this._handle.getsockname) {\\r\\n    var out = {};\\r\\n    this._handle.getsockname(out);\\r\\n    // TODO(bnoordhuis) Check err and throw?\\r\\n    return out;\\r\\n  } else if (this._pipeName) {\\r\\n    return this._pipeName;\\r\\n  } else {\\r\\n    return null;\\r\\n  }\\r\\n};\\r\\n\\r\\nfunction onconnection(err, clientHandle) {\\r\\n  var handle = this;\\r\\n  var self = handle.owner;\\r\\n\\r\\n  debug('onconnection');\\r\\n\\r\\n  if (err) {\\r\\n    self.emit('error', errnoException(err, 'accept'));\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\r\\n    clientHandle.close();\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  var socket = new Socket({\\r\\n    handle: clientHandle,\\r\\n    allowHalfOpen: self.allowHalfOpen,\\r\\n    pauseOnCreate: self.pauseOnConnect\\r\\n  });\\r\\n  socket.readable = socket.writable = true;\\r\\n\\r\\n\\r\\n  self._connections++;\\r\\n  socket.server = self;\\r\\n\\r\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\r\\n  LTTNG_NET_SERVER_CONNECTION(socket);\\r\\n  COUNTER_NET_SERVER_CONNECTION(socket);\\r\\n  self.emit('connection', socket);\\r\\n}\\r\\n\\r\\n\\r\\nServer.prototype.getConnections = function(cb) {\\r\\n  function end(err, connections) {\\r\\n    process.nextTick(cb, err, connections);\\r\\n  }\\r\\n\\r\\n  if (!this._usingSlaves) {\\r\\n    return end(null, this._connections);\\r\\n  }\\r\\n\\r\\n  // Poll slaves\\r\\n  var left = this._slaves.length,\\r\\n      total = this._connections;\\r\\n\\r\\n  function oncount(err, count) {\\r\\n    if (err) {\\r\\n      left = -1;\\r\\n      return end(err);\\r\\n    }\\r\\n\\r\\n    total += count;\\r\\n    if (--left === 0) return end(null, total);\\r\\n  }\\r\\n\\r\\n  this._slaves.forEach(function(slave) {\\r\\n    slave.getConnections(oncount);\\r\\n  });\\r\\n};\\r\\n\\r\\n\\r\\nServer.prototype.close = function(cb) {\\r\\n  function onSlaveClose() {\\r\\n    if (--left !== 0) return;\\r\\n\\r\\n    self._connections = 0;\\r\\n    self._emitCloseIfDrained();\\r\\n  }\\r\\n\\r\\n  if (typeof cb === 'function') {\\r\\n    if (!this._handle) {\\r\\n      this.once('close', function() {\\r\\n        cb(new Error('Not running'));\\r\\n      });\\r\\n    } else {\\r\\n      this.once('close', cb);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (this._handle) {\\r\\n    this._handle.close();\\r\\n    this._handle = null;\\r\\n  }\\r\\n\\r\\n  if (this._usingSlaves) {\\r\\n    var self = this,\\r\\n        left = this._slaves.length;\\r\\n\\r\\n    // Increment connections to be sure that, even if all sockets will be closed\\r\\n    // during polling of slaves, `close` event will be emitted only once.\\r\\n    this._connections++;\\r\\n\\r\\n    // Poll slaves\\r\\n    this._slaves.forEach(function(slave) {\\r\\n      slave.close(onSlaveClose);\\r\\n    });\\r\\n  } else {\\r\\n    this._emitCloseIfDrained();\\r\\n  }\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\nServer.prototype._emitCloseIfDrained = function() {\\r\\n  debug('SERVER _emitCloseIfDrained');\\r\\n  var self = this;\\r\\n\\r\\n  if (self._handle || self._connections) {\\r\\n    debug('SERVER handle? %j   connections? %d',\\r\\n          !!self._handle, self._connections);\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  process.nextTick(emitCloseNT, self);\\r\\n};\\r\\n\\r\\n\\r\\nfunction emitCloseNT(self) {\\r\\n  debug('SERVER: emit close');\\r\\n  self.emit('close');\\r\\n}\\r\\n\\r\\n\\r\\nServer.prototype.listenFD = internalUtil.deprecate(function(fd, type) {\\r\\n  return this.listen({ fd: fd });\\r\\n}, 'Server.listenFD is deprecated. Use Server.listen({fd: <number>}) instead.');\\r\\n\\r\\nServer.prototype._setupSlave = function(socketList) {\\r\\n  this._usingSlaves = true;\\r\\n  this._slaves.push(socketList);\\r\\n};\\r\\n\\r\\nServer.prototype.ref = function() {\\r\\n  this._unref = false;\\r\\n\\r\\n  if (this._handle)\\r\\n    this._handle.ref();\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\nServer.prototype.unref = function() {\\r\\n  this._unref = true;\\r\\n\\r\\n  if (this._handle)\\r\\n    this._handle.unref();\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n\\r\\nexports.isIP = cares.isIP;\\r\\n\\r\\n\\r\\nexports.isIPv4 = function(input) {\\r\\n  return exports.isIP(input) === 4;\\r\\n};\\r\\n\\r\\n\\r\\nexports.isIPv6 = function(input) {\\r\\n  return exports.isIP(input) === 6;\\r\\n};\\r\\n\\r\\n\\r\\nif (process.platform === 'win32') {\\r\\n  var simultaneousAccepts;\\r\\n\\r\\n  exports._setSimultaneousAccepts = function(handle) {\\r\\n    if (handle === undefined) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    if (simultaneousAccepts === undefined) {\\r\\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\\r\\n                             process.env.NODE_MANY_ACCEPTS !== '0');\\r\\n    }\\r\\n\\r\\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\\r\\n      handle.setSimultaneousAccepts(simultaneousAccepts);\\r\\n      handle._simultaneousAccepts = simultaneousAccepts;\\r\\n    }\\r\\n  };\\r\\n} else {\\r\\n  exports._setSimultaneousAccepts = function(handle) {};\\r\\n}\\r\\n\",\"dns\":\"'use strict';\\n\\nvar net = require('net');\\nvar util = require('util');\\n\\nvar cares = process.binding('cares_wrap');\\nvar uv = process.binding('uv');\\n\\nvar GetAddrInfoReqWrap = cares.GetAddrInfoReqWrap;\\nvar GetNameInfoReqWrap = cares.GetNameInfoReqWrap;\\nvar QueryReqWrap = cares.QueryReqWrap;\\n\\nvar isIp = net.isIP;\\n\\n\\nfunction errnoException(err, syscall, hostname) {\\n  // FIXME(bnoordhuis) Remove this backwards compatibility nonsense and pass\\n  // the true error to the user. ENOTFOUND is not even a proper POSIX error!\\n  if (err === uv.UV_EAI_MEMORY ||\\n      err === uv.UV_EAI_NODATA ||\\n      err === uv.UV_EAI_NONAME) {\\n    err = 'ENOTFOUND';\\n  }\\n  var ex = null;\\n  if (typeof err === 'string') {  // c-ares error code.\\n    ex = new Error(syscall + ' ' + err + (hostname ? ' ' + hostname : ''));\\n    ex.code = err;\\n    ex.errno = err;\\n    ex.syscall = syscall;\\n  } else {\\n    ex = util._errnoException(err, syscall);\\n  }\\n  if (hostname) {\\n    ex.hostname = hostname;\\n  }\\n  return ex;\\n}\\n\\n\\n// c-ares invokes a callback either synchronously or asynchronously,\\n// but the dns API should always invoke a callback asynchronously.\\n//\\n// This function makes sure that the callback is invoked asynchronously.\\n// It returns a function that invokes the callback within nextTick().\\n//\\n// To avoid invoking unnecessary nextTick(), `immediately` property of\\n// returned function should be set to true after c-ares returned.\\n//\\n// Usage:\\n//\\n// function someAPI(callback) {\\n//   callback = makeAsync(callback);\\n//   channel.someAPI(..., callback);\\n//   callback.immediately = true;\\n// }\\nfunction makeAsync(callback) {\\n  if (typeof callback !== 'function') {\\n    return callback;\\n  }\\n  return function asyncCallback() {\\n    if (asyncCallback.immediately) {\\n      // The API already returned, we can invoke the callback immediately.\\n      callback.apply(null, arguments);\\n    } else {\\n      var args = new Array(arguments.length + 1);\\n      args[0] = callback;\\n      for (var i = 1, a = 0; a < arguments.length; ++i, ++a)\\n        args[i] = arguments[a];\\n      process.nextTick.apply(null, args);\\n    }\\n  };\\n}\\n\\n\\nfunction onlookup(err, addresses) {\\n  if (err) {\\n    return this.callback(errnoException(err, 'getaddrinfo', this.hostname));\\n  }\\n  if (this.family) {\\n    this.callback(null, addresses[0], this.family);\\n  } else {\\n    this.callback(null, addresses[0], addresses[0].indexOf(':') >= 0 ? 6 : 4);\\n  }\\n}\\n\\n\\nfunction onlookupall(err, addresses) {\\n  var results = [];\\n  if (err) {\\n    return this.callback(errnoException(err, 'getaddrinfo', this.hostname));\\n  }\\n\\n  for (var i = 0; i < addresses.length; i++) {\\n    results.push({\\n      address: addresses[i],\\n      family: this.family || (addresses[i].indexOf(':') >= 0 ? 6 : 4)\\n    });\\n  }\\n\\n  this.callback(null, results);\\n}\\n\\n\\n// Easy DNS A/AAAA look up\\n// lookup(hostname, [options,] callback)\\nexports.lookup = function lookup(hostname, options, callback) {\\n  var hints = 0;\\n  var family = -1;\\n  var all = false;\\n\\n  // Parse arguments\\n  if (hostname && typeof hostname !== 'string') {\\n    throw new TypeError('Invalid arguments: ' +\\n                        'hostname must be a string or falsey');\\n  } else if (typeof options === 'function') {\\n    callback = options;\\n    family = 0;\\n  } else if (typeof callback !== 'function') {\\n    throw new TypeError('Invalid arguments: callback must be passed');\\n  } else if (options !== null && typeof options === 'object') {\\n    hints = options.hints >>> 0;\\n    family = options.family >>> 0;\\n    all = options.all === true;\\n\\n    if (hints !== 0 &&\\n        hints !== exports.ADDRCONFIG &&\\n        hints !== exports.V4MAPPED &&\\n        hints !== (exports.ADDRCONFIG | exports.V4MAPPED)) {\\n      throw new TypeError('Invalid argument: hints must use valid flags');\\n    }\\n  } else {\\n    family = options >>> 0;\\n  }\\n\\n  if (family !== 0 && family !== 4 && family !== 6)\\n    throw new TypeError('Invalid argument: family must be 4 or 6');\\n\\n  callback = makeAsync(callback);\\n\\n  if (!hostname) {\\n    if (all) {\\n      callback(null, []);\\n    } else {\\n      callback(null, null, family === 6 ? 6 : 4);\\n    }\\n    return {};\\n  }\\n\\n  var matchedFamily = net.isIP(hostname);\\n  if (matchedFamily) {\\n    if (all) {\\n      callback(null, [{address: hostname, family: matchedFamily}]);\\n    } else {\\n      callback(null, hostname, matchedFamily);\\n    }\\n    return {};\\n  }\\n\\n  var req = new GetAddrInfoReqWrap();\\n  req.callback = callback;\\n  req.family = family;\\n  req.hostname = hostname;\\n  req.oncomplete = all ? onlookupall : onlookup;\\n\\n  var err = cares.getaddrinfo(req, hostname, family, hints);\\n  if (err) {\\n    callback(errnoException(err, 'getaddrinfo', hostname));\\n    return {};\\n  }\\n\\n  callback.immediately = true;\\n  return req;\\n};\\n\\n\\nfunction onlookupservice(err, host, service) {\\n  if (err)\\n    return this.callback(errnoException(err, 'getnameinfo', this.host));\\n\\n  this.callback(null, host, service);\\n}\\n\\n\\n// lookupService(address, port, callback)\\nexports.lookupService = function(host, port, callback) {\\n  if (arguments.length !== 3)\\n    throw new Error('Invalid arguments');\\n\\n  if (cares.isIP(host) === 0)\\n    throw new TypeError('\\\"host\\\" argument needs to be a valid IP address');\\n\\n  callback = makeAsync(callback);\\n\\n  var req = new GetNameInfoReqWrap();\\n  req.callback = callback;\\n  req.host = host;\\n  req.port = port;\\n  req.oncomplete = onlookupservice;\\n\\n  var err = cares.getnameinfo(req, host, port);\\n  if (err) throw errnoException(err, 'getnameinfo', host);\\n\\n  callback.immediately = true;\\n  return req;\\n};\\n\\n\\nfunction onresolve(err, result) {\\n  if (err)\\n    this.callback(errnoException(err, this.bindingName, this.hostname));\\n  else\\n    this.callback(null, result);\\n}\\n\\n\\nfunction resolver(bindingName) {\\n  var binding = cares[bindingName];\\n\\n  return function query(name, callback) {\\n    if (typeof name !== 'string') {\\n      throw new Error('\\\"name\\\" argument must be a string');\\n    } else if (typeof callback !== 'function') {\\n      throw new Error('\\\"callback\\\" argument must be a function');\\n    }\\n\\n    callback = makeAsync(callback);\\n    var req = new QueryReqWrap();\\n    req.bindingName = bindingName;\\n    req.callback = callback;\\n    req.hostname = name;\\n    req.oncomplete = onresolve;\\n    var err = binding(req, name);\\n    if (err) throw errnoException(err, bindingName);\\n    callback.immediately = true;\\n    return req;\\n  };\\n}\\n\\n\\nvar resolveMap = {};\\nexports.resolve4 = resolveMap.A = resolver('queryA');\\nexports.resolve6 = resolveMap.AAAA = resolver('queryAaaa');\\nexports.resolveCname = resolveMap.CNAME = resolver('queryCname');\\nexports.resolveMx = resolveMap.MX = resolver('queryMx');\\nexports.resolveNs = resolveMap.NS = resolver('queryNs');\\nexports.resolveTxt = resolveMap.TXT = resolver('queryTxt');\\nexports.resolveSrv = resolveMap.SRV = resolver('querySrv');\\nexports.resolveNaptr = resolveMap.NAPTR = resolver('queryNaptr');\\nexports.resolveSoa = resolveMap.SOA = resolver('querySoa');\\nexports.reverse = resolveMap.PTR = resolver('getHostByAddr');\\n\\n\\nexports.resolve = function(hostname, type_, callback_) {\\n  var resolver, callback;\\n  if (typeof type_ === 'string') {\\n    resolver = resolveMap[type_];\\n    callback = callback_;\\n  } else if (typeof type_ === 'function') {\\n    resolver = exports.resolve4;\\n    callback = type_;\\n  } else {\\n    throw new Error('\\\"type\\\" argument must be a string');\\n  }\\n\\n  if (typeof resolver === 'function') {\\n    return resolver(hostname, callback);\\n  } else {\\n    throw new Error('Unknown type \\\"' + type_ + '\\\"');\\n  }\\n};\\n\\n\\nexports.getServers = function() {\\n  return cares.getServers();\\n};\\n\\n\\nexports.setServers = function(servers) {\\n  // cache the original servers because in the event of an error setting the\\n  // servers cares won't have any servers available for resolution\\n  var orig = cares.getServers();\\n\\n  var newSet = [];\\n\\n  servers.forEach(function(serv) {\\n    var ver = isIp(serv);\\n\\n    if (ver)\\n      return newSet.push([ver, serv]);\\n\\n    var match = serv.match(/\\\\[(.*)\\\\](:\\\\d+)?/);\\n\\n    // we have an IPv6 in brackets\\n    if (match) {\\n      ver = isIp(match[1]);\\n      if (ver)\\n        return newSet.push([ver, match[1]]);\\n    }\\n\\n    var s = serv.split(/:\\\\d+$/)[0];\\n    ver = isIp(s);\\n\\n    if (ver)\\n      return newSet.push([ver, s]);\\n\\n    throw new Error('IP address is not properly formatted: ' + serv);\\n  });\\n\\n  var r = cares.setServers(newSet);\\n\\n  if (r) {\\n    // reset the servers to the old servers, because ares probably unset them\\n    cares.setServers(orig.join(','));\\n\\n    var err = cares.strerror(r);\\n    throw new Error('c-ares failed to set servers: \\\"' + err +\\n                    '\\\" [' + servers + ']');\\n  }\\n};\\n\\n// uv_getaddrinfo flags\\nexports.ADDRCONFIG = cares.AI_ADDRCONFIG;\\nexports.V4MAPPED = cares.AI_V4MAPPED;\\n\\n// ERROR CODES\\nexports.NODATA = 'ENODATA';\\nexports.FORMERR = 'EFORMERR';\\nexports.SERVFAIL = 'ESERVFAIL';\\nexports.NOTFOUND = 'ENOTFOUND';\\nexports.NOTIMP = 'ENOTIMP';\\nexports.REFUSED = 'EREFUSED';\\nexports.BADQUERY = 'EBADQUERY';\\nexports.BADNAME = 'EBADNAME';\\nexports.BADFAMILY = 'EBADFAMILY';\\nexports.BADRESP = 'EBADRESP';\\nexports.CONNREFUSED = 'ECONNREFUSED';\\nexports.TIMEOUT = 'ETIMEOUT';\\nexports.EOF = 'EOF';\\nexports.FILE = 'EFILE';\\nexports.NOMEM = 'ENOMEM';\\nexports.DESTRUCTION = 'EDESTRUCTION';\\nexports.BADSTR = 'EBADSTR';\\nexports.BADFLAGS = 'EBADFLAGS';\\nexports.NONAME = 'ENONAME';\\nexports.BADHINTS = 'EBADHINTS';\\nexports.NOTINITIALIZED = 'ENOTINITIALIZED';\\nexports.LOADIPHLPAPI = 'ELOADIPHLPAPI';\\nexports.ADDRGETNETWORKPARAMS = 'EADDRGETNETWORKPARAMS';\\nexports.CANCELLED = 'ECANCELLED';\\n\",\"cluster\":\"exports.isMaster = true;\\r\\n\",\"string_decoder\":\"'use strict';\\r\\n\\r\\nvar Buffer = require('buffer').Buffer;\\r\\n\\r\\nfunction assertEncoding(encoding) {\\r\\n  // Do not cache `Buffer.isEncoding`, some modules monkey-patch it to support\\r\\n  // additional encodings\\r\\n  if (encoding && !Buffer.isEncoding(encoding)) {\\r\\n    throw new Error('Unknown encoding: ' + encoding);\\r\\n  }\\r\\n}\\r\\n\\r\\n// StringDecoder provides an interface for efficiently splitting a series of\\r\\n// buffers into a series of JS strings without breaking apart multi-byte\\r\\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\\r\\n//\\r\\n// @TODO Handling all encodings inside a single object makes it very difficult\\r\\n// to reason about this code, so it should be split up in the future.\\r\\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\\r\\n// points as used by CESU-8.\\r\\nvar StringDecoder = exports.StringDecoder = function(encoding) {\\r\\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\\r\\n  assertEncoding(encoding);\\r\\n  switch (this.encoding) {\\r\\n    case 'utf8':\\r\\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\\r\\n      this.surrogateSize = 3;\\r\\n      break;\\r\\n    case 'ucs2':\\r\\n    case 'utf16le':\\r\\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\\r\\n      this.surrogateSize = 2;\\r\\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\\r\\n      break;\\r\\n    case 'base64':\\r\\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\\r\\n      this.surrogateSize = 3;\\r\\n      this.detectIncompleteChar = base64DetectIncompleteChar;\\r\\n      break;\\r\\n    default:\\r\\n      this.write = passThroughWrite;\\r\\n      return;\\r\\n  }\\r\\n\\r\\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\\r\\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\\r\\n  this.charBuffer = Buffer(6);\\r\\n  // Number of bytes received for the current incomplete multi-byte character.\\r\\n  this.charReceived = 0;\\r\\n  // Number of bytes expected for the current incomplete multi-byte character.\\r\\n  this.charLength = 0;\\r\\n};\\r\\n\\r\\n\\r\\n// write decodes the given buffer and returns it as JS string that is\\r\\n// guaranteed to not contain any partial multi-byte characters. Any partial\\r\\n// character found at the end of the buffer is buffered up, and will be\\r\\n// returned when calling write again with the remaining bytes.\\r\\n//\\r\\n// Note: Converting a Buffer containing an orphan surrogate to a String\\r\\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\\r\\n// Buffer#write) will replace incomplete surrogates with the unicode\\r\\n// replacement character. See https://codereview.chromium.org/121173009/ .\\r\\nStringDecoder.prototype.write = function(buffer) {\\r\\n  var charStr = '';\\r\\n  var buflen = buffer.length;\\r\\n  var charBuffer = this.charBuffer;\\r\\n  var charLength = this.charLength;\\r\\n  var charReceived = this.charReceived;\\r\\n  var surrogateSize = this.surrogateSize;\\r\\n  var encoding = this.encoding;\\r\\n  // if our last write ended with an incomplete multibyte character\\r\\n  while (charLength) {\\r\\n    // determine how many remaining bytes this buffer has to offer for this char\\r\\n    var diff = charLength - charReceived;\\r\\n    var available = (buflen >= diff) ? diff : buflen;\\r\\n\\r\\n    // add the new bytes to the char buffer\\r\\n    buffer.copy(charBuffer, charReceived, 0, available);\\r\\n    charReceived += available;\\r\\n\\r\\n    if (charReceived < charLength) {\\r\\n      // still not enough chars in this buffer? wait for more ...\\r\\n\\r\\n      this.charLength = charLength;\\r\\n      this.charReceived = charReceived;\\r\\n\\r\\n      return '';\\r\\n    }\\r\\n\\r\\n    // remove bytes belonging to the current character from the buffer\\r\\n    buffer = buffer.slice(available, buflen);\\r\\n    buflen = buffer.length;\\r\\n\\r\\n    // get the character that was split\\r\\n    charStr = charBuffer.toString(encoding, 0, charLength);\\r\\n\\r\\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\\r\\n    var charCode = charStr.charCodeAt(charStr.length - 1);\\r\\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\\r\\n      charLength += surrogateSize;\\r\\n      charStr = '';\\r\\n      continue;\\r\\n    }\\r\\n    charReceived = charLength = 0;\\r\\n\\r\\n    // if there are no more bytes in this buffer, just emit our char\\r\\n    if (buflen === 0) {\\r\\n      this.charLength = charLength;\\r\\n      this.charReceived = charReceived;\\r\\n\\r\\n      return charStr;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // determine and set charLength / charReceived\\r\\n  if (this.detectIncompleteChar(buffer))\\r\\n    charLength = this.charLength;\\r\\n  charReceived = this.charReceived;\\r\\n\\r\\n  var end = buflen;\\r\\n  if (charLength) {\\r\\n    // buffer the incomplete character bytes we got\\r\\n    buffer.copy(charBuffer, 0, buflen - charReceived, end);\\r\\n    end -= charReceived;\\r\\n  }\\r\\n\\r\\n  this.charLength = charLength;\\r\\n  charStr += buffer.toString(encoding, 0, end);\\r\\n\\r\\n  var end = charStr.length - 1;\\r\\n  var charCode = charStr.charCodeAt(end);\\r\\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\\r\\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\\r\\n    charLength += surrogateSize;\\r\\n    charReceived += surrogateSize;\\r\\n    charBuffer.copy(charBuffer, surrogateSize, 0, surrogateSize);\\r\\n    buffer.copy(charBuffer, 0, 0, surrogateSize);\\r\\n\\r\\n    this.charLength = charLength;\\r\\n    this.charReceived = charReceived;\\r\\n\\r\\n    return charStr.substring(0, end);\\r\\n  }\\r\\n\\r\\n  // or just emit the charStr\\r\\n  return charStr;\\r\\n};\\r\\n\\r\\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\\r\\n// the end of the given buffer. If so, it sets this.charLength to the byte\\r\\n// length that character, and sets this.charReceived to the number of bytes\\r\\n// that are available for this character.\\r\\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\\r\\n  var buflen = buffer.length;\\r\\n  // determine how many bytes we have to check at the end of this buffer\\r\\n  var i = (buflen >= 3) ? 3 : buflen;\\r\\n  var newlen = false;\\r\\n\\r\\n  // Figure out if one of the last i bytes of our buffer announces an\\r\\n  // incomplete char.\\r\\n  for (; i > 0; i--) {\\r\\n    var c = buffer[buflen - i];\\r\\n\\r\\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\\r\\n\\r\\n    // 110XXXXX\\r\\n    if (i === 1 && c >> 5 === 0x06) {\\r\\n      this.charLength = 2;\\r\\n      newlen = true;\\r\\n      break;\\r\\n    }\\r\\n\\r\\n    // 1110XXXX\\r\\n    if (i <= 2 && c >> 4 === 0x0E) {\\r\\n      this.charLength = 3;\\r\\n      newlen = true;\\r\\n      break;\\r\\n    }\\r\\n\\r\\n    // 11110XXX\\r\\n    if (i <= 3 && c >> 3 === 0x1E) {\\r\\n      this.charLength = 4;\\r\\n      newlen = true;\\r\\n      break;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  this.charReceived = i;\\r\\n\\r\\n  return newlen;\\r\\n};\\r\\n\\r\\nStringDecoder.prototype.end = function(buffer) {\\r\\n  var res = '';\\r\\n  if (buffer && buffer.length)\\r\\n    res = this.write(buffer);\\r\\n\\r\\n  var charReceived = this.charReceived;\\r\\n  if (charReceived) {\\r\\n    var cr = charReceived;\\r\\n    var buf = this.charBuffer;\\r\\n    var enc = this.encoding;\\r\\n    res += buf.toString(enc, 0, cr);\\r\\n  }\\r\\n\\r\\n  return res;\\r\\n};\\r\\n\\r\\nfunction passThroughWrite(buffer) {\\r\\n  return buffer.toString(this.encoding);\\r\\n}\\r\\n\\r\\nfunction utf16DetectIncompleteChar(buffer) {\\r\\n  var charReceived = this.charReceived = buffer.length % 2;\\r\\n  this.charLength = charReceived ? 2 : 0;\\r\\n  return true;\\r\\n}\\r\\n\\r\\nfunction base64DetectIncompleteChar(buffer) {\\r\\n  var charReceived = this.charReceived = buffer.length % 3;\\r\\n  this.charLength = charReceived ? 3 : 0;\\r\\n  return true;\\r\\n}\\r\\n\",\"tty\":\"'use strict';\\r\\n\\r\\nvar util = require('util');\\r\\nvar internalUtil = require('internal/util');\\r\\nvar net = require('net');\\r\\nvar TTY = process.binding('tty_wrap').TTY;\\r\\nvar isTTY = process.binding('tty_wrap').isTTY;\\r\\nvar inherits = util.inherits;\\r\\nvar errnoException = util._errnoException;\\r\\n\\r\\n\\r\\nexports.isatty = function(fd) {\\r\\n  return isTTY(fd);\\r\\n};\\r\\n\\r\\n\\r\\n// backwards-compat\\r\\nexports.setRawMode = internalUtil.deprecate(function(flag) {\\r\\n  if (!process.stdin.isTTY) {\\r\\n    throw new Error('Can\\\\'t set raw mode on non-tty');\\r\\n  }\\r\\n  process.stdin.setRawMode(flag);\\r\\n}, 'tty.setRawMode is deprecated. ' +\\r\\n   'Use process.stdin.setRawMode instead.');\\r\\n\\r\\n\\r\\nfunction ReadStream(fd, options) {\\r\\n  if (!(this instanceof ReadStream))\\r\\n    return new ReadStream(fd, options);\\r\\n\\r\\n  options = util._extend({\\r\\n    highWaterMark: 0,\\r\\n    readable: true,\\r\\n    writable: false,\\r\\n    handle: new TTY(fd, true)\\r\\n  }, options);\\r\\n\\r\\n  net.Socket.call(this, options);\\r\\n\\r\\n  this.isRaw = false;\\r\\n  this.isTTY = true;\\r\\n}\\r\\ninherits(ReadStream, net.Socket);\\r\\n\\r\\nexports.ReadStream = ReadStream;\\r\\n\\r\\nReadStream.prototype.setRawMode = function(flag) {\\r\\n  flag = !!flag;\\r\\n  this._handle.setRawMode(flag);\\r\\n  this.isRaw = flag;\\r\\n};\\r\\n\\r\\n\\r\\nfunction WriteStream(fd) {\\r\\n  if (!(this instanceof WriteStream)) return new WriteStream(fd);\\r\\n  net.Socket.call(this, {\\r\\n    handle: new TTY(fd, false),\\r\\n    readable: false,\\r\\n    writable: true\\r\\n  });\\r\\n\\r\\n  var winSize = [];\\r\\n  var err = this._handle.getWindowSize(winSize);\\r\\n  if (!err) {\\r\\n    this.columns = winSize[0];\\r\\n    this.rows = winSize[1];\\r\\n  }\\r\\n}\\r\\ninherits(WriteStream, net.Socket);\\r\\nexports.WriteStream = WriteStream;\\r\\n\\r\\n\\r\\nWriteStream.prototype.isTTY = true;\\r\\n\\r\\n\\r\\nWriteStream.prototype._refreshSize = function() {\\r\\n  var oldCols = this.columns;\\r\\n  var oldRows = this.rows;\\r\\n  var winSize = [];\\r\\n  var err = this._handle.getWindowSize(winSize);\\r\\n  if (err) {\\r\\n    this.emit('error', errnoException(err, 'getWindowSize'));\\r\\n    return;\\r\\n  }\\r\\n  var newCols = winSize[0];\\r\\n  var newRows = winSize[1];\\r\\n  if (oldCols !== newCols || oldRows !== newRows) {\\r\\n    this.columns = newCols;\\r\\n    this.rows = newRows;\\r\\n    this.emit('resize');\\r\\n  }\\r\\n};\\r\\n\\r\\n\\r\\n// backwards-compat\\r\\nWriteStream.prototype.cursorTo = function(x, y) {\\r\\n  require('readline').cursorTo(this, x, y);\\r\\n};\\r\\nWriteStream.prototype.moveCursor = function(dx, dy) {\\r\\n  require('readline').moveCursor(this, dx, dy);\\r\\n};\\r\\nWriteStream.prototype.clearLine = function(dir) {\\r\\n  require('readline').clearLine(this, dir);\\r\\n};\\r\\nWriteStream.prototype.clearScreenDown = function() {\\r\\n  require('readline').clearScreenDown(this);\\r\\n};\\r\\nWriteStream.prototype.getWindowSize = function() {\\r\\n  return [this.columns, this.rows];\\r\\n};\\r\\n\",\"internal/child_process\":\"'use strict';\\n\\nvar StringDecoder = require('string_decoder').StringDecoder;\\nvar Buffer = require('buffer').Buffer;\\nvar EventEmitter = require('events');\\nvar net = require('net');\\n//FIXME: dgram\\n// var dgram = require('dgram');\\nvar util = require('util');\\nvar constants = require('constants');\\nvar assert = require('assert');\\n\\nvar Process = process.binding('process_wrap').Process;\\nvar WriteWrap = process.binding('stream_wrap').WriteWrap;\\nvar uv = process.binding('uv');\\nvar Pipe = process.binding('pipe_wrap').Pipe;\\nvar TTY = process.binding('tty_wrap').TTY;\\nvar TCP = process.binding('tcp_wrap').TCP;\\n//FIXME udp\\n// var UDP = process.binding('udp_wrap').UDP;\\nvar SocketList = require('internal/socket_list');\\n\\nvar errnoException = util._errnoException;\\nvar SocketListSend = SocketList.SocketListSend;\\nvar SocketListReceive = SocketList.SocketListReceive;\\n\\nexports.ChildProcess = ChildProcess;\\nexports.setupChannel = setupChannel;\\nexports._validateStdio = _validateStdio;\\nexports.getSocketList = getSocketList;\\n\\n// module.exports = {\\n//   ChildProcess,\\n//   setupChannel,\\n//   _validateStdio,\\n//   getSocketList\\n// };\\n\\n// this object contain function to convert TCP objects to native handle objects\\n// and back again.\\nvar handleConversion = {\\n  'net.Native': {\\n    simultaneousAccepts: true,\\n\\n    send: function(message, handle) {\\n      return handle;\\n    },\\n\\n    got: function(message, handle, emit) {\\n      emit(handle);\\n    }\\n  },\\n\\n  'net.Server': {\\n    simultaneousAccepts: true,\\n\\n    send: function(message, server) {\\n      return server._handle;\\n    },\\n\\n    got: function(message, handle, emit) {\\n      var server = new net.Server();\\n      server.listen(handle, function() {\\n        emit(server);\\n      });\\n    }\\n  },\\n\\n  'net.Socket': {\\n    send: function(message, socket) {\\n      if (!socket._handle)\\n        return;\\n\\n      // if the socket was created by net.Server\\n      if (socket.server) {\\n        // the slave should keep track of the socket\\n        message.key = socket.server._connectionKey;\\n\\n        var firstTime = !this._channel.sockets.send[message.key];\\n        var socketList = getSocketList('send', this, message.key);\\n\\n        // the server should no longer expose a .connection property\\n        // and when asked to close it should query the socket status from\\n        // the slaves\\n        if (firstTime) socket.server._setupSlave(socketList);\\n\\n        // Act like socket is detached\\n        socket.server._connections--;\\n      }\\n\\n      // remove handle from socket object, it will be closed when the socket\\n      // will be sent\\n      var handle = socket._handle;\\n      handle.onread = function() {};\\n      socket._handle = null;\\n\\n      return handle;\\n    },\\n\\n    postSend: function(handle) {\\n      // Close the Socket handle after sending it\\n      if (handle)\\n        handle.close();\\n    },\\n\\n    got: function(message, handle, emit) {\\n      var socket = new net.Socket({handle: handle});\\n      socket.readable = socket.writable = true;\\n\\n      // if the socket was created by net.Server we will track the socket\\n      if (message.key) {\\n\\n        // add socket to connections list\\n        var socketList = getSocketList('got', this, message.key);\\n        socketList.add({\\n          socket: socket\\n        });\\n      }\\n\\n      emit(socket);\\n    }\\n  },\\n\\n  'dgram.Native': {\\n    simultaneousAccepts: false,\\n\\n    send: function(message, handle) {\\n      return handle;\\n    },\\n\\n    got: function(message, handle, emit) {\\n      emit(handle);\\n    }\\n  },\\n\\n  'dgram.Socket': {\\n    simultaneousAccepts: false,\\n\\n    send: function(message, socket) {\\n      message.dgramType = socket.type;\\n\\n      return socket._handle;\\n    },\\n\\n    got: function(message, handle, emit) {\\n      var socket = new dgram.Socket(message.dgramType);\\n\\n      socket.bind(handle, function() {\\n        emit(socket);\\n      });\\n    }\\n  }\\n};\\n\\n\\nfunction ChildProcess() {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n\\n  this._closesNeeded = 1;\\n  this._closesGot = 0;\\n  this.connected = false;\\n\\n  this.signalCode = null;\\n  this.exitCode = null;\\n  this.killed = false;\\n  this.spawnfile = null;\\n\\n  this._handle = new Process();\\n  this._handle.owner = this;\\n\\n  this._handle.onexit = function(exitCode, signalCode) {\\n    //\\n    // follow 0.4.x behaviour:\\n    //\\n    // - normally terminated processes don't touch this.signalCode\\n    // - signaled processes don't touch this.exitCode\\n    //\\n    // new in 0.9.x:\\n    //\\n    // - spawn failures are reported with exitCode < 0\\n    //\\n    var syscall = self.spawnfile ? 'spawn ' + self.spawnfile : 'spawn';\\n    var err = (exitCode < 0) ? errnoException(exitCode, syscall) : null;\\n\\n    if (signalCode) {\\n      self.signalCode = signalCode;\\n    } else {\\n      self.exitCode = exitCode;\\n    }\\n\\n    if (self.stdin) {\\n      self.stdin.destroy();\\n    }\\n\\n    self._handle.close();\\n    self._handle = null;\\n\\n    if (exitCode < 0) {\\n      if (self.spawnfile)\\n        err.path = self.spawnfile;\\n\\n      err.spawnargs = self.spawnargs.slice(1);\\n      self.emit('error', err);\\n    } else {\\n      self.emit('exit', self.exitCode, self.signalCode);\\n    }\\n\\n    // if any of the stdio streams have not been touched,\\n    // then pull all the data through so that it can get the\\n    // eof and emit a 'close' event.\\n    // Do it on nextTick so that the user has one last chance\\n    // to consume the output, if for example they only want to\\n    // start reading the data once the process exits.\\n    process.nextTick(flushStdio, self);\\n\\n    maybeClose(self);\\n  };\\n}\\nutil.inherits(ChildProcess, EventEmitter);\\n\\n\\nfunction flushStdio(subprocess) {\\n  if (subprocess.stdio == null) return;\\n  subprocess.stdio.forEach(function(stream, fd, stdio) {\\n    if (!stream || !stream.readable)\\n      return;\\n    stream.resume();\\n  });\\n}\\n\\n\\nfunction createSocket(pipe, readable) {\\n  var s = new net.Socket({ handle: pipe });\\n\\n  if (readable) {\\n    s.writable = false;\\n    s.readable = true;\\n  } else {\\n    s.writable = true;\\n    s.readable = false;\\n  }\\n\\n  return s;\\n}\\n\\n\\nfunction getHandleWrapType(stream) {\\n  if (stream instanceof Pipe) return 'pipe';\\n  if (stream instanceof TTY) return 'tty';\\n  if (stream instanceof TCP) return 'tcp';\\n  if (stream instanceof UDP) return 'udp';\\n\\n  return false;\\n}\\n\\n\\nChildProcess.prototype.spawn = function(options) {\\n  var self = this,\\n      ipc,\\n      ipcFd,\\n      // If no `stdio` option was given - use default\\n      stdio = options.stdio || 'pipe';\\n\\n  stdio = _validateStdio(stdio, false);\\n\\n  ipc = stdio.ipc;\\n  ipcFd = stdio.ipcFd;\\n  stdio = options.stdio = stdio.stdio;\\n\\n  if (ipc !== undefined) {\\n    // Let child process know about opened IPC channel\\n    options.envPairs = options.envPairs || [];\\n    options.envPairs.push('NODE_CHANNEL_FD=' + ipcFd);\\n  }\\n\\n  this.spawnfile = options.file;\\n  this.spawnargs = options.args;\\n\\n  var err = this._handle.spawn(options);\\n\\n  // Run-time errors should emit an error, not throw an exception.\\n  if (err === uv.UV_EAGAIN ||\\n      err === uv.UV_EMFILE ||\\n      err === uv.UV_ENFILE ||\\n      err === uv.UV_ENOENT) {\\n    process.nextTick(onErrorNT, self, err);\\n    // There is no point in continuing when we've hit EMFILE or ENFILE\\n    // because we won't be able to set up the stdio file descriptors.\\n    // It's kind of silly that the de facto spec for ENOENT (the test suite)\\n    // mandates that stdio _is_ set up, even if there is no process on the\\n    // receiving end, but it is what it is.\\n    if (err !== uv.UV_ENOENT) return err;\\n  } else if (err) {\\n    // Close all opened fds on error\\n    stdio.forEach(function(stdio) {\\n      if (stdio.type === 'pipe') {\\n        stdio.handle.close();\\n      }\\n    });\\n\\n    this._handle.close();\\n    this._handle = null;\\n    throw errnoException(err, 'spawn');\\n  }\\n\\n  this.pid = this._handle.pid;\\n\\n  stdio.forEach(function(stdio, i) {\\n    if (stdio.type === 'ignore') return;\\n\\n    if (stdio.ipc) {\\n      self._closesNeeded++;\\n      return;\\n    }\\n\\n    if (stdio.handle) {\\n      // when i === 0 - we're dealing with stdin\\n      // (which is the only one writable pipe)\\n      stdio.socket = createSocket(self.pid !== 0 ? stdio.handle : null, i > 0);\\n\\n      if (i > 0 && self.pid !== 0) {\\n        self._closesNeeded++;\\n        stdio.socket.on('close', function() {\\n          maybeClose(self);\\n        });\\n      }\\n    }\\n  });\\n\\n  this.stdin = stdio.length >= 1 && stdio[0].socket !== undefined ?\\n      stdio[0].socket : null;\\n  this.stdout = stdio.length >= 2 && stdio[1].socket !== undefined ?\\n      stdio[1].socket : null;\\n  this.stderr = stdio.length >= 3 && stdio[2].socket !== undefined ?\\n      stdio[2].socket : null;\\n\\n  this.stdio = stdio.map(function(stdio) {\\n    return stdio.socket === undefined ? null : stdio.socket;\\n  });\\n\\n  // Add .send() method and start listening for IPC data\\n  if (ipc !== undefined) setupChannel(this, ipc);\\n\\n  return err;\\n};\\n\\n\\nfunction onErrorNT(self, err) {\\n  self._handle.onexit(err);\\n}\\n\\n\\nChildProcess.prototype.kill = function(sig) {\\n  var signal;\\n\\n  if (sig === 0) {\\n    signal = 0;\\n  } else if (!sig) {\\n    signal = constants['SIGTERM'];\\n  } else {\\n    signal = constants[sig];\\n  }\\n\\n  if (signal === undefined) {\\n    throw new Error('Unknown signal: ' + sig);\\n  }\\n\\n  if (this._handle) {\\n    var err = this._handle.kill(signal);\\n    if (err === 0) {\\n      /* Success. */\\n      this.killed = true;\\n      return true;\\n    }\\n    if (err === uv.UV_ESRCH) {\\n      /* Already dead. */\\n    } else if (err === uv.UV_EINVAL || err === uv.UV_ENOSYS) {\\n      /* The underlying platform doesn't support this signal. */\\n      throw errnoException(err, 'kill');\\n    } else {\\n      /* Other error, almost certainly EPERM. */\\n      this.emit('error', errnoException(err, 'kill'));\\n    }\\n  }\\n\\n  /* Kill didn't succeed. */\\n  return false;\\n};\\n\\n\\nChildProcess.prototype.ref = function() {\\n  if (this._handle) this._handle.ref();\\n};\\n\\n\\nChildProcess.prototype.unref = function() {\\n  if (this._handle) this._handle.unref();\\n};\\n\\n// COMO nodejs code modification\\n// modified code here from es6 to es5\\nutil.inherits(ClassExtends, EventEmitter);\\nfunction ClassExtends (channel){\\n  EventEmitter.call(this);\\n  this.channel = channel;\\n  this.refs = 0;\\n\\n  this.ref = function() {\\n    if (++this.refs === 1) {\\n      this.channel.ref();\\n    }\\n  };\\n\\n  this.unref = function() {\\n    if (--this.refs === 0) {\\n      this.channel.unref();\\n      this.emit('unref');\\n    }\\n  };\\n}\\n\\nfunction setupChannel(target, channel) {\\n  target._channel = channel;\\n  target._handleQueue = null;\\n  var control = new ClassExtends(channel);\\n  // Object.setPrototypeOf(control, EventEmitter);\\n  // console.log(control);\\n  // var control = new class extends EventEmitter {\\n  //   constructor() {\\n  //     super();\\n  //     this.channel = channel;\\n  //     this.refs = 0;\\n  //   }\\n  //   ref() {\\n  //     if (++this.refs === 1) {\\n  //       this.channel.ref();\\n  //     }\\n  //   }\\n  //   unref() {\\n  //     if (--this.refs === 0) {\\n  //       this.channel.unref();\\n  //       this.emit('unref');\\n  //     }\\n  //   }\\n  // };\\n\\n  var decoder = new StringDecoder('utf8');\\n  var jsonBuffer = '';\\n  channel.buffering = false;\\n  channel.onread = function(nread, pool, recvHandle) {\\n    // TODO(bnoordhuis) Check that nread > 0.\\n    if (pool) {\\n      jsonBuffer += decoder.write(pool);\\n\\n      var i, start = 0;\\n\\n      //Linebreak is used as a message end sign\\n      while ((i = jsonBuffer.indexOf('\\\\n', start)) >= 0) {\\n        var json = jsonBuffer.slice(start, i);\\n        var message = JSON.parse(json);\\n\\n        // There will be at most one NODE_HANDLE message in every chunk we\\n        // read because SCM_RIGHTS messages don't get coalesced. Make sure\\n        // that we deliver the handle with the right message however.\\n        if (message && message.cmd === 'NODE_HANDLE')\\n          handleMessage(target, message, recvHandle);\\n        else\\n          handleMessage(target, message, undefined);\\n\\n        start = i + 1;\\n      }\\n      jsonBuffer = jsonBuffer.slice(start);\\n      this.buffering = jsonBuffer.length !== 0;\\n\\n    } else {\\n      this.buffering = false;\\n      target.disconnect();\\n      channel.onread = nop;\\n      channel.close();\\n      target._channel = null;\\n      maybeClose(target);\\n    }\\n  };\\n\\n  // object where socket lists will live\\n  channel.sockets = { got: {}, send: {} };\\n\\n  // handlers will go through this\\n  target.on('internalMessage', function(message, handle) {\\n    // Once acknowledged - continue sending handles.\\n    if (message.cmd === 'NODE_HANDLE_ACK') {\\n      assert(Array.isArray(target._handleQueue));\\n      var queue = target._handleQueue;\\n      target._handleQueue = null;\\n\\n      queue.forEach(function(args) {\\n        target._send(args.message, args.handle, false, args.callback);\\n      });\\n\\n      // Process a pending disconnect (if any).\\n      if (!target.connected && target._channel && !target._handleQueue)\\n        target._disconnect();\\n\\n      return;\\n    }\\n\\n    if (message.cmd !== 'NODE_HANDLE') return;\\n\\n    // Acknowledge handle receival. Don't emit error events (for example if\\n    // the other side has disconnected) because this call to send() is not\\n    // initiated by the user and it shouldn't be fatal to be unable to ACK\\n    // a message.\\n    target._send({ cmd: 'NODE_HANDLE_ACK' }, null, true);\\n\\n    var obj = handleConversion[message.type];\\n\\n    // Update simultaneous accepts on Windows\\n    if (process.platform === 'win32') {\\n      handle._simultaneousAccepts = false;\\n      net._setSimultaneousAccepts(handle);\\n    }\\n\\n    // Convert handle object\\n    obj.got.call(this, message, handle, function(handle) {\\n      handleMessage(target, message.msg, handle);\\n    });\\n  });\\n\\n  target.send = function(message, handle, callback) {\\n    if (typeof handle === 'function') {\\n      callback = handle;\\n      handle = undefined;\\n    }\\n    if (this.connected) {\\n      return this._send(message, handle, false, callback);\\n    }\\n    var ex = new Error('channel closed');\\n    if (typeof callback === 'function') {\\n      process.nextTick(callback, ex);\\n    } else {\\n      this.emit('error', ex);  // FIXME(bnoordhuis) Defer to next tick.\\n    }\\n    return false;\\n  };\\n\\n  target._send = function(message, handle, swallowErrors, callback) {\\n    assert(this.connected || this._channel);\\n\\n    if (message === undefined)\\n      throw new TypeError('\\\"message\\\" argument cannot be undefined');\\n\\n    // package messages with a handle object\\n    if (handle) {\\n      // this message will be handled by an internalMessage event handler\\n      message = {\\n        cmd: 'NODE_HANDLE',\\n        type: null,\\n        msg: message\\n      };\\n\\n      if (handle instanceof net.Socket) {\\n        message.type = 'net.Socket';\\n      } else if (handle instanceof net.Server) {\\n        message.type = 'net.Server';\\n      } else if (handle instanceof TCP || handle instanceof Pipe) {\\n        message.type = 'net.Native';\\n      } else if (handle instanceof dgram.Socket) {\\n        message.type = 'dgram.Socket';\\n      } else if (handle instanceof UDP) {\\n        message.type = 'dgram.Native';\\n      } else {\\n        throw new TypeError('This handle type can\\\\'t be sent');\\n      }\\n\\n      // Queue-up message and handle if we haven't received ACK yet.\\n      if (this._handleQueue) {\\n        this._handleQueue.push({\\n          callback: callback,\\n          handle: handle,\\n          message: message.msg,\\n        });\\n        return this._handleQueue.length === 1;\\n      }\\n\\n      var obj = handleConversion[message.type];\\n\\n      // convert TCP object to native handle object\\n      handle =\\n          handleConversion[message.type].send.call(target, message, handle);\\n\\n      // If handle was sent twice, or it is impossible to get native handle\\n      // out of it - just send a text without the handle.\\n      if (!handle)\\n        message = message.msg;\\n\\n      // Update simultaneous accepts on Windows\\n      if (obj.simultaneousAccepts) {\\n        net._setSimultaneousAccepts(handle);\\n      }\\n    } else if (this._handleQueue &&\\n               !(message && message.cmd === 'NODE_HANDLE_ACK')) {\\n      // Queue request anyway to avoid out-of-order messages.\\n      this._handleQueue.push({\\n        callback: callback,\\n        handle: null,\\n        message: message,\\n      });\\n      return this._handleQueue.length === 1;\\n    }\\n\\n    var req = new WriteWrap();\\n    req.async = false;\\n\\n    var string = JSON.stringify(message) + '\\\\n';\\n    var err = channel.writeUtf8String(req, string, handle);\\n\\n    if (err === 0) {\\n      if (handle && !this._handleQueue)\\n        this._handleQueue = [];\\n      req.oncomplete = function() {\\n        if (this.async === true)\\n          control.unref();\\n        if (obj && obj.postSend)\\n          obj.postSend(handle);\\n        if (typeof callback === 'function')\\n          callback(null);\\n      };\\n      if (req.async === true) {\\n        control.ref();\\n      } else {\\n        process.nextTick(function() { req.oncomplete(); });\\n      }\\n    } else if (!swallowErrors) {\\n      var ex = errnoException(err, 'write');\\n      if (typeof callback === 'function') {\\n        process.nextTick(callback, ex);\\n      } else {\\n        this.emit('error', ex);  // FIXME(bnoordhuis) Defer to next tick.\\n      }\\n    }\\n\\n    /* If the master is > 2 read() calls behind, please stop sending. */\\n    return channel.writeQueueSize < (65536 * 2);\\n  };\\n\\n  // connected will be set to false immediately when a disconnect() is\\n  // requested, even though the channel might still be alive internally to\\n  // process queued messages. The three states are distinguished as follows:\\n  // - disconnect() never requested: _channel is not null and connected\\n  //   is true\\n  // - disconnect() requested, messages in the queue: _channel is not null\\n  //   and connected is false\\n  // - disconnect() requested, channel actually disconnected: _channel is\\n  //   null and connected is false\\n  target.connected = true;\\n\\n  target.disconnect = function() {\\n    if (!this.connected) {\\n      this.emit('error', new Error('IPC channel is already disconnected'));\\n      return;\\n    }\\n\\n    // Do not allow any new messages to be written.\\n    this.connected = false;\\n\\n    // If there are no queued messages, disconnect immediately. Otherwise,\\n    // postpone the disconnect so that it happens internally after the\\n    // queue is flushed.\\n    if (!this._handleQueue)\\n      this._disconnect();\\n  };\\n\\n  target._disconnect = function() {\\n    assert(this._channel);\\n\\n    // This marks the fact that the channel is actually disconnected.\\n    this._channel = null;\\n\\n    var fired = false;\\n    function finish() {\\n      if (fired) return;\\n      fired = true;\\n\\n      channel.close();\\n      target.emit('disconnect');\\n    }\\n\\n    // If a message is being read, then wait for it to complete.\\n    if (channel.buffering) {\\n      this.once('message', finish);\\n      this.once('internalMessage', finish);\\n\\n      return;\\n    }\\n\\n    process.nextTick(finish);\\n  };\\n\\n  channel.readStart();\\n  return control;\\n}\\n\\n\\nvar INTERNAL_PREFIX = 'NODE_';\\nfunction handleMessage(target, message, handle) {\\n  var eventName = 'message';\\n  if (message !== null &&\\n      typeof message === 'object' &&\\n      typeof message.cmd === 'string' &&\\n      message.cmd.length > INTERNAL_PREFIX.length &&\\n      message.cmd.slice(0, INTERNAL_PREFIX.length) === INTERNAL_PREFIX) {\\n    eventName = 'internalMessage';\\n  }\\n  target.emit(eventName, message, handle);\\n}\\n\\nfunction nop() { }\\n\\nfunction _validateStdio(stdio, sync) {\\n  var ipc,\\n      ipcFd;\\n\\n  // Replace shortcut with an array\\n  if (typeof stdio === 'string') {\\n    switch (stdio) {\\n      case 'ignore': stdio = ['ignore', 'ignore', 'ignore']; break;\\n      case 'pipe': stdio = ['pipe', 'pipe', 'pipe']; break;\\n      case 'inherit': stdio = [0, 1, 2]; break;\\n      default: throw new TypeError('Incorrect value of stdio option: ' + stdio);\\n    }\\n  } else if (!Array.isArray(stdio)) {\\n    throw new TypeError('Incorrect value of stdio option: ' +\\n        util.inspect(stdio));\\n  }\\n\\n  // At least 3 stdio will be created\\n  // Don't concat() a new Array() because it would be sparse, and\\n  // stdio.reduce() would skip the sparse elements of stdio.\\n  // See http://stackoverflow.com/a/5501711/3561\\n  while (stdio.length < 3) stdio.push(undefined);\\n\\n  // Translate stdio into C++-readable form\\n  // (i.e. PipeWraps or fds)\\n  stdio = stdio.reduce(function(acc, stdio, i) {\\n    function cleanup() {\\n      acc.filter(function(stdio) {\\n        return stdio.type === 'pipe' || stdio.type === 'ipc';\\n      }).forEach(function(stdio) {\\n        if (stdio.handle)\\n          stdio.handle.close();\\n      });\\n    }\\n\\n    // Defaults\\n    if (stdio === null || stdio === undefined) {\\n      stdio = i < 3 ? 'pipe' : 'ignore';\\n    }\\n\\n    if (stdio === null || stdio === 'ignore') {\\n      acc.push({type: 'ignore'});\\n    } else if (stdio === 'pipe' || typeof stdio === 'number' && stdio < 0) {\\n      var a = {\\n        type: 'pipe',\\n        readable: i === 0,\\n        writable: i !== 0\\n      };\\n\\n      if (!sync)\\n        a.handle = new Pipe();\\n\\n      acc.push(a);\\n    } else if (stdio === 'ipc') {\\n      if (sync || ipc !== undefined) {\\n        // Cleanup previously created pipes\\n        cleanup();\\n        if (!sync)\\n          throw new Error('Child process can have only one IPC pipe');\\n        else\\n          throw new Error('You cannot use IPC with synchronous forks');\\n      }\\n\\n      ipc = new Pipe(true);\\n      ipcFd = i;\\n\\n      acc.push({\\n        type: 'pipe',\\n        handle: ipc,\\n        ipc: true\\n      });\\n    } else if (stdio === 'inherit') {\\n      acc.push({\\n        type: 'inherit',\\n        fd: i\\n      });\\n    } else if (typeof stdio === 'number' || typeof stdio.fd === 'number') {\\n      acc.push({\\n        type: 'fd',\\n        fd: typeof stdio === 'number' ? stdio : stdio.fd\\n      });\\n    } else if (getHandleWrapType(stdio) || getHandleWrapType(stdio.handle) ||\\n               getHandleWrapType(stdio._handle)) {\\n      var handle = getHandleWrapType(stdio) ?\\n          stdio :\\n          getHandleWrapType(stdio.handle) ? stdio.handle : stdio._handle;\\n\\n      acc.push({\\n        type: 'wrap',\\n        wrapType: getHandleWrapType(handle),\\n        handle: handle\\n      });\\n    } else if (stdio instanceof Buffer || typeof stdio === 'string') {\\n      if (!sync) {\\n        cleanup();\\n        throw new TypeError('Asynchronous forks do not support Buffer input: ' +\\n            util.inspect(stdio));\\n      }\\n    } else {\\n      // Cleanup\\n      cleanup();\\n      throw new TypeError('Incorrect value for stdio stream: ' +\\n          util.inspect(stdio));\\n    }\\n\\n    return acc;\\n  }, []);\\n\\n  return {stdio: stdio, ipc: ipc, ipcFd: ipcFd};\\n}\\n\\n\\nfunction getSocketList(type, slave, key) {\\n  var sockets = slave._channel.sockets[type];\\n  var socketList = sockets[key];\\n  if (!socketList) {\\n    var Construct = type === 'send' ? SocketListSend : SocketListReceive;\\n    socketList = sockets[key] = new Construct(slave, key);\\n  }\\n  return socketList;\\n}\\n\\n\\nfunction maybeClose(subprocess) {\\n  subprocess._closesGot++;\\n\\n  if (subprocess._closesGot == subprocess._closesNeeded) {\\n    subprocess.emit('close', subprocess.exitCode, subprocess.signalCode);\\n  }\\n}\\n\",\"internal/socket_list\":\"'use strict';\\n\\nexports.SocketListSend = SocketListSend;\\nexports.SocketListReceive = SocketListReceive;\\n\\nvar EventEmitter = require('events');\\nvar util = require('util');\\n\\n// This object keep track of the socket there are sended\\nfunction SocketListSend(slave, key) {\\n  EventEmitter.call(this);\\n\\n  this.key = key;\\n  this.slave = slave;\\n}\\nutil.inherits(SocketListSend, EventEmitter);\\n\\nSocketListSend.prototype._request = function(msg, cmd, callback) {\\n  var self = this;\\n\\n  if (!this.slave.connected) return onclose();\\n  this.slave.send(msg);\\n\\n  function onclose() {\\n    self.slave.removeListener('internalMessage', onreply);\\n    callback(new Error('Slave closed before reply'));\\n  }\\n\\n  function onreply(msg) {\\n    if (!(msg.cmd === cmd && msg.key === self.key)) return;\\n    self.slave.removeListener('disconnect', onclose);\\n    self.slave.removeListener('internalMessage', onreply);\\n\\n    callback(null, msg);\\n  }\\n\\n  this.slave.once('disconnect', onclose);\\n  this.slave.on('internalMessage', onreply);\\n};\\n\\nSocketListSend.prototype.close = function close(callback) {\\n  this._request({\\n    cmd: 'NODE_SOCKET_NOTIFY_CLOSE',\\n    key: this.key\\n  }, 'NODE_SOCKET_ALL_CLOSED', callback);\\n};\\n\\nSocketListSend.prototype.getConnections = function getConnections(callback) {\\n  this._request({\\n    cmd: 'NODE_SOCKET_GET_COUNT',\\n    key: this.key\\n  }, 'NODE_SOCKET_COUNT', function(err, msg) {\\n    if (err) return callback(err);\\n    callback(null, msg.count);\\n  });\\n};\\n\\n// This object keep track of the socket there are received\\nfunction SocketListReceive(slave, key) {\\n  EventEmitter.call(this);\\n\\n  var self = this;\\n\\n  this.connections = 0;\\n  this.key = key;\\n  this.slave = slave;\\n\\n  function onempty() {\\n    if (!self.slave.connected) return;\\n\\n    self.slave.send({\\n      cmd: 'NODE_SOCKET_ALL_CLOSED',\\n      key: self.key\\n    });\\n  }\\n\\n  this.slave.on('internalMessage', function(msg) {\\n    if (msg.key !== self.key) return;\\n\\n    if (msg.cmd === 'NODE_SOCKET_NOTIFY_CLOSE') {\\n      // Already empty\\n      if (self.connections === 0) return onempty();\\n\\n      // Wait for sockets to get closed\\n      self.once('empty', onempty);\\n    } else if (msg.cmd === 'NODE_SOCKET_GET_COUNT') {\\n      if (!self.slave.connected) return;\\n      self.slave.send({\\n        cmd: 'NODE_SOCKET_COUNT',\\n        key: self.key,\\n        count: self.connections\\n      });\\n    }\\n  });\\n}\\nutil.inherits(SocketListReceive, EventEmitter);\\n\\nSocketListReceive.prototype.add = function(obj) {\\n  var self = this;\\n\\n  this.connections++;\\n\\n  // Notify previous owner of socket about its state change\\n  obj.socket.once('close', function() {\\n    self.connections--;\\n\\n    if (self.connections === 0) self.emit('empty');\\n  });\\n};\\n\",\"child_process\":\"'use strict';\\n\\nvar util = require('util');\\nvar internalUtil = require('internal/util');\\nvar debug = util.debuglog('child_process');\\nvar constants = require('constants');\\n\\nvar uv = process.binding('uv');\\nvar spawn_sync = require('spawn_sync');\\nvar Buffer = require('buffer').Buffer;\\nvar Pipe = process.binding('pipe_wrap').Pipe;\\nvar child_process = require('internal/child_process');\\n\\nvar errnoException = util._errnoException;\\nvar _validateStdio = child_process._validateStdio;\\nvar setupChannel = child_process.setupChannel;\\nvar ChildProcess = exports.ChildProcess = child_process.ChildProcess;\\n\\nexports.fork = function(modulePath /*, args, options*/) {\\n\\n  // Get options and args arguments.\\n  var options, args, execArgv;\\n  if (Array.isArray(arguments[1])) {\\n    args = arguments[1];\\n    options = util._extend({}, arguments[2]);\\n  } else if (arguments[1] && typeof arguments[1] !== 'object') {\\n    throw new TypeError('Incorrect value of args option');\\n  } else {\\n    args = [];\\n    options = util._extend({}, arguments[1]);\\n  }\\n\\n  // Prepare arguments for fork:\\n  execArgv = options.execArgv || process.execArgv;\\n\\n  if (execArgv === process.execArgv && process._eval != null) {\\n    var index = execArgv.lastIndexOf(process._eval);\\n    if (index > 0) {\\n      // Remove the -e switch to avoid fork bombing ourselves.\\n      execArgv = execArgv.slice();\\n      execArgv.splice(index - 1, 2);\\n    }\\n  }\\n\\n  args = execArgv.concat([modulePath], args);\\n\\n  // Leave stdin open for the IPC channel. stdout and stderr should be the\\n  // same as the parent's if silent isn't set.\\n  options.stdio = options.silent ? ['pipe', 'pipe', 'pipe', 'ipc'] :\\n      [0, 1, 2, 'ipc'];\\n\\n  options.execPath = options.execPath || process.execPath;\\n\\n  return spawn(options.execPath, args, options);\\n};\\n\\n\\nexports._forkChild = function(fd) {\\n  // set process.send()\\n  var p = new Pipe(true);\\n  p.open(fd);\\n  p.unref();\\n  var control = setupChannel(process, p);\\n  process.on('newListener', function(name) {\\n    if (name === 'message' || name === 'disconnect') control.ref();\\n  });\\n  process.on('removeListener', function(name) {\\n    if (name === 'message' || name === 'disconnect') control.unref();\\n  });\\n};\\n\\n\\nfunction normalizeExecArgs(command /*, options, callback*/) {\\n  var file, args, options, callback;\\n\\n  if (typeof arguments[1] === 'function') {\\n    options = undefined;\\n    callback = arguments[1];\\n  } else {\\n    options = arguments[1];\\n    callback = arguments[2];\\n  }\\n\\n  if (process.platform === 'win32') {\\n    file = process.env.comspec || 'cmd.exe';\\n    args = ['/s', '/c', '\\\"' + command + '\\\"'];\\n    // Make a shallow copy before patching so we don't clobber the user's\\n    // options object.\\n    options = util._extend({}, options);\\n    options.windowsVerbatimArguments = true;\\n  } else {\\n    file = '/bin/sh';\\n    args = ['-c', command];\\n  }\\n\\n  if (options && options.shell)\\n    file = options.shell;\\n\\n  return {\\n    cmd: command,\\n    file: file,\\n    args: args,\\n    options: options,\\n    callback: callback\\n  };\\n}\\n\\n\\nexports.exec = function(command /*, options, callback*/) {\\n  var opts = normalizeExecArgs.apply(null, arguments);\\n  return exports.execFile(opts.file,\\n                          opts.args,\\n                          opts.options,\\n                          opts.callback);\\n};\\n\\n\\nexports.execFile = function(file /*, args, options, callback*/) {\\n  var args = [], callback;\\n  var options = {\\n    encoding: 'utf8',\\n    timeout: 0,\\n    maxBuffer: 200 * 1024,\\n    killSignal: 'SIGTERM',\\n    cwd: null,\\n    env: null\\n  };\\n\\n  // Parse the optional positional parameters.\\n  var pos = 1;\\n  if (pos < arguments.length && Array.isArray(arguments[pos])) {\\n    args = arguments[pos++];\\n  } else if (pos < arguments.length && arguments[pos] == null) {\\n    pos++;\\n  }\\n\\n  if (pos < arguments.length && typeof arguments[pos] === 'object') {\\n    options = util._extend(options, arguments[pos++]);\\n  } else if (pos < arguments.length && arguments[pos] == null) {\\n    pos++;\\n  }\\n\\n  if (pos < arguments.length && typeof arguments[pos] === 'function') {\\n    callback = arguments[pos++];\\n  }\\n\\n  if (pos === 1 && arguments.length > 1) {\\n    throw new TypeError('Incorrect value of args option');\\n  }\\n\\n  var child = spawn(file, args, {\\n    cwd: options.cwd,\\n    env: options.env,\\n    gid: options.gid,\\n    uid: options.uid,\\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments\\n  });\\n\\n  var encoding;\\n  var _stdout;\\n  var _stderr;\\n  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {\\n    encoding = options.encoding;\\n    _stdout = '';\\n    _stderr = '';\\n  } else {\\n    _stdout = [];\\n    _stderr = [];\\n    encoding = null;\\n  }\\n  var stdoutLen = 0;\\n  var stderrLen = 0;\\n  var killed = false;\\n  var exited = false;\\n  var timeoutId;\\n\\n  var ex = null;\\n\\n  function exithandler(code, signal) {\\n    if (exited) return;\\n    exited = true;\\n\\n    if (timeoutId) {\\n      clearTimeout(timeoutId);\\n      timeoutId = null;\\n    }\\n\\n    if (!callback) return;\\n\\n    // merge chunks\\n    var stdout;\\n    var stderr;\\n    if (!encoding) {\\n      stdout = Buffer.concat(_stdout);\\n      stderr = Buffer.concat(_stderr);\\n    } else {\\n      stdout = _stdout;\\n      stderr = _stderr;\\n    }\\n\\n    if (ex) {\\n      // Will be handled later\\n    } else if (code === 0 && signal === null) {\\n      callback(null, stdout, stderr);\\n      return;\\n    }\\n\\n    var cmd = file;\\n    if (args.length !== 0)\\n      cmd += ' ' + args.join(' ');\\n\\n    if (!ex) {\\n      ex = new Error('Command failed: ' + cmd + '\\\\n' + stderr);\\n      ex.killed = child.killed || killed;\\n      ex.code = code < 0 ? uv.errname(code) : code;\\n      ex.signal = signal;\\n    }\\n\\n    ex.cmd = cmd;\\n    callback(ex, stdout, stderr);\\n  }\\n\\n  function errorhandler(e) {\\n    ex = e;\\n\\n    if (child.stdout)\\n      child.stdout.destroy();\\n\\n    if (child.stderr)\\n      child.stderr.destroy();\\n\\n    exithandler();\\n  }\\n\\n  function kill() {\\n    if (child.stdout)\\n      child.stdout.destroy();\\n\\n    if (child.stderr)\\n      child.stderr.destroy();\\n\\n    killed = true;\\n    try {\\n      child.kill(options.killSignal);\\n    } catch (e) {\\n      ex = e;\\n      exithandler();\\n    }\\n  }\\n\\n  if (options.timeout > 0) {\\n    timeoutId = setTimeout(function() {\\n      kill();\\n      timeoutId = null;\\n    }, options.timeout);\\n  }\\n\\n  if (child.stdout) {\\n    if (encoding)\\n      child.stdout.setEncoding(encoding);\\n\\n    child.stdout.addListener('data', function(chunk) {\\n      stdoutLen += chunk.length;\\n\\n      if (stdoutLen > options.maxBuffer) {\\n        ex = new Error('stdout maxBuffer exceeded');\\n        kill();\\n      } else {\\n        if (!encoding)\\n          _stdout.push(chunk);\\n        else\\n          _stdout += chunk;\\n      }\\n    });\\n  }\\n\\n  if (child.stderr) {\\n    if (encoding)\\n      child.stderr.setEncoding(encoding);\\n\\n    child.stderr.addListener('data', function(chunk) {\\n      stderrLen += chunk.length;\\n\\n      if (stderrLen > options.maxBuffer) {\\n        ex = new Error('stderr maxBuffer exceeded');\\n        kill();\\n      } else {\\n        if (!encoding)\\n          _stderr.push(chunk);\\n        else\\n          _stderr += chunk;\\n      }\\n    });\\n  }\\n\\n  child.addListener('close', exithandler);\\n  child.addListener('error', errorhandler);\\n\\n  return child;\\n};\\n\\nvar _deprecatedCustomFds = internalUtil.deprecate(function(options) {\\n  options.stdio = options.customFds.map(function(fd) {\\n    return fd === -1 ? 'pipe' : fd;\\n  });\\n}, 'child_process: options.customFds option is deprecated. ' +\\n   'Use options.stdio instead.');\\n\\nfunction _convertCustomFds(options) {\\n  if (options && options.customFds && !options.stdio) {\\n    _deprecatedCustomFds(options);\\n  }\\n}\\n\\nfunction normalizeSpawnArguments(file /*, args, options*/) {\\n  var args, options;\\n\\n  if (Array.isArray(arguments[1])) {\\n    args = arguments[1].slice(0);\\n    options = arguments[2];\\n  } else if (arguments[1] !== undefined &&\\n             (arguments[1] === null || typeof arguments[1] !== 'object')) {\\n    throw new TypeError('Incorrect value of args option');\\n  } else {\\n    args = [];\\n    options = arguments[1];\\n  }\\n\\n  if (options === undefined)\\n    options = {};\\n  else if (options === null || typeof options !== 'object')\\n    throw new TypeError('\\\"options\\\" argument must be an object');\\n\\n  options = util._extend({}, options);\\n  args.unshift(file);\\n\\n  var env = options.env || process.env;\\n  var envPairs = [];\\n\\n  for (var key in env) {\\n    envPairs.push(key + '=' + env[key]);\\n  }\\n\\n  _convertCustomFds(options);\\n\\n  return {\\n    file: file,\\n    args: args,\\n    options: options,\\n    envPairs: envPairs\\n  };\\n}\\n\\n\\nvar spawn = exports.spawn = function(/*file, args, options*/) {\\n  var opts = normalizeSpawnArguments.apply(null, arguments);\\n  var options = opts.options;\\n  var child = new ChildProcess();\\n\\n  debug('spawn', opts.args, options);\\n\\n  child.spawn({\\n    file: opts.file,\\n    args: opts.args,\\n    cwd: options.cwd,\\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments,\\n    detached: !!options.detached,\\n    envPairs: opts.envPairs,\\n    stdio: options.stdio,\\n    uid: options.uid,\\n    gid: options.gid\\n  });\\n\\n  return child;\\n};\\n\\n\\nfunction lookupSignal(signal) {\\n  if (typeof signal === 'number')\\n    return signal;\\n\\n  if (!(signal in constants))\\n    throw new Error('Unknown signal: ' + signal);\\n\\n  return constants[signal];\\n}\\n\\n\\n//node to como modification\\nfunction spawnSync(/*file, args, options*/) {\\n  var opts = normalizeSpawnArguments.apply(null, arguments);\\n\\n  var options = opts.options;\\n\\n  // var i;\\n\\n  // debug('spawnSync', opts.args, options);\\n\\n  // options.file = opts.file;\\n  // options.args = opts.args;\\n  // options.envPairs = opts.envPairs;\\n\\n  // if (options.killSignal)\\n  //   options.killSignal = lookupSignal(options.killSignal);\\n\\n  // options.stdio = _validateStdio(options.stdio || 'pipe', true).stdio;\\n\\n  // if (options.input) {\\n  //   var stdin = options.stdio[0] = util._extend({}, options.stdio[0]);\\n  //   stdin.input = options.input;\\n  // }\\n\\n  // // We may want to pass data in on any given fd, ensure it is a valid buffer\\n  // for (i = 0; i < options.stdio.length; i++) {\\n  //   var input = options.stdio[i] && options.stdio[i].input;\\n  //   if (input != null) {\\n  //     var pipe = options.stdio[i] = util._extend({}, options.stdio[i]);\\n  //     if (Buffer.isBuffer(input))\\n  //       pipe.input = input;\\n  //     else if (typeof input === 'string')\\n  //       pipe.input = new Buffer(input, options.encoding);\\n  //     else\\n  //       throw new TypeError(util.format(\\n  //           'stdio[%d] should be Buffer or string not %s',\\n  //           i,\\n  //           typeof input));\\n  //   }\\n  // }\\n\\n\\n  // var result = spawn_sync.spawn(options);\\n\\n  var result = spawn_sync.spawn.apply(null, arguments);\\n  if (result.output && options.encoding) {\\n    for (i = 0; i < result.output.length; i++) {\\n      if (!result.output[i])\\n        continue;\\n      result.output[i] = result.output[i].toString(options.encoding);\\n    }\\n  }\\n\\n  result.stdout = result.output && result.output[1];\\n  result.stderr = result.output && result.output[2];\\n\\n  // if (result.error) {\\n  //   result.error = errnoException(result.error, 'spawnSync ' + opts.file);\\n  //   result.error.path = opts.file;\\n  //   result.error.spawnargs = opts.args.slice(1);\\n  // }\\n\\n  util._extend(result, opts);\\n\\n  return result;\\n}\\nexports.spawnSync = spawnSync;\\n\\n\\nfunction checkExecSyncError(ret) {\\n  if (ret.error || ret.status !== 0) {\\n    var err = ret.error;\\n    ret.error = null;\\n\\n    if (!err) {\\n      var msg = 'Command failed: ' +\\n                (ret.cmd ? ret.cmd : ret.args.join(' ')) +\\n                (ret.stderr ? '\\\\n' + ret.stderr.toString() : '');\\n      err = new Error(msg);\\n    }\\n\\n    util._extend(err, ret);\\n    return err;\\n  }\\n\\n  return false;\\n}\\n\\n\\nfunction execFileSync(/*command, args, options*/) {\\n  var opts = normalizeSpawnArguments.apply(null, arguments);\\n  var inheritStderr = !opts.options.stdio;\\n\\n  var ret = spawnSync(opts.file, opts.args.slice(1), opts.options);\\n\\n  if (inheritStderr)\\n    process.stderr.write(ret.stderr);\\n\\n  var err = checkExecSyncError(ret);\\n\\n  if (err)\\n    throw err;\\n  else\\n    return ret.stdout;\\n}\\nexports.execFileSync = execFileSync;\\n\\n\\nfunction execSync(/*command, options*/) {\\n  var opts = normalizeExecArgs.apply(null, arguments);\\n  var inheritStderr = opts.options ? !opts.options.stdio : true;\\n\\n  var ret = spawnSync(opts.file, opts.args, opts.options);\\n  ret.cmd = opts.cmd;\\n\\n  if (inheritStderr)\\n    process.stderr.write(ret.stderr);\\n\\n  var err = checkExecSyncError(ret);\\n\\n  if (err)\\n    throw err;\\n  else\\n    return ret.stdout;\\n}\\nexports.execSync = execSync;\\n\",\"stream\":\"'use strict';\\n\\nmodule.exports = Stream;\\n\\nvar EE = require('events');\\nvar util = require('util');\\n\\nutil.inherits(Stream, EE);\\nStream.Readable = require('_stream_readable');\\nStream.Writable = require('_stream_writable');\\nStream.Duplex = require('_stream_duplex');\\nStream.Transform = require('_stream_transform');\\nStream.PassThrough = require('_stream_passthrough');\\n\\n// Backwards-compat with node 0.4.x\\nStream.Stream = Stream;\\n\\n\\n// old-style streams.  Note that the pipe method (the only relevant\\n// part of this class) is overridden in the Readable class.\\n\\nfunction Stream() {\\n  EE.call(this);\\n}\\n\\nStream.prototype.pipe = function(dest, options) {\\n  var source = this;\\n\\n  function ondata(chunk) {\\n    if (dest.writable) {\\n      if (false === dest.write(chunk) && source.pause) {\\n        source.pause();\\n      }\\n    }\\n  }\\n\\n  source.on('data', ondata);\\n\\n  function ondrain() {\\n    if (source.readable && source.resume) {\\n      source.resume();\\n    }\\n  }\\n\\n  dest.on('drain', ondrain);\\n\\n  // If the 'end' option is not supplied, dest.end() will be called when\\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\\n  if (!dest._isStdio && (!options || options.end !== false)) {\\n    source.on('end', onend);\\n    source.on('close', onclose);\\n  }\\n\\n  var didOnEnd = false;\\n  function onend() {\\n    if (didOnEnd) return;\\n    didOnEnd = true;\\n\\n    dest.end();\\n  }\\n\\n\\n  function onclose() {\\n    if (didOnEnd) return;\\n    didOnEnd = true;\\n\\n    if (typeof dest.destroy === 'function') dest.destroy();\\n  }\\n\\n  // don't leave dangling pipes when there are errors.\\n  function onerror(er) {\\n    cleanup();\\n    if (EE.listenerCount(this, 'error') === 0) {\\n      throw er; // Unhandled stream error in pipe.\\n    }\\n  }\\n\\n  source.on('error', onerror);\\n  dest.on('error', onerror);\\n\\n  // remove all the event listeners that were added.\\n  function cleanup() {\\n    source.removeListener('data', ondata);\\n    dest.removeListener('drain', ondrain);\\n\\n    source.removeListener('end', onend);\\n    source.removeListener('close', onclose);\\n\\n    source.removeListener('error', onerror);\\n    dest.removeListener('error', onerror);\\n\\n    source.removeListener('end', cleanup);\\n    source.removeListener('close', cleanup);\\n\\n    dest.removeListener('close', cleanup);\\n  }\\n\\n  source.on('end', cleanup);\\n  source.on('close', cleanup);\\n\\n  dest.on('close', cleanup);\\n\\n  dest.emit('pipe', source);\\n\\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\\n  return dest;\\n};\\n\",\"_stream_readable\":\"'use strict';\\n\\nmodule.exports = Readable;\\nReadable.ReadableState = ReadableState;\\n\\nvar EE = require('events');\\nvar Stream = require('stream');\\nvar Buffer = require('buffer').Buffer;\\nvar util = require('util');\\nvar debug = util.debuglog('stream');\\nvar StringDecoder;\\n\\nutil.inherits(Readable, Stream);\\n\\nfunction ReadableState(options, stream) {\\n  options = options || {};\\n\\n  // object stream flag. Used to make read(n) ignore n and to\\n  // make all the buffer merging and length checks go away\\n  this.objectMode = !!options.objectMode;\\n\\n  if (stream instanceof Stream.Duplex)\\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\\n\\n  // the point at which it stops calling _read() to fill the buffer\\n  // Note: 0 is a valid value, means \\\"don't call _read preemptively ever\\\"\\n  var hwm = options.highWaterMark;\\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\\n\\n  // cast to ints.\\n  this.highWaterMark = ~~this.highWaterMark;\\n\\n  this.buffer = [];\\n  this.length = 0;\\n  this.pipes = null;\\n  this.pipesCount = 0;\\n  this.flowing = null;\\n  this.ended = false;\\n  this.endEmitted = false;\\n  this.reading = false;\\n\\n  // a flag to be able to tell if the onwrite cb is called immediately,\\n  // or on a later tick.  We set this to true at first, because any\\n  // actions that shouldn't happen until \\\"later\\\" should generally also\\n  // not happen before the first write call.\\n  this.sync = true;\\n\\n  // whenever we return null, then we set a flag to say\\n  // that we're awaiting a 'readable' event emission.\\n  this.needReadable = false;\\n  this.emittedReadable = false;\\n  this.readableListening = false;\\n\\n  // Crypto is kind of old and crusty.  Historically, its default string\\n  // encoding is 'binary' so we have to make this configurable.\\n  // Everything else in the universe uses 'utf8', though.\\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\\n\\n  // when piping, we only care about 'readable' events that happen\\n  // after read()ing all the bytes and not getting any pushback.\\n  this.ranOut = false;\\n\\n  // the number of writers that are awaiting a drain event in .pipe()s\\n  this.awaitDrain = 0;\\n\\n  // if true, a maybeReadMore has been scheduled\\n  this.readingMore = false;\\n\\n  this.decoder = null;\\n  this.encoding = null;\\n  if (options.encoding) {\\n    if (!StringDecoder)\\n      StringDecoder = require('string_decoder').StringDecoder;\\n    this.decoder = new StringDecoder(options.encoding);\\n    this.encoding = options.encoding;\\n  }\\n}\\n\\nfunction Readable(options) {\\n  if (!(this instanceof Readable))\\n    return new Readable(options);\\n\\n  this._readableState = new ReadableState(options, this);\\n\\n  // legacy\\n  this.readable = true;\\n\\n  if (options && typeof options.read === 'function')\\n    this._read = options.read;\\n\\n  Stream.call(this);\\n}\\n\\n// Manually shove something into the read() buffer.\\n// This returns true if the highWaterMark has not been hit yet,\\n// similar to how Writable.write() returns true if you should\\n// write() some more.\\nReadable.prototype.push = function(chunk, encoding) {\\n  var state = this._readableState;\\n\\n  if (!state.objectMode && typeof chunk === 'string') {\\n    encoding = encoding || state.defaultEncoding;\\n    if (encoding !== state.encoding) {\\n      chunk = Buffer(chunk, encoding);\\n      encoding = '';\\n    }\\n  }\\n\\n  return readableAddChunk(this, state, chunk, encoding, false);\\n};\\n\\n// Unshift should *always* be something directly out of read()\\nReadable.prototype.unshift = function(chunk) {\\n  var state = this._readableState;\\n  return readableAddChunk(this, state, chunk, '', true);\\n};\\n\\nReadable.prototype.isPaused = function() {\\n  return this._readableState.flowing === false;\\n};\\n\\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\\n  var er = chunkInvalid(state, chunk);\\n  if (er) {\\n    stream.emit('error', er);\\n  } else if (chunk === null) {\\n    state.reading = false;\\n    onEofChunk(stream, state);\\n  } else if (state.objectMode || chunk && chunk.length > 0) {\\n    if (state.ended && !addToFront) {\\n      var e = new Error('stream.push() after EOF');\\n      stream.emit('error', e);\\n    } else if (state.endEmitted && addToFront) {\\n      var e = new Error('stream.unshift() after end event');\\n      stream.emit('error', e);\\n    } else {\\n      if (state.decoder && !addToFront && !encoding)\\n        chunk = state.decoder.write(chunk);\\n\\n      if (!addToFront)\\n        state.reading = false;\\n\\n      // if we want the data now, just emit it.\\n      if (state.flowing && state.length === 0 && !state.sync) {\\n        stream.emit('data', chunk);\\n        stream.read(0);\\n      } else {\\n        // update the buffer info.\\n        state.length += state.objectMode ? 1 : chunk.length;\\n        if (addToFront)\\n          state.buffer.unshift(chunk);\\n        else\\n          state.buffer.push(chunk);\\n\\n        if (state.needReadable)\\n          emitReadable(stream);\\n      }\\n\\n      maybeReadMore(stream, state);\\n    }\\n  } else if (!addToFront) {\\n    state.reading = false;\\n  }\\n\\n  return needMoreData(state);\\n}\\n\\n\\n// if it's past the high water mark, we can push in some more.\\n// Also, if we have no data yet, we can stand some\\n// more bytes.  This is to work around cases where hwm=0,\\n// such as the repl.  Also, if the push() triggered a\\n// readable event, and the user called read(largeNumber) such that\\n// needReadable was set, then we ought to push more, so that another\\n// 'readable' event will be triggered.\\nfunction needMoreData(state) {\\n  return !state.ended &&\\n         (state.needReadable ||\\n          state.length < state.highWaterMark ||\\n          state.length === 0);\\n}\\n\\n// backwards compatibility.\\nReadable.prototype.setEncoding = function(enc) {\\n  if (!StringDecoder)\\n    StringDecoder = require('string_decoder').StringDecoder;\\n  this._readableState.decoder = new StringDecoder(enc);\\n  this._readableState.encoding = enc;\\n  return this;\\n};\\n\\n// Don't raise the hwm > 8MB\\nvar MAX_HWM = 0x800000;\\nfunction computeNewHighWaterMark(n) {\\n  if (n >= MAX_HWM) {\\n    n = MAX_HWM;\\n  } else {\\n    // Get the next highest power of 2\\n    n--;\\n    n |= n >>> 1;\\n    n |= n >>> 2;\\n    n |= n >>> 4;\\n    n |= n >>> 8;\\n    n |= n >>> 16;\\n    n++;\\n  }\\n  return n;\\n}\\n\\nfunction howMuchToRead(n, state) {\\n  if (state.length === 0 && state.ended)\\n    return 0;\\n\\n  if (state.objectMode)\\n    return n === 0 ? 0 : 1;\\n\\n  if (n === null || isNaN(n)) {\\n    // only flow one buffer at a time\\n    if (state.flowing && state.buffer.length)\\n      return state.buffer[0].length;\\n    else\\n      return state.length;\\n  }\\n\\n  if (n <= 0)\\n    return 0;\\n\\n  // If we're asking for more than the target buffer level,\\n  // then raise the water mark.  Bump up to the next highest\\n  // power of 2, to prevent increasing it excessively in tiny\\n  // amounts.\\n  if (n > state.highWaterMark)\\n    state.highWaterMark = computeNewHighWaterMark(n);\\n\\n  // don't have that much.  return null, unless we've ended.\\n  if (n > state.length) {\\n    if (!state.ended) {\\n      state.needReadable = true;\\n      return 0;\\n    } else {\\n      return state.length;\\n    }\\n  }\\n\\n  return n;\\n}\\n\\n// you can override either this method, or the async _read(n) below.\\nReadable.prototype.read = function(n) {\\n  debug('read', n);\\n  var state = this._readableState;\\n  var nOrig = n;\\n\\n  if (typeof n !== 'number' || n > 0)\\n    state.emittedReadable = false;\\n\\n  // if we're doing read(0) to trigger a readable event, but we\\n  // already have a bunch of data in the buffer, then just trigger\\n  // the 'readable' event and move on.\\n  if (n === 0 &&\\n      state.needReadable &&\\n      (state.length >= state.highWaterMark || state.ended)) {\\n    debug('read: emitReadable', state.length, state.ended);\\n    if (state.length === 0 && state.ended)\\n      endReadable(this);\\n    else\\n      emitReadable(this);\\n    return null;\\n  }\\n\\n  n = howMuchToRead(n, state);\\n\\n  // if we've ended, and we're now clear, then finish it up.\\n  if (n === 0 && state.ended) {\\n    if (state.length === 0)\\n      endReadable(this);\\n    return null;\\n  }\\n\\n  // All the actual chunk generation logic needs to be\\n  // *below* the call to _read.  The reason is that in certain\\n  // synthetic stream cases, such as passthrough streams, _read\\n  // may be a completely synchronous operation which may change\\n  // the state of the read buffer, providing enough data when\\n  // before there was *not* enough.\\n  //\\n  // So, the steps are:\\n  // 1. Figure out what the state of things will be after we do\\n  // a read from the buffer.\\n  //\\n  // 2. If that resulting state will trigger a _read, then call _read.\\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\\n  // deeply ugly to write APIs this way, but that still doesn't mean\\n  // that the Readable class should behave improperly, as streams are\\n  // designed to be sync/async agnostic.\\n  // Take note if the _read call is sync or async (ie, if the read call\\n  // has returned yet), so that we know whether or not it's safe to emit\\n  // 'readable' etc.\\n  //\\n  // 3. Actually pull the requested chunks out of the buffer and return.\\n\\n  // if we need a readable event, then we need to do some reading.\\n  var doRead = state.needReadable;\\n  debug('need readable', doRead);\\n\\n  // if we currently have less than the highWaterMark, then also read some\\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\\n    doRead = true;\\n    debug('length less than watermark', doRead);\\n  }\\n\\n  // however, if we've ended, then there's no point, and if we're already\\n  // reading, then it's unnecessary.\\n  if (state.ended || state.reading) {\\n    doRead = false;\\n    debug('reading or ended', doRead);\\n  }\\n\\n  if (doRead) {\\n    debug('do read');\\n    state.reading = true;\\n    state.sync = true;\\n    // if the length is currently zero, then we *need* a readable event.\\n    if (state.length === 0)\\n      state.needReadable = true;\\n    // call internal read method\\n    this._read(state.highWaterMark);\\n    state.sync = false;\\n  }\\n\\n  // If _read pushed data synchronously, then `reading` will be false,\\n  // and we need to re-evaluate how much data we can return to the user.\\n  if (doRead && !state.reading)\\n    n = howMuchToRead(nOrig, state);\\n\\n  var ret;\\n  if (n > 0)\\n    ret = fromList(n, state);\\n  else\\n    ret = null;\\n\\n  if (ret === null) {\\n    state.needReadable = true;\\n    n = 0;\\n  }\\n\\n  state.length -= n;\\n\\n  // If we have nothing in the buffer, then we want to know\\n  // as soon as we *do* get something into the buffer.\\n  if (state.length === 0 && !state.ended)\\n    state.needReadable = true;\\n\\n  // If we tried to read() past the EOF, then emit end on the next tick.\\n  if (nOrig !== n && state.ended && state.length === 0)\\n    endReadable(this);\\n\\n  if (ret !== null)\\n    this.emit('data', ret);\\n\\n  return ret;\\n};\\n\\nfunction chunkInvalid(state, chunk) {\\n  var er = null;\\n  if (!(Buffer.isBuffer(chunk)) &&\\n      typeof chunk !== 'string' &&\\n      chunk !== null &&\\n      chunk !== undefined &&\\n      !state.objectMode) {\\n    er = new TypeError('Invalid non-string/buffer chunk');\\n  }\\n  return er;\\n}\\n\\n\\nfunction onEofChunk(stream, state) {\\n  if (state.ended) return;\\n  if (state.decoder) {\\n    var chunk = state.decoder.end();\\n    if (chunk && chunk.length) {\\n      state.buffer.push(chunk);\\n      state.length += state.objectMode ? 1 : chunk.length;\\n    }\\n  }\\n  state.ended = true;\\n\\n  // emit 'readable' now to make sure it gets picked up.\\n  emitReadable(stream);\\n}\\n\\n// Don't emit readable right away in sync mode, because this can trigger\\n// another read() call => stack overflow.  This way, it might trigger\\n// a nextTick recursion warning, but that's not so bad.\\nfunction emitReadable(stream) {\\n  var state = stream._readableState;\\n  state.needReadable = false;\\n  if (!state.emittedReadable) {\\n    debug('emitReadable', state.flowing);\\n    state.emittedReadable = true;\\n    if (state.sync)\\n      process.nextTick(emitReadable_, stream);\\n    else\\n      emitReadable_(stream);\\n  }\\n}\\n\\nfunction emitReadable_(stream) {\\n  debug('emit readable');\\n  stream.emit('readable');\\n  flow(stream);\\n}\\n\\n\\n// at this point, the user has presumably seen the 'readable' event,\\n// and called read() to consume some data.  that may have triggered\\n// in turn another _read(n) call, in which case reading = true if\\n// it's in progress.\\n// However, if we're not ended, or reading, and the length < hwm,\\n// then go ahead and try to read some more preemptively.\\nfunction maybeReadMore(stream, state) {\\n  if (!state.readingMore) {\\n    state.readingMore = true;\\n    process.nextTick(maybeReadMore_, stream, state);\\n  }\\n}\\n\\nfunction maybeReadMore_(stream, state) {\\n  var len = state.length;\\n  while (!state.reading && !state.flowing && !state.ended &&\\n         state.length < state.highWaterMark) {\\n    debug('maybeReadMore read 0');\\n    stream.read(0);\\n    if (len === state.length)\\n      // didn't get any data, stop spinning.\\n      break;\\n    else\\n      len = state.length;\\n  }\\n  state.readingMore = false;\\n}\\n\\n// abstract method.  to be overridden in specific implementation classes.\\n// call cb(er, data) where data is <= n in length.\\n// for virtual (non-string, non-buffer) streams, \\\"length\\\" is somewhat\\n// arbitrary, and perhaps not very meaningful.\\nReadable.prototype._read = function(n) {\\n  this.emit('error', new Error('not implemented'));\\n};\\n\\nReadable.prototype.pipe = function(dest, pipeOpts) {\\n  var src = this;\\n  var state = this._readableState;\\n\\n  switch (state.pipesCount) {\\n    case 0:\\n      state.pipes = dest;\\n      break;\\n    case 1:\\n      state.pipes = [state.pipes, dest];\\n      break;\\n    default:\\n      state.pipes.push(dest);\\n      break;\\n  }\\n  state.pipesCount += 1;\\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\\n\\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\\n              dest !== process.stdout &&\\n              dest !== process.stderr;\\n\\n  var endFn = doEnd ? onend : cleanup;\\n  if (state.endEmitted)\\n    process.nextTick(endFn);\\n  else\\n    src.once('end', endFn);\\n\\n  dest.on('unpipe', onunpipe);\\n  function onunpipe(readable) {\\n    debug('onunpipe');\\n    if (readable === src) {\\n      cleanup();\\n    }\\n  }\\n\\n  function onend() {\\n    debug('onend');\\n    dest.end();\\n  }\\n\\n  // when the dest drains, it reduces the awaitDrain counter\\n  // on the source.  This would be more elegant with a .once()\\n  // handler in flow(), but adding and removing repeatedly is\\n  // too slow.\\n  var ondrain = pipeOnDrain(src);\\n  dest.on('drain', ondrain);\\n\\n  var cleanedUp = false;\\n  function cleanup() {\\n    debug('cleanup');\\n    // cleanup event handlers once the pipe is broken\\n    dest.removeListener('close', onclose);\\n    dest.removeListener('finish', onfinish);\\n    dest.removeListener('drain', ondrain);\\n    dest.removeListener('error', onerror);\\n    dest.removeListener('unpipe', onunpipe);\\n    src.removeListener('end', onend);\\n    src.removeListener('end', cleanup);\\n    src.removeListener('data', ondata);\\n\\n    cleanedUp = true;\\n\\n    // if the reader is waiting for a drain event from this\\n    // specific writer, then it would cause it to never start\\n    // flowing again.\\n    // So, if this is awaiting a drain, then we just call it now.\\n    // If we don't know, then assume that we are waiting for one.\\n    if (state.awaitDrain &&\\n        (!dest._writableState || dest._writableState.needDrain))\\n      ondrain();\\n  }\\n\\n  src.on('data', ondata);\\n  function ondata(chunk) {\\n    debug('ondata');\\n    var ret = dest.write(chunk);\\n    if (false === ret) {\\n      // If the user unpiped during `dest.write()`, it is possible\\n      // to get stuck in a permanently paused state if that write\\n      // also returned false.\\n      if (state.pipesCount === 1 &&\\n          state.pipes[0] === dest &&\\n          src.listenerCount('data') === 1 &&\\n          !cleanedUp) {\\n        debug('false write response, pause', src._readableState.awaitDrain);\\n        src._readableState.awaitDrain++;\\n      }\\n      src.pause();\\n    }\\n  }\\n\\n  // if the dest has an error, then stop piping into it.\\n  // however, don't suppress the throwing behavior for this.\\n  function onerror(er) {\\n    debug('onerror', er);\\n    unpipe();\\n    dest.removeListener('error', onerror);\\n    if (EE.listenerCount(dest, 'error') === 0)\\n      dest.emit('error', er);\\n  }\\n  // This is a brutally ugly hack to make sure that our error handler\\n  // is attached before any userland ones.  NEVER DO THIS.\\n  if (!dest._events || !dest._events.error)\\n    dest.on('error', onerror);\\n  else if (Array.isArray(dest._events.error))\\n    dest._events.error.unshift(onerror);\\n  else\\n    dest._events.error = [onerror, dest._events.error];\\n\\n\\n  // Both close and finish should trigger unpipe, but only once.\\n  function onclose() {\\n    dest.removeListener('finish', onfinish);\\n    unpipe();\\n  }\\n  dest.once('close', onclose);\\n  function onfinish() {\\n    debug('onfinish');\\n    dest.removeListener('close', onclose);\\n    unpipe();\\n  }\\n  dest.once('finish', onfinish);\\n\\n  function unpipe() {\\n    debug('unpipe');\\n    src.unpipe(dest);\\n  }\\n\\n  // tell the dest that it's being piped to\\n  dest.emit('pipe', src);\\n\\n  // start the flow if it hasn't been started already.\\n  if (!state.flowing) {\\n    debug('pipe resume');\\n    src.resume();\\n  }\\n\\n  return dest;\\n};\\n\\nfunction pipeOnDrain(src) {\\n  return function() {\\n    var state = src._readableState;\\n    debug('pipeOnDrain', state.awaitDrain);\\n    if (state.awaitDrain)\\n      state.awaitDrain--;\\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\\n      state.flowing = true;\\n      flow(src);\\n    }\\n  };\\n}\\n\\n\\nReadable.prototype.unpipe = function(dest) {\\n  var state = this._readableState;\\n\\n  // if we're not piping anywhere, then do nothing.\\n  if (state.pipesCount === 0)\\n    return this;\\n\\n  // just one destination.  most common case.\\n  if (state.pipesCount === 1) {\\n    // passed in one, but it's not the right one.\\n    if (dest && dest !== state.pipes)\\n      return this;\\n\\n    if (!dest)\\n      dest = state.pipes;\\n\\n    // got a match.\\n    state.pipes = null;\\n    state.pipesCount = 0;\\n    state.flowing = false;\\n    if (dest)\\n      dest.emit('unpipe', this);\\n    return this;\\n  }\\n\\n  // slow case. multiple pipe destinations.\\n\\n  if (!dest) {\\n    // remove all.\\n    var dests = state.pipes;\\n    var len = state.pipesCount;\\n    state.pipes = null;\\n    state.pipesCount = 0;\\n    state.flowing = false;\\n\\n    for (var i = 0; i < len; i++)\\n      dests[i].emit('unpipe', this);\\n    return this;\\n  }\\n\\n  // try to find the right one.\\n  var i = state.pipes.indexOf(dest);\\n  if (i === -1)\\n    return this;\\n\\n  state.pipes.splice(i, 1);\\n  state.pipesCount -= 1;\\n  if (state.pipesCount === 1)\\n    state.pipes = state.pipes[0];\\n\\n  dest.emit('unpipe', this);\\n\\n  return this;\\n};\\n\\n// set up data events if they are asked for\\n// Ensure readable listeners eventually get something\\nReadable.prototype.on = function(ev, fn) {\\n  var res = Stream.prototype.on.call(this, ev, fn);\\n\\n  // If listening to data, and it has not explicitly been paused,\\n  // then call resume to start the flow of data on the next tick.\\n  if (ev === 'data' && false !== this._readableState.flowing) {\\n    this.resume();\\n  }\\n\\n  if (ev === 'readable' && this.readable) {\\n    var state = this._readableState;\\n    if (!state.readableListening) {\\n      state.readableListening = true;\\n      state.emittedReadable = false;\\n      state.needReadable = true;\\n      if (!state.reading) {\\n        process.nextTick(nReadingNextTick, this);\\n      } else if (state.length) {\\n        emitReadable(this, state);\\n      }\\n    }\\n  }\\n\\n  return res;\\n};\\nReadable.prototype.addListener = Readable.prototype.on;\\n\\nfunction nReadingNextTick(self) {\\n  debug('readable nexttick read 0');\\n  self.read(0);\\n}\\n\\n// pause() and resume() are remnants of the legacy readable stream API\\n// If the user uses them, then switch into old mode.\\nReadable.prototype.resume = function() {\\n  var state = this._readableState;\\n  if (!state.flowing) {\\n    debug('resume');\\n    state.flowing = true;\\n    resume(this, state);\\n  }\\n  return this;\\n};\\n\\nfunction resume(stream, state) {\\n  if (!state.resumeScheduled) {\\n    state.resumeScheduled = true;\\n    process.nextTick(resume_, stream, state);\\n  }\\n}\\n\\nfunction resume_(stream, state) {\\n  if (!state.reading) {\\n    debug('resume read 0');\\n    stream.read(0);\\n  }\\n\\n  state.resumeScheduled = false;\\n  stream.emit('resume');\\n  flow(stream);\\n  if (state.flowing && !state.reading)\\n    stream.read(0);\\n}\\n\\nReadable.prototype.pause = function() {\\n  debug('call pause flowing=%j', this._readableState.flowing);\\n  if (false !== this._readableState.flowing) {\\n    debug('pause');\\n    this._readableState.flowing = false;\\n    this.emit('pause');\\n  }\\n  return this;\\n};\\n\\nfunction flow(stream) {\\n  var state = stream._readableState;\\n  debug('flow', state.flowing);\\n  if (state.flowing) {\\n    do {\\n      var chunk = stream.read();\\n    } while (null !== chunk && state.flowing);\\n  }\\n}\\n\\n// wrap an old-style stream as the async data source.\\n// This is *not* part of the readable stream interface.\\n// It is an ugly unfortunate mess of history.\\nReadable.prototype.wrap = function(stream) {\\n  var state = this._readableState;\\n  var paused = false;\\n\\n  var self = this;\\n  stream.on('end', function() {\\n    debug('wrapped end');\\n    if (state.decoder && !state.ended) {\\n      var chunk = state.decoder.end();\\n      if (chunk && chunk.length)\\n        self.push(chunk);\\n    }\\n\\n    self.push(null);\\n  });\\n\\n  stream.on('data', function(chunk) {\\n    debug('wrapped data');\\n    if (state.decoder)\\n      chunk = state.decoder.write(chunk);\\n\\n    // don't skip over falsy values in objectMode\\n    if (state.objectMode && (chunk === null || chunk === undefined))\\n      return;\\n    else if (!state.objectMode && (!chunk || !chunk.length))\\n      return;\\n\\n    var ret = self.push(chunk);\\n    if (!ret) {\\n      paused = true;\\n      stream.pause();\\n    }\\n  });\\n\\n  // proxy all the other methods.\\n  // important when wrapping filters and duplexes.\\n  for (var i in stream) {\\n    if (this[i] === undefined && typeof stream[i] === 'function') {\\n      this[i] = function(method) { return function() {\\n        return stream[method].apply(stream, arguments);\\n      }; }(i);\\n    }\\n  }\\n\\n  // proxy certain important events.\\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\\n  events.forEach(function(ev) {\\n    stream.on(ev, self.emit.bind(self, ev));\\n  });\\n\\n  // when we try to consume some more bytes, simply unpause the\\n  // underlying stream.\\n  self._read = function(n) {\\n    debug('wrapped _read', n);\\n    if (paused) {\\n      paused = false;\\n      stream.resume();\\n    }\\n  };\\n\\n  return self;\\n};\\n\\n\\n// exposed for testing purposes only.\\nReadable._fromList = fromList;\\n\\n// Pluck off n bytes from an array of buffers.\\n// Length is the combined lengths of all the buffers in the list.\\nfunction fromList(n, state) {\\n  var list = state.buffer;\\n  var length = state.length;\\n  var stringMode = !!state.decoder;\\n  var objectMode = !!state.objectMode;\\n  var ret;\\n\\n  // nothing in the list, definitely empty.\\n  if (list.length === 0)\\n    return null;\\n\\n  if (length === 0)\\n    ret = null;\\n  else if (objectMode)\\n    ret = list.shift();\\n  else if (!n || n >= length) {\\n    // read it all, truncate the array.\\n    if (stringMode)\\n      ret = list.join('');\\n    else if (list.length === 1)\\n      ret = list[0];\\n    else\\n      ret = Buffer.concat(list, length);\\n    list.length = 0;\\n  } else {\\n    // read just some of it.\\n    if (n < list[0].length) {\\n      // just take a part of the first list item.\\n      // slice is the same for buffers and strings.\\n      var buf = list[0];\\n      ret = buf.slice(0, n);\\n      list[0] = buf.slice(n);\\n    } else if (n === list[0].length) {\\n      // first list is a perfect match\\n      ret = list.shift();\\n    } else {\\n      // complex case.\\n      // we have enough to cover it, but it spans past the first buffer.\\n      if (stringMode)\\n        ret = '';\\n      else\\n        ret = new Buffer(n);\\n\\n      var c = 0;\\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\\n        var buf = list[0];\\n        var cpy = Math.min(n - c, buf.length);\\n\\n        if (stringMode)\\n          ret += buf.slice(0, cpy);\\n        else\\n          buf.copy(ret, c, 0, cpy);\\n\\n        if (cpy < buf.length)\\n          list[0] = buf.slice(cpy);\\n        else\\n          list.shift();\\n\\n        c += cpy;\\n      }\\n    }\\n  }\\n\\n  return ret;\\n}\\n\\nfunction endReadable(stream) {\\n  var state = stream._readableState;\\n\\n  // If we get here before consuming all the bytes, then that is a\\n  // bug in node.  Should never happen.\\n  if (state.length > 0)\\n    throw new Error('\\\"endReadable()\\\" called on non-empty stream');\\n\\n  if (!state.endEmitted) {\\n    state.ended = true;\\n    process.nextTick(endReadableNT, state, stream);\\n  }\\n}\\n\\nfunction endReadableNT(state, stream) {\\n  // Check that we didn't get one last unshift.\\n  if (!state.endEmitted && state.length === 0) {\\n    state.endEmitted = true;\\n    stream.readable = false;\\n    stream.emit('end');\\n  }\\n}\\n\",\"_stream_writable\":\"// A bit simpler than readable streams.\\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\\n// the drain event emission and buffering.\\n\\n'use strict';\\n\\nmodule.exports = Writable;\\nWritable.WritableState = WritableState;\\n\\nvar util = require('util');\\nvar internalUtil = require('internal/util');\\nvar Stream = require('stream');\\nvar Buffer = require('buffer').Buffer;\\n\\nutil.inherits(Writable, Stream);\\n\\nfunction nop() {}\\n\\nfunction WriteReq(chunk, encoding, cb) {\\n  this.chunk = chunk;\\n  this.encoding = encoding;\\n  this.callback = cb;\\n  this.next = null;\\n}\\n\\nfunction WritableState(options, stream) {\\n  options = options || {};\\n\\n  // object stream flag to indicate whether or not this stream\\n  // contains buffers or objects.\\n  this.objectMode = !!options.objectMode;\\n\\n  if (stream instanceof Stream.Duplex)\\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\\n\\n  // the point at which write() starts returning false\\n  // Note: 0 is a valid value, means that we always return false if\\n  // the entire buffer is not flushed immediately on write()\\n  var hwm = options.highWaterMark;\\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\\n\\n  // cast to ints.\\n  this.highWaterMark = ~~this.highWaterMark;\\n\\n  this.needDrain = false;\\n  // at the start of calling end()\\n  this.ending = false;\\n  // when end() has been called, and returned\\n  this.ended = false;\\n  // when 'finish' is emitted\\n  this.finished = false;\\n\\n  // should we decode strings into buffers before passing to _write?\\n  // this is here so that some node-core streams can optimize string\\n  // handling at a lower level.\\n  var noDecode = options.decodeStrings === false;\\n  this.decodeStrings = !noDecode;\\n\\n  // Crypto is kind of old and crusty.  Historically, its default string\\n  // encoding is 'binary' so we have to make this configurable.\\n  // Everything else in the universe uses 'utf8', though.\\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\\n\\n  // not an actual buffer we keep track of, but a measurement\\n  // of how much we're waiting to get pushed to some underlying\\n  // socket or file.\\n  this.length = 0;\\n\\n  // a flag to see when we're in the middle of a write.\\n  this.writing = false;\\n\\n  // when true all writes will be buffered until .uncork() call\\n  this.corked = 0;\\n\\n  // a flag to be able to tell if the onwrite cb is called immediately,\\n  // or on a later tick.  We set this to true at first, because any\\n  // actions that shouldn't happen until \\\"later\\\" should generally also\\n  // not happen before the first write call.\\n  this.sync = true;\\n\\n  // a flag to know if we're processing previously buffered items, which\\n  // may call the _write() callback in the same tick, so that we don't\\n  // end up in an overlapped onwrite situation.\\n  this.bufferProcessing = false;\\n\\n  // the callback that's passed to _write(chunk,cb)\\n  this.onwrite = function(er) {\\n    onwrite(stream, er);\\n  };\\n\\n  // the callback that the user supplies to write(chunk,encoding,cb)\\n  this.writecb = null;\\n\\n  // the amount that is being written when _write is called.\\n  this.writelen = 0;\\n\\n  this.bufferedRequest = null;\\n  this.lastBufferedRequest = null;\\n\\n  // number of pending user-supplied write callbacks\\n  // this must be 0 before 'finish' can be emitted\\n  this.pendingcb = 0;\\n\\n  // emit prefinish if the only thing we're waiting for is _write cbs\\n  // This is relevant for synchronous Transform streams\\n  this.prefinished = false;\\n\\n  // True if the error was already emitted and should not be thrown again\\n  this.errorEmitted = false;\\n}\\n\\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\\n  var current = this.bufferedRequest;\\n  var out = [];\\n  while (current) {\\n    out.push(current);\\n    current = current.next;\\n  }\\n  return out;\\n};\\n\\nObject.defineProperty(WritableState.prototype, 'buffer', {\\n  get: internalUtil.deprecate(function() {\\n    return this.getBuffer();\\n  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +\\n     'instead.')\\n});\\n\\nfunction Writable(options) {\\n  // Writable ctor is applied to Duplexes, though they're not\\n  // instanceof Writable, they're instanceof Readable.\\n  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))\\n    return new Writable(options);\\n\\n  this._writableState = new WritableState(options, this);\\n\\n  // legacy.\\n  this.writable = true;\\n\\n  if (options) {\\n    if (typeof options.write === 'function')\\n      this._write = options.write;\\n\\n    if (typeof options.writev === 'function')\\n      this._writev = options.writev;\\n  }\\n\\n  Stream.call(this);\\n}\\n\\n// Otherwise people can pipe Writable streams, which is just wrong.\\nWritable.prototype.pipe = function() {\\n  this.emit('error', new Error('Cannot pipe, not readable'));\\n};\\n\\n\\nfunction writeAfterEnd(stream, cb) {\\n  var er = new Error('write after end');\\n  // TODO: defer error events consistently everywhere, not just the cb\\n  stream.emit('error', er);\\n  process.nextTick(cb, er);\\n}\\n\\n// If we get something that is not a buffer, string, null, or undefined,\\n// and we're not in objectMode, then that's an error.\\n// Otherwise stream chunks are all considered to be of length=1, and the\\n// watermarks determine how many objects to keep in the buffer, rather than\\n// how many bytes or characters.\\nfunction validChunk(stream, state, chunk, cb) {\\n  var valid = true;\\n\\n  if (!(Buffer.isBuffer(chunk)) &&\\n      typeof chunk !== 'string' &&\\n      chunk !== null &&\\n      chunk !== undefined &&\\n      !state.objectMode) {\\n    var er = new TypeError('Invalid non-string/buffer chunk');\\n    stream.emit('error', er);\\n    process.nextTick(cb, er);\\n    valid = false;\\n  }\\n  return valid;\\n}\\n\\nWritable.prototype.write = function(chunk, encoding, cb) {\\n  var state = this._writableState;\\n  var ret = false;\\n\\n  if (typeof encoding === 'function') {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n\\n  if (chunk instanceof Buffer)\\n    encoding = 'buffer';\\n  else if (!encoding)\\n    encoding = state.defaultEncoding;\\n\\n  if (typeof cb !== 'function')\\n    cb = nop;\\n\\n  if (state.ended)\\n    writeAfterEnd(this, cb);\\n  else if (validChunk(this, state, chunk, cb)) {\\n    state.pendingcb++;\\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\\n  }\\n\\n  return ret;\\n};\\n\\nWritable.prototype.cork = function() {\\n  var state = this._writableState;\\n\\n  state.corked++;\\n};\\n\\nWritable.prototype.uncork = function() {\\n  var state = this._writableState;\\n\\n  if (state.corked) {\\n    state.corked--;\\n\\n    if (!state.writing &&\\n        !state.corked &&\\n        !state.finished &&\\n        !state.bufferProcessing &&\\n        state.bufferedRequest)\\n      clearBuffer(this, state);\\n  }\\n};\\n\\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\\n  // node::ParseEncoding() requires lower case.\\n  if (typeof encoding === 'string')\\n    encoding = encoding.toLowerCase();\\n  if (!Buffer.isEncoding(encoding))\\n    throw new TypeError('Unknown encoding: ' + encoding);\\n  this._writableState.defaultEncoding = encoding;\\n};\\n\\nfunction decodeChunk(state, chunk, encoding) {\\n  if (!state.objectMode &&\\n      state.decodeStrings !== false &&\\n      typeof chunk === 'string') {\\n    chunk = Buffer(chunk, encoding);\\n  }\\n  return chunk;\\n}\\n\\n// if we're already writing something, then just put this\\n// in the queue, and wait our turn.  Otherwise, call _write\\n// If we return false, then we need a drain event, so set that flag.\\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\\n  chunk = decodeChunk(state, chunk, encoding);\\n\\n  if (chunk instanceof Buffer)\\n    encoding = 'buffer';\\n  var len = state.objectMode ? 1 : chunk.length;\\n\\n  state.length += len;\\n\\n  var ret = state.length < state.highWaterMark;\\n  // we must ensure that previous needDrain will not be reset to false.\\n  if (!ret)\\n    state.needDrain = true;\\n\\n  if (state.writing || state.corked) {\\n    var last = state.lastBufferedRequest;\\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\\n    if (last) {\\n      last.next = state.lastBufferedRequest;\\n    } else {\\n      state.bufferedRequest = state.lastBufferedRequest;\\n    }\\n  } else {\\n    doWrite(stream, state, false, len, chunk, encoding, cb);\\n  }\\n\\n  return ret;\\n}\\n\\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\\n  state.writelen = len;\\n  state.writecb = cb;\\n  state.writing = true;\\n  state.sync = true;\\n  if (writev)\\n    stream._writev(chunk, state.onwrite);\\n  else\\n    stream._write(chunk, encoding, state.onwrite);\\n  state.sync = false;\\n}\\n\\nfunction onwriteError(stream, state, sync, er, cb) {\\n  --state.pendingcb;\\n  if (sync)\\n    process.nextTick(cb, er);\\n  else\\n    cb(er);\\n\\n  stream._writableState.errorEmitted = true;\\n  stream.emit('error', er);\\n}\\n\\nfunction onwriteStateUpdate(state) {\\n  state.writing = false;\\n  state.writecb = null;\\n  state.length -= state.writelen;\\n  state.writelen = 0;\\n}\\n\\nfunction onwrite(stream, er) {\\n  var state = stream._writableState;\\n  var sync = state.sync;\\n  var cb = state.writecb;\\n\\n  onwriteStateUpdate(state);\\n\\n  if (er)\\n    onwriteError(stream, state, sync, er, cb);\\n  else {\\n    // Check if we're actually ready to finish, but don't emit yet\\n    var finished = needFinish(state);\\n\\n    if (!finished &&\\n        !state.corked &&\\n        !state.bufferProcessing &&\\n        state.bufferedRequest) {\\n      clearBuffer(stream, state);\\n    }\\n\\n    if (sync) {\\n      process.nextTick(afterWrite, stream, state, finished, cb);\\n    } else {\\n      afterWrite(stream, state, finished, cb);\\n    }\\n  }\\n}\\n\\nfunction afterWrite(stream, state, finished, cb) {\\n  if (!finished)\\n    onwriteDrain(stream, state);\\n  state.pendingcb--;\\n  cb();\\n  finishMaybe(stream, state);\\n}\\n\\n// Must force callback to be called on nextTick, so that we don't\\n// emit 'drain' before the write() consumer gets the 'false' return\\n// value, and has a chance to attach a 'drain' listener.\\nfunction onwriteDrain(stream, state) {\\n  if (state.length === 0 && state.needDrain) {\\n    state.needDrain = false;\\n    stream.emit('drain');\\n  }\\n}\\n\\n\\n// if there's something in the buffer waiting, then process it\\nfunction clearBuffer(stream, state) {\\n  state.bufferProcessing = true;\\n  var entry = state.bufferedRequest;\\n\\n  if (stream._writev && entry && entry.next) {\\n    // Fast case, write everything using _writev()\\n    var buffer = [];\\n    var cbs = [];\\n    while (entry) {\\n      cbs.push(entry.callback);\\n      buffer.push(entry);\\n      entry = entry.next;\\n    }\\n\\n    // count the one we are adding, as well.\\n    // TODO(isaacs) clean this up\\n    state.pendingcb++;\\n    state.lastBufferedRequest = null;\\n    doWrite(stream, state, true, state.length, buffer, '', function(err) {\\n      for (var i = 0; i < cbs.length; i++) {\\n        state.pendingcb--;\\n        cbs[i](err);\\n      }\\n    });\\n\\n    // Clear buffer\\n  } else {\\n    // Slow case, write chunks one-by-one\\n    while (entry) {\\n      var chunk = entry.chunk;\\n      var encoding = entry.encoding;\\n      var cb = entry.callback;\\n      var len = state.objectMode ? 1 : chunk.length;\\n\\n      doWrite(stream, state, false, len, chunk, encoding, cb);\\n      entry = entry.next;\\n      // if we didn't call the onwrite immediately, then\\n      // it means that we need to wait until it does.\\n      // also, that means that the chunk and cb are currently\\n      // being processed, so move the buffer counter past them.\\n      if (state.writing) {\\n        break;\\n      }\\n    }\\n\\n    if (entry === null)\\n      state.lastBufferedRequest = null;\\n  }\\n  state.bufferedRequest = entry;\\n  state.bufferProcessing = false;\\n}\\n\\nWritable.prototype._write = function(chunk, encoding, cb) {\\n  cb(new Error('not implemented'));\\n};\\n\\nWritable.prototype._writev = null;\\n\\nWritable.prototype.end = function(chunk, encoding, cb) {\\n  var state = this._writableState;\\n\\n  if (typeof chunk === 'function') {\\n    cb = chunk;\\n    chunk = null;\\n    encoding = null;\\n  } else if (typeof encoding === 'function') {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n\\n  if (chunk !== null && chunk !== undefined)\\n    this.write(chunk, encoding);\\n\\n  // .end() fully uncorks\\n  if (state.corked) {\\n    state.corked = 1;\\n    this.uncork();\\n  }\\n\\n  // ignore unnecessary end() calls.\\n  if (!state.ending && !state.finished)\\n    endWritable(this, state, cb);\\n};\\n\\n\\nfunction needFinish(state) {\\n  return (state.ending &&\\n          state.length === 0 &&\\n          state.bufferedRequest === null &&\\n          !state.finished &&\\n          !state.writing);\\n}\\n\\nfunction prefinish(stream, state) {\\n  if (!state.prefinished) {\\n    state.prefinished = true;\\n    stream.emit('prefinish');\\n  }\\n}\\n\\nfunction finishMaybe(stream, state) {\\n  var need = needFinish(state);\\n  if (need) {\\n    if (state.pendingcb === 0) {\\n      prefinish(stream, state);\\n      state.finished = true;\\n      stream.emit('finish');\\n    } else {\\n      prefinish(stream, state);\\n    }\\n  }\\n  return need;\\n}\\n\\nfunction endWritable(stream, state, cb) {\\n  state.ending = true;\\n  finishMaybe(stream, state);\\n  if (cb) {\\n    if (state.finished)\\n      process.nextTick(cb);\\n    else\\n      stream.once('finish', cb);\\n  }\\n  state.ended = true;\\n}\\n\",\"_stream_duplex\":\"// a duplex stream is just a stream that is both readable and writable.\\n// Since JS doesn't have multiple prototypal inheritance, this class\\n// prototypally inherits from Readable, and then parasitically from\\n// Writable.\\n\\n'use strict';\\n\\nmodule.exports = Duplex;\\n\\nvar util = require('util');\\nvar Readable = require('_stream_readable');\\nvar Writable = require('_stream_writable');\\n\\nutil.inherits(Duplex, Readable);\\n\\nvar keys = Object.keys(Writable.prototype);\\nfor (var v = 0; v < keys.length; v++) {\\n  var method = keys[v];\\n  if (!Duplex.prototype[method])\\n    Duplex.prototype[method] = Writable.prototype[method];\\n}\\n\\nfunction Duplex(options) {\\n  if (!(this instanceof Duplex))\\n    return new Duplex(options);\\n\\n  Readable.call(this, options);\\n  Writable.call(this, options);\\n\\n  if (options && options.readable === false)\\n    this.readable = false;\\n\\n  if (options && options.writable === false)\\n    this.writable = false;\\n\\n  this.allowHalfOpen = true;\\n  if (options && options.allowHalfOpen === false)\\n    this.allowHalfOpen = false;\\n\\n  this.once('end', onend);\\n}\\n\\n// the no-half-open enforcer\\nfunction onend() {\\n  // if we allow half-open state, or if the writable side ended,\\n  // then we're ok.\\n  if (this.allowHalfOpen || this._writableState.ended)\\n    return;\\n\\n  // no more data can be written.\\n  // But allow more writes to happen in this tick.\\n  process.nextTick(onEndNT, this);\\n}\\n\\nfunction onEndNT(self) {\\n  self.end();\\n}\\n\",\"_stream_transform\":\"// a transform stream is a readable/writable stream where you do\\n// something with the data.  Sometimes it's called a \\\"filter\\\",\\n// but that's not a great name for it, since that implies a thing where\\n// some bits pass through, and others are simply ignored.  (That would\\n// be a valid example of a transform, of course.)\\n//\\n// While the output is causally related to the input, it's not a\\n// necessarily symmetric or synchronous transformation.  For example,\\n// a zlib stream might take multiple plain-text writes(), and then\\n// emit a single compressed chunk some time in the future.\\n//\\n// Here's how this works:\\n//\\n// The Transform stream has all the aspects of the readable and writable\\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\\n// internally, and returns false if there's a lot of pending writes\\n// buffered up.  When you call read(), that calls _read(n) until\\n// there's enough pending readable data buffered up.\\n//\\n// In a transform stream, the written data is placed in a buffer.  When\\n// _read(n) is called, it transforms the queued up data, calling the\\n// buffered _write cb's as it consumes chunks.  If consuming a single\\n// written chunk would result in multiple output chunks, then the first\\n// outputted bit calls the readcb, and subsequent chunks just go into\\n// the read buffer, and will cause it to emit 'readable' if necessary.\\n//\\n// This way, back-pressure is actually determined by the reading side,\\n// since _read has to be called to start processing a new chunk.  However,\\n// a pathological inflate type of transform can cause excessive buffering\\n// here.  For example, imagine a stream where every byte of input is\\n// interpreted as an integer from 0-255, and then results in that many\\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\\n// 1kb of data being output.  In this case, you could write a very small\\n// amount of input, and end up with a very large amount of output.  In\\n// such a pathological inflating mechanism, there'd be no way to tell\\n// the system to stop doing the transform.  A single 4MB write could\\n// cause the system to run out of memory.\\n//\\n// However, even in such a pathological case, only a single written chunk\\n// would be consumed, and then the rest would wait (un-transformed) until\\n// the results of the previous transformed chunk were consumed.\\n\\n'use strict';\\n\\nmodule.exports = Transform;\\n\\nvar Duplex = require('_stream_duplex');\\nvar util = require('util');\\nutil.inherits(Transform, Duplex);\\n\\n\\nfunction TransformState(stream) {\\n  this.afterTransform = function(er, data) {\\n    return afterTransform(stream, er, data);\\n  };\\n\\n  this.needTransform = false;\\n  this.transforming = false;\\n  this.writecb = null;\\n  this.writechunk = null;\\n}\\n\\nfunction afterTransform(stream, er, data) {\\n  var ts = stream._transformState;\\n  ts.transforming = false;\\n\\n  var cb = ts.writecb;\\n\\n  if (!cb)\\n    return stream.emit('error', new Error('no writecb in Transform class'));\\n\\n  ts.writechunk = null;\\n  ts.writecb = null;\\n\\n  if (data !== null && data !== undefined)\\n    stream.push(data);\\n\\n  if (cb)\\n    cb(er);\\n\\n  var rs = stream._readableState;\\n  rs.reading = false;\\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\\n    stream._read(rs.highWaterMark);\\n  }\\n}\\n\\n\\nfunction Transform(options) {\\n  if (!(this instanceof Transform))\\n    return new Transform(options);\\n\\n  Duplex.call(this, options);\\n\\n  this._transformState = new TransformState(this);\\n\\n  // when the writable side finishes, then flush out anything remaining.\\n  var stream = this;\\n\\n  // start out asking for a readable event once data is transformed.\\n  this._readableState.needReadable = true;\\n\\n  // we have implemented the _read method, and done the other things\\n  // that Readable wants before the first _read call, so unset the\\n  // sync guard flag.\\n  this._readableState.sync = false;\\n\\n  if (options) {\\n    if (typeof options.transform === 'function')\\n      this._transform = options.transform;\\n\\n    if (typeof options.flush === 'function')\\n      this._flush = options.flush;\\n  }\\n\\n  this.once('prefinish', function() {\\n    if (typeof this._flush === 'function')\\n      this._flush(function(er) {\\n        done(stream, er);\\n      });\\n    else\\n      done(stream);\\n  });\\n}\\n\\nTransform.prototype.push = function(chunk, encoding) {\\n  this._transformState.needTransform = false;\\n  return Duplex.prototype.push.call(this, chunk, encoding);\\n};\\n\\n// This is the part where you do stuff!\\n// override this function in implementation classes.\\n// 'chunk' is an input chunk.\\n//\\n// Call `push(newChunk)` to pass along transformed output\\n// to the readable side.  You may call 'push' zero or more times.\\n//\\n// Call `cb(err)` when you are done with this chunk.  If you pass\\n// an error, then that'll put the hurt on the whole operation.  If you\\n// never call cb(), then you'll never get another chunk.\\nTransform.prototype._transform = function(chunk, encoding, cb) {\\n  throw new Error('Not implemented');\\n};\\n\\nTransform.prototype._write = function(chunk, encoding, cb) {\\n  var ts = this._transformState;\\n  ts.writecb = cb;\\n  ts.writechunk = chunk;\\n  ts.writeencoding = encoding;\\n  if (!ts.transforming) {\\n    var rs = this._readableState;\\n    if (ts.needTransform ||\\n        rs.needReadable ||\\n        rs.length < rs.highWaterMark)\\n      this._read(rs.highWaterMark);\\n  }\\n};\\n\\n// Doesn't matter what the args are here.\\n// _transform does all the work.\\n// That we got here means that the readable side wants more data.\\nTransform.prototype._read = function(n) {\\n  var ts = this._transformState;\\n\\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\\n    ts.transforming = true;\\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\\n  } else {\\n    // mark that we need a transform, so that any data that comes in\\n    // will get processed, now that we've asked for it.\\n    ts.needTransform = true;\\n  }\\n};\\n\\n\\nfunction done(stream, er) {\\n  if (er)\\n    return stream.emit('error', er);\\n\\n  // if there's nothing in the write buffer, then that means\\n  // that nothing more will ever be provided\\n  var ws = stream._writableState;\\n  var ts = stream._transformState;\\n\\n  if (ws.length)\\n    throw new Error('Calling transform done when ws.length != 0');\\n\\n  if (ts.transforming)\\n    throw new Error('Calling transform done when still transforming');\\n\\n  return stream.push(null);\\n}\\n\",\"_stream_passthrough\":\"// a passthrough stream.\\n// basically just the most minimal sort of Transform stream.\\n// Every written chunk gets output as-is.\\n\\n'use strict';\\n\\nmodule.exports = PassThrough;\\n\\nvar Transform = require('_stream_transform');\\nvar util = require('util');\\nutil.inherits(PassThrough, Transform);\\n\\nfunction PassThrough(options) {\\n  if (!(this instanceof PassThrough))\\n    return new PassThrough(options);\\n\\n  Transform.call(this, options);\\n}\\n\\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\\n  cb(null, chunk);\\n};\\n\",\"timer_wrap\":\"var loop = process.binding('loop');\\r\\nvar main_loop = process.main_loop;\\r\\n\\r\\nvar Handle = process.binding('handle_wrap');\\r\\n\\r\\nvar kOnTimeout = 'ontimeout';\\r\\n\\r\\nfunction Timer() {\\r\\n\\tvar handle = loop.handle_init(main_loop, OnTimeout);\\r\\n\\tthis._handle = handle;\\r\\n\\tHandle.wrap(handle, this);\\r\\n\\treturn this;\\r\\n}\\r\\n\\r\\nTimer.kOnTimeout = kOnTimeout;\\r\\n\\r\\nTimer.prototype.start  = function (timeout, repeat) {\\r\\n\\tvar handle = this._handle;\\r\\n\\tloop.timer_start(handle, timeout, repeat || -1);\\r\\n};\\r\\n\\r\\nTimer.prototype.stop  = function (timeout, repeat) {\\r\\n\\tvar handle = this._handle;\\r\\n\\tloop.timer_stop(handle);\\r\\n};\\r\\n\\r\\nTimer.prototype.close = Handle.close;\\r\\nTimer.prototype.unref = Handle.unref;\\r\\nTimer.prototype.ref   = Handle.ref;\\r\\n\\r\\nTimer.now = function () {\\r\\n\\treturn loop.update_time(main_loop);\\r\\n};\\r\\n\\r\\nfunction OnTimeout (handle) {\\r\\n\\tvar wrap = Handle.unwrap(handle);\\r\\n\\tprocess.MakeCallback(wrap, kOnTimeout);\\r\\n}\\r\\n\\r\\nmodule.exports = {\\r\\n\\tTimer : Timer,\\r\\n\\tkOnTimeout : Timer.kOnTimeout\\r\\n};\\r\\n\",\"buffer_wrap\":\"var binding = process.binding('buffer');\\r\\nvar _bufferPrototype;\\r\\n\\r\\nfunction _enc (enc){\\r\\n\\treturn binding.encodings[enc] || 3;\\r\\n}\\r\\n\\r\\nexports.setupBufferJS = function(proto, obj){\\r\\n\\t_bufferPrototype = proto;\\r\\n\\r\\n\\tproto.hexSlice     = binding.hexSlice;\\r\\n\\tproto.asciiSlice   = binding.asciiSlice;\\r\\n\\tproto.base64Slice  = binding.base64Slice;\\r\\n\\tproto.binarySlice  = binding.asciiSlice;\\r\\n\\tproto.utf8Slice    = binding.utf8Slice;\\r\\n\\tproto.ucs2Slice    = binding.ucs2Slice;\\r\\n\\r\\n\\t// proto.utf8Slice    = function(s,e){\\r\\n\\t// \\treturn NODE_BUFFER.prototype.toString.call(this, 'utf8', s, e);\\r\\n\\t// };\\r\\n\\r\\n\\tproto.hexWrite = binding.hexWrite;\\r\\n\\tproto.utf8Write = binding.utf8Write;\\r\\n\\tproto.asciiWrite = binding.asciiWrite;\\r\\n\\tproto.binaryWrite = binding.binaryWrite;\\r\\n\\tproto.base64Write = binding.base64Write;\\r\\n\\tproto.ucs2Write   = binding.ucs2Write;\\r\\n\\r\\n\\tproto.foreach = binding.foreach;\\r\\n\\tproto.copy = NODE_BUFFER.prototype.copy;\\r\\n\\r\\n\\tobj.flags = new Uint8Array(1);\\r\\n};\\r\\n\\r\\nexports.createFromString = function(string, encoding){\\r\\n\\tvar enc = _enc(encoding);\\r\\n\\tvar buf = binding.createFromString(string, enc);\\r\\n\\t// buf = new Int32Array(buf, 0, buf.byteLength);\\r\\n\\tObject.setPrototypeOf(buf, _bufferPrototype);\\r\\n\\treturn buf;\\r\\n};\\r\\n\\r\\nexports.createFromArrayBuffer = function(ab){\\r\\n\\tif(!(ab instanceof ArrayBuffer)) throw(\\\"argument is not an ArrayBuffer\\\");\\r\\n\\tvar buf = new Uint8Array(ab, 0, ab.byteLength);\\r\\n\\tObject.setPrototypeOf(buf, _bufferPrototype);\\r\\n\\treturn buf;\\r\\n};\\r\\n\\r\\nexports.fill    = binding.fill;\\r\\nexports.compare = binding.compare;\\r\\n\\r\\nexports.byteLengthUtf8 = binding.byteLengthUtf8;\\r\\nexports.create = binding.create;\\r\\nexports.kMaxLength = binding.kMaxLength;\\r\\n\",\"handle_wrap\":\"var loop = process.binding('loop');\\r\\nvar assert = require('assert');\\r\\n\\r\\nvar kUnref = 1;\\r\\nvar kCloseCallback = 2;\\r\\n\\r\\nfunction Handle(){}\\r\\nHandle.wrap = function (handle, wrap){\\r\\n\\tloop.handle_wrap(handle, wrap);\\r\\n};\\r\\n\\r\\nHandle.unwrap = function (handle){\\r\\n\\treturn loop.handle_unwrap(handle);\\r\\n};\\r\\n\\r\\nHandle.close = function (cb) {\\r\\n\\tvar wrap = this;\\r\\n\\tif (!wrap || !wrap._handle) {\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (typeof cb == 'function') {\\r\\n\\t\\twrap.onclose = cb;\\r\\n\\t\\twrap.flags |= kCloseCallback;\\r\\n\\t}\\r\\n\\r\\n\\tloop.handle_close(wrap._handle, OnClose);\\r\\n\\twrap._handle = null;\\r\\n}\\r\\n\\r\\nfunction OnClose (handle) {\\r\\n\\tvar wrap = Handle.unwrap(handle);\\r\\n\\tif (!wrap) throw(\\\"The wrap object should still be there\\\");\\r\\n\\tif (wrap._handle) throw(\\\"the handle pointer should be gone\\\");\\r\\n\\tif ( wrap.flags && (wrap.flags & kCloseCallback) ) {\\r\\n\\t\\tprocess.MakeCallback(wrap, 'onclose', 0);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nHandle.unref = function() {\\r\\n\\tvar wrap = this;\\r\\n\\tif (wrap && wrap._handle) {\\r\\n\\t\\tloop.handle_unref(wrap._handle);\\r\\n\\t\\twrap.flags |= kUnref;\\r\\n\\t}\\r\\n\\treturn wrap;\\r\\n}\\r\\n\\r\\nHandle.ref =  function (wrap) {\\r\\n\\tif (wrap && wrap._handle) {\\r\\n\\t\\tloop.handle_ref(wrap._handle);\\r\\n\\t\\twrap.flags &= ~kUnref;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nmodule.exports = Handle;\\r\\n\",\"tcp_wrap\":\"var sock    = process.binding('socket');\\r\\nvar uv      = require('uv');\\r\\n\\r\\nexports.TCP = TCP;\\r\\nexports.TCPConnectWrap = TCPConnectWrap;\\r\\n\\r\\nvar MakeCallback = process.MakeCallback;\\r\\n\\r\\nfunction TCPConnectWrap (){}\\r\\n\\r\\nfunction TCP (){\\r\\n\\tthis.writeQueueSize = 0;\\r\\n\\tthis._handle = new uv.TCP();\\r\\n}\\r\\n\\r\\n\\r\\nTCP.prototype.bind6 = TCP.prototype.bind = function(ip, port){\\r\\n\\tvar addr = sock.pton(ip, port);\\r\\n\\tif (!addr){\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\tvar err = this._handle.bind(addr, 0);\\r\\n\\treturn err;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.close = function(cb){\\r\\n\\tvar tcp = this;\\r\\n\\tprocess.nextTick(function(){\\r\\n\\t\\ttcp._handle.close(cb);\\r\\n\\t});\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.listen = function(backlog){\\r\\n\\tvar tcp = this;\\r\\n\\t//pass onConnection callback\\r\\n\\treturn this._handle.listen(backlog, function(status){\\r\\n\\t\\tvar client;\\r\\n\\t\\tif (status === 0){\\r\\n\\t\\t\\tclient = new TCP();\\r\\n\\t\\t\\tthis.accept(client._handle);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tMakeCallback(tcp, \\\"onconnection\\\", status, client);\\r\\n\\t});\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.readStart = function(){\\r\\n\\tvar tcp = this;\\r\\n\\tthis._handle.read_start(function(err, buf){\\r\\n\\t\\tvar len;\\r\\n\\t\\tif (err){\\r\\n\\t\\t\\tlen = err > 0 ? -err : err;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\telse if (buf){\\r\\n\\t\\t\\tlen = buf.length;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// nread == 0\\r\\n\\t\\telse { return; }\\r\\n\\r\\n\\t\\tMakeCallback(tcp, \\\"onread\\\", len, buf);\\r\\n\\t});\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.readStop = function(){\\r\\n\\treturn this._handle.read_stop();\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.open = function(fd){\\r\\n\\treturn this._handle.open(fd);\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.setSimultaneousAccepts = function(enable) {\\r\\n\\treturn this._handle.simultaneous_accepts(enable);\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.shutdown = function(req){\\r\\n\\tvar tcp = this;\\r\\n\\tthis._handle.shutdown(function(status){\\r\\n\\t\\tMakeCallback(req, \\\"oncomplete\\\", status, tcp, req);\\r\\n\\t});\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.writeBinaryString = function(req, data){\\r\\n\\tdata = Buffer(data, \\\"binary\\\");\\r\\n\\treturn this.writeUtf8String(req, data.toString(\\\"binary\\\"));\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.writeBuffer =\\r\\nTCP.prototype.writeUtf8String = function(req, data){\\r\\n\\tvar tcp = this;\\r\\n\\tthis._handle.write(data, function(status){\\r\\n\\t\\ttcp.writeQueueSize = tcp._handle.write_queue_size;\\r\\n\\t\\treq.bytes = this.bytes;\\r\\n\\t\\tMakeCallback(req, \\\"oncomplete\\\", status, tcp, req, 0);\\r\\n\\t});\\r\\n\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nTCP.prototype.connect = function(req_wrap_obj, ip_address, port){\\r\\n\\tvar tcp = this;\\r\\n\\tvar addr = uv.ip4_addr(\\\"127.0.0.1\\\", port);\\r\\n\\tif (addr === null){\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\tvar err = this._handle.connect(addr, function AfterConnect (status){\\r\\n\\t\\tMakeCallback(req_wrap_obj, \\\"oncomplete\\\", status, tcp, req_wrap_obj, true, true);\\r\\n\\t\\t//req_wrap_obj.oncomplete(status, tcp, req_wrap_obj, true, true);\\r\\n\\t});\\r\\n\\treturn err;\\r\\n};\\r\\n\",\"stream_wrap\":\"exports.WriteWrap = function(){};\\r\\nexports.ShutdownWrap = function(){};\\r\\n\\r\\n\",\"pipe_wrap\":\"var uv           = require('uv');\\r\\nvar MakeCallback = process.MakeCallback;\\r\\nvar syscall      = require('syscall');\\r\\nvar tcpWrap      = process.binding('tcp_wrap').TCP;\\r\\nvar errno        = require('errno');\\r\\n\\r\\n\\r\\nfunction Pipe(ipc){\\r\\n\\tthis._handle = new uv.Pipe(ipc);\\r\\n}\\r\\n\\r\\n\\r\\nPipe.prototype.close = function(cb){\\r\\n\\tvar pipe = this;\\r\\n\\tpipe._handle.close(cb);\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.readStop = function(){\\r\\n\\tthrow new Error('read stop');\\r\\n\\treturn this._handle.read_stop();\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.writeBuffer =\\r\\nPipe.prototype.writeUtf8String = function(req, data, send_handle){\\r\\n\\tvar stream = this;\\r\\n\\r\\n\\tif (send_handle){\\r\\n\\t\\tsend_handle = send_handle._handle;\\r\\n\\t}\\r\\n\\r\\n\\tthis._handle.write(data, function(status){\\r\\n\\t\\tstream.writeQueueSize = stream._handle.write_queue_size;\\r\\n\\t\\treq.bytes = this.bytes;\\r\\n\\t\\tMakeCallback(req, \\\"oncomplete\\\", status, stream, req, 0);\\r\\n\\t}, send_handle);\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.open = function(fd){\\r\\n\\treturn this._handle.open(fd);\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.unref = function(fd){\\r\\n\\tthis._handle.io_watcher.unref();\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.ref = function(fd){\\r\\n\\tthis._handle.io_watcher.ref();\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nPipe.prototype.readStart = function(){\\r\\n\\tvar pipe = this;\\r\\n\\r\\n\\tpipe._handle.read_start(function(err, buf){\\r\\n\\t\\tvar handle = pipe._handle;\\r\\n\\r\\n\\t\\t// get pending type\\r\\n\\t\\tvar type   = 'UNKNOWN_HANDLE';\\r\\n\\t\\tif (handle.type === 'NAMED_PIPE' && handle.ipc &&\\r\\n\\t\\t\\tuv.pipe_pending_count(handle) > 0){\\r\\n\\t\\t\\ttype = uv.pipe_handle_type(handle);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar nread = 0;\\r\\n\\t\\tif (err){\\r\\n\\t\\t\\tnread = err > 0 ? -err : err;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\telse if (buf){\\r\\n\\t\\t\\tnread = Buffer.byteLength(buf);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\telse { nread = 0; }\\r\\n\\r\\n\\t\\tif (nread === 0) return;\\r\\n\\r\\n\\t\\tvar pending_object;\\r\\n\\t\\tif (type !== 'UNKNOWN_HANDLE'){\\r\\n\\t\\t\\tpending_object = new tcpWrap();\\r\\n\\t\\t\\tvar ret = this.accept(pending_object._handle);\\r\\n\\t\\t\\tif (ret){\\r\\n\\t\\t\\t\\tthrow new Error(\\\"pending object error\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tMakeCallback(pipe, 'onread', nread, Buffer(buf).toString(), pending_object);\\r\\n\\t});\\r\\n};\\r\\n\\r\\nexports.Pipe = Pipe;\\r\\n\",\"fs_wrap\":\"var posix    = process.binding('posix');\\r\\nvar syscall  = require('syscall');\\r\\nvar util     = require('util');\\r\\n\\r\\nvar isWin    = process.platform == 'win32';\\r\\nvar errnoException = require('util')._errnoException;\\r\\n\\r\\nfunction _throw (errno, syscall, path){\\r\\n\\tvar error = errnoException(errno, syscall);\\r\\n\\tif (path) error.path = path.replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\/, '');\\r\\n\\treturn error;\\r\\n}\\r\\n\\r\\nexports.FSReqWrap = function(){};\\r\\n\\r\\nvar statFunction; /* global */\\r\\nexports.FSInitialize = function(fn){\\r\\n\\tstatFunction = fn;\\r\\n};\\r\\n\\r\\n\\r\\nexports.open = function(file, flags, mode, req){\\r\\n\\tvar err = null;\\r\\n\\tvar fd = posix.open(file, flags, mode);\\r\\n\\tif (fd === null){\\r\\n\\t\\terr = _throw(process.errno, 'open', file);\\r\\n\\t} else {\\r\\n\\t\\tvar closefd = isWin ? syscall.GetFdHandle(fd) : fd;\\r\\n\\t\\tif (!syscall.cloexec(closefd, 1)){\\r\\n\\t\\t    err = _throw(process.errno, 'open', file);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (req){\\r\\n\\t\\tprocess.nextTick(function(){\\r\\n\\t\\t\\treq.oncomplete(err, fd);\\r\\n\\t\\t});\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (err) throw(err);\\r\\n\\treturn fd;\\r\\n};\\r\\n\\r\\n\\r\\nexports.read = function(fd, buffer, offset, length, position, req){\\r\\n\\toffset = offset || 0;\\r\\n\\tlength = length || buffer.byteLength;\\r\\n\\r\\n\\tvar err;\\r\\n\\tvar nread = posix.read(fd, [buffer, offset], length, position);\\r\\n\\tif (nread === null){\\r\\n\\t\\terr = _throw(process.errno, 'read');\\r\\n\\t}\\r\\n\\r\\n\\tif (req){\\r\\n\\t\\tprocess.nextTick(function(){\\r\\n\\t\\t\\treq.oncomplete(err, nread);\\r\\n\\t\\t});\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (err) throw err;\\r\\n\\treturn nread;\\r\\n};\\r\\n\\r\\n\\r\\nexports.writeBuffers = function(fd, chunks, pos, req){\\r\\n\\tif (req){\\r\\n\\t\\tcb = {};\\r\\n\\t\\tcb.oncomplete = function(err, n){\\r\\n\\t\\t\\tif (err){\\r\\n\\t\\t\\t\\treq.oncomplete(err);\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tvar chunk = chunks.shift();\\r\\n\\t\\t\\tif (!chunk){\\r\\n\\t\\t\\t\\treq.oncomplete(err, n);\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\texports.writeBuffer(fd, chunk, 0, chunk.byteLength, pos, cb);\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tcb.oncomplete(null);\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tchunks.forEach(function(chunk){\\r\\n\\t\\texports.writeBuffer(fd, chunk, 0, chunk.byteLength, pos);\\r\\n\\t});\\r\\n};\\r\\n\\r\\n\\r\\nexports.writeBuffer = exports.writeString = function(fd, data, offset, length, position, req){\\r\\n\\tvar err;\\r\\n\\tvar buffer;\\r\\n\\r\\n\\tif (util.isBuffer(data)){\\r\\n\\t\\tbuffer = data;\\r\\n\\t\\tif (!util.isNumber(position)){\\r\\n\\t\\t\\tposition = 0;\\r\\n\\t\\t}\\r\\n\\t} else {\\r\\n\\t\\tvar args = [].slice.call(arguments);\\r\\n\\t\\tposition = args[2];\\r\\n\\t\\tif (!util.isNumber(position)){\\r\\n\\t\\t\\tposition = 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar encoding = args[3];\\r\\n\\t\\treq = args[4];\\r\\n\\r\\n\\t\\tif (!util.isString(encoding)){\\r\\n\\t\\t\\tencoding = 'utf8';\\r\\n\\t\\t\\treq = encoding;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tbuffer = Buffer(data, encoding);\\r\\n\\t\\tlength = buffer.byteLength;\\r\\n\\t\\toffset = 0;\\r\\n\\t}\\r\\n\\r\\n\\tvar nwritten = posix.writeBuffer(fd, [buffer, offset], length, position);\\r\\n\\tif (nwritten === null){\\r\\n\\t\\terr = _throw(process.errno, 'write');\\r\\n\\t}\\r\\n\\r\\n\\tif (req){\\r\\n\\t\\tprocess.nextTick(function(){\\r\\n\\t\\t\\treq.oncomplete(err, nwritten);\\r\\n\\t\\t});\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\r\\n\\tif (err) throw(err);\\r\\n\\treturn nwritten;\\r\\n};\\r\\n\\r\\n\\r\\nfunction _normalizePath (args){\\r\\n\\tif (typeof args[0] === 'string'){\\r\\n\\targs[0] = args[0].replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\/, '');\\r\\n\\t}\\r\\n\\treturn args;\\r\\n}\\r\\n\\r\\n\\r\\nfunction _normalizeLinkArgs (args) {\\r\\n\\t//src => args[0]\\r\\n\\tif (!util.isString(args[0])){\\r\\n\\t\\tthrow new Error('src path must be a string');\\r\\n\\t}\\r\\n\\r\\n\\t//dest => args[1]\\r\\n\\tif (!util.isString(args[1])){\\r\\n\\t\\tthrow new Error('dest path must be a string');\\r\\n\\t}\\r\\n\\r\\n\\targs[0] = _normalizePath(args[0]);\\r\\n\\targs[1] = _normalizePath(args[1]);\\r\\n\\r\\n\\treturn args;\\r\\n}\\r\\n\\r\\n\\r\\nfunction _checkAccessArgs (args){\\r\\n\\t if (!util.isString(args[0])){\\r\\n\\t\\tthrow new Error(\\\"path must be a string\\\");\\r\\n\\t}\\r\\n\\treturn args;\\r\\n}\\r\\n\\r\\n\\r\\n[\\r\\n\\t['close', 2],\\r\\n\\t['ftruncate', 3],\\r\\n\\t['rmdir', 3],\\r\\n\\t['mkdir', 3],\\r\\n\\t['fchmod', 3],\\r\\n\\t['chmod', 3],\\r\\n\\t['unlink', 2],\\r\\n\\t['symlink', 4],\\r\\n\\t['readdir', 2],\\r\\n\\t['fsync', 2],\\r\\n\\t['link', 3, _normalizeLinkArgs],\\r\\n\\t['access', 3, _checkAccessArgs]\\r\\n].forEach(function(obj){\\r\\n\\tvar fn         = obj[0];\\r\\n\\tvar argsLength = obj[1];\\r\\n\\tvar _normalize = obj[2] || _normalizePath;\\r\\n\\r\\n\\texports[fn] = function(){\\r\\n\\t\\tvar args = [].slice.call(arguments);\\r\\n\\t\\tvar req;\\r\\n\\t\\tvar err = null;\\r\\n\\r\\n\\t\\tif (args.length === argsLength){\\r\\n\\t\\t\\treq = args.pop();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//normalize and or check arguments\\r\\n\\t\\targs = _normalize(args);\\r\\n\\r\\n\\t\\tvar ret = posix[fn].apply(null, args);\\r\\n\\r\\n\\t\\tif (ret === null){\\r\\n\\t\\t\\terr = _throw(process.errno, fn, args[0]);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (req){\\r\\n\\t\\t\\tprocess.nextTick(function(){\\r\\n\\t\\t\\t\\treq.oncomplete(err, ret);\\r\\n\\t\\t\\t});\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (err) throw err;\\r\\n\\t\\treturn ret;\\r\\n\\t};\\r\\n});\\r\\n\\r\\nexports.fdatasync = exports.fsync;\\r\\n\\r\\n\\r\\n//stat functions\\r\\n['lstat', 'fstat', 'stat'].forEach(function(fn){\\r\\n\\texports[fn] = function(file, req){\\r\\n\\t\\tvar err = null;\\r\\n\\t\\tvar stat;\\r\\n\\r\\n\\t\\tif (typeof file === 'string'){\\r\\n\\t\\t\\tfile = file.replace(/^\\\\\\\\\\\\\\\\\\\\?\\\\\\\\/, '');\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar s = posix[fn](file);\\r\\n\\t\\tif (s === null){\\r\\n\\t\\t\\terr = _throw(process.errno, fn, file);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (s && !err){\\r\\n\\t\\t\\tstat = new statFunction(s.dev,\\r\\n\\t\\t\\t\\ts.mode,\\r\\n\\t\\t\\t\\ts.nlink,\\r\\n\\t\\t\\t\\ts.uid,\\r\\n\\t\\t\\t\\ts.gid,\\r\\n\\t\\t\\t\\ts.rdev,\\r\\n\\t\\t\\t\\ts.blksize,\\r\\n\\t\\t\\t\\ts.ino,\\r\\n\\t\\t\\t\\ts.size,\\r\\n\\t\\t\\t\\ts.blocks,\\r\\n\\t\\t\\t\\ts.atime * 1000, //to millisecond\\r\\n\\t\\t\\t\\ts.mtime * 1000, //to millisecond\\r\\n\\t\\t\\t\\ts.ctime * 1000, //to millisecond\\r\\n\\t\\t\\t\\ts.birthtim_msec\\r\\n\\t\\t\\t);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (req){\\r\\n\\t\\t\\tprocess.nextTick(function(){\\r\\n\\t\\t\\t\\treq.oncomplete(err, stat);\\r\\n\\t\\t\\t});\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (err) throw err;\\r\\n\\t\\treturn stat;\\r\\n\\t};\\r\\n});\\r\\n\",\"fs_event_wrap\":\"//empty file\\r\\nmodule.exports = {};\\r\\n\",\"cares_wrap\":\"var socket = process.binding('socket');\\r\\n\\r\\nexports.GetAddrInfoReqWrap = function(){};\\r\\n\\r\\nexports.getaddrinfo = function(){\\r\\n\\tconsole.log(arguments);\\r\\n}\\r\\n\\r\\nexports.isIP = function(ip){\\r\\n    return socket.isIP(ip);\\r\\n};\\r\\n\",\"tty_wrap\":\"// var bindings = process.binding('tty');\\r\\n// var uv       = require('uv');\\r\\n\\r\\n// exports.guessHandleType = bindings.guessHandleType;\\r\\n\\r\\nfunction TTY (fd, readable){\\r\\n\\tthis._handle = new uv.TTY(fd, readable);\\r\\n\\tthis.readStart(function(){});\\r\\n};\\r\\n\\r\\nTTY.prototype.writeUtf8String = function(req, data){\\r\\n\\tthis._handle.write(data);\\r\\n};\\r\\n\\r\\nTTY.prototype.getWindowSize = function(arr){\\r\\n\\tvar winsize = bindings.getWindowSize();\\r\\n\\tif (!winsize){\\r\\n\\t\\treturn process.errno;\\r\\n\\t}\\r\\n\\r\\n\\tarr[0] = winsize.width;\\r\\n\\tarr[1] = winsize.height;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\nTTY.prototype.readStart = function(){\\r\\n\\tvar tcp = this;\\r\\n\\tthis._handle.read_start(function(err, buf){\\r\\n\\t\\tvar len;\\r\\n\\t\\tif (err){\\r\\n\\t\\t\\tlen = err;\\r\\n\\t\\t} else if (buf){\\r\\n\\t\\t\\tlen = buf.length;\\r\\n\\t\\t} else { len = 0; }\\r\\n\\r\\n\\t\\ttcp.onread(len, buf);\\r\\n\\t});\\r\\n};\\r\\n\\r\\nTTY.prototype.readStop = function(){\\r\\n\\treturn this._handle.read_stop();\\r\\n};\\r\\n\\r\\nTTY.prototype.setRawMode = function(mode){\\r\\n\\tthis._handle.set_mode(mode ? 1 : 0);\\r\\n};\\r\\n\\r\\nexports.TTY = TTY;\\r\\n\\r\\n// TODO\\r\\nexports.guessHandleType = function(h){\\r\\n\\treturn 'TCP';\\r\\n};\\r\\n\",\"spawn_sync\":\"\\r\\nvar process_wrap = process.binding('process_wrap').Process;\\r\\nvar loop = process.binding('loop');\\r\\nvar child_process = require('child_process');\\r\\n\\r\\n\\r\\n// exports.spawn = function(options){\\r\\n// \\t// save main event loop as we\\r\\n// \\t// are going to use it again\\r\\n// \\tvar main_loop = process.main_loop;\\r\\n\\r\\n// \\t// create new event loop\\r\\n// \\tvar new_loop = process.main_loop = loop.init();\\r\\n\\r\\n// \\t// console.log(options);\\r\\n// \\tvar Process = new process_wrap();\\r\\n// \\tProcess.onexit = function tttest (){\\r\\n// \\t\\tprint('XXXXXXXXXXXXXXXX');\\r\\n// \\t};\\r\\n\\r\\n// \\tvar h = loop.handle_init(new_loop, function(){\\r\\n// \\t\\tprint('XCC');\\r\\n// \\t});\\r\\n\\r\\n// \\tloop.timer_start(h, 100, 100);\\r\\n// \\tProcess.spawn(options);\\r\\n// \\tloop.run(new_loop, 0);\\r\\n\\r\\n// \\t// reset back to main loop\\r\\n// \\tprocess.main_loop = main_loop;\\r\\n\\r\\n// \\t// free new loop\\r\\n// \\tloop.destroy(new_loop);\\r\\n\\r\\n// \\t// child_process.spawn\\r\\n// \\t// child_process.spawn(options.file, options.args, options);\\r\\n// };\\r\\n\\r\\nvar iz = 9;\\r\\nexports.spawn = function(a,b,c){\\r\\n\\t// save main event loop as we\\r\\n\\t// are going to use it again\\r\\n\\tvar main_loop = process.main_loop;\\r\\n\\tvar nextTick  = process.nextTick;\\r\\n\\r\\n\\tprocess.nextTick = function(){\\r\\n\\t\\tvar args = [].slice.call(arguments);\\r\\n\\t\\tvar callback = args.shift();\\r\\n\\t\\tcallback.apply(null, args);\\r\\n\\t};\\r\\n\\r\\n\\t// create new event loop\\r\\n\\tvar new_loop = process.main_loop = loop.init();\\r\\n\\r\\n\\tvar result = {\\r\\n\\t\\tstatus : 0,\\r\\n\\t\\toutput : []\\r\\n\\t};\\r\\n\\r\\n\\tvar stdout = [];\\r\\n\\tvar stderr = [];\\r\\n\\tvar status;\\r\\n\\r\\n\\ttry {\\r\\n\\t\\tvar child = child_process.spawn.apply(null, arguments);\\r\\n\\t} catch (e){\\r\\n\\t\\te.syscall = e.syscall.replace('spawn', 'spawnSync');\\r\\n\\t\\tresult.error = e;\\r\\n\\t\\tprocess.main_loop = main_loop;\\r\\n\\t\\tprocess.nextTick = nextTick;\\r\\n\\t\\treturn result;\\r\\n\\t}\\r\\n\\r\\n\\tchild.on('exit', function(code){\\r\\n\\t\\tresult.status = code;\\r\\n\\t});\\r\\n\\r\\n\\t// child.on('error', function(e){\\r\\n\\t// \\tresult.error = e;\\r\\n\\t// });\\r\\n\\r\\n\\tchild.stdout.on('data', function(data){\\r\\n\\t\\tstdout.push(data);\\r\\n\\t});\\r\\n\\r\\n\\tchild.stderr.on('data', function(data){\\r\\n\\t\\tstderr.push(data);\\r\\n\\t});\\r\\n\\r\\n\\tloop.run(new_loop, 0);\\r\\n\\r\\n\\tif (stdout.length > 0){\\r\\n\\t\\tresult.output[1] = Buffer.concat(stdout);\\r\\n\\t}\\r\\n\\r\\n\\tif (stderr.length > 0){\\r\\n\\t\\tresult.output[2] = Buffer.concat(stderr);\\r\\n\\t}\\r\\n\\r\\n\\t// reset back to main loop\\r\\n\\tprocess.main_loop = main_loop;\\r\\n\\tprocess.nextTick = nextTick;\\r\\n\\r\\n\\t// free new loop\\r\\n\\t// loop.destroy(new_loop);\\r\\n\\treturn result;\\r\\n};\\r\\n\",\"process_wrap\":\"\\r\\nvar uv           = require('uv');\\r\\nvar MakeCallback = process.MakeCallback;\\r\\nvar cons = require('constants');\\r\\n\\r\\nfunction Process (){\\r\\n\\r\\n}\\r\\n\\r\\n// convert signal number to string\\r\\n// return null if not found\\r\\nfunction signum_to_string(signum){\\r\\n\\tif (signum === 0) return null;\\r\\n\\tfor (var key in cons){\\r\\n\\t\\tif (cons[key] === signum){\\r\\n\\t\\t\\treturn key;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn null;\\r\\n}\\r\\n\\r\\n\\r\\nfunction ParseStdioOptions(stdios, options){\\r\\n\\r\\n\\tvar stdioLength = stdios.length\\r\\n\\tvar stdio_container = uv.stdio_container(stdioLength);\\r\\n\\r\\n\\t// options.stdio_count = stdioLength;\\r\\n\\r\\n\\tfor (var i = 0; i < stdioLength; i++){\\r\\n\\t\\tvar stdio = stdios[i];\\r\\n\\t\\tvar type  = stdio.type;\\r\\n\\r\\n\\t\\t//ignor\\r\\n\\t\\tif (type === 'ignore'){\\r\\n\\t\\t\\tstdio_container[i].flags = uv.IGNORE;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//pipe\\r\\n\\t\\telse if (type === 'pipe'){\\r\\n\\t\\t\\tstdio_container[i].flags = uv.CREATE_PIPE | uv.STREAM_READABLE | uv.STREAM_WRITABLE;\\r\\n\\t\\t\\tstdio_container[i].stream = stdio.handle._handle;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//inherit\\r\\n\\t\\telse if (type === 'fd' || type === 'inherit') {\\r\\n\\t\\t\\tstdio_container[i].flags  = uv.INHERIT_FD;\\r\\n\\t\\t\\tstdio_container[i].fd     = stdio.fd;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\telse {\\r\\n\\t\\t\\tconsole.log(stdio);\\r\\n\\t\\t\\tthrow new Error('unknown type!');\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\treturn stdio_container;\\r\\n}\\r\\n\\r\\n\\r\\nProcess.prototype.spawn = function(js_options){\\r\\n\\tvar process = this;\\r\\n\\r\\n\\tvar options   = {};\\r\\n\\toptions.flags = 0;\\r\\n\\toptions.file  = js_options.file;\\r\\n\\toptions.cwd   = js_options.cwd || null;\\r\\n\\toptions.args  = js_options.args || [];\\r\\n\\r\\n\\tif (!options.file){\\r\\n\\t\\tthrow new Error(\\\"Bad argument\\\");\\r\\n\\t}\\r\\n\\r\\n\\toptions.stdio_count = js_options.stdio.length;\\r\\n\\toptions.stdio = ParseStdioOptions(js_options.stdio);\\r\\n\\r\\n\\r\\n\\t//env pairs\\r\\n\\tvar env = js_options.envPairs;\\r\\n\\tif (!env){\\r\\n\\t\\tthrow new Error(\\\"TODO set current env block\\\");\\r\\n\\t}\\r\\n\\r\\n\\toptions.env = env;\\r\\n\\r\\n\\tif ( js_options.windowsVerbatimArguments ){\\r\\n\\t\\toptions.flags |= uv.PROCESS_WINDOWS_VERBATIM_ARGUMENTS;\\r\\n\\t}\\r\\n\\r\\n\\t// detach process\\r\\n\\tif ( js_options.detached ) {\\r\\n\\t\\toptions.flags |= uv.PROCESS_DETACHED;\\r\\n\\t}\\r\\n\\r\\n\\t// options.uid\\r\\n\\tif ( js_options.uid ) {\\r\\n\\t\\toptions.flags |= uv.PROCESS_SETUID;\\r\\n\\t\\toptions.uid    = js_options.uid;\\r\\n\\t}\\r\\n\\r\\n\\t// options.uid\\r\\n\\tif ( js_options.gid ) {\\r\\n\\t\\toptions.flags |= uv.PROCESS_SETGID;\\r\\n\\t\\toptions.gid = js_options.gid;\\r\\n\\t}\\r\\n\\r\\n\\t// on exit call back\\r\\n\\toptions.exit_cb = function(status, term_signal){\\r\\n\\t\\tvar sig = signum_to_string(term_signal);\\r\\n\\t\\t// MakeCallback(process, 'onexit', status, sig);\\r\\n\\t\\tprocess.onexit(status, sig);\\r\\n\\t};\\r\\n\\r\\n\\tthis._handle = uv.spawn(options);\\r\\n\\tif (this._handle.errno){\\r\\n\\t\\treturn -this._handle.errno;\\r\\n\\t}\\r\\n\\r\\n\\tthis.pid = this._handle.pid;\\r\\n\\treturn 0;\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.unref = function(){\\r\\n\\treturn this._handle.unref();\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.kill = function(signum){\\r\\n\\treturn this._handle.kill(signum);\\r\\n};\\r\\n\\r\\n\\r\\nProcess.prototype.close = function(cb){\\r\\n\\treturn this._handle.close(cb);\\r\\n};\\r\\n\\r\\nexports.Process = Process;\\r\\n\",\"uv_wrap\":\"var errno = require('errno');\\r\\nvar ERROR_MAP = {};\\r\\n\\r\\nObject.keys(errno).forEach(function(key) {\\r\\n    var val = errno[key];\\r\\n    ERROR_MAP[val] = key;\\r\\n    var uv_key = 'UV_' + key;\\r\\n    exports[uv_key] = -val;\\r\\n});\\r\\n\\r\\n// reset uv_eof to negative value\\r\\nexports.UV_EOF = -exports.UV_EOF;\\r\\n\\r\\nexports.errname = function(err){\\r\\n    if (err < 0) err = -err;\\r\\n    return ERROR_MAP[err];\\r\\n};\\r\\n\"}"
